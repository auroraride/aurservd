// Code generated by ent, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/auroraride/aurservd/app/model"
	"github.com/auroraride/aurservd/internal/ent/agent"
	"github.com/auroraride/aurservd/internal/ent/assetcheck"
	"github.com/auroraride/aurservd/internal/ent/assetmanager"
	"github.com/auroraride/aurservd/internal/ent/employee"
	"github.com/auroraride/aurservd/internal/ent/enterprisestation"
	"github.com/auroraride/aurservd/internal/ent/store"
	"github.com/auroraride/aurservd/internal/ent/warehouse"
)

// AssetCheck is the model entity for the AssetCheck schema.
type AssetCheck struct {
	config `json:"-"`
	// ID of the ent.
	ID uint64 `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
	// DeletedAt holds the value of the "deleted_at" field.
	DeletedAt *time.Time `json:"deleted_at,omitempty"`
	// 创建人
	Creator *model.Modifier `json:"creator,omitempty"`
	// 最后修改人
	LastModifier *model.Modifier `json:"last_modifier,omitempty"`
	// 管理员改动原因/备注
	Remark string `json:"remark,omitempty"`
	// 盘点状态 1:待盘点 2:已盘点
	Status uint8 `json:"status,omitempty"`
	// 应盘点电池数量
	BatteryNum uint `json:"battery_num,omitempty"`
	// 实盘电池数量
	BatteryNumReal uint `json:"battery_num_real,omitempty"`
	// 应盘电车数量
	EbikeNum uint `json:"ebike_num,omitempty"`
	// 实盘电车数量
	EbikeNumReal uint `json:"ebike_num_real,omitempty"`
	// 盘点人id
	OperateID uint64 `json:"operate_id,omitempty"`
	// 盘点角色类型 1:门店 3:代理 6:资产后台
	OperateType uint8 `json:"operate_type,omitempty"`
	// 盘点位置类型 1:仓库 2:门店 3:代理
	LocationsType uint8 `json:"locations_type,omitempty"`
	// 盘点位置id
	LocationsID uint64 `json:"locations_id,omitempty"`
	// 盘点开始时间
	StartAt *time.Time `json:"start_at,omitempty"`
	// 盘点结束时间
	EndAt *time.Time `json:"end_at,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the AssetCheckQuery when eager-loading is set.
	Edges        AssetCheckEdges `json:"edges"`
	selectValues sql.SelectValues
}

// AssetCheckEdges holds the relations/edges for other nodes in the graph.
type AssetCheckEdges struct {
	// CheckDetails holds the value of the check_details edge.
	CheckDetails []*AssetCheckDetails `json:"check_details,omitempty"`
	// OperateAssetManager holds the value of the operate_asset_manager edge.
	OperateAssetManager *AssetManager `json:"operate_asset_manager,omitempty"`
	// OperateEmployee holds the value of the operate_employee edge.
	OperateEmployee *Employee `json:"operate_employee,omitempty"`
	// OperateAgent holds the value of the operate_agent edge.
	OperateAgent *Agent `json:"operate_agent,omitempty"`
	// Warehouse holds the value of the warehouse edge.
	Warehouse *Warehouse `json:"warehouse,omitempty"`
	// Store holds the value of the store edge.
	Store *Store `json:"store,omitempty"`
	// Station holds the value of the station edge.
	Station *EnterpriseStation `json:"station,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [7]bool
}

// CheckDetailsOrErr returns the CheckDetails value or an error if the edge
// was not loaded in eager-loading.
func (e AssetCheckEdges) CheckDetailsOrErr() ([]*AssetCheckDetails, error) {
	if e.loadedTypes[0] {
		return e.CheckDetails, nil
	}
	return nil, &NotLoadedError{edge: "check_details"}
}

// OperateAssetManagerOrErr returns the OperateAssetManager value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e AssetCheckEdges) OperateAssetManagerOrErr() (*AssetManager, error) {
	if e.OperateAssetManager != nil {
		return e.OperateAssetManager, nil
	} else if e.loadedTypes[1] {
		return nil, &NotFoundError{label: assetmanager.Label}
	}
	return nil, &NotLoadedError{edge: "operate_asset_manager"}
}

// OperateEmployeeOrErr returns the OperateEmployee value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e AssetCheckEdges) OperateEmployeeOrErr() (*Employee, error) {
	if e.OperateEmployee != nil {
		return e.OperateEmployee, nil
	} else if e.loadedTypes[2] {
		return nil, &NotFoundError{label: employee.Label}
	}
	return nil, &NotLoadedError{edge: "operate_employee"}
}

// OperateAgentOrErr returns the OperateAgent value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e AssetCheckEdges) OperateAgentOrErr() (*Agent, error) {
	if e.OperateAgent != nil {
		return e.OperateAgent, nil
	} else if e.loadedTypes[3] {
		return nil, &NotFoundError{label: agent.Label}
	}
	return nil, &NotLoadedError{edge: "operate_agent"}
}

// WarehouseOrErr returns the Warehouse value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e AssetCheckEdges) WarehouseOrErr() (*Warehouse, error) {
	if e.Warehouse != nil {
		return e.Warehouse, nil
	} else if e.loadedTypes[4] {
		return nil, &NotFoundError{label: warehouse.Label}
	}
	return nil, &NotLoadedError{edge: "warehouse"}
}

// StoreOrErr returns the Store value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e AssetCheckEdges) StoreOrErr() (*Store, error) {
	if e.Store != nil {
		return e.Store, nil
	} else if e.loadedTypes[5] {
		return nil, &NotFoundError{label: store.Label}
	}
	return nil, &NotLoadedError{edge: "store"}
}

// StationOrErr returns the Station value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e AssetCheckEdges) StationOrErr() (*EnterpriseStation, error) {
	if e.Station != nil {
		return e.Station, nil
	} else if e.loadedTypes[6] {
		return nil, &NotFoundError{label: enterprisestation.Label}
	}
	return nil, &NotLoadedError{edge: "station"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*AssetCheck) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case assetcheck.FieldCreator, assetcheck.FieldLastModifier:
			values[i] = new([]byte)
		case assetcheck.FieldID, assetcheck.FieldStatus, assetcheck.FieldBatteryNum, assetcheck.FieldBatteryNumReal, assetcheck.FieldEbikeNum, assetcheck.FieldEbikeNumReal, assetcheck.FieldOperateID, assetcheck.FieldOperateType, assetcheck.FieldLocationsType, assetcheck.FieldLocationsID:
			values[i] = new(sql.NullInt64)
		case assetcheck.FieldRemark:
			values[i] = new(sql.NullString)
		case assetcheck.FieldCreatedAt, assetcheck.FieldUpdatedAt, assetcheck.FieldDeletedAt, assetcheck.FieldStartAt, assetcheck.FieldEndAt:
			values[i] = new(sql.NullTime)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the AssetCheck fields.
func (ac *AssetCheck) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case assetcheck.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			ac.ID = uint64(value.Int64)
		case assetcheck.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				ac.CreatedAt = value.Time
			}
		case assetcheck.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				ac.UpdatedAt = value.Time
			}
		case assetcheck.FieldDeletedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field deleted_at", values[i])
			} else if value.Valid {
				ac.DeletedAt = new(time.Time)
				*ac.DeletedAt = value.Time
			}
		case assetcheck.FieldCreator:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field creator", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &ac.Creator); err != nil {
					return fmt.Errorf("unmarshal field creator: %w", err)
				}
			}
		case assetcheck.FieldLastModifier:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field last_modifier", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &ac.LastModifier); err != nil {
					return fmt.Errorf("unmarshal field last_modifier: %w", err)
				}
			}
		case assetcheck.FieldRemark:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field remark", values[i])
			} else if value.Valid {
				ac.Remark = value.String
			}
		case assetcheck.FieldStatus:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				ac.Status = uint8(value.Int64)
			}
		case assetcheck.FieldBatteryNum:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field battery_num", values[i])
			} else if value.Valid {
				ac.BatteryNum = uint(value.Int64)
			}
		case assetcheck.FieldBatteryNumReal:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field battery_num_real", values[i])
			} else if value.Valid {
				ac.BatteryNumReal = uint(value.Int64)
			}
		case assetcheck.FieldEbikeNum:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field ebike_num", values[i])
			} else if value.Valid {
				ac.EbikeNum = uint(value.Int64)
			}
		case assetcheck.FieldEbikeNumReal:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field ebike_num_real", values[i])
			} else if value.Valid {
				ac.EbikeNumReal = uint(value.Int64)
			}
		case assetcheck.FieldOperateID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field operate_id", values[i])
			} else if value.Valid {
				ac.OperateID = uint64(value.Int64)
			}
		case assetcheck.FieldOperateType:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field operate_type", values[i])
			} else if value.Valid {
				ac.OperateType = uint8(value.Int64)
			}
		case assetcheck.FieldLocationsType:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field locations_type", values[i])
			} else if value.Valid {
				ac.LocationsType = uint8(value.Int64)
			}
		case assetcheck.FieldLocationsID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field locations_id", values[i])
			} else if value.Valid {
				ac.LocationsID = uint64(value.Int64)
			}
		case assetcheck.FieldStartAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field start_at", values[i])
			} else if value.Valid {
				ac.StartAt = new(time.Time)
				*ac.StartAt = value.Time
			}
		case assetcheck.FieldEndAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field end_at", values[i])
			} else if value.Valid {
				ac.EndAt = new(time.Time)
				*ac.EndAt = value.Time
			}
		default:
			ac.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the AssetCheck.
// This includes values selected through modifiers, order, etc.
func (ac *AssetCheck) Value(name string) (ent.Value, error) {
	return ac.selectValues.Get(name)
}

// QueryCheckDetails queries the "check_details" edge of the AssetCheck entity.
func (ac *AssetCheck) QueryCheckDetails() *AssetCheckDetailsQuery {
	return NewAssetCheckClient(ac.config).QueryCheckDetails(ac)
}

// QueryOperateAssetManager queries the "operate_asset_manager" edge of the AssetCheck entity.
func (ac *AssetCheck) QueryOperateAssetManager() *AssetManagerQuery {
	return NewAssetCheckClient(ac.config).QueryOperateAssetManager(ac)
}

// QueryOperateEmployee queries the "operate_employee" edge of the AssetCheck entity.
func (ac *AssetCheck) QueryOperateEmployee() *EmployeeQuery {
	return NewAssetCheckClient(ac.config).QueryOperateEmployee(ac)
}

// QueryOperateAgent queries the "operate_agent" edge of the AssetCheck entity.
func (ac *AssetCheck) QueryOperateAgent() *AgentQuery {
	return NewAssetCheckClient(ac.config).QueryOperateAgent(ac)
}

// QueryWarehouse queries the "warehouse" edge of the AssetCheck entity.
func (ac *AssetCheck) QueryWarehouse() *WarehouseQuery {
	return NewAssetCheckClient(ac.config).QueryWarehouse(ac)
}

// QueryStore queries the "store" edge of the AssetCheck entity.
func (ac *AssetCheck) QueryStore() *StoreQuery {
	return NewAssetCheckClient(ac.config).QueryStore(ac)
}

// QueryStation queries the "station" edge of the AssetCheck entity.
func (ac *AssetCheck) QueryStation() *EnterpriseStationQuery {
	return NewAssetCheckClient(ac.config).QueryStation(ac)
}

// Update returns a builder for updating this AssetCheck.
// Note that you need to call AssetCheck.Unwrap() before calling this method if this AssetCheck
// was returned from a transaction, and the transaction was committed or rolled back.
func (ac *AssetCheck) Update() *AssetCheckUpdateOne {
	return NewAssetCheckClient(ac.config).UpdateOne(ac)
}

// Unwrap unwraps the AssetCheck entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (ac *AssetCheck) Unwrap() *AssetCheck {
	_tx, ok := ac.config.driver.(*txDriver)
	if !ok {
		panic("ent: AssetCheck is not a transactional entity")
	}
	ac.config.driver = _tx.drv
	return ac
}

// String implements the fmt.Stringer.
func (ac *AssetCheck) String() string {
	var builder strings.Builder
	builder.WriteString("AssetCheck(")
	builder.WriteString(fmt.Sprintf("id=%v, ", ac.ID))
	builder.WriteString("created_at=")
	builder.WriteString(ac.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(ac.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	if v := ac.DeletedAt; v != nil {
		builder.WriteString("deleted_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	builder.WriteString("creator=")
	builder.WriteString(fmt.Sprintf("%v", ac.Creator))
	builder.WriteString(", ")
	builder.WriteString("last_modifier=")
	builder.WriteString(fmt.Sprintf("%v", ac.LastModifier))
	builder.WriteString(", ")
	builder.WriteString("remark=")
	builder.WriteString(ac.Remark)
	builder.WriteString(", ")
	builder.WriteString("status=")
	builder.WriteString(fmt.Sprintf("%v", ac.Status))
	builder.WriteString(", ")
	builder.WriteString("battery_num=")
	builder.WriteString(fmt.Sprintf("%v", ac.BatteryNum))
	builder.WriteString(", ")
	builder.WriteString("battery_num_real=")
	builder.WriteString(fmt.Sprintf("%v", ac.BatteryNumReal))
	builder.WriteString(", ")
	builder.WriteString("ebike_num=")
	builder.WriteString(fmt.Sprintf("%v", ac.EbikeNum))
	builder.WriteString(", ")
	builder.WriteString("ebike_num_real=")
	builder.WriteString(fmt.Sprintf("%v", ac.EbikeNumReal))
	builder.WriteString(", ")
	builder.WriteString("operate_id=")
	builder.WriteString(fmt.Sprintf("%v", ac.OperateID))
	builder.WriteString(", ")
	builder.WriteString("operate_type=")
	builder.WriteString(fmt.Sprintf("%v", ac.OperateType))
	builder.WriteString(", ")
	builder.WriteString("locations_type=")
	builder.WriteString(fmt.Sprintf("%v", ac.LocationsType))
	builder.WriteString(", ")
	builder.WriteString("locations_id=")
	builder.WriteString(fmt.Sprintf("%v", ac.LocationsID))
	builder.WriteString(", ")
	if v := ac.StartAt; v != nil {
		builder.WriteString("start_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteString(", ")
	if v := ac.EndAt; v != nil {
		builder.WriteString("end_at=")
		builder.WriteString(v.Format(time.ANSIC))
	}
	builder.WriteByte(')')
	return builder.String()
}

// AssetChecks is a parsable slice of AssetCheck.
type AssetChecks []*AssetCheck
