// Code generated by liasica and entc, DO NOT EDIT.

package ent

import (
    "context"
    "fmt"
    "sync"
    "errors"
    "time"
    "github.com/auroraride/aurservd/internal/ent/assistance"
    "github.com/auroraride/aurservd/app/model"
    "github.com/auroraride/aurservd/internal/ent/predicate"

    "entgo.io/ent"
)


// AssistanceMutation represents an operation that mutates the Assistance nodes in the graph.
type AssistanceMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint64
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	creator            **model.Modifier
	last_modifier      **model.Modifier
	remark             *string
	status             *uint8
	addstatus          *int8
	lng                *float64
	addlng             *float64
	lat                *float64
	addlat             *float64
	address            *string
	breakdown          *string
	breakdown_desc     *string
	breakdown_photos   *[]string
	cancel_reason      *string
	cancel_reason_desc *string
	distance           *float64
	adddistance        *float64
	reason             *string
	detect_photo       *string
	joint_photo        *string
	cost               *float64
	addcost            *float64
	refused_desc       *string
	pay_at             *time.Time
	allocate_at        *time.Time
	wait               *int
	addwait            *int
	free_reason        *string
	fail_reason        *string
	process_at         *time.Time
	price              *float64
	addprice           *float64
	navi_duration      *int
	addnavi_duration   *int
	navi_polylines     *[]string
	clearedFields      map[string]struct{}
	store              *uint64
	clearedstore       bool
	rider              *uint64
	clearedrider       bool
	subscribe          *uint64
	clearedsubscribe   bool
	city               *uint64
	clearedcity        bool
	_order             *uint64
	cleared_order      bool
	employee           *uint64
	clearedemployee    bool
	done               bool
	oldValue           func(context.Context) (*Assistance, error)
	predicates         []predicate.Assistance
}

var _ ent.Mutation = (*AssistanceMutation)(nil)

// assistanceOption allows management of the mutation configuration using functional options.
type assistanceOption func(*AssistanceMutation)

// newAssistanceMutation creates new mutation for the Assistance entity.
func newAssistanceMutation(c config, op Op, opts ...assistanceOption) *AssistanceMutation {
	m := &AssistanceMutation{
		config:        c,
		op:            op,
		typ:           TypeAssistance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssistanceID sets the ID field of the mutation.
func withAssistanceID(id uint64) assistanceOption {
	return func(m *AssistanceMutation) {
		var (
			err   error
			once  sync.Once
			value *Assistance
		)
		m.oldValue = func(ctx context.Context) (*Assistance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Assistance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssistance sets the old Assistance of the mutation.
func withAssistance(node *Assistance) assistanceOption {
	return func(m *AssistanceMutation) {
		m.oldValue = func(context.Context) (*Assistance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssistanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssistanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssistanceMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssistanceMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Assistance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AssistanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssistanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssistanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssistanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssistanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssistanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AssistanceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AssistanceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AssistanceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[assistance.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AssistanceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[assistance.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AssistanceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, assistance.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *AssistanceMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *AssistanceMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *AssistanceMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[assistance.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *AssistanceMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[assistance.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *AssistanceMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, assistance.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *AssistanceMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *AssistanceMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *AssistanceMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[assistance.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *AssistanceMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[assistance.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *AssistanceMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, assistance.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *AssistanceMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *AssistanceMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *AssistanceMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[assistance.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *AssistanceMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[assistance.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *AssistanceMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, assistance.FieldRemark)
}

// SetStoreID sets the "store_id" field.
func (m *AssistanceMutation) SetStoreID(u uint64) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *AssistanceMutation) StoreID() (r uint64, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldStoreID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *AssistanceMutation) ClearStoreID() {
	m.store = nil
	m.clearedFields[assistance.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *AssistanceMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[assistance.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *AssistanceMutation) ResetStoreID() {
	m.store = nil
	delete(m.clearedFields, assistance.FieldStoreID)
}

// SetRiderID sets the "rider_id" field.
func (m *AssistanceMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *AssistanceMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *AssistanceMutation) ResetRiderID() {
	m.rider = nil
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *AssistanceMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *AssistanceMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldSubscribeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *AssistanceMutation) ResetSubscribeID() {
	m.subscribe = nil
}

// SetCityID sets the "city_id" field.
func (m *AssistanceMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *AssistanceMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *AssistanceMutation) ResetCityID() {
	m.city = nil
}

// SetEmployeeID sets the "employee_id" field.
func (m *AssistanceMutation) SetEmployeeID(u uint64) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *AssistanceMutation) EmployeeID() (r uint64, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldEmployeeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *AssistanceMutation) ClearEmployeeID() {
	m.employee = nil
	m.clearedFields[assistance.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *AssistanceMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[assistance.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *AssistanceMutation) ResetEmployeeID() {
	m.employee = nil
	delete(m.clearedFields, assistance.FieldEmployeeID)
}

// SetOrderID sets the "order_id" field.
func (m *AssistanceMutation) SetOrderID(u uint64) {
	m._order = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *AssistanceMutation) OrderID() (r uint64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldOrderID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *AssistanceMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[assistance.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *AssistanceMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[assistance.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *AssistanceMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, assistance.FieldOrderID)
}

// SetStatus sets the "status" field.
func (m *AssistanceMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AssistanceMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *AssistanceMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AssistanceMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *AssistanceMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetLng sets the "lng" field.
func (m *AssistanceMutation) SetLng(f float64) {
	m.lng = &f
	m.addlng = nil
}

// Lng returns the value of the "lng" field in the mutation.
func (m *AssistanceMutation) Lng() (r float64, exists bool) {
	v := m.lng
	if v == nil {
		return
	}
	return *v, true
}

// OldLng returns the old "lng" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldLng(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLng is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLng requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLng: %w", err)
	}
	return oldValue.Lng, nil
}

// AddLng adds f to the "lng" field.
func (m *AssistanceMutation) AddLng(f float64) {
	if m.addlng != nil {
		*m.addlng += f
	} else {
		m.addlng = &f
	}
}

// AddedLng returns the value that was added to the "lng" field in this mutation.
func (m *AssistanceMutation) AddedLng() (r float64, exists bool) {
	v := m.addlng
	if v == nil {
		return
	}
	return *v, true
}

// ResetLng resets all changes to the "lng" field.
func (m *AssistanceMutation) ResetLng() {
	m.lng = nil
	m.addlng = nil
}

// SetLat sets the "lat" field.
func (m *AssistanceMutation) SetLat(f float64) {
	m.lat = &f
	m.addlat = nil
}

// Lat returns the value of the "lat" field in the mutation.
func (m *AssistanceMutation) Lat() (r float64, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "lat" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// AddLat adds f to the "lat" field.
func (m *AssistanceMutation) AddLat(f float64) {
	if m.addlat != nil {
		*m.addlat += f
	} else {
		m.addlat = &f
	}
}

// AddedLat returns the value that was added to the "lat" field in this mutation.
func (m *AssistanceMutation) AddedLat() (r float64, exists bool) {
	v := m.addlat
	if v == nil {
		return
	}
	return *v, true
}

// ResetLat resets all changes to the "lat" field.
func (m *AssistanceMutation) ResetLat() {
	m.lat = nil
	m.addlat = nil
}

// SetAddress sets the "address" field.
func (m *AssistanceMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *AssistanceMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *AssistanceMutation) ResetAddress() {
	m.address = nil
}

// SetBreakdown sets the "breakdown" field.
func (m *AssistanceMutation) SetBreakdown(s string) {
	m.breakdown = &s
}

// Breakdown returns the value of the "breakdown" field in the mutation.
func (m *AssistanceMutation) Breakdown() (r string, exists bool) {
	v := m.breakdown
	if v == nil {
		return
	}
	return *v, true
}

// OldBreakdown returns the old "breakdown" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldBreakdown(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBreakdown is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBreakdown requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreakdown: %w", err)
	}
	return oldValue.Breakdown, nil
}

// ResetBreakdown resets all changes to the "breakdown" field.
func (m *AssistanceMutation) ResetBreakdown() {
	m.breakdown = nil
}

// SetBreakdownDesc sets the "breakdown_desc" field.
func (m *AssistanceMutation) SetBreakdownDesc(s string) {
	m.breakdown_desc = &s
}

// BreakdownDesc returns the value of the "breakdown_desc" field in the mutation.
func (m *AssistanceMutation) BreakdownDesc() (r string, exists bool) {
	v := m.breakdown_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldBreakdownDesc returns the old "breakdown_desc" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldBreakdownDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBreakdownDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBreakdownDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreakdownDesc: %w", err)
	}
	return oldValue.BreakdownDesc, nil
}

// ClearBreakdownDesc clears the value of the "breakdown_desc" field.
func (m *AssistanceMutation) ClearBreakdownDesc() {
	m.breakdown_desc = nil
	m.clearedFields[assistance.FieldBreakdownDesc] = struct{}{}
}

// BreakdownDescCleared returns if the "breakdown_desc" field was cleared in this mutation.
func (m *AssistanceMutation) BreakdownDescCleared() bool {
	_, ok := m.clearedFields[assistance.FieldBreakdownDesc]
	return ok
}

// ResetBreakdownDesc resets all changes to the "breakdown_desc" field.
func (m *AssistanceMutation) ResetBreakdownDesc() {
	m.breakdown_desc = nil
	delete(m.clearedFields, assistance.FieldBreakdownDesc)
}

// SetBreakdownPhotos sets the "breakdown_photos" field.
func (m *AssistanceMutation) SetBreakdownPhotos(s []string) {
	m.breakdown_photos = &s
}

// BreakdownPhotos returns the value of the "breakdown_photos" field in the mutation.
func (m *AssistanceMutation) BreakdownPhotos() (r []string, exists bool) {
	v := m.breakdown_photos
	if v == nil {
		return
	}
	return *v, true
}

// OldBreakdownPhotos returns the old "breakdown_photos" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldBreakdownPhotos(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBreakdownPhotos is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBreakdownPhotos requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreakdownPhotos: %w", err)
	}
	return oldValue.BreakdownPhotos, nil
}

// ResetBreakdownPhotos resets all changes to the "breakdown_photos" field.
func (m *AssistanceMutation) ResetBreakdownPhotos() {
	m.breakdown_photos = nil
}

// SetCancelReason sets the "cancel_reason" field.
func (m *AssistanceMutation) SetCancelReason(s string) {
	m.cancel_reason = &s
}

// CancelReason returns the value of the "cancel_reason" field in the mutation.
func (m *AssistanceMutation) CancelReason() (r string, exists bool) {
	v := m.cancel_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelReason returns the old "cancel_reason" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldCancelReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelReason: %w", err)
	}
	return oldValue.CancelReason, nil
}

// ClearCancelReason clears the value of the "cancel_reason" field.
func (m *AssistanceMutation) ClearCancelReason() {
	m.cancel_reason = nil
	m.clearedFields[assistance.FieldCancelReason] = struct{}{}
}

// CancelReasonCleared returns if the "cancel_reason" field was cleared in this mutation.
func (m *AssistanceMutation) CancelReasonCleared() bool {
	_, ok := m.clearedFields[assistance.FieldCancelReason]
	return ok
}

// ResetCancelReason resets all changes to the "cancel_reason" field.
func (m *AssistanceMutation) ResetCancelReason() {
	m.cancel_reason = nil
	delete(m.clearedFields, assistance.FieldCancelReason)
}

// SetCancelReasonDesc sets the "cancel_reason_desc" field.
func (m *AssistanceMutation) SetCancelReasonDesc(s string) {
	m.cancel_reason_desc = &s
}

// CancelReasonDesc returns the value of the "cancel_reason_desc" field in the mutation.
func (m *AssistanceMutation) CancelReasonDesc() (r string, exists bool) {
	v := m.cancel_reason_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelReasonDesc returns the old "cancel_reason_desc" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldCancelReasonDesc(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelReasonDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelReasonDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelReasonDesc: %w", err)
	}
	return oldValue.CancelReasonDesc, nil
}

// ClearCancelReasonDesc clears the value of the "cancel_reason_desc" field.
func (m *AssistanceMutation) ClearCancelReasonDesc() {
	m.cancel_reason_desc = nil
	m.clearedFields[assistance.FieldCancelReasonDesc] = struct{}{}
}

// CancelReasonDescCleared returns if the "cancel_reason_desc" field was cleared in this mutation.
func (m *AssistanceMutation) CancelReasonDescCleared() bool {
	_, ok := m.clearedFields[assistance.FieldCancelReasonDesc]
	return ok
}

// ResetCancelReasonDesc resets all changes to the "cancel_reason_desc" field.
func (m *AssistanceMutation) ResetCancelReasonDesc() {
	m.cancel_reason_desc = nil
	delete(m.clearedFields, assistance.FieldCancelReasonDesc)
}

// SetDistance sets the "distance" field.
func (m *AssistanceMutation) SetDistance(f float64) {
	m.distance = &f
	m.adddistance = nil
}

// Distance returns the value of the "distance" field in the mutation.
func (m *AssistanceMutation) Distance() (r float64, exists bool) {
	v := m.distance
	if v == nil {
		return
	}
	return *v, true
}

// OldDistance returns the old "distance" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldDistance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistance: %w", err)
	}
	return oldValue.Distance, nil
}

// AddDistance adds f to the "distance" field.
func (m *AssistanceMutation) AddDistance(f float64) {
	if m.adddistance != nil {
		*m.adddistance += f
	} else {
		m.adddistance = &f
	}
}

// AddedDistance returns the value that was added to the "distance" field in this mutation.
func (m *AssistanceMutation) AddedDistance() (r float64, exists bool) {
	v := m.adddistance
	if v == nil {
		return
	}
	return *v, true
}

// ClearDistance clears the value of the "distance" field.
func (m *AssistanceMutation) ClearDistance() {
	m.distance = nil
	m.adddistance = nil
	m.clearedFields[assistance.FieldDistance] = struct{}{}
}

// DistanceCleared returns if the "distance" field was cleared in this mutation.
func (m *AssistanceMutation) DistanceCleared() bool {
	_, ok := m.clearedFields[assistance.FieldDistance]
	return ok
}

// ResetDistance resets all changes to the "distance" field.
func (m *AssistanceMutation) ResetDistance() {
	m.distance = nil
	m.adddistance = nil
	delete(m.clearedFields, assistance.FieldDistance)
}

// SetReason sets the "reason" field.
func (m *AssistanceMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *AssistanceMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *AssistanceMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[assistance.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *AssistanceMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[assistance.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *AssistanceMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, assistance.FieldReason)
}

// SetDetectPhoto sets the "detect_photo" field.
func (m *AssistanceMutation) SetDetectPhoto(s string) {
	m.detect_photo = &s
}

// DetectPhoto returns the value of the "detect_photo" field in the mutation.
func (m *AssistanceMutation) DetectPhoto() (r string, exists bool) {
	v := m.detect_photo
	if v == nil {
		return
	}
	return *v, true
}

// OldDetectPhoto returns the old "detect_photo" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldDetectPhoto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetectPhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetectPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetectPhoto: %w", err)
	}
	return oldValue.DetectPhoto, nil
}

// ClearDetectPhoto clears the value of the "detect_photo" field.
func (m *AssistanceMutation) ClearDetectPhoto() {
	m.detect_photo = nil
	m.clearedFields[assistance.FieldDetectPhoto] = struct{}{}
}

// DetectPhotoCleared returns if the "detect_photo" field was cleared in this mutation.
func (m *AssistanceMutation) DetectPhotoCleared() bool {
	_, ok := m.clearedFields[assistance.FieldDetectPhoto]
	return ok
}

// ResetDetectPhoto resets all changes to the "detect_photo" field.
func (m *AssistanceMutation) ResetDetectPhoto() {
	m.detect_photo = nil
	delete(m.clearedFields, assistance.FieldDetectPhoto)
}

// SetJointPhoto sets the "joint_photo" field.
func (m *AssistanceMutation) SetJointPhoto(s string) {
	m.joint_photo = &s
}

// JointPhoto returns the value of the "joint_photo" field in the mutation.
func (m *AssistanceMutation) JointPhoto() (r string, exists bool) {
	v := m.joint_photo
	if v == nil {
		return
	}
	return *v, true
}

// OldJointPhoto returns the old "joint_photo" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldJointPhoto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJointPhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJointPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJointPhoto: %w", err)
	}
	return oldValue.JointPhoto, nil
}

// ClearJointPhoto clears the value of the "joint_photo" field.
func (m *AssistanceMutation) ClearJointPhoto() {
	m.joint_photo = nil
	m.clearedFields[assistance.FieldJointPhoto] = struct{}{}
}

// JointPhotoCleared returns if the "joint_photo" field was cleared in this mutation.
func (m *AssistanceMutation) JointPhotoCleared() bool {
	_, ok := m.clearedFields[assistance.FieldJointPhoto]
	return ok
}

// ResetJointPhoto resets all changes to the "joint_photo" field.
func (m *AssistanceMutation) ResetJointPhoto() {
	m.joint_photo = nil
	delete(m.clearedFields, assistance.FieldJointPhoto)
}

// SetCost sets the "cost" field.
func (m *AssistanceMutation) SetCost(f float64) {
	m.cost = &f
	m.addcost = nil
}

// Cost returns the value of the "cost" field in the mutation.
func (m *AssistanceMutation) Cost() (r float64, exists bool) {
	v := m.cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCost returns the old "cost" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCost: %w", err)
	}
	return oldValue.Cost, nil
}

// AddCost adds f to the "cost" field.
func (m *AssistanceMutation) AddCost(f float64) {
	if m.addcost != nil {
		*m.addcost += f
	} else {
		m.addcost = &f
	}
}

// AddedCost returns the value that was added to the "cost" field in this mutation.
func (m *AssistanceMutation) AddedCost() (r float64, exists bool) {
	v := m.addcost
	if v == nil {
		return
	}
	return *v, true
}

// ClearCost clears the value of the "cost" field.
func (m *AssistanceMutation) ClearCost() {
	m.cost = nil
	m.addcost = nil
	m.clearedFields[assistance.FieldCost] = struct{}{}
}

// CostCleared returns if the "cost" field was cleared in this mutation.
func (m *AssistanceMutation) CostCleared() bool {
	_, ok := m.clearedFields[assistance.FieldCost]
	return ok
}

// ResetCost resets all changes to the "cost" field.
func (m *AssistanceMutation) ResetCost() {
	m.cost = nil
	m.addcost = nil
	delete(m.clearedFields, assistance.FieldCost)
}

// SetRefusedDesc sets the "refused_desc" field.
func (m *AssistanceMutation) SetRefusedDesc(s string) {
	m.refused_desc = &s
}

// RefusedDesc returns the value of the "refused_desc" field in the mutation.
func (m *AssistanceMutation) RefusedDesc() (r string, exists bool) {
	v := m.refused_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldRefusedDesc returns the old "refused_desc" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldRefusedDesc(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefusedDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefusedDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefusedDesc: %w", err)
	}
	return oldValue.RefusedDesc, nil
}

// ClearRefusedDesc clears the value of the "refused_desc" field.
func (m *AssistanceMutation) ClearRefusedDesc() {
	m.refused_desc = nil
	m.clearedFields[assistance.FieldRefusedDesc] = struct{}{}
}

// RefusedDescCleared returns if the "refused_desc" field was cleared in this mutation.
func (m *AssistanceMutation) RefusedDescCleared() bool {
	_, ok := m.clearedFields[assistance.FieldRefusedDesc]
	return ok
}

// ResetRefusedDesc resets all changes to the "refused_desc" field.
func (m *AssistanceMutation) ResetRefusedDesc() {
	m.refused_desc = nil
	delete(m.clearedFields, assistance.FieldRefusedDesc)
}

// SetPayAt sets the "pay_at" field.
func (m *AssistanceMutation) SetPayAt(t time.Time) {
	m.pay_at = &t
}

// PayAt returns the value of the "pay_at" field in the mutation.
func (m *AssistanceMutation) PayAt() (r time.Time, exists bool) {
	v := m.pay_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPayAt returns the old "pay_at" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldPayAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayAt: %w", err)
	}
	return oldValue.PayAt, nil
}

// ClearPayAt clears the value of the "pay_at" field.
func (m *AssistanceMutation) ClearPayAt() {
	m.pay_at = nil
	m.clearedFields[assistance.FieldPayAt] = struct{}{}
}

// PayAtCleared returns if the "pay_at" field was cleared in this mutation.
func (m *AssistanceMutation) PayAtCleared() bool {
	_, ok := m.clearedFields[assistance.FieldPayAt]
	return ok
}

// ResetPayAt resets all changes to the "pay_at" field.
func (m *AssistanceMutation) ResetPayAt() {
	m.pay_at = nil
	delete(m.clearedFields, assistance.FieldPayAt)
}

// SetAllocateAt sets the "allocate_at" field.
func (m *AssistanceMutation) SetAllocateAt(t time.Time) {
	m.allocate_at = &t
}

// AllocateAt returns the value of the "allocate_at" field in the mutation.
func (m *AssistanceMutation) AllocateAt() (r time.Time, exists bool) {
	v := m.allocate_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAllocateAt returns the old "allocate_at" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldAllocateAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllocateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllocateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllocateAt: %w", err)
	}
	return oldValue.AllocateAt, nil
}

// ClearAllocateAt clears the value of the "allocate_at" field.
func (m *AssistanceMutation) ClearAllocateAt() {
	m.allocate_at = nil
	m.clearedFields[assistance.FieldAllocateAt] = struct{}{}
}

// AllocateAtCleared returns if the "allocate_at" field was cleared in this mutation.
func (m *AssistanceMutation) AllocateAtCleared() bool {
	_, ok := m.clearedFields[assistance.FieldAllocateAt]
	return ok
}

// ResetAllocateAt resets all changes to the "allocate_at" field.
func (m *AssistanceMutation) ResetAllocateAt() {
	m.allocate_at = nil
	delete(m.clearedFields, assistance.FieldAllocateAt)
}

// SetWait sets the "wait" field.
func (m *AssistanceMutation) SetWait(i int) {
	m.wait = &i
	m.addwait = nil
}

// Wait returns the value of the "wait" field in the mutation.
func (m *AssistanceMutation) Wait() (r int, exists bool) {
	v := m.wait
	if v == nil {
		return
	}
	return *v, true
}

// OldWait returns the old "wait" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldWait(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWait is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWait requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWait: %w", err)
	}
	return oldValue.Wait, nil
}

// AddWait adds i to the "wait" field.
func (m *AssistanceMutation) AddWait(i int) {
	if m.addwait != nil {
		*m.addwait += i
	} else {
		m.addwait = &i
	}
}

// AddedWait returns the value that was added to the "wait" field in this mutation.
func (m *AssistanceMutation) AddedWait() (r int, exists bool) {
	v := m.addwait
	if v == nil {
		return
	}
	return *v, true
}

// ResetWait resets all changes to the "wait" field.
func (m *AssistanceMutation) ResetWait() {
	m.wait = nil
	m.addwait = nil
}

// SetFreeReason sets the "free_reason" field.
func (m *AssistanceMutation) SetFreeReason(s string) {
	m.free_reason = &s
}

// FreeReason returns the value of the "free_reason" field in the mutation.
func (m *AssistanceMutation) FreeReason() (r string, exists bool) {
	v := m.free_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFreeReason returns the old "free_reason" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldFreeReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreeReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreeReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreeReason: %w", err)
	}
	return oldValue.FreeReason, nil
}

// ClearFreeReason clears the value of the "free_reason" field.
func (m *AssistanceMutation) ClearFreeReason() {
	m.free_reason = nil
	m.clearedFields[assistance.FieldFreeReason] = struct{}{}
}

// FreeReasonCleared returns if the "free_reason" field was cleared in this mutation.
func (m *AssistanceMutation) FreeReasonCleared() bool {
	_, ok := m.clearedFields[assistance.FieldFreeReason]
	return ok
}

// ResetFreeReason resets all changes to the "free_reason" field.
func (m *AssistanceMutation) ResetFreeReason() {
	m.free_reason = nil
	delete(m.clearedFields, assistance.FieldFreeReason)
}

// SetFailReason sets the "fail_reason" field.
func (m *AssistanceMutation) SetFailReason(s string) {
	m.fail_reason = &s
}

// FailReason returns the value of the "fail_reason" field in the mutation.
func (m *AssistanceMutation) FailReason() (r string, exists bool) {
	v := m.fail_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailReason returns the old "fail_reason" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldFailReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailReason: %w", err)
	}
	return oldValue.FailReason, nil
}

// ClearFailReason clears the value of the "fail_reason" field.
func (m *AssistanceMutation) ClearFailReason() {
	m.fail_reason = nil
	m.clearedFields[assistance.FieldFailReason] = struct{}{}
}

// FailReasonCleared returns if the "fail_reason" field was cleared in this mutation.
func (m *AssistanceMutation) FailReasonCleared() bool {
	_, ok := m.clearedFields[assistance.FieldFailReason]
	return ok
}

// ResetFailReason resets all changes to the "fail_reason" field.
func (m *AssistanceMutation) ResetFailReason() {
	m.fail_reason = nil
	delete(m.clearedFields, assistance.FieldFailReason)
}

// SetProcessAt sets the "process_at" field.
func (m *AssistanceMutation) SetProcessAt(t time.Time) {
	m.process_at = &t
}

// ProcessAt returns the value of the "process_at" field in the mutation.
func (m *AssistanceMutation) ProcessAt() (r time.Time, exists bool) {
	v := m.process_at
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessAt returns the old "process_at" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldProcessAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessAt: %w", err)
	}
	return oldValue.ProcessAt, nil
}

// ClearProcessAt clears the value of the "process_at" field.
func (m *AssistanceMutation) ClearProcessAt() {
	m.process_at = nil
	m.clearedFields[assistance.FieldProcessAt] = struct{}{}
}

// ProcessAtCleared returns if the "process_at" field was cleared in this mutation.
func (m *AssistanceMutation) ProcessAtCleared() bool {
	_, ok := m.clearedFields[assistance.FieldProcessAt]
	return ok
}

// ResetProcessAt resets all changes to the "process_at" field.
func (m *AssistanceMutation) ResetProcessAt() {
	m.process_at = nil
	delete(m.clearedFields, assistance.FieldProcessAt)
}

// SetPrice sets the "price" field.
func (m *AssistanceMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *AssistanceMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *AssistanceMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *AssistanceMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *AssistanceMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[assistance.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *AssistanceMutation) PriceCleared() bool {
	_, ok := m.clearedFields[assistance.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *AssistanceMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, assistance.FieldPrice)
}

// SetNaviDuration sets the "navi_duration" field.
func (m *AssistanceMutation) SetNaviDuration(i int) {
	m.navi_duration = &i
	m.addnavi_duration = nil
}

// NaviDuration returns the value of the "navi_duration" field in the mutation.
func (m *AssistanceMutation) NaviDuration() (r int, exists bool) {
	v := m.navi_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldNaviDuration returns the old "navi_duration" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldNaviDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNaviDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNaviDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNaviDuration: %w", err)
	}
	return oldValue.NaviDuration, nil
}

// AddNaviDuration adds i to the "navi_duration" field.
func (m *AssistanceMutation) AddNaviDuration(i int) {
	if m.addnavi_duration != nil {
		*m.addnavi_duration += i
	} else {
		m.addnavi_duration = &i
	}
}

// AddedNaviDuration returns the value that was added to the "navi_duration" field in this mutation.
func (m *AssistanceMutation) AddedNaviDuration() (r int, exists bool) {
	v := m.addnavi_duration
	if v == nil {
		return
	}
	return *v, true
}

// ClearNaviDuration clears the value of the "navi_duration" field.
func (m *AssistanceMutation) ClearNaviDuration() {
	m.navi_duration = nil
	m.addnavi_duration = nil
	m.clearedFields[assistance.FieldNaviDuration] = struct{}{}
}

// NaviDurationCleared returns if the "navi_duration" field was cleared in this mutation.
func (m *AssistanceMutation) NaviDurationCleared() bool {
	_, ok := m.clearedFields[assistance.FieldNaviDuration]
	return ok
}

// ResetNaviDuration resets all changes to the "navi_duration" field.
func (m *AssistanceMutation) ResetNaviDuration() {
	m.navi_duration = nil
	m.addnavi_duration = nil
	delete(m.clearedFields, assistance.FieldNaviDuration)
}

// SetNaviPolylines sets the "navi_polylines" field.
func (m *AssistanceMutation) SetNaviPolylines(s []string) {
	m.navi_polylines = &s
}

// NaviPolylines returns the value of the "navi_polylines" field in the mutation.
func (m *AssistanceMutation) NaviPolylines() (r []string, exists bool) {
	v := m.navi_polylines
	if v == nil {
		return
	}
	return *v, true
}

// OldNaviPolylines returns the old "navi_polylines" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldNaviPolylines(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNaviPolylines is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNaviPolylines requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNaviPolylines: %w", err)
	}
	return oldValue.NaviPolylines, nil
}

// ClearNaviPolylines clears the value of the "navi_polylines" field.
func (m *AssistanceMutation) ClearNaviPolylines() {
	m.navi_polylines = nil
	m.clearedFields[assistance.FieldNaviPolylines] = struct{}{}
}

// NaviPolylinesCleared returns if the "navi_polylines" field was cleared in this mutation.
func (m *AssistanceMutation) NaviPolylinesCleared() bool {
	_, ok := m.clearedFields[assistance.FieldNaviPolylines]
	return ok
}

// ResetNaviPolylines resets all changes to the "navi_polylines" field.
func (m *AssistanceMutation) ResetNaviPolylines() {
	m.navi_polylines = nil
	delete(m.clearedFields, assistance.FieldNaviPolylines)
}

// ClearStore clears the "store" edge to the Store entity.
func (m *AssistanceMutation) ClearStore() {
	m.clearedstore = true
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *AssistanceMutation) StoreCleared() bool {
	return m.StoreIDCleared() || m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *AssistanceMutation) StoreIDs() (ids []uint64) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *AssistanceMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *AssistanceMutation) ClearRider() {
	m.clearedrider = true
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *AssistanceMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *AssistanceMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *AssistanceMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *AssistanceMutation) ClearSubscribe() {
	m.clearedsubscribe = true
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *AssistanceMutation) SubscribeCleared() bool {
	return m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *AssistanceMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *AssistanceMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *AssistanceMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *AssistanceMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *AssistanceMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *AssistanceMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *AssistanceMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *AssistanceMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *AssistanceMutation) OrderIDs() (ids []uint64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *AssistanceMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *AssistanceMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *AssistanceMutation) EmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *AssistanceMutation) EmployeeIDs() (ids []uint64) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *AssistanceMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// Where appends a list predicates to the AssistanceMutation builder.
func (m *AssistanceMutation) Where(ps ...predicate.Assistance) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AssistanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Assistance).
func (m *AssistanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssistanceMutation) Fields() []string {
	fields := make([]string, 0, 36)
	if m.created_at != nil {
		fields = append(fields, assistance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, assistance.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, assistance.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, assistance.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, assistance.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, assistance.FieldRemark)
	}
	if m.store != nil {
		fields = append(fields, assistance.FieldStoreID)
	}
	if m.rider != nil {
		fields = append(fields, assistance.FieldRiderID)
	}
	if m.subscribe != nil {
		fields = append(fields, assistance.FieldSubscribeID)
	}
	if m.city != nil {
		fields = append(fields, assistance.FieldCityID)
	}
	if m.employee != nil {
		fields = append(fields, assistance.FieldEmployeeID)
	}
	if m._order != nil {
		fields = append(fields, assistance.FieldOrderID)
	}
	if m.status != nil {
		fields = append(fields, assistance.FieldStatus)
	}
	if m.lng != nil {
		fields = append(fields, assistance.FieldLng)
	}
	if m.lat != nil {
		fields = append(fields, assistance.FieldLat)
	}
	if m.address != nil {
		fields = append(fields, assistance.FieldAddress)
	}
	if m.breakdown != nil {
		fields = append(fields, assistance.FieldBreakdown)
	}
	if m.breakdown_desc != nil {
		fields = append(fields, assistance.FieldBreakdownDesc)
	}
	if m.breakdown_photos != nil {
		fields = append(fields, assistance.FieldBreakdownPhotos)
	}
	if m.cancel_reason != nil {
		fields = append(fields, assistance.FieldCancelReason)
	}
	if m.cancel_reason_desc != nil {
		fields = append(fields, assistance.FieldCancelReasonDesc)
	}
	if m.distance != nil {
		fields = append(fields, assistance.FieldDistance)
	}
	if m.reason != nil {
		fields = append(fields, assistance.FieldReason)
	}
	if m.detect_photo != nil {
		fields = append(fields, assistance.FieldDetectPhoto)
	}
	if m.joint_photo != nil {
		fields = append(fields, assistance.FieldJointPhoto)
	}
	if m.cost != nil {
		fields = append(fields, assistance.FieldCost)
	}
	if m.refused_desc != nil {
		fields = append(fields, assistance.FieldRefusedDesc)
	}
	if m.pay_at != nil {
		fields = append(fields, assistance.FieldPayAt)
	}
	if m.allocate_at != nil {
		fields = append(fields, assistance.FieldAllocateAt)
	}
	if m.wait != nil {
		fields = append(fields, assistance.FieldWait)
	}
	if m.free_reason != nil {
		fields = append(fields, assistance.FieldFreeReason)
	}
	if m.fail_reason != nil {
		fields = append(fields, assistance.FieldFailReason)
	}
	if m.process_at != nil {
		fields = append(fields, assistance.FieldProcessAt)
	}
	if m.price != nil {
		fields = append(fields, assistance.FieldPrice)
	}
	if m.navi_duration != nil {
		fields = append(fields, assistance.FieldNaviDuration)
	}
	if m.navi_polylines != nil {
		fields = append(fields, assistance.FieldNaviPolylines)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssistanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assistance.FieldCreatedAt:
		return m.CreatedAt()
	case assistance.FieldUpdatedAt:
		return m.UpdatedAt()
	case assistance.FieldDeletedAt:
		return m.DeletedAt()
	case assistance.FieldCreator:
		return m.Creator()
	case assistance.FieldLastModifier:
		return m.LastModifier()
	case assistance.FieldRemark:
		return m.Remark()
	case assistance.FieldStoreID:
		return m.StoreID()
	case assistance.FieldRiderID:
		return m.RiderID()
	case assistance.FieldSubscribeID:
		return m.SubscribeID()
	case assistance.FieldCityID:
		return m.CityID()
	case assistance.FieldEmployeeID:
		return m.EmployeeID()
	case assistance.FieldOrderID:
		return m.OrderID()
	case assistance.FieldStatus:
		return m.Status()
	case assistance.FieldLng:
		return m.Lng()
	case assistance.FieldLat:
		return m.Lat()
	case assistance.FieldAddress:
		return m.Address()
	case assistance.FieldBreakdown:
		return m.Breakdown()
	case assistance.FieldBreakdownDesc:
		return m.BreakdownDesc()
	case assistance.FieldBreakdownPhotos:
		return m.BreakdownPhotos()
	case assistance.FieldCancelReason:
		return m.CancelReason()
	case assistance.FieldCancelReasonDesc:
		return m.CancelReasonDesc()
	case assistance.FieldDistance:
		return m.Distance()
	case assistance.FieldReason:
		return m.Reason()
	case assistance.FieldDetectPhoto:
		return m.DetectPhoto()
	case assistance.FieldJointPhoto:
		return m.JointPhoto()
	case assistance.FieldCost:
		return m.Cost()
	case assistance.FieldRefusedDesc:
		return m.RefusedDesc()
	case assistance.FieldPayAt:
		return m.PayAt()
	case assistance.FieldAllocateAt:
		return m.AllocateAt()
	case assistance.FieldWait:
		return m.Wait()
	case assistance.FieldFreeReason:
		return m.FreeReason()
	case assistance.FieldFailReason:
		return m.FailReason()
	case assistance.FieldProcessAt:
		return m.ProcessAt()
	case assistance.FieldPrice:
		return m.Price()
	case assistance.FieldNaviDuration:
		return m.NaviDuration()
	case assistance.FieldNaviPolylines:
		return m.NaviPolylines()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssistanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assistance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case assistance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case assistance.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case assistance.FieldCreator:
		return m.OldCreator(ctx)
	case assistance.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case assistance.FieldRemark:
		return m.OldRemark(ctx)
	case assistance.FieldStoreID:
		return m.OldStoreID(ctx)
	case assistance.FieldRiderID:
		return m.OldRiderID(ctx)
	case assistance.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case assistance.FieldCityID:
		return m.OldCityID(ctx)
	case assistance.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case assistance.FieldOrderID:
		return m.OldOrderID(ctx)
	case assistance.FieldStatus:
		return m.OldStatus(ctx)
	case assistance.FieldLng:
		return m.OldLng(ctx)
	case assistance.FieldLat:
		return m.OldLat(ctx)
	case assistance.FieldAddress:
		return m.OldAddress(ctx)
	case assistance.FieldBreakdown:
		return m.OldBreakdown(ctx)
	case assistance.FieldBreakdownDesc:
		return m.OldBreakdownDesc(ctx)
	case assistance.FieldBreakdownPhotos:
		return m.OldBreakdownPhotos(ctx)
	case assistance.FieldCancelReason:
		return m.OldCancelReason(ctx)
	case assistance.FieldCancelReasonDesc:
		return m.OldCancelReasonDesc(ctx)
	case assistance.FieldDistance:
		return m.OldDistance(ctx)
	case assistance.FieldReason:
		return m.OldReason(ctx)
	case assistance.FieldDetectPhoto:
		return m.OldDetectPhoto(ctx)
	case assistance.FieldJointPhoto:
		return m.OldJointPhoto(ctx)
	case assistance.FieldCost:
		return m.OldCost(ctx)
	case assistance.FieldRefusedDesc:
		return m.OldRefusedDesc(ctx)
	case assistance.FieldPayAt:
		return m.OldPayAt(ctx)
	case assistance.FieldAllocateAt:
		return m.OldAllocateAt(ctx)
	case assistance.FieldWait:
		return m.OldWait(ctx)
	case assistance.FieldFreeReason:
		return m.OldFreeReason(ctx)
	case assistance.FieldFailReason:
		return m.OldFailReason(ctx)
	case assistance.FieldProcessAt:
		return m.OldProcessAt(ctx)
	case assistance.FieldPrice:
		return m.OldPrice(ctx)
	case assistance.FieldNaviDuration:
		return m.OldNaviDuration(ctx)
	case assistance.FieldNaviPolylines:
		return m.OldNaviPolylines(ctx)
	}
	return nil, fmt.Errorf("unknown Assistance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssistanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assistance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case assistance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case assistance.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case assistance.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case assistance.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case assistance.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case assistance.FieldStoreID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case assistance.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case assistance.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case assistance.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case assistance.FieldEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case assistance.FieldOrderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case assistance.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case assistance.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLng(v)
		return nil
	case assistance.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	case assistance.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case assistance.FieldBreakdown:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreakdown(v)
		return nil
	case assistance.FieldBreakdownDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreakdownDesc(v)
		return nil
	case assistance.FieldBreakdownPhotos:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreakdownPhotos(v)
		return nil
	case assistance.FieldCancelReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelReason(v)
		return nil
	case assistance.FieldCancelReasonDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelReasonDesc(v)
		return nil
	case assistance.FieldDistance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistance(v)
		return nil
	case assistance.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case assistance.FieldDetectPhoto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetectPhoto(v)
		return nil
	case assistance.FieldJointPhoto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJointPhoto(v)
		return nil
	case assistance.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCost(v)
		return nil
	case assistance.FieldRefusedDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefusedDesc(v)
		return nil
	case assistance.FieldPayAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayAt(v)
		return nil
	case assistance.FieldAllocateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllocateAt(v)
		return nil
	case assistance.FieldWait:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWait(v)
		return nil
	case assistance.FieldFreeReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreeReason(v)
		return nil
	case assistance.FieldFailReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailReason(v)
		return nil
	case assistance.FieldProcessAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessAt(v)
		return nil
	case assistance.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case assistance.FieldNaviDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNaviDuration(v)
		return nil
	case assistance.FieldNaviPolylines:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNaviPolylines(v)
		return nil
	}
	return fmt.Errorf("unknown Assistance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssistanceMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, assistance.FieldStatus)
	}
	if m.addlng != nil {
		fields = append(fields, assistance.FieldLng)
	}
	if m.addlat != nil {
		fields = append(fields, assistance.FieldLat)
	}
	if m.adddistance != nil {
		fields = append(fields, assistance.FieldDistance)
	}
	if m.addcost != nil {
		fields = append(fields, assistance.FieldCost)
	}
	if m.addwait != nil {
		fields = append(fields, assistance.FieldWait)
	}
	if m.addprice != nil {
		fields = append(fields, assistance.FieldPrice)
	}
	if m.addnavi_duration != nil {
		fields = append(fields, assistance.FieldNaviDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssistanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case assistance.FieldStatus:
		return m.AddedStatus()
	case assistance.FieldLng:
		return m.AddedLng()
	case assistance.FieldLat:
		return m.AddedLat()
	case assistance.FieldDistance:
		return m.AddedDistance()
	case assistance.FieldCost:
		return m.AddedCost()
	case assistance.FieldWait:
		return m.AddedWait()
	case assistance.FieldPrice:
		return m.AddedPrice()
	case assistance.FieldNaviDuration:
		return m.AddedNaviDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssistanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case assistance.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case assistance.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLng(v)
		return nil
	case assistance.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLat(v)
		return nil
	case assistance.FieldDistance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDistance(v)
		return nil
	case assistance.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCost(v)
		return nil
	case assistance.FieldWait:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWait(v)
		return nil
	case assistance.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case assistance.FieldNaviDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNaviDuration(v)
		return nil
	}
	return fmt.Errorf("unknown Assistance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssistanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(assistance.FieldDeletedAt) {
		fields = append(fields, assistance.FieldDeletedAt)
	}
	if m.FieldCleared(assistance.FieldCreator) {
		fields = append(fields, assistance.FieldCreator)
	}
	if m.FieldCleared(assistance.FieldLastModifier) {
		fields = append(fields, assistance.FieldLastModifier)
	}
	if m.FieldCleared(assistance.FieldRemark) {
		fields = append(fields, assistance.FieldRemark)
	}
	if m.FieldCleared(assistance.FieldStoreID) {
		fields = append(fields, assistance.FieldStoreID)
	}
	if m.FieldCleared(assistance.FieldEmployeeID) {
		fields = append(fields, assistance.FieldEmployeeID)
	}
	if m.FieldCleared(assistance.FieldOrderID) {
		fields = append(fields, assistance.FieldOrderID)
	}
	if m.FieldCleared(assistance.FieldBreakdownDesc) {
		fields = append(fields, assistance.FieldBreakdownDesc)
	}
	if m.FieldCleared(assistance.FieldCancelReason) {
		fields = append(fields, assistance.FieldCancelReason)
	}
	if m.FieldCleared(assistance.FieldCancelReasonDesc) {
		fields = append(fields, assistance.FieldCancelReasonDesc)
	}
	if m.FieldCleared(assistance.FieldDistance) {
		fields = append(fields, assistance.FieldDistance)
	}
	if m.FieldCleared(assistance.FieldReason) {
		fields = append(fields, assistance.FieldReason)
	}
	if m.FieldCleared(assistance.FieldDetectPhoto) {
		fields = append(fields, assistance.FieldDetectPhoto)
	}
	if m.FieldCleared(assistance.FieldJointPhoto) {
		fields = append(fields, assistance.FieldJointPhoto)
	}
	if m.FieldCleared(assistance.FieldCost) {
		fields = append(fields, assistance.FieldCost)
	}
	if m.FieldCleared(assistance.FieldRefusedDesc) {
		fields = append(fields, assistance.FieldRefusedDesc)
	}
	if m.FieldCleared(assistance.FieldPayAt) {
		fields = append(fields, assistance.FieldPayAt)
	}
	if m.FieldCleared(assistance.FieldAllocateAt) {
		fields = append(fields, assistance.FieldAllocateAt)
	}
	if m.FieldCleared(assistance.FieldFreeReason) {
		fields = append(fields, assistance.FieldFreeReason)
	}
	if m.FieldCleared(assistance.FieldFailReason) {
		fields = append(fields, assistance.FieldFailReason)
	}
	if m.FieldCleared(assistance.FieldProcessAt) {
		fields = append(fields, assistance.FieldProcessAt)
	}
	if m.FieldCleared(assistance.FieldPrice) {
		fields = append(fields, assistance.FieldPrice)
	}
	if m.FieldCleared(assistance.FieldNaviDuration) {
		fields = append(fields, assistance.FieldNaviDuration)
	}
	if m.FieldCleared(assistance.FieldNaviPolylines) {
		fields = append(fields, assistance.FieldNaviPolylines)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssistanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssistanceMutation) ClearField(name string) error {
	switch name {
	case assistance.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case assistance.FieldCreator:
		m.ClearCreator()
		return nil
	case assistance.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case assistance.FieldRemark:
		m.ClearRemark()
		return nil
	case assistance.FieldStoreID:
		m.ClearStoreID()
		return nil
	case assistance.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case assistance.FieldOrderID:
		m.ClearOrderID()
		return nil
	case assistance.FieldBreakdownDesc:
		m.ClearBreakdownDesc()
		return nil
	case assistance.FieldCancelReason:
		m.ClearCancelReason()
		return nil
	case assistance.FieldCancelReasonDesc:
		m.ClearCancelReasonDesc()
		return nil
	case assistance.FieldDistance:
		m.ClearDistance()
		return nil
	case assistance.FieldReason:
		m.ClearReason()
		return nil
	case assistance.FieldDetectPhoto:
		m.ClearDetectPhoto()
		return nil
	case assistance.FieldJointPhoto:
		m.ClearJointPhoto()
		return nil
	case assistance.FieldCost:
		m.ClearCost()
		return nil
	case assistance.FieldRefusedDesc:
		m.ClearRefusedDesc()
		return nil
	case assistance.FieldPayAt:
		m.ClearPayAt()
		return nil
	case assistance.FieldAllocateAt:
		m.ClearAllocateAt()
		return nil
	case assistance.FieldFreeReason:
		m.ClearFreeReason()
		return nil
	case assistance.FieldFailReason:
		m.ClearFailReason()
		return nil
	case assistance.FieldProcessAt:
		m.ClearProcessAt()
		return nil
	case assistance.FieldPrice:
		m.ClearPrice()
		return nil
	case assistance.FieldNaviDuration:
		m.ClearNaviDuration()
		return nil
	case assistance.FieldNaviPolylines:
		m.ClearNaviPolylines()
		return nil
	}
	return fmt.Errorf("unknown Assistance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssistanceMutation) ResetField(name string) error {
	switch name {
	case assistance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case assistance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case assistance.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case assistance.FieldCreator:
		m.ResetCreator()
		return nil
	case assistance.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case assistance.FieldRemark:
		m.ResetRemark()
		return nil
	case assistance.FieldStoreID:
		m.ResetStoreID()
		return nil
	case assistance.FieldRiderID:
		m.ResetRiderID()
		return nil
	case assistance.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case assistance.FieldCityID:
		m.ResetCityID()
		return nil
	case assistance.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case assistance.FieldOrderID:
		m.ResetOrderID()
		return nil
	case assistance.FieldStatus:
		m.ResetStatus()
		return nil
	case assistance.FieldLng:
		m.ResetLng()
		return nil
	case assistance.FieldLat:
		m.ResetLat()
		return nil
	case assistance.FieldAddress:
		m.ResetAddress()
		return nil
	case assistance.FieldBreakdown:
		m.ResetBreakdown()
		return nil
	case assistance.FieldBreakdownDesc:
		m.ResetBreakdownDesc()
		return nil
	case assistance.FieldBreakdownPhotos:
		m.ResetBreakdownPhotos()
		return nil
	case assistance.FieldCancelReason:
		m.ResetCancelReason()
		return nil
	case assistance.FieldCancelReasonDesc:
		m.ResetCancelReasonDesc()
		return nil
	case assistance.FieldDistance:
		m.ResetDistance()
		return nil
	case assistance.FieldReason:
		m.ResetReason()
		return nil
	case assistance.FieldDetectPhoto:
		m.ResetDetectPhoto()
		return nil
	case assistance.FieldJointPhoto:
		m.ResetJointPhoto()
		return nil
	case assistance.FieldCost:
		m.ResetCost()
		return nil
	case assistance.FieldRefusedDesc:
		m.ResetRefusedDesc()
		return nil
	case assistance.FieldPayAt:
		m.ResetPayAt()
		return nil
	case assistance.FieldAllocateAt:
		m.ResetAllocateAt()
		return nil
	case assistance.FieldWait:
		m.ResetWait()
		return nil
	case assistance.FieldFreeReason:
		m.ResetFreeReason()
		return nil
	case assistance.FieldFailReason:
		m.ResetFailReason()
		return nil
	case assistance.FieldProcessAt:
		m.ResetProcessAt()
		return nil
	case assistance.FieldPrice:
		m.ResetPrice()
		return nil
	case assistance.FieldNaviDuration:
		m.ResetNaviDuration()
		return nil
	case assistance.FieldNaviPolylines:
		m.ResetNaviPolylines()
		return nil
	}
	return fmt.Errorf("unknown Assistance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssistanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.store != nil {
		edges = append(edges, assistance.EdgeStore)
	}
	if m.rider != nil {
		edges = append(edges, assistance.EdgeRider)
	}
	if m.subscribe != nil {
		edges = append(edges, assistance.EdgeSubscribe)
	}
	if m.city != nil {
		edges = append(edges, assistance.EdgeCity)
	}
	if m._order != nil {
		edges = append(edges, assistance.EdgeOrder)
	}
	if m.employee != nil {
		edges = append(edges, assistance.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssistanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case assistance.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	case assistance.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case assistance.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	case assistance.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case assistance.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	case assistance.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssistanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssistanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssistanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedstore {
		edges = append(edges, assistance.EdgeStore)
	}
	if m.clearedrider {
		edges = append(edges, assistance.EdgeRider)
	}
	if m.clearedsubscribe {
		edges = append(edges, assistance.EdgeSubscribe)
	}
	if m.clearedcity {
		edges = append(edges, assistance.EdgeCity)
	}
	if m.cleared_order {
		edges = append(edges, assistance.EdgeOrder)
	}
	if m.clearedemployee {
		edges = append(edges, assistance.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssistanceMutation) EdgeCleared(name string) bool {
	switch name {
	case assistance.EdgeStore:
		return m.clearedstore
	case assistance.EdgeRider:
		return m.clearedrider
	case assistance.EdgeSubscribe:
		return m.clearedsubscribe
	case assistance.EdgeCity:
		return m.clearedcity
	case assistance.EdgeOrder:
		return m.cleared_order
	case assistance.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssistanceMutation) ClearEdge(name string) error {
	switch name {
	case assistance.EdgeStore:
		m.ClearStore()
		return nil
	case assistance.EdgeRider:
		m.ClearRider()
		return nil
	case assistance.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	case assistance.EdgeCity:
		m.ClearCity()
		return nil
	case assistance.EdgeOrder:
		m.ClearOrder()
		return nil
	case assistance.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown Assistance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssistanceMutation) ResetEdge(name string) error {
	switch name {
	case assistance.EdgeStore:
		m.ResetStore()
		return nil
	case assistance.EdgeRider:
		m.ResetRider()
		return nil
	case assistance.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	case assistance.EdgeCity:
		m.ResetCity()
		return nil
	case assistance.EdgeOrder:
		m.ResetOrder()
		return nil
	case assistance.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Assistance edge %s", name)
}

