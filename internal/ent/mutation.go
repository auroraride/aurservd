// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/auroraride/aurservd/app/model"
	"github.com/auroraride/aurservd/internal/ent/attendance"
	"github.com/auroraride/aurservd/internal/ent/batterymodel"
	"github.com/auroraride/aurservd/internal/ent/branch"
	"github.com/auroraride/aurservd/internal/ent/branchcontract"
	"github.com/auroraride/aurservd/internal/ent/business"
	"github.com/auroraride/aurservd/internal/ent/cabinet"
	"github.com/auroraride/aurservd/internal/ent/cabinetfault"
	"github.com/auroraride/aurservd/internal/ent/city"
	"github.com/auroraride/aurservd/internal/ent/commission"
	"github.com/auroraride/aurservd/internal/ent/contract"
	"github.com/auroraride/aurservd/internal/ent/employee"
	"github.com/auroraride/aurservd/internal/ent/enterprise"
	"github.com/auroraride/aurservd/internal/ent/enterprisebill"
	"github.com/auroraride/aurservd/internal/ent/enterprisecontract"
	"github.com/auroraride/aurservd/internal/ent/enterpriseprepayment"
	"github.com/auroraride/aurservd/internal/ent/enterpriseprice"
	"github.com/auroraride/aurservd/internal/ent/enterprisestatement"
	"github.com/auroraride/aurservd/internal/ent/enterprisestation"
	"github.com/auroraride/aurservd/internal/ent/exception"
	"github.com/auroraride/aurservd/internal/ent/exchange"
	"github.com/auroraride/aurservd/internal/ent/inventory"
	"github.com/auroraride/aurservd/internal/ent/manager"
	"github.com/auroraride/aurservd/internal/ent/order"
	"github.com/auroraride/aurservd/internal/ent/orderrefund"
	"github.com/auroraride/aurservd/internal/ent/person"
	"github.com/auroraride/aurservd/internal/ent/plan"
	"github.com/auroraride/aurservd/internal/ent/predicate"
	"github.com/auroraride/aurservd/internal/ent/rider"
	"github.com/auroraride/aurservd/internal/ent/setting"
	"github.com/auroraride/aurservd/internal/ent/stock"
	"github.com/auroraride/aurservd/internal/ent/store"
	"github.com/auroraride/aurservd/internal/ent/subscribe"
	"github.com/auroraride/aurservd/internal/ent/subscribealter"
	"github.com/auroraride/aurservd/internal/ent/subscribepause"
	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAttendance           = "Attendance"
	TypeBatteryModel         = "BatteryModel"
	TypeBranch               = "Branch"
	TypeBranchContract       = "BranchContract"
	TypeBusiness             = "Business"
	TypeCabinet              = "Cabinet"
	TypeCabinetFault         = "CabinetFault"
	TypeCity                 = "City"
	TypeCommission           = "Commission"
	TypeContract             = "Contract"
	TypeEmployee             = "Employee"
	TypeEnterprise           = "Enterprise"
	TypeEnterpriseBill       = "EnterpriseBill"
	TypeEnterpriseContract   = "EnterpriseContract"
	TypeEnterprisePrepayment = "EnterprisePrepayment"
	TypeEnterprisePrice      = "EnterprisePrice"
	TypeEnterpriseStatement  = "EnterpriseStatement"
	TypeEnterpriseStation    = "EnterpriseStation"
	TypeException            = "Exception"
	TypeExchange             = "Exchange"
	TypeInventory            = "Inventory"
	TypeManager              = "Manager"
	TypeOrder                = "Order"
	TypeOrderRefund          = "OrderRefund"
	TypePerson               = "Person"
	TypePlan                 = "Plan"
	TypeRider                = "Rider"
	TypeSetting              = "Setting"
	TypeStock                = "Stock"
	TypeStore                = "Store"
	TypeSubscribe            = "Subscribe"
	TypeSubscribeAlter       = "SubscribeAlter"
	TypeSubscribePause       = "SubscribePause"
)

// AttendanceMutation represents an operation that mutates the Attendance nodes in the graph.
type AttendanceMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	creator         **model.Modifier
	last_modifier   **model.Modifier
	remark          *string
	inventory       *map[string]int
	photo           *string
	duty            *bool
	date            *time.Time
	lng             *float64
	addlng          *float64
	lat             *float64
	addlat          *float64
	address         *string
	distance        *float64
	adddistance     *float64
	clearedFields   map[string]struct{}
	store           *uint64
	clearedstore    bool
	employee        *uint64
	clearedemployee bool
	done            bool
	oldValue        func(context.Context) (*Attendance, error)
	predicates      []predicate.Attendance
}

var _ ent.Mutation = (*AttendanceMutation)(nil)

// attendanceOption allows management of the mutation configuration using functional options.
type attendanceOption func(*AttendanceMutation)

// newAttendanceMutation creates new mutation for the Attendance entity.
func newAttendanceMutation(c config, op Op, opts ...attendanceOption) *AttendanceMutation {
	m := &AttendanceMutation{
		config:        c,
		op:            op,
		typ:           TypeAttendance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttendanceID sets the ID field of the mutation.
func withAttendanceID(id uint64) attendanceOption {
	return func(m *AttendanceMutation) {
		var (
			err   error
			once  sync.Once
			value *Attendance
		)
		m.oldValue = func(ctx context.Context) (*Attendance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Attendance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttendance sets the old Attendance of the mutation.
func withAttendance(node *Attendance) attendanceOption {
	return func(m *AttendanceMutation) {
		m.oldValue = func(context.Context) (*Attendance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttendanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttendanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttendanceMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttendanceMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Attendance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AttendanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttendanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttendanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AttendanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AttendanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AttendanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AttendanceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AttendanceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AttendanceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[attendance.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AttendanceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[attendance.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AttendanceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, attendance.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *AttendanceMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *AttendanceMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *AttendanceMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[attendance.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *AttendanceMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[attendance.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *AttendanceMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, attendance.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *AttendanceMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *AttendanceMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *AttendanceMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[attendance.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *AttendanceMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[attendance.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *AttendanceMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, attendance.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *AttendanceMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *AttendanceMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *AttendanceMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[attendance.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *AttendanceMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[attendance.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *AttendanceMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, attendance.FieldRemark)
}

// SetStoreID sets the "store_id" field.
func (m *AttendanceMutation) SetStoreID(u uint64) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *AttendanceMutation) StoreID() (r uint64, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldStoreID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *AttendanceMutation) ResetStoreID() {
	m.store = nil
}

// SetEmployeeID sets the "employee_id" field.
func (m *AttendanceMutation) SetEmployeeID(u uint64) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *AttendanceMutation) EmployeeID() (r uint64, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldEmployeeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *AttendanceMutation) ResetEmployeeID() {
	m.employee = nil
}

// SetInventory sets the "inventory" field.
func (m *AttendanceMutation) SetInventory(value map[string]int) {
	m.inventory = &value
}

// Inventory returns the value of the "inventory" field in the mutation.
func (m *AttendanceMutation) Inventory() (r map[string]int, exists bool) {
	v := m.inventory
	if v == nil {
		return
	}
	return *v, true
}

// OldInventory returns the old "inventory" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldInventory(ctx context.Context) (v map[string]int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInventory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInventory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInventory: %w", err)
	}
	return oldValue.Inventory, nil
}

// ClearInventory clears the value of the "inventory" field.
func (m *AttendanceMutation) ClearInventory() {
	m.inventory = nil
	m.clearedFields[attendance.FieldInventory] = struct{}{}
}

// InventoryCleared returns if the "inventory" field was cleared in this mutation.
func (m *AttendanceMutation) InventoryCleared() bool {
	_, ok := m.clearedFields[attendance.FieldInventory]
	return ok
}

// ResetInventory resets all changes to the "inventory" field.
func (m *AttendanceMutation) ResetInventory() {
	m.inventory = nil
	delete(m.clearedFields, attendance.FieldInventory)
}

// SetPhoto sets the "photo" field.
func (m *AttendanceMutation) SetPhoto(s string) {
	m.photo = &s
}

// Photo returns the value of the "photo" field in the mutation.
func (m *AttendanceMutation) Photo() (r string, exists bool) {
	v := m.photo
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoto returns the old "photo" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldPhoto(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoto: %w", err)
	}
	return oldValue.Photo, nil
}

// ClearPhoto clears the value of the "photo" field.
func (m *AttendanceMutation) ClearPhoto() {
	m.photo = nil
	m.clearedFields[attendance.FieldPhoto] = struct{}{}
}

// PhotoCleared returns if the "photo" field was cleared in this mutation.
func (m *AttendanceMutation) PhotoCleared() bool {
	_, ok := m.clearedFields[attendance.FieldPhoto]
	return ok
}

// ResetPhoto resets all changes to the "photo" field.
func (m *AttendanceMutation) ResetPhoto() {
	m.photo = nil
	delete(m.clearedFields, attendance.FieldPhoto)
}

// SetDuty sets the "duty" field.
func (m *AttendanceMutation) SetDuty(b bool) {
	m.duty = &b
}

// Duty returns the value of the "duty" field in the mutation.
func (m *AttendanceMutation) Duty() (r bool, exists bool) {
	v := m.duty
	if v == nil {
		return
	}
	return *v, true
}

// OldDuty returns the old "duty" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldDuty(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuty: %w", err)
	}
	return oldValue.Duty, nil
}

// ResetDuty resets all changes to the "duty" field.
func (m *AttendanceMutation) ResetDuty() {
	m.duty = nil
}

// SetDate sets the "date" field.
func (m *AttendanceMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *AttendanceMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *AttendanceMutation) ResetDate() {
	m.date = nil
}

// SetLng sets the "lng" field.
func (m *AttendanceMutation) SetLng(f float64) {
	m.lng = &f
	m.addlng = nil
}

// Lng returns the value of the "lng" field in the mutation.
func (m *AttendanceMutation) Lng() (r float64, exists bool) {
	v := m.lng
	if v == nil {
		return
	}
	return *v, true
}

// OldLng returns the old "lng" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldLng(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLng is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLng requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLng: %w", err)
	}
	return oldValue.Lng, nil
}

// AddLng adds f to the "lng" field.
func (m *AttendanceMutation) AddLng(f float64) {
	if m.addlng != nil {
		*m.addlng += f
	} else {
		m.addlng = &f
	}
}

// AddedLng returns the value that was added to the "lng" field in this mutation.
func (m *AttendanceMutation) AddedLng() (r float64, exists bool) {
	v := m.addlng
	if v == nil {
		return
	}
	return *v, true
}

// ClearLng clears the value of the "lng" field.
func (m *AttendanceMutation) ClearLng() {
	m.lng = nil
	m.addlng = nil
	m.clearedFields[attendance.FieldLng] = struct{}{}
}

// LngCleared returns if the "lng" field was cleared in this mutation.
func (m *AttendanceMutation) LngCleared() bool {
	_, ok := m.clearedFields[attendance.FieldLng]
	return ok
}

// ResetLng resets all changes to the "lng" field.
func (m *AttendanceMutation) ResetLng() {
	m.lng = nil
	m.addlng = nil
	delete(m.clearedFields, attendance.FieldLng)
}

// SetLat sets the "lat" field.
func (m *AttendanceMutation) SetLat(f float64) {
	m.lat = &f
	m.addlat = nil
}

// Lat returns the value of the "lat" field in the mutation.
func (m *AttendanceMutation) Lat() (r float64, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "lat" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldLat(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// AddLat adds f to the "lat" field.
func (m *AttendanceMutation) AddLat(f float64) {
	if m.addlat != nil {
		*m.addlat += f
	} else {
		m.addlat = &f
	}
}

// AddedLat returns the value that was added to the "lat" field in this mutation.
func (m *AttendanceMutation) AddedLat() (r float64, exists bool) {
	v := m.addlat
	if v == nil {
		return
	}
	return *v, true
}

// ClearLat clears the value of the "lat" field.
func (m *AttendanceMutation) ClearLat() {
	m.lat = nil
	m.addlat = nil
	m.clearedFields[attendance.FieldLat] = struct{}{}
}

// LatCleared returns if the "lat" field was cleared in this mutation.
func (m *AttendanceMutation) LatCleared() bool {
	_, ok := m.clearedFields[attendance.FieldLat]
	return ok
}

// ResetLat resets all changes to the "lat" field.
func (m *AttendanceMutation) ResetLat() {
	m.lat = nil
	m.addlat = nil
	delete(m.clearedFields, attendance.FieldLat)
}

// SetAddress sets the "address" field.
func (m *AttendanceMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *AttendanceMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *AttendanceMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[attendance.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *AttendanceMutation) AddressCleared() bool {
	_, ok := m.clearedFields[attendance.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *AttendanceMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, attendance.FieldAddress)
}

// SetDistance sets the "distance" field.
func (m *AttendanceMutation) SetDistance(f float64) {
	m.distance = &f
	m.adddistance = nil
}

// Distance returns the value of the "distance" field in the mutation.
func (m *AttendanceMutation) Distance() (r float64, exists bool) {
	v := m.distance
	if v == nil {
		return
	}
	return *v, true
}

// OldDistance returns the old "distance" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldDistance(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistance: %w", err)
	}
	return oldValue.Distance, nil
}

// AddDistance adds f to the "distance" field.
func (m *AttendanceMutation) AddDistance(f float64) {
	if m.adddistance != nil {
		*m.adddistance += f
	} else {
		m.adddistance = &f
	}
}

// AddedDistance returns the value that was added to the "distance" field in this mutation.
func (m *AttendanceMutation) AddedDistance() (r float64, exists bool) {
	v := m.adddistance
	if v == nil {
		return
	}
	return *v, true
}

// ClearDistance clears the value of the "distance" field.
func (m *AttendanceMutation) ClearDistance() {
	m.distance = nil
	m.adddistance = nil
	m.clearedFields[attendance.FieldDistance] = struct{}{}
}

// DistanceCleared returns if the "distance" field was cleared in this mutation.
func (m *AttendanceMutation) DistanceCleared() bool {
	_, ok := m.clearedFields[attendance.FieldDistance]
	return ok
}

// ResetDistance resets all changes to the "distance" field.
func (m *AttendanceMutation) ResetDistance() {
	m.distance = nil
	m.adddistance = nil
	delete(m.clearedFields, attendance.FieldDistance)
}

// ClearStore clears the "store" edge to the Store entity.
func (m *AttendanceMutation) ClearStore() {
	m.clearedstore = true
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *AttendanceMutation) StoreCleared() bool {
	return m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *AttendanceMutation) StoreIDs() (ids []uint64) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *AttendanceMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *AttendanceMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *AttendanceMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *AttendanceMutation) EmployeeIDs() (ids []uint64) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *AttendanceMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// Where appends a list predicates to the AttendanceMutation builder.
func (m *AttendanceMutation) Where(ps ...predicate.Attendance) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AttendanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Attendance).
func (m *AttendanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttendanceMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, attendance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, attendance.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, attendance.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, attendance.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, attendance.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, attendance.FieldRemark)
	}
	if m.store != nil {
		fields = append(fields, attendance.FieldStoreID)
	}
	if m.employee != nil {
		fields = append(fields, attendance.FieldEmployeeID)
	}
	if m.inventory != nil {
		fields = append(fields, attendance.FieldInventory)
	}
	if m.photo != nil {
		fields = append(fields, attendance.FieldPhoto)
	}
	if m.duty != nil {
		fields = append(fields, attendance.FieldDuty)
	}
	if m.date != nil {
		fields = append(fields, attendance.FieldDate)
	}
	if m.lng != nil {
		fields = append(fields, attendance.FieldLng)
	}
	if m.lat != nil {
		fields = append(fields, attendance.FieldLat)
	}
	if m.address != nil {
		fields = append(fields, attendance.FieldAddress)
	}
	if m.distance != nil {
		fields = append(fields, attendance.FieldDistance)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttendanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attendance.FieldCreatedAt:
		return m.CreatedAt()
	case attendance.FieldUpdatedAt:
		return m.UpdatedAt()
	case attendance.FieldDeletedAt:
		return m.DeletedAt()
	case attendance.FieldCreator:
		return m.Creator()
	case attendance.FieldLastModifier:
		return m.LastModifier()
	case attendance.FieldRemark:
		return m.Remark()
	case attendance.FieldStoreID:
		return m.StoreID()
	case attendance.FieldEmployeeID:
		return m.EmployeeID()
	case attendance.FieldInventory:
		return m.Inventory()
	case attendance.FieldPhoto:
		return m.Photo()
	case attendance.FieldDuty:
		return m.Duty()
	case attendance.FieldDate:
		return m.Date()
	case attendance.FieldLng:
		return m.Lng()
	case attendance.FieldLat:
		return m.Lat()
	case attendance.FieldAddress:
		return m.Address()
	case attendance.FieldDistance:
		return m.Distance()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttendanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attendance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case attendance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case attendance.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case attendance.FieldCreator:
		return m.OldCreator(ctx)
	case attendance.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case attendance.FieldRemark:
		return m.OldRemark(ctx)
	case attendance.FieldStoreID:
		return m.OldStoreID(ctx)
	case attendance.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case attendance.FieldInventory:
		return m.OldInventory(ctx)
	case attendance.FieldPhoto:
		return m.OldPhoto(ctx)
	case attendance.FieldDuty:
		return m.OldDuty(ctx)
	case attendance.FieldDate:
		return m.OldDate(ctx)
	case attendance.FieldLng:
		return m.OldLng(ctx)
	case attendance.FieldLat:
		return m.OldLat(ctx)
	case attendance.FieldAddress:
		return m.OldAddress(ctx)
	case attendance.FieldDistance:
		return m.OldDistance(ctx)
	}
	return nil, fmt.Errorf("unknown Attendance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttendanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attendance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case attendance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case attendance.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case attendance.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case attendance.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case attendance.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case attendance.FieldStoreID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case attendance.FieldEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case attendance.FieldInventory:
		v, ok := value.(map[string]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInventory(v)
		return nil
	case attendance.FieldPhoto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoto(v)
		return nil
	case attendance.FieldDuty:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuty(v)
		return nil
	case attendance.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case attendance.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLng(v)
		return nil
	case attendance.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	case attendance.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case attendance.FieldDistance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistance(v)
		return nil
	}
	return fmt.Errorf("unknown Attendance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttendanceMutation) AddedFields() []string {
	var fields []string
	if m.addlng != nil {
		fields = append(fields, attendance.FieldLng)
	}
	if m.addlat != nil {
		fields = append(fields, attendance.FieldLat)
	}
	if m.adddistance != nil {
		fields = append(fields, attendance.FieldDistance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttendanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case attendance.FieldLng:
		return m.AddedLng()
	case attendance.FieldLat:
		return m.AddedLat()
	case attendance.FieldDistance:
		return m.AddedDistance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttendanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case attendance.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLng(v)
		return nil
	case attendance.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLat(v)
		return nil
	case attendance.FieldDistance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDistance(v)
		return nil
	}
	return fmt.Errorf("unknown Attendance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttendanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(attendance.FieldDeletedAt) {
		fields = append(fields, attendance.FieldDeletedAt)
	}
	if m.FieldCleared(attendance.FieldCreator) {
		fields = append(fields, attendance.FieldCreator)
	}
	if m.FieldCleared(attendance.FieldLastModifier) {
		fields = append(fields, attendance.FieldLastModifier)
	}
	if m.FieldCleared(attendance.FieldRemark) {
		fields = append(fields, attendance.FieldRemark)
	}
	if m.FieldCleared(attendance.FieldInventory) {
		fields = append(fields, attendance.FieldInventory)
	}
	if m.FieldCleared(attendance.FieldPhoto) {
		fields = append(fields, attendance.FieldPhoto)
	}
	if m.FieldCleared(attendance.FieldLng) {
		fields = append(fields, attendance.FieldLng)
	}
	if m.FieldCleared(attendance.FieldLat) {
		fields = append(fields, attendance.FieldLat)
	}
	if m.FieldCleared(attendance.FieldAddress) {
		fields = append(fields, attendance.FieldAddress)
	}
	if m.FieldCleared(attendance.FieldDistance) {
		fields = append(fields, attendance.FieldDistance)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttendanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttendanceMutation) ClearField(name string) error {
	switch name {
	case attendance.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case attendance.FieldCreator:
		m.ClearCreator()
		return nil
	case attendance.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case attendance.FieldRemark:
		m.ClearRemark()
		return nil
	case attendance.FieldInventory:
		m.ClearInventory()
		return nil
	case attendance.FieldPhoto:
		m.ClearPhoto()
		return nil
	case attendance.FieldLng:
		m.ClearLng()
		return nil
	case attendance.FieldLat:
		m.ClearLat()
		return nil
	case attendance.FieldAddress:
		m.ClearAddress()
		return nil
	case attendance.FieldDistance:
		m.ClearDistance()
		return nil
	}
	return fmt.Errorf("unknown Attendance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttendanceMutation) ResetField(name string) error {
	switch name {
	case attendance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case attendance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case attendance.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case attendance.FieldCreator:
		m.ResetCreator()
		return nil
	case attendance.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case attendance.FieldRemark:
		m.ResetRemark()
		return nil
	case attendance.FieldStoreID:
		m.ResetStoreID()
		return nil
	case attendance.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case attendance.FieldInventory:
		m.ResetInventory()
		return nil
	case attendance.FieldPhoto:
		m.ResetPhoto()
		return nil
	case attendance.FieldDuty:
		m.ResetDuty()
		return nil
	case attendance.FieldDate:
		m.ResetDate()
		return nil
	case attendance.FieldLng:
		m.ResetLng()
		return nil
	case attendance.FieldLat:
		m.ResetLat()
		return nil
	case attendance.FieldAddress:
		m.ResetAddress()
		return nil
	case attendance.FieldDistance:
		m.ResetDistance()
		return nil
	}
	return fmt.Errorf("unknown Attendance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttendanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.store != nil {
		edges = append(edges, attendance.EdgeStore)
	}
	if m.employee != nil {
		edges = append(edges, attendance.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttendanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attendance.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	case attendance.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttendanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttendanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttendanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstore {
		edges = append(edges, attendance.EdgeStore)
	}
	if m.clearedemployee {
		edges = append(edges, attendance.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttendanceMutation) EdgeCleared(name string) bool {
	switch name {
	case attendance.EdgeStore:
		return m.clearedstore
	case attendance.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttendanceMutation) ClearEdge(name string) error {
	switch name {
	case attendance.EdgeStore:
		m.ClearStore()
		return nil
	case attendance.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown Attendance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttendanceMutation) ResetEdge(name string) error {
	switch name {
	case attendance.EdgeStore:
		m.ResetStore()
		return nil
	case attendance.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Attendance edge %s", name)
}

// BatteryModelMutation represents an operation that mutates the BatteryModel nodes in the graph.
type BatteryModelMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	creator         **model.Modifier
	last_modifier   **model.Modifier
	remark          *string
	voltage         *float64
	addvoltage      *float64
	capacity        *float64
	addcapacity     *float64
	clearedFields   map[string]struct{}
	cabinets        map[uint64]struct{}
	removedcabinets map[uint64]struct{}
	clearedcabinets bool
	plans           map[uint64]struct{}
	removedplans    map[uint64]struct{}
	clearedplans    bool
	done            bool
	oldValue        func(context.Context) (*BatteryModel, error)
	predicates      []predicate.BatteryModel
}

var _ ent.Mutation = (*BatteryModelMutation)(nil)

// batterymodelOption allows management of the mutation configuration using functional options.
type batterymodelOption func(*BatteryModelMutation)

// newBatteryModelMutation creates new mutation for the BatteryModel entity.
func newBatteryModelMutation(c config, op Op, opts ...batterymodelOption) *BatteryModelMutation {
	m := &BatteryModelMutation{
		config:        c,
		op:            op,
		typ:           TypeBatteryModel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBatteryModelID sets the ID field of the mutation.
func withBatteryModelID(id uint64) batterymodelOption {
	return func(m *BatteryModelMutation) {
		var (
			err   error
			once  sync.Once
			value *BatteryModel
		)
		m.oldValue = func(ctx context.Context) (*BatteryModel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BatteryModel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBatteryModel sets the old BatteryModel of the mutation.
func withBatteryModel(node *BatteryModel) batterymodelOption {
	return func(m *BatteryModelMutation) {
		m.oldValue = func(context.Context) (*BatteryModel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BatteryModelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BatteryModelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BatteryModelMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BatteryModelMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BatteryModel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BatteryModelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BatteryModelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BatteryModel entity.
// If the BatteryModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryModelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BatteryModelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BatteryModelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BatteryModelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BatteryModel entity.
// If the BatteryModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryModelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BatteryModelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BatteryModelMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BatteryModelMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BatteryModel entity.
// If the BatteryModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryModelMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BatteryModelMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[batterymodel.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BatteryModelMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[batterymodel.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BatteryModelMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, batterymodel.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *BatteryModelMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *BatteryModelMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the BatteryModel entity.
// If the BatteryModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryModelMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *BatteryModelMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[batterymodel.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *BatteryModelMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[batterymodel.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *BatteryModelMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, batterymodel.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *BatteryModelMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *BatteryModelMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the BatteryModel entity.
// If the BatteryModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryModelMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *BatteryModelMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[batterymodel.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *BatteryModelMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[batterymodel.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *BatteryModelMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, batterymodel.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *BatteryModelMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *BatteryModelMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the BatteryModel entity.
// If the BatteryModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryModelMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *BatteryModelMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[batterymodel.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *BatteryModelMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[batterymodel.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *BatteryModelMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, batterymodel.FieldRemark)
}

// SetVoltage sets the "voltage" field.
func (m *BatteryModelMutation) SetVoltage(f float64) {
	m.voltage = &f
	m.addvoltage = nil
}

// Voltage returns the value of the "voltage" field in the mutation.
func (m *BatteryModelMutation) Voltage() (r float64, exists bool) {
	v := m.voltage
	if v == nil {
		return
	}
	return *v, true
}

// OldVoltage returns the old "voltage" field's value of the BatteryModel entity.
// If the BatteryModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryModelMutation) OldVoltage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoltage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoltage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoltage: %w", err)
	}
	return oldValue.Voltage, nil
}

// AddVoltage adds f to the "voltage" field.
func (m *BatteryModelMutation) AddVoltage(f float64) {
	if m.addvoltage != nil {
		*m.addvoltage += f
	} else {
		m.addvoltage = &f
	}
}

// AddedVoltage returns the value that was added to the "voltage" field in this mutation.
func (m *BatteryModelMutation) AddedVoltage() (r float64, exists bool) {
	v := m.addvoltage
	if v == nil {
		return
	}
	return *v, true
}

// ResetVoltage resets all changes to the "voltage" field.
func (m *BatteryModelMutation) ResetVoltage() {
	m.voltage = nil
	m.addvoltage = nil
}

// SetCapacity sets the "capacity" field.
func (m *BatteryModelMutation) SetCapacity(f float64) {
	m.capacity = &f
	m.addcapacity = nil
}

// Capacity returns the value of the "capacity" field in the mutation.
func (m *BatteryModelMutation) Capacity() (r float64, exists bool) {
	v := m.capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldCapacity returns the old "capacity" field's value of the BatteryModel entity.
// If the BatteryModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryModelMutation) OldCapacity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapacity: %w", err)
	}
	return oldValue.Capacity, nil
}

// AddCapacity adds f to the "capacity" field.
func (m *BatteryModelMutation) AddCapacity(f float64) {
	if m.addcapacity != nil {
		*m.addcapacity += f
	} else {
		m.addcapacity = &f
	}
}

// AddedCapacity returns the value that was added to the "capacity" field in this mutation.
func (m *BatteryModelMutation) AddedCapacity() (r float64, exists bool) {
	v := m.addcapacity
	if v == nil {
		return
	}
	return *v, true
}

// ResetCapacity resets all changes to the "capacity" field.
func (m *BatteryModelMutation) ResetCapacity() {
	m.capacity = nil
	m.addcapacity = nil
}

// AddCabinetIDs adds the "cabinets" edge to the Cabinet entity by ids.
func (m *BatteryModelMutation) AddCabinetIDs(ids ...uint64) {
	if m.cabinets == nil {
		m.cabinets = make(map[uint64]struct{})
	}
	for i := range ids {
		m.cabinets[ids[i]] = struct{}{}
	}
}

// ClearCabinets clears the "cabinets" edge to the Cabinet entity.
func (m *BatteryModelMutation) ClearCabinets() {
	m.clearedcabinets = true
}

// CabinetsCleared reports if the "cabinets" edge to the Cabinet entity was cleared.
func (m *BatteryModelMutation) CabinetsCleared() bool {
	return m.clearedcabinets
}

// RemoveCabinetIDs removes the "cabinets" edge to the Cabinet entity by IDs.
func (m *BatteryModelMutation) RemoveCabinetIDs(ids ...uint64) {
	if m.removedcabinets == nil {
		m.removedcabinets = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.cabinets, ids[i])
		m.removedcabinets[ids[i]] = struct{}{}
	}
}

// RemovedCabinets returns the removed IDs of the "cabinets" edge to the Cabinet entity.
func (m *BatteryModelMutation) RemovedCabinetsIDs() (ids []uint64) {
	for id := range m.removedcabinets {
		ids = append(ids, id)
	}
	return
}

// CabinetsIDs returns the "cabinets" edge IDs in the mutation.
func (m *BatteryModelMutation) CabinetsIDs() (ids []uint64) {
	for id := range m.cabinets {
		ids = append(ids, id)
	}
	return
}

// ResetCabinets resets all changes to the "cabinets" edge.
func (m *BatteryModelMutation) ResetCabinets() {
	m.cabinets = nil
	m.clearedcabinets = false
	m.removedcabinets = nil
}

// AddPlanIDs adds the "plans" edge to the Plan entity by ids.
func (m *BatteryModelMutation) AddPlanIDs(ids ...uint64) {
	if m.plans == nil {
		m.plans = make(map[uint64]struct{})
	}
	for i := range ids {
		m.plans[ids[i]] = struct{}{}
	}
}

// ClearPlans clears the "plans" edge to the Plan entity.
func (m *BatteryModelMutation) ClearPlans() {
	m.clearedplans = true
}

// PlansCleared reports if the "plans" edge to the Plan entity was cleared.
func (m *BatteryModelMutation) PlansCleared() bool {
	return m.clearedplans
}

// RemovePlanIDs removes the "plans" edge to the Plan entity by IDs.
func (m *BatteryModelMutation) RemovePlanIDs(ids ...uint64) {
	if m.removedplans == nil {
		m.removedplans = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.plans, ids[i])
		m.removedplans[ids[i]] = struct{}{}
	}
}

// RemovedPlans returns the removed IDs of the "plans" edge to the Plan entity.
func (m *BatteryModelMutation) RemovedPlansIDs() (ids []uint64) {
	for id := range m.removedplans {
		ids = append(ids, id)
	}
	return
}

// PlansIDs returns the "plans" edge IDs in the mutation.
func (m *BatteryModelMutation) PlansIDs() (ids []uint64) {
	for id := range m.plans {
		ids = append(ids, id)
	}
	return
}

// ResetPlans resets all changes to the "plans" edge.
func (m *BatteryModelMutation) ResetPlans() {
	m.plans = nil
	m.clearedplans = false
	m.removedplans = nil
}

// Where appends a list predicates to the BatteryModelMutation builder.
func (m *BatteryModelMutation) Where(ps ...predicate.BatteryModel) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BatteryModelMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BatteryModel).
func (m *BatteryModelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BatteryModelMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, batterymodel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, batterymodel.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, batterymodel.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, batterymodel.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, batterymodel.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, batterymodel.FieldRemark)
	}
	if m.voltage != nil {
		fields = append(fields, batterymodel.FieldVoltage)
	}
	if m.capacity != nil {
		fields = append(fields, batterymodel.FieldCapacity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BatteryModelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case batterymodel.FieldCreatedAt:
		return m.CreatedAt()
	case batterymodel.FieldUpdatedAt:
		return m.UpdatedAt()
	case batterymodel.FieldDeletedAt:
		return m.DeletedAt()
	case batterymodel.FieldCreator:
		return m.Creator()
	case batterymodel.FieldLastModifier:
		return m.LastModifier()
	case batterymodel.FieldRemark:
		return m.Remark()
	case batterymodel.FieldVoltage:
		return m.Voltage()
	case batterymodel.FieldCapacity:
		return m.Capacity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BatteryModelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case batterymodel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case batterymodel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case batterymodel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case batterymodel.FieldCreator:
		return m.OldCreator(ctx)
	case batterymodel.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case batterymodel.FieldRemark:
		return m.OldRemark(ctx)
	case batterymodel.FieldVoltage:
		return m.OldVoltage(ctx)
	case batterymodel.FieldCapacity:
		return m.OldCapacity(ctx)
	}
	return nil, fmt.Errorf("unknown BatteryModel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BatteryModelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case batterymodel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case batterymodel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case batterymodel.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case batterymodel.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case batterymodel.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case batterymodel.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case batterymodel.FieldVoltage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoltage(v)
		return nil
	case batterymodel.FieldCapacity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapacity(v)
		return nil
	}
	return fmt.Errorf("unknown BatteryModel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BatteryModelMutation) AddedFields() []string {
	var fields []string
	if m.addvoltage != nil {
		fields = append(fields, batterymodel.FieldVoltage)
	}
	if m.addcapacity != nil {
		fields = append(fields, batterymodel.FieldCapacity)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BatteryModelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case batterymodel.FieldVoltage:
		return m.AddedVoltage()
	case batterymodel.FieldCapacity:
		return m.AddedCapacity()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BatteryModelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case batterymodel.FieldVoltage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVoltage(v)
		return nil
	case batterymodel.FieldCapacity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCapacity(v)
		return nil
	}
	return fmt.Errorf("unknown BatteryModel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BatteryModelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(batterymodel.FieldDeletedAt) {
		fields = append(fields, batterymodel.FieldDeletedAt)
	}
	if m.FieldCleared(batterymodel.FieldCreator) {
		fields = append(fields, batterymodel.FieldCreator)
	}
	if m.FieldCleared(batterymodel.FieldLastModifier) {
		fields = append(fields, batterymodel.FieldLastModifier)
	}
	if m.FieldCleared(batterymodel.FieldRemark) {
		fields = append(fields, batterymodel.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BatteryModelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BatteryModelMutation) ClearField(name string) error {
	switch name {
	case batterymodel.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case batterymodel.FieldCreator:
		m.ClearCreator()
		return nil
	case batterymodel.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case batterymodel.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown BatteryModel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BatteryModelMutation) ResetField(name string) error {
	switch name {
	case batterymodel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case batterymodel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case batterymodel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case batterymodel.FieldCreator:
		m.ResetCreator()
		return nil
	case batterymodel.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case batterymodel.FieldRemark:
		m.ResetRemark()
		return nil
	case batterymodel.FieldVoltage:
		m.ResetVoltage()
		return nil
	case batterymodel.FieldCapacity:
		m.ResetCapacity()
		return nil
	}
	return fmt.Errorf("unknown BatteryModel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BatteryModelMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cabinets != nil {
		edges = append(edges, batterymodel.EdgeCabinets)
	}
	if m.plans != nil {
		edges = append(edges, batterymodel.EdgePlans)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BatteryModelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case batterymodel.EdgeCabinets:
		ids := make([]ent.Value, 0, len(m.cabinets))
		for id := range m.cabinets {
			ids = append(ids, id)
		}
		return ids
	case batterymodel.EdgePlans:
		ids := make([]ent.Value, 0, len(m.plans))
		for id := range m.plans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BatteryModelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcabinets != nil {
		edges = append(edges, batterymodel.EdgeCabinets)
	}
	if m.removedplans != nil {
		edges = append(edges, batterymodel.EdgePlans)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BatteryModelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case batterymodel.EdgeCabinets:
		ids := make([]ent.Value, 0, len(m.removedcabinets))
		for id := range m.removedcabinets {
			ids = append(ids, id)
		}
		return ids
	case batterymodel.EdgePlans:
		ids := make([]ent.Value, 0, len(m.removedplans))
		for id := range m.removedplans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BatteryModelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcabinets {
		edges = append(edges, batterymodel.EdgeCabinets)
	}
	if m.clearedplans {
		edges = append(edges, batterymodel.EdgePlans)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BatteryModelMutation) EdgeCleared(name string) bool {
	switch name {
	case batterymodel.EdgeCabinets:
		return m.clearedcabinets
	case batterymodel.EdgePlans:
		return m.clearedplans
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BatteryModelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BatteryModel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BatteryModelMutation) ResetEdge(name string) error {
	switch name {
	case batterymodel.EdgeCabinets:
		m.ResetCabinets()
		return nil
	case batterymodel.EdgePlans:
		m.ResetPlans()
		return nil
	}
	return fmt.Errorf("unknown BatteryModel edge %s", name)
}

// BranchMutation represents an operation that mutates the Branch nodes in the graph.
type BranchMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	creator          **model.Modifier
	last_modifier    **model.Modifier
	remark           *string
	name             *string
	lng              *float64
	addlng           *float64
	lat              *float64
	addlat           *float64
	address          *string
	photos           *[]string
	geom             **model.Geometry
	clearedFields    map[string]struct{}
	city             *uint64
	clearedcity      bool
	contracts        map[uint64]struct{}
	removedcontracts map[uint64]struct{}
	clearedcontracts bool
	cabinets         map[uint64]struct{}
	removedcabinets  map[uint64]struct{}
	clearedcabinets  bool
	faults           map[uint64]struct{}
	removedfaults    map[uint64]struct{}
	clearedfaults    bool
	stores           map[uint64]struct{}
	removedstores    map[uint64]struct{}
	clearedstores    bool
	done             bool
	oldValue         func(context.Context) (*Branch, error)
	predicates       []predicate.Branch
}

var _ ent.Mutation = (*BranchMutation)(nil)

// branchOption allows management of the mutation configuration using functional options.
type branchOption func(*BranchMutation)

// newBranchMutation creates new mutation for the Branch entity.
func newBranchMutation(c config, op Op, opts ...branchOption) *BranchMutation {
	m := &BranchMutation{
		config:        c,
		op:            op,
		typ:           TypeBranch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBranchID sets the ID field of the mutation.
func withBranchID(id uint64) branchOption {
	return func(m *BranchMutation) {
		var (
			err   error
			once  sync.Once
			value *Branch
		)
		m.oldValue = func(ctx context.Context) (*Branch, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Branch.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBranch sets the old Branch of the mutation.
func withBranch(node *Branch) branchOption {
	return func(m *BranchMutation) {
		m.oldValue = func(context.Context) (*Branch, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BranchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BranchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BranchMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BranchMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Branch.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BranchMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BranchMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BranchMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BranchMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BranchMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BranchMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BranchMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BranchMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BranchMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[branch.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BranchMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[branch.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BranchMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, branch.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *BranchMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *BranchMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *BranchMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[branch.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *BranchMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[branch.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *BranchMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, branch.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *BranchMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *BranchMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *BranchMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[branch.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *BranchMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[branch.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *BranchMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, branch.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *BranchMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *BranchMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *BranchMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[branch.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *BranchMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[branch.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *BranchMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, branch.FieldRemark)
}

// SetCityID sets the "city_id" field.
func (m *BranchMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *BranchMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *BranchMutation) ResetCityID() {
	m.city = nil
}

// SetName sets the "name" field.
func (m *BranchMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BranchMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BranchMutation) ResetName() {
	m.name = nil
}

// SetLng sets the "lng" field.
func (m *BranchMutation) SetLng(f float64) {
	m.lng = &f
	m.addlng = nil
}

// Lng returns the value of the "lng" field in the mutation.
func (m *BranchMutation) Lng() (r float64, exists bool) {
	v := m.lng
	if v == nil {
		return
	}
	return *v, true
}

// OldLng returns the old "lng" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldLng(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLng is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLng requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLng: %w", err)
	}
	return oldValue.Lng, nil
}

// AddLng adds f to the "lng" field.
func (m *BranchMutation) AddLng(f float64) {
	if m.addlng != nil {
		*m.addlng += f
	} else {
		m.addlng = &f
	}
}

// AddedLng returns the value that was added to the "lng" field in this mutation.
func (m *BranchMutation) AddedLng() (r float64, exists bool) {
	v := m.addlng
	if v == nil {
		return
	}
	return *v, true
}

// ResetLng resets all changes to the "lng" field.
func (m *BranchMutation) ResetLng() {
	m.lng = nil
	m.addlng = nil
}

// SetLat sets the "lat" field.
func (m *BranchMutation) SetLat(f float64) {
	m.lat = &f
	m.addlat = nil
}

// Lat returns the value of the "lat" field in the mutation.
func (m *BranchMutation) Lat() (r float64, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "lat" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// AddLat adds f to the "lat" field.
func (m *BranchMutation) AddLat(f float64) {
	if m.addlat != nil {
		*m.addlat += f
	} else {
		m.addlat = &f
	}
}

// AddedLat returns the value that was added to the "lat" field in this mutation.
func (m *BranchMutation) AddedLat() (r float64, exists bool) {
	v := m.addlat
	if v == nil {
		return
	}
	return *v, true
}

// ResetLat resets all changes to the "lat" field.
func (m *BranchMutation) ResetLat() {
	m.lat = nil
	m.addlat = nil
}

// SetAddress sets the "address" field.
func (m *BranchMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *BranchMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *BranchMutation) ResetAddress() {
	m.address = nil
}

// SetPhotos sets the "photos" field.
func (m *BranchMutation) SetPhotos(s []string) {
	m.photos = &s
}

// Photos returns the value of the "photos" field in the mutation.
func (m *BranchMutation) Photos() (r []string, exists bool) {
	v := m.photos
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotos returns the old "photos" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldPhotos(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotos is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotos requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotos: %w", err)
	}
	return oldValue.Photos, nil
}

// ResetPhotos resets all changes to the "photos" field.
func (m *BranchMutation) ResetPhotos() {
	m.photos = nil
}

// SetGeom sets the "geom" field.
func (m *BranchMutation) SetGeom(value *model.Geometry) {
	m.geom = &value
}

// Geom returns the value of the "geom" field in the mutation.
func (m *BranchMutation) Geom() (r *model.Geometry, exists bool) {
	v := m.geom
	if v == nil {
		return
	}
	return *v, true
}

// OldGeom returns the old "geom" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldGeom(ctx context.Context) (v *model.Geometry, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeom: %w", err)
	}
	return oldValue.Geom, nil
}

// ResetGeom resets all changes to the "geom" field.
func (m *BranchMutation) ResetGeom() {
	m.geom = nil
}

// ClearCity clears the "city" edge to the City entity.
func (m *BranchMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *BranchMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *BranchMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *BranchMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// AddContractIDs adds the "contracts" edge to the BranchContract entity by ids.
func (m *BranchMutation) AddContractIDs(ids ...uint64) {
	if m.contracts == nil {
		m.contracts = make(map[uint64]struct{})
	}
	for i := range ids {
		m.contracts[ids[i]] = struct{}{}
	}
}

// ClearContracts clears the "contracts" edge to the BranchContract entity.
func (m *BranchMutation) ClearContracts() {
	m.clearedcontracts = true
}

// ContractsCleared reports if the "contracts" edge to the BranchContract entity was cleared.
func (m *BranchMutation) ContractsCleared() bool {
	return m.clearedcontracts
}

// RemoveContractIDs removes the "contracts" edge to the BranchContract entity by IDs.
func (m *BranchMutation) RemoveContractIDs(ids ...uint64) {
	if m.removedcontracts == nil {
		m.removedcontracts = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.contracts, ids[i])
		m.removedcontracts[ids[i]] = struct{}{}
	}
}

// RemovedContracts returns the removed IDs of the "contracts" edge to the BranchContract entity.
func (m *BranchMutation) RemovedContractsIDs() (ids []uint64) {
	for id := range m.removedcontracts {
		ids = append(ids, id)
	}
	return
}

// ContractsIDs returns the "contracts" edge IDs in the mutation.
func (m *BranchMutation) ContractsIDs() (ids []uint64) {
	for id := range m.contracts {
		ids = append(ids, id)
	}
	return
}

// ResetContracts resets all changes to the "contracts" edge.
func (m *BranchMutation) ResetContracts() {
	m.contracts = nil
	m.clearedcontracts = false
	m.removedcontracts = nil
}

// AddCabinetIDs adds the "cabinets" edge to the Cabinet entity by ids.
func (m *BranchMutation) AddCabinetIDs(ids ...uint64) {
	if m.cabinets == nil {
		m.cabinets = make(map[uint64]struct{})
	}
	for i := range ids {
		m.cabinets[ids[i]] = struct{}{}
	}
}

// ClearCabinets clears the "cabinets" edge to the Cabinet entity.
func (m *BranchMutation) ClearCabinets() {
	m.clearedcabinets = true
}

// CabinetsCleared reports if the "cabinets" edge to the Cabinet entity was cleared.
func (m *BranchMutation) CabinetsCleared() bool {
	return m.clearedcabinets
}

// RemoveCabinetIDs removes the "cabinets" edge to the Cabinet entity by IDs.
func (m *BranchMutation) RemoveCabinetIDs(ids ...uint64) {
	if m.removedcabinets == nil {
		m.removedcabinets = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.cabinets, ids[i])
		m.removedcabinets[ids[i]] = struct{}{}
	}
}

// RemovedCabinets returns the removed IDs of the "cabinets" edge to the Cabinet entity.
func (m *BranchMutation) RemovedCabinetsIDs() (ids []uint64) {
	for id := range m.removedcabinets {
		ids = append(ids, id)
	}
	return
}

// CabinetsIDs returns the "cabinets" edge IDs in the mutation.
func (m *BranchMutation) CabinetsIDs() (ids []uint64) {
	for id := range m.cabinets {
		ids = append(ids, id)
	}
	return
}

// ResetCabinets resets all changes to the "cabinets" edge.
func (m *BranchMutation) ResetCabinets() {
	m.cabinets = nil
	m.clearedcabinets = false
	m.removedcabinets = nil
}

// AddFaultIDs adds the "faults" edge to the CabinetFault entity by ids.
func (m *BranchMutation) AddFaultIDs(ids ...uint64) {
	if m.faults == nil {
		m.faults = make(map[uint64]struct{})
	}
	for i := range ids {
		m.faults[ids[i]] = struct{}{}
	}
}

// ClearFaults clears the "faults" edge to the CabinetFault entity.
func (m *BranchMutation) ClearFaults() {
	m.clearedfaults = true
}

// FaultsCleared reports if the "faults" edge to the CabinetFault entity was cleared.
func (m *BranchMutation) FaultsCleared() bool {
	return m.clearedfaults
}

// RemoveFaultIDs removes the "faults" edge to the CabinetFault entity by IDs.
func (m *BranchMutation) RemoveFaultIDs(ids ...uint64) {
	if m.removedfaults == nil {
		m.removedfaults = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.faults, ids[i])
		m.removedfaults[ids[i]] = struct{}{}
	}
}

// RemovedFaults returns the removed IDs of the "faults" edge to the CabinetFault entity.
func (m *BranchMutation) RemovedFaultsIDs() (ids []uint64) {
	for id := range m.removedfaults {
		ids = append(ids, id)
	}
	return
}

// FaultsIDs returns the "faults" edge IDs in the mutation.
func (m *BranchMutation) FaultsIDs() (ids []uint64) {
	for id := range m.faults {
		ids = append(ids, id)
	}
	return
}

// ResetFaults resets all changes to the "faults" edge.
func (m *BranchMutation) ResetFaults() {
	m.faults = nil
	m.clearedfaults = false
	m.removedfaults = nil
}

// AddStoreIDs adds the "stores" edge to the Store entity by ids.
func (m *BranchMutation) AddStoreIDs(ids ...uint64) {
	if m.stores == nil {
		m.stores = make(map[uint64]struct{})
	}
	for i := range ids {
		m.stores[ids[i]] = struct{}{}
	}
}

// ClearStores clears the "stores" edge to the Store entity.
func (m *BranchMutation) ClearStores() {
	m.clearedstores = true
}

// StoresCleared reports if the "stores" edge to the Store entity was cleared.
func (m *BranchMutation) StoresCleared() bool {
	return m.clearedstores
}

// RemoveStoreIDs removes the "stores" edge to the Store entity by IDs.
func (m *BranchMutation) RemoveStoreIDs(ids ...uint64) {
	if m.removedstores == nil {
		m.removedstores = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.stores, ids[i])
		m.removedstores[ids[i]] = struct{}{}
	}
}

// RemovedStores returns the removed IDs of the "stores" edge to the Store entity.
func (m *BranchMutation) RemovedStoresIDs() (ids []uint64) {
	for id := range m.removedstores {
		ids = append(ids, id)
	}
	return
}

// StoresIDs returns the "stores" edge IDs in the mutation.
func (m *BranchMutation) StoresIDs() (ids []uint64) {
	for id := range m.stores {
		ids = append(ids, id)
	}
	return
}

// ResetStores resets all changes to the "stores" edge.
func (m *BranchMutation) ResetStores() {
	m.stores = nil
	m.clearedstores = false
	m.removedstores = nil
}

// Where appends a list predicates to the BranchMutation builder.
func (m *BranchMutation) Where(ps ...predicate.Branch) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BranchMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Branch).
func (m *BranchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BranchMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, branch.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, branch.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, branch.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, branch.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, branch.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, branch.FieldRemark)
	}
	if m.city != nil {
		fields = append(fields, branch.FieldCityID)
	}
	if m.name != nil {
		fields = append(fields, branch.FieldName)
	}
	if m.lng != nil {
		fields = append(fields, branch.FieldLng)
	}
	if m.lat != nil {
		fields = append(fields, branch.FieldLat)
	}
	if m.address != nil {
		fields = append(fields, branch.FieldAddress)
	}
	if m.photos != nil {
		fields = append(fields, branch.FieldPhotos)
	}
	if m.geom != nil {
		fields = append(fields, branch.FieldGeom)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BranchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case branch.FieldCreatedAt:
		return m.CreatedAt()
	case branch.FieldUpdatedAt:
		return m.UpdatedAt()
	case branch.FieldDeletedAt:
		return m.DeletedAt()
	case branch.FieldCreator:
		return m.Creator()
	case branch.FieldLastModifier:
		return m.LastModifier()
	case branch.FieldRemark:
		return m.Remark()
	case branch.FieldCityID:
		return m.CityID()
	case branch.FieldName:
		return m.Name()
	case branch.FieldLng:
		return m.Lng()
	case branch.FieldLat:
		return m.Lat()
	case branch.FieldAddress:
		return m.Address()
	case branch.FieldPhotos:
		return m.Photos()
	case branch.FieldGeom:
		return m.Geom()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BranchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case branch.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case branch.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case branch.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case branch.FieldCreator:
		return m.OldCreator(ctx)
	case branch.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case branch.FieldRemark:
		return m.OldRemark(ctx)
	case branch.FieldCityID:
		return m.OldCityID(ctx)
	case branch.FieldName:
		return m.OldName(ctx)
	case branch.FieldLng:
		return m.OldLng(ctx)
	case branch.FieldLat:
		return m.OldLat(ctx)
	case branch.FieldAddress:
		return m.OldAddress(ctx)
	case branch.FieldPhotos:
		return m.OldPhotos(ctx)
	case branch.FieldGeom:
		return m.OldGeom(ctx)
	}
	return nil, fmt.Errorf("unknown Branch field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BranchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case branch.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case branch.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case branch.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case branch.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case branch.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case branch.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case branch.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case branch.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case branch.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLng(v)
		return nil
	case branch.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	case branch.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case branch.FieldPhotos:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotos(v)
		return nil
	case branch.FieldGeom:
		v, ok := value.(*model.Geometry)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeom(v)
		return nil
	}
	return fmt.Errorf("unknown Branch field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BranchMutation) AddedFields() []string {
	var fields []string
	if m.addlng != nil {
		fields = append(fields, branch.FieldLng)
	}
	if m.addlat != nil {
		fields = append(fields, branch.FieldLat)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BranchMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case branch.FieldLng:
		return m.AddedLng()
	case branch.FieldLat:
		return m.AddedLat()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BranchMutation) AddField(name string, value ent.Value) error {
	switch name {
	case branch.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLng(v)
		return nil
	case branch.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLat(v)
		return nil
	}
	return fmt.Errorf("unknown Branch numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BranchMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(branch.FieldDeletedAt) {
		fields = append(fields, branch.FieldDeletedAt)
	}
	if m.FieldCleared(branch.FieldCreator) {
		fields = append(fields, branch.FieldCreator)
	}
	if m.FieldCleared(branch.FieldLastModifier) {
		fields = append(fields, branch.FieldLastModifier)
	}
	if m.FieldCleared(branch.FieldRemark) {
		fields = append(fields, branch.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BranchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BranchMutation) ClearField(name string) error {
	switch name {
	case branch.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case branch.FieldCreator:
		m.ClearCreator()
		return nil
	case branch.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case branch.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Branch nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BranchMutation) ResetField(name string) error {
	switch name {
	case branch.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case branch.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case branch.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case branch.FieldCreator:
		m.ResetCreator()
		return nil
	case branch.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case branch.FieldRemark:
		m.ResetRemark()
		return nil
	case branch.FieldCityID:
		m.ResetCityID()
		return nil
	case branch.FieldName:
		m.ResetName()
		return nil
	case branch.FieldLng:
		m.ResetLng()
		return nil
	case branch.FieldLat:
		m.ResetLat()
		return nil
	case branch.FieldAddress:
		m.ResetAddress()
		return nil
	case branch.FieldPhotos:
		m.ResetPhotos()
		return nil
	case branch.FieldGeom:
		m.ResetGeom()
		return nil
	}
	return fmt.Errorf("unknown Branch field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BranchMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.city != nil {
		edges = append(edges, branch.EdgeCity)
	}
	if m.contracts != nil {
		edges = append(edges, branch.EdgeContracts)
	}
	if m.cabinets != nil {
		edges = append(edges, branch.EdgeCabinets)
	}
	if m.faults != nil {
		edges = append(edges, branch.EdgeFaults)
	}
	if m.stores != nil {
		edges = append(edges, branch.EdgeStores)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BranchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case branch.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case branch.EdgeContracts:
		ids := make([]ent.Value, 0, len(m.contracts))
		for id := range m.contracts {
			ids = append(ids, id)
		}
		return ids
	case branch.EdgeCabinets:
		ids := make([]ent.Value, 0, len(m.cabinets))
		for id := range m.cabinets {
			ids = append(ids, id)
		}
		return ids
	case branch.EdgeFaults:
		ids := make([]ent.Value, 0, len(m.faults))
		for id := range m.faults {
			ids = append(ids, id)
		}
		return ids
	case branch.EdgeStores:
		ids := make([]ent.Value, 0, len(m.stores))
		for id := range m.stores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BranchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcontracts != nil {
		edges = append(edges, branch.EdgeContracts)
	}
	if m.removedcabinets != nil {
		edges = append(edges, branch.EdgeCabinets)
	}
	if m.removedfaults != nil {
		edges = append(edges, branch.EdgeFaults)
	}
	if m.removedstores != nil {
		edges = append(edges, branch.EdgeStores)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BranchMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case branch.EdgeContracts:
		ids := make([]ent.Value, 0, len(m.removedcontracts))
		for id := range m.removedcontracts {
			ids = append(ids, id)
		}
		return ids
	case branch.EdgeCabinets:
		ids := make([]ent.Value, 0, len(m.removedcabinets))
		for id := range m.removedcabinets {
			ids = append(ids, id)
		}
		return ids
	case branch.EdgeFaults:
		ids := make([]ent.Value, 0, len(m.removedfaults))
		for id := range m.removedfaults {
			ids = append(ids, id)
		}
		return ids
	case branch.EdgeStores:
		ids := make([]ent.Value, 0, len(m.removedstores))
		for id := range m.removedstores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BranchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcity {
		edges = append(edges, branch.EdgeCity)
	}
	if m.clearedcontracts {
		edges = append(edges, branch.EdgeContracts)
	}
	if m.clearedcabinets {
		edges = append(edges, branch.EdgeCabinets)
	}
	if m.clearedfaults {
		edges = append(edges, branch.EdgeFaults)
	}
	if m.clearedstores {
		edges = append(edges, branch.EdgeStores)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BranchMutation) EdgeCleared(name string) bool {
	switch name {
	case branch.EdgeCity:
		return m.clearedcity
	case branch.EdgeContracts:
		return m.clearedcontracts
	case branch.EdgeCabinets:
		return m.clearedcabinets
	case branch.EdgeFaults:
		return m.clearedfaults
	case branch.EdgeStores:
		return m.clearedstores
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BranchMutation) ClearEdge(name string) error {
	switch name {
	case branch.EdgeCity:
		m.ClearCity()
		return nil
	}
	return fmt.Errorf("unknown Branch unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BranchMutation) ResetEdge(name string) error {
	switch name {
	case branch.EdgeCity:
		m.ResetCity()
		return nil
	case branch.EdgeContracts:
		m.ResetContracts()
		return nil
	case branch.EdgeCabinets:
		m.ResetCabinets()
		return nil
	case branch.EdgeFaults:
		m.ResetFaults()
		return nil
	case branch.EdgeStores:
		m.ResetStores()
		return nil
	}
	return fmt.Errorf("unknown Branch edge %s", name)
}

// BranchContractMutation represents an operation that mutates the BranchContract nodes in the graph.
type BranchContractMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	creator               **model.Modifier
	last_modifier         **model.Modifier
	remark                *string
	landlord_name         *string
	id_card_number        *string
	phone                 *string
	bank_number           *string
	pledge                *float64
	addpledge             *float64
	rent                  *float64
	addrent               *float64
	lease                 *uint
	addlease              *int
	electricity_pledge    *float64
	addelectricity_pledge *float64
	electricity           *float64
	addelectricity        *float64
	area                  *float64
	addarea               *float64
	start_time            *string
	end_time              *string
	file                  *string
	sheets                *[]string
	clearedFields         map[string]struct{}
	branch                *uint64
	clearedbranch         bool
	done                  bool
	oldValue              func(context.Context) (*BranchContract, error)
	predicates            []predicate.BranchContract
}

var _ ent.Mutation = (*BranchContractMutation)(nil)

// branchcontractOption allows management of the mutation configuration using functional options.
type branchcontractOption func(*BranchContractMutation)

// newBranchContractMutation creates new mutation for the BranchContract entity.
func newBranchContractMutation(c config, op Op, opts ...branchcontractOption) *BranchContractMutation {
	m := &BranchContractMutation{
		config:        c,
		op:            op,
		typ:           TypeBranchContract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBranchContractID sets the ID field of the mutation.
func withBranchContractID(id uint64) branchcontractOption {
	return func(m *BranchContractMutation) {
		var (
			err   error
			once  sync.Once
			value *BranchContract
		)
		m.oldValue = func(ctx context.Context) (*BranchContract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BranchContract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBranchContract sets the old BranchContract of the mutation.
func withBranchContract(node *BranchContract) branchcontractOption {
	return func(m *BranchContractMutation) {
		m.oldValue = func(context.Context) (*BranchContract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BranchContractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BranchContractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BranchContractMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BranchContractMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BranchContract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BranchContractMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BranchContractMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BranchContractMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BranchContractMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BranchContractMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BranchContractMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BranchContractMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BranchContractMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BranchContractMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[branchcontract.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BranchContractMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[branchcontract.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BranchContractMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, branchcontract.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *BranchContractMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *BranchContractMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *BranchContractMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[branchcontract.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *BranchContractMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[branchcontract.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *BranchContractMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, branchcontract.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *BranchContractMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *BranchContractMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *BranchContractMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[branchcontract.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *BranchContractMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[branchcontract.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *BranchContractMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, branchcontract.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *BranchContractMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *BranchContractMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *BranchContractMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[branchcontract.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *BranchContractMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[branchcontract.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *BranchContractMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, branchcontract.FieldRemark)
}

// SetBranchID sets the "branch_id" field.
func (m *BranchContractMutation) SetBranchID(u uint64) {
	m.branch = &u
}

// BranchID returns the value of the "branch_id" field in the mutation.
func (m *BranchContractMutation) BranchID() (r uint64, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranchID returns the old "branch_id" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldBranchID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBranchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBranchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranchID: %w", err)
	}
	return oldValue.BranchID, nil
}

// ResetBranchID resets all changes to the "branch_id" field.
func (m *BranchContractMutation) ResetBranchID() {
	m.branch = nil
}

// SetLandlordName sets the "landlord_name" field.
func (m *BranchContractMutation) SetLandlordName(s string) {
	m.landlord_name = &s
}

// LandlordName returns the value of the "landlord_name" field in the mutation.
func (m *BranchContractMutation) LandlordName() (r string, exists bool) {
	v := m.landlord_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLandlordName returns the old "landlord_name" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldLandlordName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLandlordName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLandlordName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLandlordName: %w", err)
	}
	return oldValue.LandlordName, nil
}

// ResetLandlordName resets all changes to the "landlord_name" field.
func (m *BranchContractMutation) ResetLandlordName() {
	m.landlord_name = nil
}

// SetIDCardNumber sets the "id_card_number" field.
func (m *BranchContractMutation) SetIDCardNumber(s string) {
	m.id_card_number = &s
}

// IDCardNumber returns the value of the "id_card_number" field in the mutation.
func (m *BranchContractMutation) IDCardNumber() (r string, exists bool) {
	v := m.id_card_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCardNumber returns the old "id_card_number" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldIDCardNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCardNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCardNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCardNumber: %w", err)
	}
	return oldValue.IDCardNumber, nil
}

// ResetIDCardNumber resets all changes to the "id_card_number" field.
func (m *BranchContractMutation) ResetIDCardNumber() {
	m.id_card_number = nil
}

// SetPhone sets the "phone" field.
func (m *BranchContractMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *BranchContractMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *BranchContractMutation) ResetPhone() {
	m.phone = nil
}

// SetBankNumber sets the "bank_number" field.
func (m *BranchContractMutation) SetBankNumber(s string) {
	m.bank_number = &s
}

// BankNumber returns the value of the "bank_number" field in the mutation.
func (m *BranchContractMutation) BankNumber() (r string, exists bool) {
	v := m.bank_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBankNumber returns the old "bank_number" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldBankNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankNumber: %w", err)
	}
	return oldValue.BankNumber, nil
}

// ResetBankNumber resets all changes to the "bank_number" field.
func (m *BranchContractMutation) ResetBankNumber() {
	m.bank_number = nil
}

// SetPledge sets the "pledge" field.
func (m *BranchContractMutation) SetPledge(f float64) {
	m.pledge = &f
	m.addpledge = nil
}

// Pledge returns the value of the "pledge" field in the mutation.
func (m *BranchContractMutation) Pledge() (r float64, exists bool) {
	v := m.pledge
	if v == nil {
		return
	}
	return *v, true
}

// OldPledge returns the old "pledge" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldPledge(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPledge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPledge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPledge: %w", err)
	}
	return oldValue.Pledge, nil
}

// AddPledge adds f to the "pledge" field.
func (m *BranchContractMutation) AddPledge(f float64) {
	if m.addpledge != nil {
		*m.addpledge += f
	} else {
		m.addpledge = &f
	}
}

// AddedPledge returns the value that was added to the "pledge" field in this mutation.
func (m *BranchContractMutation) AddedPledge() (r float64, exists bool) {
	v := m.addpledge
	if v == nil {
		return
	}
	return *v, true
}

// ResetPledge resets all changes to the "pledge" field.
func (m *BranchContractMutation) ResetPledge() {
	m.pledge = nil
	m.addpledge = nil
}

// SetRent sets the "rent" field.
func (m *BranchContractMutation) SetRent(f float64) {
	m.rent = &f
	m.addrent = nil
}

// Rent returns the value of the "rent" field in the mutation.
func (m *BranchContractMutation) Rent() (r float64, exists bool) {
	v := m.rent
	if v == nil {
		return
	}
	return *v, true
}

// OldRent returns the old "rent" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldRent(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRent: %w", err)
	}
	return oldValue.Rent, nil
}

// AddRent adds f to the "rent" field.
func (m *BranchContractMutation) AddRent(f float64) {
	if m.addrent != nil {
		*m.addrent += f
	} else {
		m.addrent = &f
	}
}

// AddedRent returns the value that was added to the "rent" field in this mutation.
func (m *BranchContractMutation) AddedRent() (r float64, exists bool) {
	v := m.addrent
	if v == nil {
		return
	}
	return *v, true
}

// ResetRent resets all changes to the "rent" field.
func (m *BranchContractMutation) ResetRent() {
	m.rent = nil
	m.addrent = nil
}

// SetLease sets the "lease" field.
func (m *BranchContractMutation) SetLease(u uint) {
	m.lease = &u
	m.addlease = nil
}

// Lease returns the value of the "lease" field in the mutation.
func (m *BranchContractMutation) Lease() (r uint, exists bool) {
	v := m.lease
	if v == nil {
		return
	}
	return *v, true
}

// OldLease returns the old "lease" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldLease(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLease is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLease requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLease: %w", err)
	}
	return oldValue.Lease, nil
}

// AddLease adds u to the "lease" field.
func (m *BranchContractMutation) AddLease(u int) {
	if m.addlease != nil {
		*m.addlease += u
	} else {
		m.addlease = &u
	}
}

// AddedLease returns the value that was added to the "lease" field in this mutation.
func (m *BranchContractMutation) AddedLease() (r int, exists bool) {
	v := m.addlease
	if v == nil {
		return
	}
	return *v, true
}

// ResetLease resets all changes to the "lease" field.
func (m *BranchContractMutation) ResetLease() {
	m.lease = nil
	m.addlease = nil
}

// SetElectricityPledge sets the "electricity_pledge" field.
func (m *BranchContractMutation) SetElectricityPledge(f float64) {
	m.electricity_pledge = &f
	m.addelectricity_pledge = nil
}

// ElectricityPledge returns the value of the "electricity_pledge" field in the mutation.
func (m *BranchContractMutation) ElectricityPledge() (r float64, exists bool) {
	v := m.electricity_pledge
	if v == nil {
		return
	}
	return *v, true
}

// OldElectricityPledge returns the old "electricity_pledge" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldElectricityPledge(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElectricityPledge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElectricityPledge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElectricityPledge: %w", err)
	}
	return oldValue.ElectricityPledge, nil
}

// AddElectricityPledge adds f to the "electricity_pledge" field.
func (m *BranchContractMutation) AddElectricityPledge(f float64) {
	if m.addelectricity_pledge != nil {
		*m.addelectricity_pledge += f
	} else {
		m.addelectricity_pledge = &f
	}
}

// AddedElectricityPledge returns the value that was added to the "electricity_pledge" field in this mutation.
func (m *BranchContractMutation) AddedElectricityPledge() (r float64, exists bool) {
	v := m.addelectricity_pledge
	if v == nil {
		return
	}
	return *v, true
}

// ResetElectricityPledge resets all changes to the "electricity_pledge" field.
func (m *BranchContractMutation) ResetElectricityPledge() {
	m.electricity_pledge = nil
	m.addelectricity_pledge = nil
}

// SetElectricity sets the "electricity" field.
func (m *BranchContractMutation) SetElectricity(f float64) {
	m.electricity = &f
	m.addelectricity = nil
}

// Electricity returns the value of the "electricity" field in the mutation.
func (m *BranchContractMutation) Electricity() (r float64, exists bool) {
	v := m.electricity
	if v == nil {
		return
	}
	return *v, true
}

// OldElectricity returns the old "electricity" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldElectricity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElectricity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElectricity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElectricity: %w", err)
	}
	return oldValue.Electricity, nil
}

// AddElectricity adds f to the "electricity" field.
func (m *BranchContractMutation) AddElectricity(f float64) {
	if m.addelectricity != nil {
		*m.addelectricity += f
	} else {
		m.addelectricity = &f
	}
}

// AddedElectricity returns the value that was added to the "electricity" field in this mutation.
func (m *BranchContractMutation) AddedElectricity() (r float64, exists bool) {
	v := m.addelectricity
	if v == nil {
		return
	}
	return *v, true
}

// ResetElectricity resets all changes to the "electricity" field.
func (m *BranchContractMutation) ResetElectricity() {
	m.electricity = nil
	m.addelectricity = nil
}

// SetArea sets the "area" field.
func (m *BranchContractMutation) SetArea(f float64) {
	m.area = &f
	m.addarea = nil
}

// Area returns the value of the "area" field in the mutation.
func (m *BranchContractMutation) Area() (r float64, exists bool) {
	v := m.area
	if v == nil {
		return
	}
	return *v, true
}

// OldArea returns the old "area" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldArea(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArea: %w", err)
	}
	return oldValue.Area, nil
}

// AddArea adds f to the "area" field.
func (m *BranchContractMutation) AddArea(f float64) {
	if m.addarea != nil {
		*m.addarea += f
	} else {
		m.addarea = &f
	}
}

// AddedArea returns the value that was added to the "area" field in this mutation.
func (m *BranchContractMutation) AddedArea() (r float64, exists bool) {
	v := m.addarea
	if v == nil {
		return
	}
	return *v, true
}

// ResetArea resets all changes to the "area" field.
func (m *BranchContractMutation) ResetArea() {
	m.area = nil
	m.addarea = nil
}

// SetStartTime sets the "start_time" field.
func (m *BranchContractMutation) SetStartTime(s string) {
	m.start_time = &s
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *BranchContractMutation) StartTime() (r string, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldStartTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *BranchContractMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *BranchContractMutation) SetEndTime(s string) {
	m.end_time = &s
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *BranchContractMutation) EndTime() (r string, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldEndTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *BranchContractMutation) ResetEndTime() {
	m.end_time = nil
}

// SetFile sets the "file" field.
func (m *BranchContractMutation) SetFile(s string) {
	m.file = &s
}

// File returns the value of the "file" field in the mutation.
func (m *BranchContractMutation) File() (r string, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldFile returns the old "file" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldFile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFile: %w", err)
	}
	return oldValue.File, nil
}

// ResetFile resets all changes to the "file" field.
func (m *BranchContractMutation) ResetFile() {
	m.file = nil
}

// SetSheets sets the "sheets" field.
func (m *BranchContractMutation) SetSheets(s []string) {
	m.sheets = &s
}

// Sheets returns the value of the "sheets" field in the mutation.
func (m *BranchContractMutation) Sheets() (r []string, exists bool) {
	v := m.sheets
	if v == nil {
		return
	}
	return *v, true
}

// OldSheets returns the old "sheets" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldSheets(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSheets is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSheets requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSheets: %w", err)
	}
	return oldValue.Sheets, nil
}

// ResetSheets resets all changes to the "sheets" field.
func (m *BranchContractMutation) ResetSheets() {
	m.sheets = nil
}

// ClearBranch clears the "branch" edge to the Branch entity.
func (m *BranchContractMutation) ClearBranch() {
	m.clearedbranch = true
}

// BranchCleared reports if the "branch" edge to the Branch entity was cleared.
func (m *BranchContractMutation) BranchCleared() bool {
	return m.clearedbranch
}

// BranchIDs returns the "branch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BranchID instead. It exists only for internal usage by the builders.
func (m *BranchContractMutation) BranchIDs() (ids []uint64) {
	if id := m.branch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBranch resets all changes to the "branch" edge.
func (m *BranchContractMutation) ResetBranch() {
	m.branch = nil
	m.clearedbranch = false
}

// Where appends a list predicates to the BranchContractMutation builder.
func (m *BranchContractMutation) Where(ps ...predicate.BranchContract) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BranchContractMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BranchContract).
func (m *BranchContractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BranchContractMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.created_at != nil {
		fields = append(fields, branchcontract.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, branchcontract.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, branchcontract.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, branchcontract.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, branchcontract.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, branchcontract.FieldRemark)
	}
	if m.branch != nil {
		fields = append(fields, branchcontract.FieldBranchID)
	}
	if m.landlord_name != nil {
		fields = append(fields, branchcontract.FieldLandlordName)
	}
	if m.id_card_number != nil {
		fields = append(fields, branchcontract.FieldIDCardNumber)
	}
	if m.phone != nil {
		fields = append(fields, branchcontract.FieldPhone)
	}
	if m.bank_number != nil {
		fields = append(fields, branchcontract.FieldBankNumber)
	}
	if m.pledge != nil {
		fields = append(fields, branchcontract.FieldPledge)
	}
	if m.rent != nil {
		fields = append(fields, branchcontract.FieldRent)
	}
	if m.lease != nil {
		fields = append(fields, branchcontract.FieldLease)
	}
	if m.electricity_pledge != nil {
		fields = append(fields, branchcontract.FieldElectricityPledge)
	}
	if m.electricity != nil {
		fields = append(fields, branchcontract.FieldElectricity)
	}
	if m.area != nil {
		fields = append(fields, branchcontract.FieldArea)
	}
	if m.start_time != nil {
		fields = append(fields, branchcontract.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, branchcontract.FieldEndTime)
	}
	if m.file != nil {
		fields = append(fields, branchcontract.FieldFile)
	}
	if m.sheets != nil {
		fields = append(fields, branchcontract.FieldSheets)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BranchContractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case branchcontract.FieldCreatedAt:
		return m.CreatedAt()
	case branchcontract.FieldUpdatedAt:
		return m.UpdatedAt()
	case branchcontract.FieldDeletedAt:
		return m.DeletedAt()
	case branchcontract.FieldCreator:
		return m.Creator()
	case branchcontract.FieldLastModifier:
		return m.LastModifier()
	case branchcontract.FieldRemark:
		return m.Remark()
	case branchcontract.FieldBranchID:
		return m.BranchID()
	case branchcontract.FieldLandlordName:
		return m.LandlordName()
	case branchcontract.FieldIDCardNumber:
		return m.IDCardNumber()
	case branchcontract.FieldPhone:
		return m.Phone()
	case branchcontract.FieldBankNumber:
		return m.BankNumber()
	case branchcontract.FieldPledge:
		return m.Pledge()
	case branchcontract.FieldRent:
		return m.Rent()
	case branchcontract.FieldLease:
		return m.Lease()
	case branchcontract.FieldElectricityPledge:
		return m.ElectricityPledge()
	case branchcontract.FieldElectricity:
		return m.Electricity()
	case branchcontract.FieldArea:
		return m.Area()
	case branchcontract.FieldStartTime:
		return m.StartTime()
	case branchcontract.FieldEndTime:
		return m.EndTime()
	case branchcontract.FieldFile:
		return m.File()
	case branchcontract.FieldSheets:
		return m.Sheets()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BranchContractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case branchcontract.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case branchcontract.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case branchcontract.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case branchcontract.FieldCreator:
		return m.OldCreator(ctx)
	case branchcontract.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case branchcontract.FieldRemark:
		return m.OldRemark(ctx)
	case branchcontract.FieldBranchID:
		return m.OldBranchID(ctx)
	case branchcontract.FieldLandlordName:
		return m.OldLandlordName(ctx)
	case branchcontract.FieldIDCardNumber:
		return m.OldIDCardNumber(ctx)
	case branchcontract.FieldPhone:
		return m.OldPhone(ctx)
	case branchcontract.FieldBankNumber:
		return m.OldBankNumber(ctx)
	case branchcontract.FieldPledge:
		return m.OldPledge(ctx)
	case branchcontract.FieldRent:
		return m.OldRent(ctx)
	case branchcontract.FieldLease:
		return m.OldLease(ctx)
	case branchcontract.FieldElectricityPledge:
		return m.OldElectricityPledge(ctx)
	case branchcontract.FieldElectricity:
		return m.OldElectricity(ctx)
	case branchcontract.FieldArea:
		return m.OldArea(ctx)
	case branchcontract.FieldStartTime:
		return m.OldStartTime(ctx)
	case branchcontract.FieldEndTime:
		return m.OldEndTime(ctx)
	case branchcontract.FieldFile:
		return m.OldFile(ctx)
	case branchcontract.FieldSheets:
		return m.OldSheets(ctx)
	}
	return nil, fmt.Errorf("unknown BranchContract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BranchContractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case branchcontract.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case branchcontract.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case branchcontract.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case branchcontract.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case branchcontract.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case branchcontract.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case branchcontract.FieldBranchID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranchID(v)
		return nil
	case branchcontract.FieldLandlordName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLandlordName(v)
		return nil
	case branchcontract.FieldIDCardNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCardNumber(v)
		return nil
	case branchcontract.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case branchcontract.FieldBankNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankNumber(v)
		return nil
	case branchcontract.FieldPledge:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPledge(v)
		return nil
	case branchcontract.FieldRent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRent(v)
		return nil
	case branchcontract.FieldLease:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLease(v)
		return nil
	case branchcontract.FieldElectricityPledge:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElectricityPledge(v)
		return nil
	case branchcontract.FieldElectricity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElectricity(v)
		return nil
	case branchcontract.FieldArea:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArea(v)
		return nil
	case branchcontract.FieldStartTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case branchcontract.FieldEndTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case branchcontract.FieldFile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFile(v)
		return nil
	case branchcontract.FieldSheets:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSheets(v)
		return nil
	}
	return fmt.Errorf("unknown BranchContract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BranchContractMutation) AddedFields() []string {
	var fields []string
	if m.addpledge != nil {
		fields = append(fields, branchcontract.FieldPledge)
	}
	if m.addrent != nil {
		fields = append(fields, branchcontract.FieldRent)
	}
	if m.addlease != nil {
		fields = append(fields, branchcontract.FieldLease)
	}
	if m.addelectricity_pledge != nil {
		fields = append(fields, branchcontract.FieldElectricityPledge)
	}
	if m.addelectricity != nil {
		fields = append(fields, branchcontract.FieldElectricity)
	}
	if m.addarea != nil {
		fields = append(fields, branchcontract.FieldArea)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BranchContractMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case branchcontract.FieldPledge:
		return m.AddedPledge()
	case branchcontract.FieldRent:
		return m.AddedRent()
	case branchcontract.FieldLease:
		return m.AddedLease()
	case branchcontract.FieldElectricityPledge:
		return m.AddedElectricityPledge()
	case branchcontract.FieldElectricity:
		return m.AddedElectricity()
	case branchcontract.FieldArea:
		return m.AddedArea()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BranchContractMutation) AddField(name string, value ent.Value) error {
	switch name {
	case branchcontract.FieldPledge:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPledge(v)
		return nil
	case branchcontract.FieldRent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRent(v)
		return nil
	case branchcontract.FieldLease:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLease(v)
		return nil
	case branchcontract.FieldElectricityPledge:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddElectricityPledge(v)
		return nil
	case branchcontract.FieldElectricity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddElectricity(v)
		return nil
	case branchcontract.FieldArea:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddArea(v)
		return nil
	}
	return fmt.Errorf("unknown BranchContract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BranchContractMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(branchcontract.FieldDeletedAt) {
		fields = append(fields, branchcontract.FieldDeletedAt)
	}
	if m.FieldCleared(branchcontract.FieldCreator) {
		fields = append(fields, branchcontract.FieldCreator)
	}
	if m.FieldCleared(branchcontract.FieldLastModifier) {
		fields = append(fields, branchcontract.FieldLastModifier)
	}
	if m.FieldCleared(branchcontract.FieldRemark) {
		fields = append(fields, branchcontract.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BranchContractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BranchContractMutation) ClearField(name string) error {
	switch name {
	case branchcontract.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case branchcontract.FieldCreator:
		m.ClearCreator()
		return nil
	case branchcontract.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case branchcontract.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown BranchContract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BranchContractMutation) ResetField(name string) error {
	switch name {
	case branchcontract.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case branchcontract.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case branchcontract.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case branchcontract.FieldCreator:
		m.ResetCreator()
		return nil
	case branchcontract.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case branchcontract.FieldRemark:
		m.ResetRemark()
		return nil
	case branchcontract.FieldBranchID:
		m.ResetBranchID()
		return nil
	case branchcontract.FieldLandlordName:
		m.ResetLandlordName()
		return nil
	case branchcontract.FieldIDCardNumber:
		m.ResetIDCardNumber()
		return nil
	case branchcontract.FieldPhone:
		m.ResetPhone()
		return nil
	case branchcontract.FieldBankNumber:
		m.ResetBankNumber()
		return nil
	case branchcontract.FieldPledge:
		m.ResetPledge()
		return nil
	case branchcontract.FieldRent:
		m.ResetRent()
		return nil
	case branchcontract.FieldLease:
		m.ResetLease()
		return nil
	case branchcontract.FieldElectricityPledge:
		m.ResetElectricityPledge()
		return nil
	case branchcontract.FieldElectricity:
		m.ResetElectricity()
		return nil
	case branchcontract.FieldArea:
		m.ResetArea()
		return nil
	case branchcontract.FieldStartTime:
		m.ResetStartTime()
		return nil
	case branchcontract.FieldEndTime:
		m.ResetEndTime()
		return nil
	case branchcontract.FieldFile:
		m.ResetFile()
		return nil
	case branchcontract.FieldSheets:
		m.ResetSheets()
		return nil
	}
	return fmt.Errorf("unknown BranchContract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BranchContractMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.branch != nil {
		edges = append(edges, branchcontract.EdgeBranch)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BranchContractMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case branchcontract.EdgeBranch:
		if id := m.branch; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BranchContractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BranchContractMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BranchContractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbranch {
		edges = append(edges, branchcontract.EdgeBranch)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BranchContractMutation) EdgeCleared(name string) bool {
	switch name {
	case branchcontract.EdgeBranch:
		return m.clearedbranch
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BranchContractMutation) ClearEdge(name string) error {
	switch name {
	case branchcontract.EdgeBranch:
		m.ClearBranch()
		return nil
	}
	return fmt.Errorf("unknown BranchContract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BranchContractMutation) ResetEdge(name string) error {
	switch name {
	case branchcontract.EdgeBranch:
		m.ResetBranch()
		return nil
	}
	return fmt.Errorf("unknown BranchContract edge %s", name)
}

// BusinessMutation represents an operation that mutates the Business nodes in the graph.
type BusinessMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	_type             *business.Type
	clearedFields     map[string]struct{}
	rider             *uint64
	clearedrider      bool
	city              *uint64
	clearedcity       bool
	subscribe         *uint64
	clearedsubscribe  bool
	employee          *uint64
	clearedemployee   bool
	store             *uint64
	clearedstore      bool
	plan              *uint64
	clearedplan       bool
	enterprise        *uint64
	clearedenterprise bool
	station           *uint64
	clearedstation    bool
	done              bool
	oldValue          func(context.Context) (*Business, error)
	predicates        []predicate.Business
}

var _ ent.Mutation = (*BusinessMutation)(nil)

// businessOption allows management of the mutation configuration using functional options.
type businessOption func(*BusinessMutation)

// newBusinessMutation creates new mutation for the Business entity.
func newBusinessMutation(c config, op Op, opts ...businessOption) *BusinessMutation {
	m := &BusinessMutation{
		config:        c,
		op:            op,
		typ:           TypeBusiness,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBusinessID sets the ID field of the mutation.
func withBusinessID(id uint64) businessOption {
	return func(m *BusinessMutation) {
		var (
			err   error
			once  sync.Once
			value *Business
		)
		m.oldValue = func(ctx context.Context) (*Business, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Business.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBusiness sets the old Business of the mutation.
func withBusiness(node *Business) businessOption {
	return func(m *BusinessMutation) {
		m.oldValue = func(context.Context) (*Business, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BusinessMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BusinessMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BusinessMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BusinessMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Business.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BusinessMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BusinessMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BusinessMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BusinessMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BusinessMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BusinessMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BusinessMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BusinessMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BusinessMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[business.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BusinessMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[business.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BusinessMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, business.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *BusinessMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *BusinessMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *BusinessMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[business.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *BusinessMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[business.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *BusinessMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, business.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *BusinessMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *BusinessMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *BusinessMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[business.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *BusinessMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[business.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *BusinessMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, business.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *BusinessMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *BusinessMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *BusinessMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[business.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *BusinessMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[business.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *BusinessMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, business.FieldRemark)
}

// SetRiderID sets the "rider_id" field.
func (m *BusinessMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *BusinessMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *BusinessMutation) ResetRiderID() {
	m.rider = nil
}

// SetCityID sets the "city_id" field.
func (m *BusinessMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *BusinessMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *BusinessMutation) ResetCityID() {
	m.city = nil
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *BusinessMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *BusinessMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldSubscribeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *BusinessMutation) ResetSubscribeID() {
	m.subscribe = nil
}

// SetEmployeeID sets the "employee_id" field.
func (m *BusinessMutation) SetEmployeeID(u uint64) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *BusinessMutation) EmployeeID() (r uint64, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldEmployeeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *BusinessMutation) ClearEmployeeID() {
	m.employee = nil
	m.clearedFields[business.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *BusinessMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[business.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *BusinessMutation) ResetEmployeeID() {
	m.employee = nil
	delete(m.clearedFields, business.FieldEmployeeID)
}

// SetStoreID sets the "store_id" field.
func (m *BusinessMutation) SetStoreID(u uint64) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *BusinessMutation) StoreID() (r uint64, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldStoreID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *BusinessMutation) ClearStoreID() {
	m.store = nil
	m.clearedFields[business.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *BusinessMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[business.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *BusinessMutation) ResetStoreID() {
	m.store = nil
	delete(m.clearedFields, business.FieldStoreID)
}

// SetPlanID sets the "plan_id" field.
func (m *BusinessMutation) SetPlanID(u uint64) {
	m.plan = &u
}

// PlanID returns the value of the "plan_id" field in the mutation.
func (m *BusinessMutation) PlanID() (r uint64, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanID returns the old "plan_id" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldPlanID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanID: %w", err)
	}
	return oldValue.PlanID, nil
}

// ClearPlanID clears the value of the "plan_id" field.
func (m *BusinessMutation) ClearPlanID() {
	m.plan = nil
	m.clearedFields[business.FieldPlanID] = struct{}{}
}

// PlanIDCleared returns if the "plan_id" field was cleared in this mutation.
func (m *BusinessMutation) PlanIDCleared() bool {
	_, ok := m.clearedFields[business.FieldPlanID]
	return ok
}

// ResetPlanID resets all changes to the "plan_id" field.
func (m *BusinessMutation) ResetPlanID() {
	m.plan = nil
	delete(m.clearedFields, business.FieldPlanID)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *BusinessMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *BusinessMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldEnterpriseID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ClearEnterpriseID clears the value of the "enterprise_id" field.
func (m *BusinessMutation) ClearEnterpriseID() {
	m.enterprise = nil
	m.clearedFields[business.FieldEnterpriseID] = struct{}{}
}

// EnterpriseIDCleared returns if the "enterprise_id" field was cleared in this mutation.
func (m *BusinessMutation) EnterpriseIDCleared() bool {
	_, ok := m.clearedFields[business.FieldEnterpriseID]
	return ok
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *BusinessMutation) ResetEnterpriseID() {
	m.enterprise = nil
	delete(m.clearedFields, business.FieldEnterpriseID)
}

// SetStationID sets the "station_id" field.
func (m *BusinessMutation) SetStationID(u uint64) {
	m.station = &u
}

// StationID returns the value of the "station_id" field in the mutation.
func (m *BusinessMutation) StationID() (r uint64, exists bool) {
	v := m.station
	if v == nil {
		return
	}
	return *v, true
}

// OldStationID returns the old "station_id" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldStationID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStationID: %w", err)
	}
	return oldValue.StationID, nil
}

// ClearStationID clears the value of the "station_id" field.
func (m *BusinessMutation) ClearStationID() {
	m.station = nil
	m.clearedFields[business.FieldStationID] = struct{}{}
}

// StationIDCleared returns if the "station_id" field was cleared in this mutation.
func (m *BusinessMutation) StationIDCleared() bool {
	_, ok := m.clearedFields[business.FieldStationID]
	return ok
}

// ResetStationID resets all changes to the "station_id" field.
func (m *BusinessMutation) ResetStationID() {
	m.station = nil
	delete(m.clearedFields, business.FieldStationID)
}

// SetType sets the "type" field.
func (m *BusinessMutation) SetType(b business.Type) {
	m._type = &b
}

// GetType returns the value of the "type" field in the mutation.
func (m *BusinessMutation) GetType() (r business.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldType(ctx context.Context) (v business.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BusinessMutation) ResetType() {
	m._type = nil
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *BusinessMutation) ClearRider() {
	m.clearedrider = true
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *BusinessMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *BusinessMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *BusinessMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *BusinessMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *BusinessMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *BusinessMutation) ClearSubscribe() {
	m.clearedsubscribe = true
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *BusinessMutation) SubscribeCleared() bool {
	return m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *BusinessMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *BusinessMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *BusinessMutation) EmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) EmployeeIDs() (ids []uint64) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *BusinessMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// ClearStore clears the "store" edge to the Store entity.
func (m *BusinessMutation) ClearStore() {
	m.clearedstore = true
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *BusinessMutation) StoreCleared() bool {
	return m.StoreIDCleared() || m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) StoreIDs() (ids []uint64) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *BusinessMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// ClearPlan clears the "plan" edge to the Plan entity.
func (m *BusinessMutation) ClearPlan() {
	m.clearedplan = true
}

// PlanCleared reports if the "plan" edge to the Plan entity was cleared.
func (m *BusinessMutation) PlanCleared() bool {
	return m.PlanIDCleared() || m.clearedplan
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) PlanIDs() (ids []uint64) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *BusinessMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *BusinessMutation) ClearEnterprise() {
	m.clearedenterprise = true
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *BusinessMutation) EnterpriseCleared() bool {
	return m.EnterpriseIDCleared() || m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *BusinessMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// ClearStation clears the "station" edge to the EnterpriseStation entity.
func (m *BusinessMutation) ClearStation() {
	m.clearedstation = true
}

// StationCleared reports if the "station" edge to the EnterpriseStation entity was cleared.
func (m *BusinessMutation) StationCleared() bool {
	return m.StationIDCleared() || m.clearedstation
}

// StationIDs returns the "station" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StationID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) StationIDs() (ids []uint64) {
	if id := m.station; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStation resets all changes to the "station" edge.
func (m *BusinessMutation) ResetStation() {
	m.station = nil
	m.clearedstation = false
}

// Where appends a list predicates to the BusinessMutation builder.
func (m *BusinessMutation) Where(ps ...predicate.Business) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BusinessMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Business).
func (m *BusinessMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BusinessMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, business.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, business.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, business.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, business.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, business.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, business.FieldRemark)
	}
	if m.rider != nil {
		fields = append(fields, business.FieldRiderID)
	}
	if m.city != nil {
		fields = append(fields, business.FieldCityID)
	}
	if m.subscribe != nil {
		fields = append(fields, business.FieldSubscribeID)
	}
	if m.employee != nil {
		fields = append(fields, business.FieldEmployeeID)
	}
	if m.store != nil {
		fields = append(fields, business.FieldStoreID)
	}
	if m.plan != nil {
		fields = append(fields, business.FieldPlanID)
	}
	if m.enterprise != nil {
		fields = append(fields, business.FieldEnterpriseID)
	}
	if m.station != nil {
		fields = append(fields, business.FieldStationID)
	}
	if m._type != nil {
		fields = append(fields, business.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BusinessMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case business.FieldCreatedAt:
		return m.CreatedAt()
	case business.FieldUpdatedAt:
		return m.UpdatedAt()
	case business.FieldDeletedAt:
		return m.DeletedAt()
	case business.FieldCreator:
		return m.Creator()
	case business.FieldLastModifier:
		return m.LastModifier()
	case business.FieldRemark:
		return m.Remark()
	case business.FieldRiderID:
		return m.RiderID()
	case business.FieldCityID:
		return m.CityID()
	case business.FieldSubscribeID:
		return m.SubscribeID()
	case business.FieldEmployeeID:
		return m.EmployeeID()
	case business.FieldStoreID:
		return m.StoreID()
	case business.FieldPlanID:
		return m.PlanID()
	case business.FieldEnterpriseID:
		return m.EnterpriseID()
	case business.FieldStationID:
		return m.StationID()
	case business.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BusinessMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case business.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case business.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case business.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case business.FieldCreator:
		return m.OldCreator(ctx)
	case business.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case business.FieldRemark:
		return m.OldRemark(ctx)
	case business.FieldRiderID:
		return m.OldRiderID(ctx)
	case business.FieldCityID:
		return m.OldCityID(ctx)
	case business.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case business.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case business.FieldStoreID:
		return m.OldStoreID(ctx)
	case business.FieldPlanID:
		return m.OldPlanID(ctx)
	case business.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case business.FieldStationID:
		return m.OldStationID(ctx)
	case business.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Business field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessMutation) SetField(name string, value ent.Value) error {
	switch name {
	case business.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case business.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case business.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case business.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case business.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case business.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case business.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case business.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case business.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case business.FieldEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case business.FieldStoreID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case business.FieldPlanID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanID(v)
		return nil
	case business.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case business.FieldStationID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStationID(v)
		return nil
	case business.FieldType:
		v, ok := value.(business.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Business field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BusinessMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BusinessMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Business numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BusinessMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(business.FieldDeletedAt) {
		fields = append(fields, business.FieldDeletedAt)
	}
	if m.FieldCleared(business.FieldCreator) {
		fields = append(fields, business.FieldCreator)
	}
	if m.FieldCleared(business.FieldLastModifier) {
		fields = append(fields, business.FieldLastModifier)
	}
	if m.FieldCleared(business.FieldRemark) {
		fields = append(fields, business.FieldRemark)
	}
	if m.FieldCleared(business.FieldEmployeeID) {
		fields = append(fields, business.FieldEmployeeID)
	}
	if m.FieldCleared(business.FieldStoreID) {
		fields = append(fields, business.FieldStoreID)
	}
	if m.FieldCleared(business.FieldPlanID) {
		fields = append(fields, business.FieldPlanID)
	}
	if m.FieldCleared(business.FieldEnterpriseID) {
		fields = append(fields, business.FieldEnterpriseID)
	}
	if m.FieldCleared(business.FieldStationID) {
		fields = append(fields, business.FieldStationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BusinessMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BusinessMutation) ClearField(name string) error {
	switch name {
	case business.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case business.FieldCreator:
		m.ClearCreator()
		return nil
	case business.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case business.FieldRemark:
		m.ClearRemark()
		return nil
	case business.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case business.FieldStoreID:
		m.ClearStoreID()
		return nil
	case business.FieldPlanID:
		m.ClearPlanID()
		return nil
	case business.FieldEnterpriseID:
		m.ClearEnterpriseID()
		return nil
	case business.FieldStationID:
		m.ClearStationID()
		return nil
	}
	return fmt.Errorf("unknown Business nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BusinessMutation) ResetField(name string) error {
	switch name {
	case business.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case business.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case business.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case business.FieldCreator:
		m.ResetCreator()
		return nil
	case business.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case business.FieldRemark:
		m.ResetRemark()
		return nil
	case business.FieldRiderID:
		m.ResetRiderID()
		return nil
	case business.FieldCityID:
		m.ResetCityID()
		return nil
	case business.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case business.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case business.FieldStoreID:
		m.ResetStoreID()
		return nil
	case business.FieldPlanID:
		m.ResetPlanID()
		return nil
	case business.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case business.FieldStationID:
		m.ResetStationID()
		return nil
	case business.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Business field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BusinessMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.rider != nil {
		edges = append(edges, business.EdgeRider)
	}
	if m.city != nil {
		edges = append(edges, business.EdgeCity)
	}
	if m.subscribe != nil {
		edges = append(edges, business.EdgeSubscribe)
	}
	if m.employee != nil {
		edges = append(edges, business.EdgeEmployee)
	}
	if m.store != nil {
		edges = append(edges, business.EdgeStore)
	}
	if m.plan != nil {
		edges = append(edges, business.EdgePlan)
	}
	if m.enterprise != nil {
		edges = append(edges, business.EdgeEnterprise)
	}
	if m.station != nil {
		edges = append(edges, business.EdgeStation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BusinessMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case business.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case business.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case business.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	case business.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case business.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	case business.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	case business.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	case business.EdgeStation:
		if id := m.station; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BusinessMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BusinessMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BusinessMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedrider {
		edges = append(edges, business.EdgeRider)
	}
	if m.clearedcity {
		edges = append(edges, business.EdgeCity)
	}
	if m.clearedsubscribe {
		edges = append(edges, business.EdgeSubscribe)
	}
	if m.clearedemployee {
		edges = append(edges, business.EdgeEmployee)
	}
	if m.clearedstore {
		edges = append(edges, business.EdgeStore)
	}
	if m.clearedplan {
		edges = append(edges, business.EdgePlan)
	}
	if m.clearedenterprise {
		edges = append(edges, business.EdgeEnterprise)
	}
	if m.clearedstation {
		edges = append(edges, business.EdgeStation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BusinessMutation) EdgeCleared(name string) bool {
	switch name {
	case business.EdgeRider:
		return m.clearedrider
	case business.EdgeCity:
		return m.clearedcity
	case business.EdgeSubscribe:
		return m.clearedsubscribe
	case business.EdgeEmployee:
		return m.clearedemployee
	case business.EdgeStore:
		return m.clearedstore
	case business.EdgePlan:
		return m.clearedplan
	case business.EdgeEnterprise:
		return m.clearedenterprise
	case business.EdgeStation:
		return m.clearedstation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BusinessMutation) ClearEdge(name string) error {
	switch name {
	case business.EdgeRider:
		m.ClearRider()
		return nil
	case business.EdgeCity:
		m.ClearCity()
		return nil
	case business.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	case business.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case business.EdgeStore:
		m.ClearStore()
		return nil
	case business.EdgePlan:
		m.ClearPlan()
		return nil
	case business.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	case business.EdgeStation:
		m.ClearStation()
		return nil
	}
	return fmt.Errorf("unknown Business unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BusinessMutation) ResetEdge(name string) error {
	switch name {
	case business.EdgeRider:
		m.ResetRider()
		return nil
	case business.EdgeCity:
		m.ResetCity()
		return nil
	case business.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	case business.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case business.EdgeStore:
		m.ResetStore()
		return nil
	case business.EdgePlan:
		m.ResetPlan()
		return nil
	case business.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	case business.EdgeStation:
		m.ResetStation()
		return nil
	}
	return fmt.Errorf("unknown Business edge %s", name)
}

// CabinetMutation represents an operation that mutates the Cabinet nodes in the graph.
type CabinetMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uint64
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	creator             **model.Modifier
	last_modifier       **model.Modifier
	remark              *string
	sn                  *string
	brand               *string
	serial              *string
	name                *string
	doors               *uint
	adddoors            *int
	status              *uint8
	addstatus           *int8
	models              *[]model.BatteryModel
	health              *uint8
	addhealth           *int8
	bin                 *[]model.CabinetBin
	battery_num         *uint
	addbattery_num      *int
	battery_full_num    *uint
	addbattery_full_num *int
	clearedFields       map[string]struct{}
	city                *uint64
	clearedcity         bool
	branch              *uint64
	clearedbranch       bool
	bms                 map[uint64]struct{}
	removedbms          map[uint64]struct{}
	clearedbms          bool
	faults              map[uint64]struct{}
	removedfaults       map[uint64]struct{}
	clearedfaults       bool
	exchanges           map[uint64]struct{}
	removedexchanges    map[uint64]struct{}
	clearedexchanges    bool
	done                bool
	oldValue            func(context.Context) (*Cabinet, error)
	predicates          []predicate.Cabinet
}

var _ ent.Mutation = (*CabinetMutation)(nil)

// cabinetOption allows management of the mutation configuration using functional options.
type cabinetOption func(*CabinetMutation)

// newCabinetMutation creates new mutation for the Cabinet entity.
func newCabinetMutation(c config, op Op, opts ...cabinetOption) *CabinetMutation {
	m := &CabinetMutation{
		config:        c,
		op:            op,
		typ:           TypeCabinet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCabinetID sets the ID field of the mutation.
func withCabinetID(id uint64) cabinetOption {
	return func(m *CabinetMutation) {
		var (
			err   error
			once  sync.Once
			value *Cabinet
		)
		m.oldValue = func(ctx context.Context) (*Cabinet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cabinet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCabinet sets the old Cabinet of the mutation.
func withCabinet(node *Cabinet) cabinetOption {
	return func(m *CabinetMutation) {
		m.oldValue = func(context.Context) (*Cabinet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CabinetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CabinetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CabinetMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CabinetMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cabinet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CabinetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CabinetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CabinetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CabinetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CabinetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CabinetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CabinetMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CabinetMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CabinetMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[cabinet.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CabinetMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CabinetMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, cabinet.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *CabinetMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *CabinetMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *CabinetMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[cabinet.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *CabinetMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *CabinetMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, cabinet.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *CabinetMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *CabinetMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *CabinetMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[cabinet.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *CabinetMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *CabinetMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, cabinet.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *CabinetMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CabinetMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *CabinetMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[cabinet.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *CabinetMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *CabinetMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, cabinet.FieldRemark)
}

// SetCityID sets the "city_id" field.
func (m *CabinetMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *CabinetMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldCityID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ClearCityID clears the value of the "city_id" field.
func (m *CabinetMutation) ClearCityID() {
	m.city = nil
	m.clearedFields[cabinet.FieldCityID] = struct{}{}
}

// CityIDCleared returns if the "city_id" field was cleared in this mutation.
func (m *CabinetMutation) CityIDCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldCityID]
	return ok
}

// ResetCityID resets all changes to the "city_id" field.
func (m *CabinetMutation) ResetCityID() {
	m.city = nil
	delete(m.clearedFields, cabinet.FieldCityID)
}

// SetBranchID sets the "branch_id" field.
func (m *CabinetMutation) SetBranchID(u uint64) {
	m.branch = &u
}

// BranchID returns the value of the "branch_id" field in the mutation.
func (m *CabinetMutation) BranchID() (r uint64, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranchID returns the old "branch_id" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldBranchID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBranchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBranchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranchID: %w", err)
	}
	return oldValue.BranchID, nil
}

// ClearBranchID clears the value of the "branch_id" field.
func (m *CabinetMutation) ClearBranchID() {
	m.branch = nil
	m.clearedFields[cabinet.FieldBranchID] = struct{}{}
}

// BranchIDCleared returns if the "branch_id" field was cleared in this mutation.
func (m *CabinetMutation) BranchIDCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldBranchID]
	return ok
}

// ResetBranchID resets all changes to the "branch_id" field.
func (m *CabinetMutation) ResetBranchID() {
	m.branch = nil
	delete(m.clearedFields, cabinet.FieldBranchID)
}

// SetSn sets the "sn" field.
func (m *CabinetMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *CabinetMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *CabinetMutation) ResetSn() {
	m.sn = nil
}

// SetBrand sets the "brand" field.
func (m *CabinetMutation) SetBrand(s string) {
	m.brand = &s
}

// Brand returns the value of the "brand" field in the mutation.
func (m *CabinetMutation) Brand() (r string, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrand returns the old "brand" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldBrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrand: %w", err)
	}
	return oldValue.Brand, nil
}

// ResetBrand resets all changes to the "brand" field.
func (m *CabinetMutation) ResetBrand() {
	m.brand = nil
}

// SetSerial sets the "serial" field.
func (m *CabinetMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *CabinetMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ResetSerial resets all changes to the "serial" field.
func (m *CabinetMutation) ResetSerial() {
	m.serial = nil
}

// SetName sets the "name" field.
func (m *CabinetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CabinetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CabinetMutation) ResetName() {
	m.name = nil
}

// SetDoors sets the "doors" field.
func (m *CabinetMutation) SetDoors(u uint) {
	m.doors = &u
	m.adddoors = nil
}

// Doors returns the value of the "doors" field in the mutation.
func (m *CabinetMutation) Doors() (r uint, exists bool) {
	v := m.doors
	if v == nil {
		return
	}
	return *v, true
}

// OldDoors returns the old "doors" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldDoors(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDoors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDoors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoors: %w", err)
	}
	return oldValue.Doors, nil
}

// AddDoors adds u to the "doors" field.
func (m *CabinetMutation) AddDoors(u int) {
	if m.adddoors != nil {
		*m.adddoors += u
	} else {
		m.adddoors = &u
	}
}

// AddedDoors returns the value that was added to the "doors" field in this mutation.
func (m *CabinetMutation) AddedDoors() (r int, exists bool) {
	v := m.adddoors
	if v == nil {
		return
	}
	return *v, true
}

// ResetDoors resets all changes to the "doors" field.
func (m *CabinetMutation) ResetDoors() {
	m.doors = nil
	m.adddoors = nil
}

// SetStatus sets the "status" field.
func (m *CabinetMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CabinetMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *CabinetMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CabinetMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CabinetMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetModels sets the "models" field.
func (m *CabinetMutation) SetModels(mm []model.BatteryModel) {
	m.models = &mm
}

// Models returns the value of the "models" field in the mutation.
func (m *CabinetMutation) Models() (r []model.BatteryModel, exists bool) {
	v := m.models
	if v == nil {
		return
	}
	return *v, true
}

// OldModels returns the old "models" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldModels(ctx context.Context) (v []model.BatteryModel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModels: %w", err)
	}
	return oldValue.Models, nil
}

// ResetModels resets all changes to the "models" field.
func (m *CabinetMutation) ResetModels() {
	m.models = nil
}

// SetHealth sets the "health" field.
func (m *CabinetMutation) SetHealth(u uint8) {
	m.health = &u
	m.addhealth = nil
}

// Health returns the value of the "health" field in the mutation.
func (m *CabinetMutation) Health() (r uint8, exists bool) {
	v := m.health
	if v == nil {
		return
	}
	return *v, true
}

// OldHealth returns the old "health" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldHealth(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHealth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHealth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealth: %w", err)
	}
	return oldValue.Health, nil
}

// AddHealth adds u to the "health" field.
func (m *CabinetMutation) AddHealth(u int8) {
	if m.addhealth != nil {
		*m.addhealth += u
	} else {
		m.addhealth = &u
	}
}

// AddedHealth returns the value that was added to the "health" field in this mutation.
func (m *CabinetMutation) AddedHealth() (r int8, exists bool) {
	v := m.addhealth
	if v == nil {
		return
	}
	return *v, true
}

// ResetHealth resets all changes to the "health" field.
func (m *CabinetMutation) ResetHealth() {
	m.health = nil
	m.addhealth = nil
}

// SetBin sets the "bin" field.
func (m *CabinetMutation) SetBin(mb []model.CabinetBin) {
	m.bin = &mb
}

// Bin returns the value of the "bin" field in the mutation.
func (m *CabinetMutation) Bin() (r []model.CabinetBin, exists bool) {
	v := m.bin
	if v == nil {
		return
	}
	return *v, true
}

// OldBin returns the old "bin" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldBin(ctx context.Context) (v []model.CabinetBin, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBin: %w", err)
	}
	return oldValue.Bin, nil
}

// ClearBin clears the value of the "bin" field.
func (m *CabinetMutation) ClearBin() {
	m.bin = nil
	m.clearedFields[cabinet.FieldBin] = struct{}{}
}

// BinCleared returns if the "bin" field was cleared in this mutation.
func (m *CabinetMutation) BinCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldBin]
	return ok
}

// ResetBin resets all changes to the "bin" field.
func (m *CabinetMutation) ResetBin() {
	m.bin = nil
	delete(m.clearedFields, cabinet.FieldBin)
}

// SetBatteryNum sets the "battery_num" field.
func (m *CabinetMutation) SetBatteryNum(u uint) {
	m.battery_num = &u
	m.addbattery_num = nil
}

// BatteryNum returns the value of the "battery_num" field in the mutation.
func (m *CabinetMutation) BatteryNum() (r uint, exists bool) {
	v := m.battery_num
	if v == nil {
		return
	}
	return *v, true
}

// OldBatteryNum returns the old "battery_num" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldBatteryNum(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatteryNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatteryNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatteryNum: %w", err)
	}
	return oldValue.BatteryNum, nil
}

// AddBatteryNum adds u to the "battery_num" field.
func (m *CabinetMutation) AddBatteryNum(u int) {
	if m.addbattery_num != nil {
		*m.addbattery_num += u
	} else {
		m.addbattery_num = &u
	}
}

// AddedBatteryNum returns the value that was added to the "battery_num" field in this mutation.
func (m *CabinetMutation) AddedBatteryNum() (r int, exists bool) {
	v := m.addbattery_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetBatteryNum resets all changes to the "battery_num" field.
func (m *CabinetMutation) ResetBatteryNum() {
	m.battery_num = nil
	m.addbattery_num = nil
}

// SetBatteryFullNum sets the "battery_full_num" field.
func (m *CabinetMutation) SetBatteryFullNum(u uint) {
	m.battery_full_num = &u
	m.addbattery_full_num = nil
}

// BatteryFullNum returns the value of the "battery_full_num" field in the mutation.
func (m *CabinetMutation) BatteryFullNum() (r uint, exists bool) {
	v := m.battery_full_num
	if v == nil {
		return
	}
	return *v, true
}

// OldBatteryFullNum returns the old "battery_full_num" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldBatteryFullNum(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatteryFullNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatteryFullNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatteryFullNum: %w", err)
	}
	return oldValue.BatteryFullNum, nil
}

// AddBatteryFullNum adds u to the "battery_full_num" field.
func (m *CabinetMutation) AddBatteryFullNum(u int) {
	if m.addbattery_full_num != nil {
		*m.addbattery_full_num += u
	} else {
		m.addbattery_full_num = &u
	}
}

// AddedBatteryFullNum returns the value that was added to the "battery_full_num" field in this mutation.
func (m *CabinetMutation) AddedBatteryFullNum() (r int, exists bool) {
	v := m.addbattery_full_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetBatteryFullNum resets all changes to the "battery_full_num" field.
func (m *CabinetMutation) ResetBatteryFullNum() {
	m.battery_full_num = nil
	m.addbattery_full_num = nil
}

// ClearCity clears the "city" edge to the City entity.
func (m *CabinetMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *CabinetMutation) CityCleared() bool {
	return m.CityIDCleared() || m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *CabinetMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *CabinetMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearBranch clears the "branch" edge to the Branch entity.
func (m *CabinetMutation) ClearBranch() {
	m.clearedbranch = true
}

// BranchCleared reports if the "branch" edge to the Branch entity was cleared.
func (m *CabinetMutation) BranchCleared() bool {
	return m.BranchIDCleared() || m.clearedbranch
}

// BranchIDs returns the "branch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BranchID instead. It exists only for internal usage by the builders.
func (m *CabinetMutation) BranchIDs() (ids []uint64) {
	if id := m.branch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBranch resets all changes to the "branch" edge.
func (m *CabinetMutation) ResetBranch() {
	m.branch = nil
	m.clearedbranch = false
}

// AddBmIDs adds the "bms" edge to the BatteryModel entity by ids.
func (m *CabinetMutation) AddBmIDs(ids ...uint64) {
	if m.bms == nil {
		m.bms = make(map[uint64]struct{})
	}
	for i := range ids {
		m.bms[ids[i]] = struct{}{}
	}
}

// ClearBms clears the "bms" edge to the BatteryModel entity.
func (m *CabinetMutation) ClearBms() {
	m.clearedbms = true
}

// BmsCleared reports if the "bms" edge to the BatteryModel entity was cleared.
func (m *CabinetMutation) BmsCleared() bool {
	return m.clearedbms
}

// RemoveBmIDs removes the "bms" edge to the BatteryModel entity by IDs.
func (m *CabinetMutation) RemoveBmIDs(ids ...uint64) {
	if m.removedbms == nil {
		m.removedbms = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.bms, ids[i])
		m.removedbms[ids[i]] = struct{}{}
	}
}

// RemovedBms returns the removed IDs of the "bms" edge to the BatteryModel entity.
func (m *CabinetMutation) RemovedBmsIDs() (ids []uint64) {
	for id := range m.removedbms {
		ids = append(ids, id)
	}
	return
}

// BmsIDs returns the "bms" edge IDs in the mutation.
func (m *CabinetMutation) BmsIDs() (ids []uint64) {
	for id := range m.bms {
		ids = append(ids, id)
	}
	return
}

// ResetBms resets all changes to the "bms" edge.
func (m *CabinetMutation) ResetBms() {
	m.bms = nil
	m.clearedbms = false
	m.removedbms = nil
}

// AddFaultIDs adds the "faults" edge to the CabinetFault entity by ids.
func (m *CabinetMutation) AddFaultIDs(ids ...uint64) {
	if m.faults == nil {
		m.faults = make(map[uint64]struct{})
	}
	for i := range ids {
		m.faults[ids[i]] = struct{}{}
	}
}

// ClearFaults clears the "faults" edge to the CabinetFault entity.
func (m *CabinetMutation) ClearFaults() {
	m.clearedfaults = true
}

// FaultsCleared reports if the "faults" edge to the CabinetFault entity was cleared.
func (m *CabinetMutation) FaultsCleared() bool {
	return m.clearedfaults
}

// RemoveFaultIDs removes the "faults" edge to the CabinetFault entity by IDs.
func (m *CabinetMutation) RemoveFaultIDs(ids ...uint64) {
	if m.removedfaults == nil {
		m.removedfaults = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.faults, ids[i])
		m.removedfaults[ids[i]] = struct{}{}
	}
}

// RemovedFaults returns the removed IDs of the "faults" edge to the CabinetFault entity.
func (m *CabinetMutation) RemovedFaultsIDs() (ids []uint64) {
	for id := range m.removedfaults {
		ids = append(ids, id)
	}
	return
}

// FaultsIDs returns the "faults" edge IDs in the mutation.
func (m *CabinetMutation) FaultsIDs() (ids []uint64) {
	for id := range m.faults {
		ids = append(ids, id)
	}
	return
}

// ResetFaults resets all changes to the "faults" edge.
func (m *CabinetMutation) ResetFaults() {
	m.faults = nil
	m.clearedfaults = false
	m.removedfaults = nil
}

// AddExchangeIDs adds the "exchanges" edge to the Exchange entity by ids.
func (m *CabinetMutation) AddExchangeIDs(ids ...uint64) {
	if m.exchanges == nil {
		m.exchanges = make(map[uint64]struct{})
	}
	for i := range ids {
		m.exchanges[ids[i]] = struct{}{}
	}
}

// ClearExchanges clears the "exchanges" edge to the Exchange entity.
func (m *CabinetMutation) ClearExchanges() {
	m.clearedexchanges = true
}

// ExchangesCleared reports if the "exchanges" edge to the Exchange entity was cleared.
func (m *CabinetMutation) ExchangesCleared() bool {
	return m.clearedexchanges
}

// RemoveExchangeIDs removes the "exchanges" edge to the Exchange entity by IDs.
func (m *CabinetMutation) RemoveExchangeIDs(ids ...uint64) {
	if m.removedexchanges == nil {
		m.removedexchanges = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.exchanges, ids[i])
		m.removedexchanges[ids[i]] = struct{}{}
	}
}

// RemovedExchanges returns the removed IDs of the "exchanges" edge to the Exchange entity.
func (m *CabinetMutation) RemovedExchangesIDs() (ids []uint64) {
	for id := range m.removedexchanges {
		ids = append(ids, id)
	}
	return
}

// ExchangesIDs returns the "exchanges" edge IDs in the mutation.
func (m *CabinetMutation) ExchangesIDs() (ids []uint64) {
	for id := range m.exchanges {
		ids = append(ids, id)
	}
	return
}

// ResetExchanges resets all changes to the "exchanges" edge.
func (m *CabinetMutation) ResetExchanges() {
	m.exchanges = nil
	m.clearedexchanges = false
	m.removedexchanges = nil
}

// Where appends a list predicates to the CabinetMutation builder.
func (m *CabinetMutation) Where(ps ...predicate.Cabinet) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CabinetMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Cabinet).
func (m *CabinetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CabinetMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, cabinet.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cabinet.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, cabinet.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, cabinet.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, cabinet.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, cabinet.FieldRemark)
	}
	if m.city != nil {
		fields = append(fields, cabinet.FieldCityID)
	}
	if m.branch != nil {
		fields = append(fields, cabinet.FieldBranchID)
	}
	if m.sn != nil {
		fields = append(fields, cabinet.FieldSn)
	}
	if m.brand != nil {
		fields = append(fields, cabinet.FieldBrand)
	}
	if m.serial != nil {
		fields = append(fields, cabinet.FieldSerial)
	}
	if m.name != nil {
		fields = append(fields, cabinet.FieldName)
	}
	if m.doors != nil {
		fields = append(fields, cabinet.FieldDoors)
	}
	if m.status != nil {
		fields = append(fields, cabinet.FieldStatus)
	}
	if m.models != nil {
		fields = append(fields, cabinet.FieldModels)
	}
	if m.health != nil {
		fields = append(fields, cabinet.FieldHealth)
	}
	if m.bin != nil {
		fields = append(fields, cabinet.FieldBin)
	}
	if m.battery_num != nil {
		fields = append(fields, cabinet.FieldBatteryNum)
	}
	if m.battery_full_num != nil {
		fields = append(fields, cabinet.FieldBatteryFullNum)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CabinetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cabinet.FieldCreatedAt:
		return m.CreatedAt()
	case cabinet.FieldUpdatedAt:
		return m.UpdatedAt()
	case cabinet.FieldDeletedAt:
		return m.DeletedAt()
	case cabinet.FieldCreator:
		return m.Creator()
	case cabinet.FieldLastModifier:
		return m.LastModifier()
	case cabinet.FieldRemark:
		return m.Remark()
	case cabinet.FieldCityID:
		return m.CityID()
	case cabinet.FieldBranchID:
		return m.BranchID()
	case cabinet.FieldSn:
		return m.Sn()
	case cabinet.FieldBrand:
		return m.Brand()
	case cabinet.FieldSerial:
		return m.Serial()
	case cabinet.FieldName:
		return m.Name()
	case cabinet.FieldDoors:
		return m.Doors()
	case cabinet.FieldStatus:
		return m.Status()
	case cabinet.FieldModels:
		return m.Models()
	case cabinet.FieldHealth:
		return m.Health()
	case cabinet.FieldBin:
		return m.Bin()
	case cabinet.FieldBatteryNum:
		return m.BatteryNum()
	case cabinet.FieldBatteryFullNum:
		return m.BatteryFullNum()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CabinetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cabinet.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cabinet.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cabinet.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case cabinet.FieldCreator:
		return m.OldCreator(ctx)
	case cabinet.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case cabinet.FieldRemark:
		return m.OldRemark(ctx)
	case cabinet.FieldCityID:
		return m.OldCityID(ctx)
	case cabinet.FieldBranchID:
		return m.OldBranchID(ctx)
	case cabinet.FieldSn:
		return m.OldSn(ctx)
	case cabinet.FieldBrand:
		return m.OldBrand(ctx)
	case cabinet.FieldSerial:
		return m.OldSerial(ctx)
	case cabinet.FieldName:
		return m.OldName(ctx)
	case cabinet.FieldDoors:
		return m.OldDoors(ctx)
	case cabinet.FieldStatus:
		return m.OldStatus(ctx)
	case cabinet.FieldModels:
		return m.OldModels(ctx)
	case cabinet.FieldHealth:
		return m.OldHealth(ctx)
	case cabinet.FieldBin:
		return m.OldBin(ctx)
	case cabinet.FieldBatteryNum:
		return m.OldBatteryNum(ctx)
	case cabinet.FieldBatteryFullNum:
		return m.OldBatteryFullNum(ctx)
	}
	return nil, fmt.Errorf("unknown Cabinet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CabinetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cabinet.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cabinet.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cabinet.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case cabinet.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case cabinet.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case cabinet.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case cabinet.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case cabinet.FieldBranchID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranchID(v)
		return nil
	case cabinet.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case cabinet.FieldBrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrand(v)
		return nil
	case cabinet.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case cabinet.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cabinet.FieldDoors:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoors(v)
		return nil
	case cabinet.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case cabinet.FieldModels:
		v, ok := value.([]model.BatteryModel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModels(v)
		return nil
	case cabinet.FieldHealth:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealth(v)
		return nil
	case cabinet.FieldBin:
		v, ok := value.([]model.CabinetBin)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBin(v)
		return nil
	case cabinet.FieldBatteryNum:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatteryNum(v)
		return nil
	case cabinet.FieldBatteryFullNum:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatteryFullNum(v)
		return nil
	}
	return fmt.Errorf("unknown Cabinet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CabinetMutation) AddedFields() []string {
	var fields []string
	if m.adddoors != nil {
		fields = append(fields, cabinet.FieldDoors)
	}
	if m.addstatus != nil {
		fields = append(fields, cabinet.FieldStatus)
	}
	if m.addhealth != nil {
		fields = append(fields, cabinet.FieldHealth)
	}
	if m.addbattery_num != nil {
		fields = append(fields, cabinet.FieldBatteryNum)
	}
	if m.addbattery_full_num != nil {
		fields = append(fields, cabinet.FieldBatteryFullNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CabinetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cabinet.FieldDoors:
		return m.AddedDoors()
	case cabinet.FieldStatus:
		return m.AddedStatus()
	case cabinet.FieldHealth:
		return m.AddedHealth()
	case cabinet.FieldBatteryNum:
		return m.AddedBatteryNum()
	case cabinet.FieldBatteryFullNum:
		return m.AddedBatteryFullNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CabinetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cabinet.FieldDoors:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDoors(v)
		return nil
	case cabinet.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case cabinet.FieldHealth:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHealth(v)
		return nil
	case cabinet.FieldBatteryNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBatteryNum(v)
		return nil
	case cabinet.FieldBatteryFullNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBatteryFullNum(v)
		return nil
	}
	return fmt.Errorf("unknown Cabinet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CabinetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cabinet.FieldDeletedAt) {
		fields = append(fields, cabinet.FieldDeletedAt)
	}
	if m.FieldCleared(cabinet.FieldCreator) {
		fields = append(fields, cabinet.FieldCreator)
	}
	if m.FieldCleared(cabinet.FieldLastModifier) {
		fields = append(fields, cabinet.FieldLastModifier)
	}
	if m.FieldCleared(cabinet.FieldRemark) {
		fields = append(fields, cabinet.FieldRemark)
	}
	if m.FieldCleared(cabinet.FieldCityID) {
		fields = append(fields, cabinet.FieldCityID)
	}
	if m.FieldCleared(cabinet.FieldBranchID) {
		fields = append(fields, cabinet.FieldBranchID)
	}
	if m.FieldCleared(cabinet.FieldBin) {
		fields = append(fields, cabinet.FieldBin)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CabinetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CabinetMutation) ClearField(name string) error {
	switch name {
	case cabinet.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case cabinet.FieldCreator:
		m.ClearCreator()
		return nil
	case cabinet.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case cabinet.FieldRemark:
		m.ClearRemark()
		return nil
	case cabinet.FieldCityID:
		m.ClearCityID()
		return nil
	case cabinet.FieldBranchID:
		m.ClearBranchID()
		return nil
	case cabinet.FieldBin:
		m.ClearBin()
		return nil
	}
	return fmt.Errorf("unknown Cabinet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CabinetMutation) ResetField(name string) error {
	switch name {
	case cabinet.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cabinet.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cabinet.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case cabinet.FieldCreator:
		m.ResetCreator()
		return nil
	case cabinet.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case cabinet.FieldRemark:
		m.ResetRemark()
		return nil
	case cabinet.FieldCityID:
		m.ResetCityID()
		return nil
	case cabinet.FieldBranchID:
		m.ResetBranchID()
		return nil
	case cabinet.FieldSn:
		m.ResetSn()
		return nil
	case cabinet.FieldBrand:
		m.ResetBrand()
		return nil
	case cabinet.FieldSerial:
		m.ResetSerial()
		return nil
	case cabinet.FieldName:
		m.ResetName()
		return nil
	case cabinet.FieldDoors:
		m.ResetDoors()
		return nil
	case cabinet.FieldStatus:
		m.ResetStatus()
		return nil
	case cabinet.FieldModels:
		m.ResetModels()
		return nil
	case cabinet.FieldHealth:
		m.ResetHealth()
		return nil
	case cabinet.FieldBin:
		m.ResetBin()
		return nil
	case cabinet.FieldBatteryNum:
		m.ResetBatteryNum()
		return nil
	case cabinet.FieldBatteryFullNum:
		m.ResetBatteryFullNum()
		return nil
	}
	return fmt.Errorf("unknown Cabinet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CabinetMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.city != nil {
		edges = append(edges, cabinet.EdgeCity)
	}
	if m.branch != nil {
		edges = append(edges, cabinet.EdgeBranch)
	}
	if m.bms != nil {
		edges = append(edges, cabinet.EdgeBms)
	}
	if m.faults != nil {
		edges = append(edges, cabinet.EdgeFaults)
	}
	if m.exchanges != nil {
		edges = append(edges, cabinet.EdgeExchanges)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CabinetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cabinet.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case cabinet.EdgeBranch:
		if id := m.branch; id != nil {
			return []ent.Value{*id}
		}
	case cabinet.EdgeBms:
		ids := make([]ent.Value, 0, len(m.bms))
		for id := range m.bms {
			ids = append(ids, id)
		}
		return ids
	case cabinet.EdgeFaults:
		ids := make([]ent.Value, 0, len(m.faults))
		for id := range m.faults {
			ids = append(ids, id)
		}
		return ids
	case cabinet.EdgeExchanges:
		ids := make([]ent.Value, 0, len(m.exchanges))
		for id := range m.exchanges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CabinetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedbms != nil {
		edges = append(edges, cabinet.EdgeBms)
	}
	if m.removedfaults != nil {
		edges = append(edges, cabinet.EdgeFaults)
	}
	if m.removedexchanges != nil {
		edges = append(edges, cabinet.EdgeExchanges)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CabinetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cabinet.EdgeBms:
		ids := make([]ent.Value, 0, len(m.removedbms))
		for id := range m.removedbms {
			ids = append(ids, id)
		}
		return ids
	case cabinet.EdgeFaults:
		ids := make([]ent.Value, 0, len(m.removedfaults))
		for id := range m.removedfaults {
			ids = append(ids, id)
		}
		return ids
	case cabinet.EdgeExchanges:
		ids := make([]ent.Value, 0, len(m.removedexchanges))
		for id := range m.removedexchanges {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CabinetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcity {
		edges = append(edges, cabinet.EdgeCity)
	}
	if m.clearedbranch {
		edges = append(edges, cabinet.EdgeBranch)
	}
	if m.clearedbms {
		edges = append(edges, cabinet.EdgeBms)
	}
	if m.clearedfaults {
		edges = append(edges, cabinet.EdgeFaults)
	}
	if m.clearedexchanges {
		edges = append(edges, cabinet.EdgeExchanges)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CabinetMutation) EdgeCleared(name string) bool {
	switch name {
	case cabinet.EdgeCity:
		return m.clearedcity
	case cabinet.EdgeBranch:
		return m.clearedbranch
	case cabinet.EdgeBms:
		return m.clearedbms
	case cabinet.EdgeFaults:
		return m.clearedfaults
	case cabinet.EdgeExchanges:
		return m.clearedexchanges
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CabinetMutation) ClearEdge(name string) error {
	switch name {
	case cabinet.EdgeCity:
		m.ClearCity()
		return nil
	case cabinet.EdgeBranch:
		m.ClearBranch()
		return nil
	}
	return fmt.Errorf("unknown Cabinet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CabinetMutation) ResetEdge(name string) error {
	switch name {
	case cabinet.EdgeCity:
		m.ResetCity()
		return nil
	case cabinet.EdgeBranch:
		m.ResetBranch()
		return nil
	case cabinet.EdgeBms:
		m.ResetBms()
		return nil
	case cabinet.EdgeFaults:
		m.ResetFaults()
		return nil
	case cabinet.EdgeExchanges:
		m.ResetExchanges()
		return nil
	}
	return fmt.Errorf("unknown Cabinet edge %s", name)
}

// CabinetFaultMutation represents an operation that mutates the CabinetFault nodes in the graph.
type CabinetFaultMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	creator        **model.Modifier
	last_modifier  **model.Modifier
	remark         *string
	status         *uint8
	addstatus      *int8
	fault          *string
	attachments    *[]string
	description    *string
	clearedFields  map[string]struct{}
	city           *uint64
	clearedcity    bool
	branch         *uint64
	clearedbranch  bool
	cabinet        *uint64
	clearedcabinet bool
	rider          *uint64
	clearedrider   bool
	done           bool
	oldValue       func(context.Context) (*CabinetFault, error)
	predicates     []predicate.CabinetFault
}

var _ ent.Mutation = (*CabinetFaultMutation)(nil)

// cabinetfaultOption allows management of the mutation configuration using functional options.
type cabinetfaultOption func(*CabinetFaultMutation)

// newCabinetFaultMutation creates new mutation for the CabinetFault entity.
func newCabinetFaultMutation(c config, op Op, opts ...cabinetfaultOption) *CabinetFaultMutation {
	m := &CabinetFaultMutation{
		config:        c,
		op:            op,
		typ:           TypeCabinetFault,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCabinetFaultID sets the ID field of the mutation.
func withCabinetFaultID(id uint64) cabinetfaultOption {
	return func(m *CabinetFaultMutation) {
		var (
			err   error
			once  sync.Once
			value *CabinetFault
		)
		m.oldValue = func(ctx context.Context) (*CabinetFault, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CabinetFault.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCabinetFault sets the old CabinetFault of the mutation.
func withCabinetFault(node *CabinetFault) cabinetfaultOption {
	return func(m *CabinetFaultMutation) {
		m.oldValue = func(context.Context) (*CabinetFault, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CabinetFaultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CabinetFaultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CabinetFaultMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CabinetFaultMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CabinetFault.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CabinetFaultMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CabinetFaultMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CabinetFaultMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CabinetFaultMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CabinetFaultMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CabinetFaultMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CabinetFaultMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CabinetFaultMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CabinetFaultMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[cabinetfault.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CabinetFaultMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[cabinetfault.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CabinetFaultMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, cabinetfault.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *CabinetFaultMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *CabinetFaultMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *CabinetFaultMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[cabinetfault.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *CabinetFaultMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[cabinetfault.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *CabinetFaultMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, cabinetfault.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *CabinetFaultMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *CabinetFaultMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *CabinetFaultMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[cabinetfault.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *CabinetFaultMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[cabinetfault.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *CabinetFaultMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, cabinetfault.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *CabinetFaultMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CabinetFaultMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *CabinetFaultMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[cabinetfault.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *CabinetFaultMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[cabinetfault.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *CabinetFaultMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, cabinetfault.FieldRemark)
}

// SetCityID sets the "city_id" field.
func (m *CabinetFaultMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *CabinetFaultMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *CabinetFaultMutation) ResetCityID() {
	m.city = nil
}

// SetStatus sets the "status" field.
func (m *CabinetFaultMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CabinetFaultMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *CabinetFaultMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CabinetFaultMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CabinetFaultMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetBranchID sets the "branch_id" field.
func (m *CabinetFaultMutation) SetBranchID(u uint64) {
	m.branch = &u
}

// BranchID returns the value of the "branch_id" field in the mutation.
func (m *CabinetFaultMutation) BranchID() (r uint64, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranchID returns the old "branch_id" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldBranchID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBranchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBranchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranchID: %w", err)
	}
	return oldValue.BranchID, nil
}

// ResetBranchID resets all changes to the "branch_id" field.
func (m *CabinetFaultMutation) ResetBranchID() {
	m.branch = nil
}

// SetCabinetID sets the "cabinet_id" field.
func (m *CabinetFaultMutation) SetCabinetID(u uint64) {
	m.cabinet = &u
}

// CabinetID returns the value of the "cabinet_id" field in the mutation.
func (m *CabinetFaultMutation) CabinetID() (r uint64, exists bool) {
	v := m.cabinet
	if v == nil {
		return
	}
	return *v, true
}

// OldCabinetID returns the old "cabinet_id" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldCabinetID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCabinetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCabinetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCabinetID: %w", err)
	}
	return oldValue.CabinetID, nil
}

// ResetCabinetID resets all changes to the "cabinet_id" field.
func (m *CabinetFaultMutation) ResetCabinetID() {
	m.cabinet = nil
}

// SetRiderID sets the "rider_id" field.
func (m *CabinetFaultMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *CabinetFaultMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *CabinetFaultMutation) ResetRiderID() {
	m.rider = nil
}

// SetFault sets the "fault" field.
func (m *CabinetFaultMutation) SetFault(s string) {
	m.fault = &s
}

// Fault returns the value of the "fault" field in the mutation.
func (m *CabinetFaultMutation) Fault() (r string, exists bool) {
	v := m.fault
	if v == nil {
		return
	}
	return *v, true
}

// OldFault returns the old "fault" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldFault(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFault: %w", err)
	}
	return oldValue.Fault, nil
}

// ClearFault clears the value of the "fault" field.
func (m *CabinetFaultMutation) ClearFault() {
	m.fault = nil
	m.clearedFields[cabinetfault.FieldFault] = struct{}{}
}

// FaultCleared returns if the "fault" field was cleared in this mutation.
func (m *CabinetFaultMutation) FaultCleared() bool {
	_, ok := m.clearedFields[cabinetfault.FieldFault]
	return ok
}

// ResetFault resets all changes to the "fault" field.
func (m *CabinetFaultMutation) ResetFault() {
	m.fault = nil
	delete(m.clearedFields, cabinetfault.FieldFault)
}

// SetAttachments sets the "attachments" field.
func (m *CabinetFaultMutation) SetAttachments(s []string) {
	m.attachments = &s
}

// Attachments returns the value of the "attachments" field in the mutation.
func (m *CabinetFaultMutation) Attachments() (r []string, exists bool) {
	v := m.attachments
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachments returns the old "attachments" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldAttachments(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttachments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttachments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachments: %w", err)
	}
	return oldValue.Attachments, nil
}

// ClearAttachments clears the value of the "attachments" field.
func (m *CabinetFaultMutation) ClearAttachments() {
	m.attachments = nil
	m.clearedFields[cabinetfault.FieldAttachments] = struct{}{}
}

// AttachmentsCleared returns if the "attachments" field was cleared in this mutation.
func (m *CabinetFaultMutation) AttachmentsCleared() bool {
	_, ok := m.clearedFields[cabinetfault.FieldAttachments]
	return ok
}

// ResetAttachments resets all changes to the "attachments" field.
func (m *CabinetFaultMutation) ResetAttachments() {
	m.attachments = nil
	delete(m.clearedFields, cabinetfault.FieldAttachments)
}

// SetDescription sets the "description" field.
func (m *CabinetFaultMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CabinetFaultMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CabinetFaultMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[cabinetfault.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CabinetFaultMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[cabinetfault.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CabinetFaultMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, cabinetfault.FieldDescription)
}

// ClearCity clears the "city" edge to the City entity.
func (m *CabinetFaultMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *CabinetFaultMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *CabinetFaultMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *CabinetFaultMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearBranch clears the "branch" edge to the Branch entity.
func (m *CabinetFaultMutation) ClearBranch() {
	m.clearedbranch = true
}

// BranchCleared reports if the "branch" edge to the Branch entity was cleared.
func (m *CabinetFaultMutation) BranchCleared() bool {
	return m.clearedbranch
}

// BranchIDs returns the "branch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BranchID instead. It exists only for internal usage by the builders.
func (m *CabinetFaultMutation) BranchIDs() (ids []uint64) {
	if id := m.branch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBranch resets all changes to the "branch" edge.
func (m *CabinetFaultMutation) ResetBranch() {
	m.branch = nil
	m.clearedbranch = false
}

// ClearCabinet clears the "cabinet" edge to the Cabinet entity.
func (m *CabinetFaultMutation) ClearCabinet() {
	m.clearedcabinet = true
}

// CabinetCleared reports if the "cabinet" edge to the Cabinet entity was cleared.
func (m *CabinetFaultMutation) CabinetCleared() bool {
	return m.clearedcabinet
}

// CabinetIDs returns the "cabinet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CabinetID instead. It exists only for internal usage by the builders.
func (m *CabinetFaultMutation) CabinetIDs() (ids []uint64) {
	if id := m.cabinet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCabinet resets all changes to the "cabinet" edge.
func (m *CabinetFaultMutation) ResetCabinet() {
	m.cabinet = nil
	m.clearedcabinet = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *CabinetFaultMutation) ClearRider() {
	m.clearedrider = true
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *CabinetFaultMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *CabinetFaultMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *CabinetFaultMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// Where appends a list predicates to the CabinetFaultMutation builder.
func (m *CabinetFaultMutation) Where(ps ...predicate.CabinetFault) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CabinetFaultMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CabinetFault).
func (m *CabinetFaultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CabinetFaultMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, cabinetfault.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cabinetfault.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, cabinetfault.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, cabinetfault.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, cabinetfault.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, cabinetfault.FieldRemark)
	}
	if m.city != nil {
		fields = append(fields, cabinetfault.FieldCityID)
	}
	if m.status != nil {
		fields = append(fields, cabinetfault.FieldStatus)
	}
	if m.branch != nil {
		fields = append(fields, cabinetfault.FieldBranchID)
	}
	if m.cabinet != nil {
		fields = append(fields, cabinetfault.FieldCabinetID)
	}
	if m.rider != nil {
		fields = append(fields, cabinetfault.FieldRiderID)
	}
	if m.fault != nil {
		fields = append(fields, cabinetfault.FieldFault)
	}
	if m.attachments != nil {
		fields = append(fields, cabinetfault.FieldAttachments)
	}
	if m.description != nil {
		fields = append(fields, cabinetfault.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CabinetFaultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cabinetfault.FieldCreatedAt:
		return m.CreatedAt()
	case cabinetfault.FieldUpdatedAt:
		return m.UpdatedAt()
	case cabinetfault.FieldDeletedAt:
		return m.DeletedAt()
	case cabinetfault.FieldCreator:
		return m.Creator()
	case cabinetfault.FieldLastModifier:
		return m.LastModifier()
	case cabinetfault.FieldRemark:
		return m.Remark()
	case cabinetfault.FieldCityID:
		return m.CityID()
	case cabinetfault.FieldStatus:
		return m.Status()
	case cabinetfault.FieldBranchID:
		return m.BranchID()
	case cabinetfault.FieldCabinetID:
		return m.CabinetID()
	case cabinetfault.FieldRiderID:
		return m.RiderID()
	case cabinetfault.FieldFault:
		return m.Fault()
	case cabinetfault.FieldAttachments:
		return m.Attachments()
	case cabinetfault.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CabinetFaultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cabinetfault.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cabinetfault.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cabinetfault.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case cabinetfault.FieldCreator:
		return m.OldCreator(ctx)
	case cabinetfault.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case cabinetfault.FieldRemark:
		return m.OldRemark(ctx)
	case cabinetfault.FieldCityID:
		return m.OldCityID(ctx)
	case cabinetfault.FieldStatus:
		return m.OldStatus(ctx)
	case cabinetfault.FieldBranchID:
		return m.OldBranchID(ctx)
	case cabinetfault.FieldCabinetID:
		return m.OldCabinetID(ctx)
	case cabinetfault.FieldRiderID:
		return m.OldRiderID(ctx)
	case cabinetfault.FieldFault:
		return m.OldFault(ctx)
	case cabinetfault.FieldAttachments:
		return m.OldAttachments(ctx)
	case cabinetfault.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown CabinetFault field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CabinetFaultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cabinetfault.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cabinetfault.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cabinetfault.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case cabinetfault.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case cabinetfault.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case cabinetfault.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case cabinetfault.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case cabinetfault.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case cabinetfault.FieldBranchID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranchID(v)
		return nil
	case cabinetfault.FieldCabinetID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCabinetID(v)
		return nil
	case cabinetfault.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case cabinetfault.FieldFault:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFault(v)
		return nil
	case cabinetfault.FieldAttachments:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachments(v)
		return nil
	case cabinetfault.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown CabinetFault field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CabinetFaultMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, cabinetfault.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CabinetFaultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cabinetfault.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CabinetFaultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cabinetfault.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown CabinetFault numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CabinetFaultMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cabinetfault.FieldDeletedAt) {
		fields = append(fields, cabinetfault.FieldDeletedAt)
	}
	if m.FieldCleared(cabinetfault.FieldCreator) {
		fields = append(fields, cabinetfault.FieldCreator)
	}
	if m.FieldCleared(cabinetfault.FieldLastModifier) {
		fields = append(fields, cabinetfault.FieldLastModifier)
	}
	if m.FieldCleared(cabinetfault.FieldRemark) {
		fields = append(fields, cabinetfault.FieldRemark)
	}
	if m.FieldCleared(cabinetfault.FieldFault) {
		fields = append(fields, cabinetfault.FieldFault)
	}
	if m.FieldCleared(cabinetfault.FieldAttachments) {
		fields = append(fields, cabinetfault.FieldAttachments)
	}
	if m.FieldCleared(cabinetfault.FieldDescription) {
		fields = append(fields, cabinetfault.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CabinetFaultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CabinetFaultMutation) ClearField(name string) error {
	switch name {
	case cabinetfault.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case cabinetfault.FieldCreator:
		m.ClearCreator()
		return nil
	case cabinetfault.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case cabinetfault.FieldRemark:
		m.ClearRemark()
		return nil
	case cabinetfault.FieldFault:
		m.ClearFault()
		return nil
	case cabinetfault.FieldAttachments:
		m.ClearAttachments()
		return nil
	case cabinetfault.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown CabinetFault nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CabinetFaultMutation) ResetField(name string) error {
	switch name {
	case cabinetfault.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cabinetfault.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cabinetfault.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case cabinetfault.FieldCreator:
		m.ResetCreator()
		return nil
	case cabinetfault.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case cabinetfault.FieldRemark:
		m.ResetRemark()
		return nil
	case cabinetfault.FieldCityID:
		m.ResetCityID()
		return nil
	case cabinetfault.FieldStatus:
		m.ResetStatus()
		return nil
	case cabinetfault.FieldBranchID:
		m.ResetBranchID()
		return nil
	case cabinetfault.FieldCabinetID:
		m.ResetCabinetID()
		return nil
	case cabinetfault.FieldRiderID:
		m.ResetRiderID()
		return nil
	case cabinetfault.FieldFault:
		m.ResetFault()
		return nil
	case cabinetfault.FieldAttachments:
		m.ResetAttachments()
		return nil
	case cabinetfault.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown CabinetFault field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CabinetFaultMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.city != nil {
		edges = append(edges, cabinetfault.EdgeCity)
	}
	if m.branch != nil {
		edges = append(edges, cabinetfault.EdgeBranch)
	}
	if m.cabinet != nil {
		edges = append(edges, cabinetfault.EdgeCabinet)
	}
	if m.rider != nil {
		edges = append(edges, cabinetfault.EdgeRider)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CabinetFaultMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cabinetfault.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case cabinetfault.EdgeBranch:
		if id := m.branch; id != nil {
			return []ent.Value{*id}
		}
	case cabinetfault.EdgeCabinet:
		if id := m.cabinet; id != nil {
			return []ent.Value{*id}
		}
	case cabinetfault.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CabinetFaultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CabinetFaultMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CabinetFaultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcity {
		edges = append(edges, cabinetfault.EdgeCity)
	}
	if m.clearedbranch {
		edges = append(edges, cabinetfault.EdgeBranch)
	}
	if m.clearedcabinet {
		edges = append(edges, cabinetfault.EdgeCabinet)
	}
	if m.clearedrider {
		edges = append(edges, cabinetfault.EdgeRider)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CabinetFaultMutation) EdgeCleared(name string) bool {
	switch name {
	case cabinetfault.EdgeCity:
		return m.clearedcity
	case cabinetfault.EdgeBranch:
		return m.clearedbranch
	case cabinetfault.EdgeCabinet:
		return m.clearedcabinet
	case cabinetfault.EdgeRider:
		return m.clearedrider
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CabinetFaultMutation) ClearEdge(name string) error {
	switch name {
	case cabinetfault.EdgeCity:
		m.ClearCity()
		return nil
	case cabinetfault.EdgeBranch:
		m.ClearBranch()
		return nil
	case cabinetfault.EdgeCabinet:
		m.ClearCabinet()
		return nil
	case cabinetfault.EdgeRider:
		m.ClearRider()
		return nil
	}
	return fmt.Errorf("unknown CabinetFault unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CabinetFaultMutation) ResetEdge(name string) error {
	switch name {
	case cabinetfault.EdgeCity:
		m.ResetCity()
		return nil
	case cabinetfault.EdgeBranch:
		m.ResetBranch()
		return nil
	case cabinetfault.EdgeCabinet:
		m.ResetCabinet()
		return nil
	case cabinetfault.EdgeRider:
		m.ResetRider()
		return nil
	}
	return fmt.Errorf("unknown CabinetFault edge %s", name)
}

// CityMutation represents an operation that mutates the City nodes in the graph.
type CityMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	creator         **model.Modifier
	last_modifier   **model.Modifier
	remark          *string
	open            *bool
	name            *string
	code            *string
	lng             *float64
	addlng          *float64
	lat             *float64
	addlat          *float64
	clearedFields   map[string]struct{}
	plans           map[uint64]struct{}
	removedplans    map[uint64]struct{}
	clearedplans    bool
	parent          *uint64
	clearedparent   bool
	children        map[uint64]struct{}
	removedchildren map[uint64]struct{}
	clearedchildren bool
	done            bool
	oldValue        func(context.Context) (*City, error)
	predicates      []predicate.City
}

var _ ent.Mutation = (*CityMutation)(nil)

// cityOption allows management of the mutation configuration using functional options.
type cityOption func(*CityMutation)

// newCityMutation creates new mutation for the City entity.
func newCityMutation(c config, op Op, opts ...cityOption) *CityMutation {
	m := &CityMutation{
		config:        c,
		op:            op,
		typ:           TypeCity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCityID sets the ID field of the mutation.
func withCityID(id uint64) cityOption {
	return func(m *CityMutation) {
		var (
			err   error
			once  sync.Once
			value *City
		)
		m.oldValue = func(ctx context.Context) (*City, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().City.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCity sets the old City of the mutation.
func withCity(node *City) cityOption {
	return func(m *CityMutation) {
		m.oldValue = func(context.Context) (*City, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of City entities.
func (m *CityMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CityMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CityMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().City.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CityMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CityMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CityMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[city.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CityMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[city.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CityMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, city.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *CityMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *CityMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *CityMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[city.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *CityMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[city.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *CityMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, city.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *CityMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *CityMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *CityMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[city.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *CityMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[city.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *CityMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, city.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *CityMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CityMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *CityMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[city.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *CityMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[city.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *CityMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, city.FieldRemark)
}

// SetOpen sets the "open" field.
func (m *CityMutation) SetOpen(b bool) {
	m.open = &b
}

// Open returns the value of the "open" field in the mutation.
func (m *CityMutation) Open() (r bool, exists bool) {
	v := m.open
	if v == nil {
		return
	}
	return *v, true
}

// OldOpen returns the old "open" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldOpen(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpen: %w", err)
	}
	return oldValue.Open, nil
}

// ClearOpen clears the value of the "open" field.
func (m *CityMutation) ClearOpen() {
	m.open = nil
	m.clearedFields[city.FieldOpen] = struct{}{}
}

// OpenCleared returns if the "open" field was cleared in this mutation.
func (m *CityMutation) OpenCleared() bool {
	_, ok := m.clearedFields[city.FieldOpen]
	return ok
}

// ResetOpen resets all changes to the "open" field.
func (m *CityMutation) ResetOpen() {
	m.open = nil
	delete(m.clearedFields, city.FieldOpen)
}

// SetName sets the "name" field.
func (m *CityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CityMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *CityMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CityMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CityMutation) ResetCode() {
	m.code = nil
}

// SetParentID sets the "parent_id" field.
func (m *CityMutation) SetParentID(u uint64) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CityMutation) ParentID() (r uint64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldParentID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *CityMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[city.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *CityMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[city.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CityMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, city.FieldParentID)
}

// SetLng sets the "lng" field.
func (m *CityMutation) SetLng(f float64) {
	m.lng = &f
	m.addlng = nil
}

// Lng returns the value of the "lng" field in the mutation.
func (m *CityMutation) Lng() (r float64, exists bool) {
	v := m.lng
	if v == nil {
		return
	}
	return *v, true
}

// OldLng returns the old "lng" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldLng(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLng is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLng requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLng: %w", err)
	}
	return oldValue.Lng, nil
}

// AddLng adds f to the "lng" field.
func (m *CityMutation) AddLng(f float64) {
	if m.addlng != nil {
		*m.addlng += f
	} else {
		m.addlng = &f
	}
}

// AddedLng returns the value that was added to the "lng" field in this mutation.
func (m *CityMutation) AddedLng() (r float64, exists bool) {
	v := m.addlng
	if v == nil {
		return
	}
	return *v, true
}

// ClearLng clears the value of the "lng" field.
func (m *CityMutation) ClearLng() {
	m.lng = nil
	m.addlng = nil
	m.clearedFields[city.FieldLng] = struct{}{}
}

// LngCleared returns if the "lng" field was cleared in this mutation.
func (m *CityMutation) LngCleared() bool {
	_, ok := m.clearedFields[city.FieldLng]
	return ok
}

// ResetLng resets all changes to the "lng" field.
func (m *CityMutation) ResetLng() {
	m.lng = nil
	m.addlng = nil
	delete(m.clearedFields, city.FieldLng)
}

// SetLat sets the "lat" field.
func (m *CityMutation) SetLat(f float64) {
	m.lat = &f
	m.addlat = nil
}

// Lat returns the value of the "lat" field in the mutation.
func (m *CityMutation) Lat() (r float64, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "lat" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// AddLat adds f to the "lat" field.
func (m *CityMutation) AddLat(f float64) {
	if m.addlat != nil {
		*m.addlat += f
	} else {
		m.addlat = &f
	}
}

// AddedLat returns the value that was added to the "lat" field in this mutation.
func (m *CityMutation) AddedLat() (r float64, exists bool) {
	v := m.addlat
	if v == nil {
		return
	}
	return *v, true
}

// ClearLat clears the value of the "lat" field.
func (m *CityMutation) ClearLat() {
	m.lat = nil
	m.addlat = nil
	m.clearedFields[city.FieldLat] = struct{}{}
}

// LatCleared returns if the "lat" field was cleared in this mutation.
func (m *CityMutation) LatCleared() bool {
	_, ok := m.clearedFields[city.FieldLat]
	return ok
}

// ResetLat resets all changes to the "lat" field.
func (m *CityMutation) ResetLat() {
	m.lat = nil
	m.addlat = nil
	delete(m.clearedFields, city.FieldLat)
}

// AddPlanIDs adds the "plans" edge to the Plan entity by ids.
func (m *CityMutation) AddPlanIDs(ids ...uint64) {
	if m.plans == nil {
		m.plans = make(map[uint64]struct{})
	}
	for i := range ids {
		m.plans[ids[i]] = struct{}{}
	}
}

// ClearPlans clears the "plans" edge to the Plan entity.
func (m *CityMutation) ClearPlans() {
	m.clearedplans = true
}

// PlansCleared reports if the "plans" edge to the Plan entity was cleared.
func (m *CityMutation) PlansCleared() bool {
	return m.clearedplans
}

// RemovePlanIDs removes the "plans" edge to the Plan entity by IDs.
func (m *CityMutation) RemovePlanIDs(ids ...uint64) {
	if m.removedplans == nil {
		m.removedplans = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.plans, ids[i])
		m.removedplans[ids[i]] = struct{}{}
	}
}

// RemovedPlans returns the removed IDs of the "plans" edge to the Plan entity.
func (m *CityMutation) RemovedPlansIDs() (ids []uint64) {
	for id := range m.removedplans {
		ids = append(ids, id)
	}
	return
}

// PlansIDs returns the "plans" edge IDs in the mutation.
func (m *CityMutation) PlansIDs() (ids []uint64) {
	for id := range m.plans {
		ids = append(ids, id)
	}
	return
}

// ResetPlans resets all changes to the "plans" edge.
func (m *CityMutation) ResetPlans() {
	m.plans = nil
	m.clearedplans = false
	m.removedplans = nil
}

// ClearParent clears the "parent" edge to the City entity.
func (m *CityMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the City entity was cleared.
func (m *CityMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CityMutation) ParentIDs() (ids []uint64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CityMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the City entity by ids.
func (m *CityMutation) AddChildIDs(ids ...uint64) {
	if m.children == nil {
		m.children = make(map[uint64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the City entity.
func (m *CityMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the City entity was cleared.
func (m *CityMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the City entity by IDs.
func (m *CityMutation) RemoveChildIDs(ids ...uint64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the City entity.
func (m *CityMutation) RemovedChildrenIDs() (ids []uint64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *CityMutation) ChildrenIDs() (ids []uint64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *CityMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the CityMutation builder.
func (m *CityMutation) Where(ps ...predicate.City) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (City).
func (m *CityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CityMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, city.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, city.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, city.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, city.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, city.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, city.FieldRemark)
	}
	if m.open != nil {
		fields = append(fields, city.FieldOpen)
	}
	if m.name != nil {
		fields = append(fields, city.FieldName)
	}
	if m.code != nil {
		fields = append(fields, city.FieldCode)
	}
	if m.parent != nil {
		fields = append(fields, city.FieldParentID)
	}
	if m.lng != nil {
		fields = append(fields, city.FieldLng)
	}
	if m.lat != nil {
		fields = append(fields, city.FieldLat)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case city.FieldCreatedAt:
		return m.CreatedAt()
	case city.FieldUpdatedAt:
		return m.UpdatedAt()
	case city.FieldDeletedAt:
		return m.DeletedAt()
	case city.FieldCreator:
		return m.Creator()
	case city.FieldLastModifier:
		return m.LastModifier()
	case city.FieldRemark:
		return m.Remark()
	case city.FieldOpen:
		return m.Open()
	case city.FieldName:
		return m.Name()
	case city.FieldCode:
		return m.Code()
	case city.FieldParentID:
		return m.ParentID()
	case city.FieldLng:
		return m.Lng()
	case city.FieldLat:
		return m.Lat()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case city.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case city.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case city.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case city.FieldCreator:
		return m.OldCreator(ctx)
	case city.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case city.FieldRemark:
		return m.OldRemark(ctx)
	case city.FieldOpen:
		return m.OldOpen(ctx)
	case city.FieldName:
		return m.OldName(ctx)
	case city.FieldCode:
		return m.OldCode(ctx)
	case city.FieldParentID:
		return m.OldParentID(ctx)
	case city.FieldLng:
		return m.OldLng(ctx)
	case city.FieldLat:
		return m.OldLat(ctx)
	}
	return nil, fmt.Errorf("unknown City field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case city.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case city.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case city.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case city.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case city.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case city.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case city.FieldOpen:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpen(v)
		return nil
	case city.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case city.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case city.FieldParentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case city.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLng(v)
		return nil
	case city.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CityMutation) AddedFields() []string {
	var fields []string
	if m.addlng != nil {
		fields = append(fields, city.FieldLng)
	}
	if m.addlat != nil {
		fields = append(fields, city.FieldLat)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case city.FieldLng:
		return m.AddedLng()
	case city.FieldLat:
		return m.AddedLat()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case city.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLng(v)
		return nil
	case city.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLat(v)
		return nil
	}
	return fmt.Errorf("unknown City numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(city.FieldDeletedAt) {
		fields = append(fields, city.FieldDeletedAt)
	}
	if m.FieldCleared(city.FieldCreator) {
		fields = append(fields, city.FieldCreator)
	}
	if m.FieldCleared(city.FieldLastModifier) {
		fields = append(fields, city.FieldLastModifier)
	}
	if m.FieldCleared(city.FieldRemark) {
		fields = append(fields, city.FieldRemark)
	}
	if m.FieldCleared(city.FieldOpen) {
		fields = append(fields, city.FieldOpen)
	}
	if m.FieldCleared(city.FieldParentID) {
		fields = append(fields, city.FieldParentID)
	}
	if m.FieldCleared(city.FieldLng) {
		fields = append(fields, city.FieldLng)
	}
	if m.FieldCleared(city.FieldLat) {
		fields = append(fields, city.FieldLat)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CityMutation) ClearField(name string) error {
	switch name {
	case city.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case city.FieldCreator:
		m.ClearCreator()
		return nil
	case city.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case city.FieldRemark:
		m.ClearRemark()
		return nil
	case city.FieldOpen:
		m.ClearOpen()
		return nil
	case city.FieldParentID:
		m.ClearParentID()
		return nil
	case city.FieldLng:
		m.ClearLng()
		return nil
	case city.FieldLat:
		m.ClearLat()
		return nil
	}
	return fmt.Errorf("unknown City nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CityMutation) ResetField(name string) error {
	switch name {
	case city.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case city.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case city.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case city.FieldCreator:
		m.ResetCreator()
		return nil
	case city.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case city.FieldRemark:
		m.ResetRemark()
		return nil
	case city.FieldOpen:
		m.ResetOpen()
		return nil
	case city.FieldName:
		m.ResetName()
		return nil
	case city.FieldCode:
		m.ResetCode()
		return nil
	case city.FieldParentID:
		m.ResetParentID()
		return nil
	case city.FieldLng:
		m.ResetLng()
		return nil
	case city.FieldLat:
		m.ResetLat()
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.plans != nil {
		edges = append(edges, city.EdgePlans)
	}
	if m.parent != nil {
		edges = append(edges, city.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, city.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case city.EdgePlans:
		ids := make([]ent.Value, 0, len(m.plans))
		for id := range m.plans {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case city.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedplans != nil {
		edges = append(edges, city.EdgePlans)
	}
	if m.removedchildren != nil {
		edges = append(edges, city.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case city.EdgePlans:
		ids := make([]ent.Value, 0, len(m.removedplans))
		for id := range m.removedplans {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedplans {
		edges = append(edges, city.EdgePlans)
	}
	if m.clearedparent {
		edges = append(edges, city.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, city.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CityMutation) EdgeCleared(name string) bool {
	switch name {
	case city.EdgePlans:
		return m.clearedplans
	case city.EdgeParent:
		return m.clearedparent
	case city.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CityMutation) ClearEdge(name string) error {
	switch name {
	case city.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown City unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CityMutation) ResetEdge(name string) error {
	switch name {
	case city.EdgePlans:
		m.ResetPlans()
		return nil
	case city.EdgeParent:
		m.ResetParent()
		return nil
	case city.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown City edge %s", name)
}

// CommissionMutation represents an operation that mutates the Commission nodes in the graph.
type CommissionMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	creator         **model.Modifier
	last_modifier   **model.Modifier
	remark          *string
	amount          *float64
	addamount       *float64
	status          *uint8
	addstatus       *int8
	clearedFields   map[string]struct{}
	_order          *uint64
	cleared_order   bool
	employee        *uint64
	clearedemployee bool
	done            bool
	oldValue        func(context.Context) (*Commission, error)
	predicates      []predicate.Commission
}

var _ ent.Mutation = (*CommissionMutation)(nil)

// commissionOption allows management of the mutation configuration using functional options.
type commissionOption func(*CommissionMutation)

// newCommissionMutation creates new mutation for the Commission entity.
func newCommissionMutation(c config, op Op, opts ...commissionOption) *CommissionMutation {
	m := &CommissionMutation{
		config:        c,
		op:            op,
		typ:           TypeCommission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommissionID sets the ID field of the mutation.
func withCommissionID(id uint64) commissionOption {
	return func(m *CommissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Commission
		)
		m.oldValue = func(ctx context.Context) (*Commission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Commission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommission sets the old Commission of the mutation.
func withCommission(node *Commission) commissionOption {
	return func(m *CommissionMutation) {
		m.oldValue = func(context.Context) (*Commission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommissionMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommissionMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Commission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CommissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CommissionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CommissionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CommissionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[commission.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CommissionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[commission.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CommissionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, commission.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *CommissionMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *CommissionMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *CommissionMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[commission.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *CommissionMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[commission.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *CommissionMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, commission.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *CommissionMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *CommissionMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *CommissionMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[commission.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *CommissionMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[commission.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *CommissionMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, commission.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *CommissionMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CommissionMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *CommissionMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[commission.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *CommissionMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[commission.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *CommissionMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, commission.FieldRemark)
}

// SetOrderID sets the "order_id" field.
func (m *CommissionMutation) SetOrderID(u uint64) {
	m._order = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *CommissionMutation) OrderID() (r uint64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldOrderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *CommissionMutation) ResetOrderID() {
	m._order = nil
}

// SetAmount sets the "amount" field.
func (m *CommissionMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *CommissionMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *CommissionMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *CommissionMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *CommissionMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetStatus sets the "status" field.
func (m *CommissionMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CommissionMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *CommissionMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CommissionMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CommissionMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetEmployeeID sets the "employee_id" field.
func (m *CommissionMutation) SetEmployeeID(u uint64) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *CommissionMutation) EmployeeID() (r uint64, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldEmployeeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *CommissionMutation) ClearEmployeeID() {
	m.employee = nil
	m.clearedFields[commission.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *CommissionMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[commission.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *CommissionMutation) ResetEmployeeID() {
	m.employee = nil
	delete(m.clearedFields, commission.FieldEmployeeID)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *CommissionMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *CommissionMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *CommissionMutation) OrderIDs() (ids []uint64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *CommissionMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *CommissionMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *CommissionMutation) EmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *CommissionMutation) EmployeeIDs() (ids []uint64) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *CommissionMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// Where appends a list predicates to the CommissionMutation builder.
func (m *CommissionMutation) Where(ps ...predicate.Commission) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CommissionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Commission).
func (m *CommissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommissionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, commission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, commission.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, commission.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, commission.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, commission.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, commission.FieldRemark)
	}
	if m._order != nil {
		fields = append(fields, commission.FieldOrderID)
	}
	if m.amount != nil {
		fields = append(fields, commission.FieldAmount)
	}
	if m.status != nil {
		fields = append(fields, commission.FieldStatus)
	}
	if m.employee != nil {
		fields = append(fields, commission.FieldEmployeeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case commission.FieldCreatedAt:
		return m.CreatedAt()
	case commission.FieldUpdatedAt:
		return m.UpdatedAt()
	case commission.FieldDeletedAt:
		return m.DeletedAt()
	case commission.FieldCreator:
		return m.Creator()
	case commission.FieldLastModifier:
		return m.LastModifier()
	case commission.FieldRemark:
		return m.Remark()
	case commission.FieldOrderID:
		return m.OrderID()
	case commission.FieldAmount:
		return m.Amount()
	case commission.FieldStatus:
		return m.Status()
	case commission.FieldEmployeeID:
		return m.EmployeeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case commission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case commission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case commission.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case commission.FieldCreator:
		return m.OldCreator(ctx)
	case commission.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case commission.FieldRemark:
		return m.OldRemark(ctx)
	case commission.FieldOrderID:
		return m.OldOrderID(ctx)
	case commission.FieldAmount:
		return m.OldAmount(ctx)
	case commission.FieldStatus:
		return m.OldStatus(ctx)
	case commission.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	}
	return nil, fmt.Errorf("unknown Commission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case commission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case commission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case commission.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case commission.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case commission.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case commission.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case commission.FieldOrderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case commission.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case commission.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case commission.FieldEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	}
	return fmt.Errorf("unknown Commission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommissionMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, commission.FieldAmount)
	}
	if m.addstatus != nil {
		fields = append(fields, commission.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case commission.FieldAmount:
		return m.AddedAmount()
	case commission.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case commission.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case commission.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Commission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(commission.FieldDeletedAt) {
		fields = append(fields, commission.FieldDeletedAt)
	}
	if m.FieldCleared(commission.FieldCreator) {
		fields = append(fields, commission.FieldCreator)
	}
	if m.FieldCleared(commission.FieldLastModifier) {
		fields = append(fields, commission.FieldLastModifier)
	}
	if m.FieldCleared(commission.FieldRemark) {
		fields = append(fields, commission.FieldRemark)
	}
	if m.FieldCleared(commission.FieldEmployeeID) {
		fields = append(fields, commission.FieldEmployeeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommissionMutation) ClearField(name string) error {
	switch name {
	case commission.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case commission.FieldCreator:
		m.ClearCreator()
		return nil
	case commission.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case commission.FieldRemark:
		m.ClearRemark()
		return nil
	case commission.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	}
	return fmt.Errorf("unknown Commission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommissionMutation) ResetField(name string) error {
	switch name {
	case commission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case commission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case commission.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case commission.FieldCreator:
		m.ResetCreator()
		return nil
	case commission.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case commission.FieldRemark:
		m.ResetRemark()
		return nil
	case commission.FieldOrderID:
		m.ResetOrderID()
		return nil
	case commission.FieldAmount:
		m.ResetAmount()
		return nil
	case commission.FieldStatus:
		m.ResetStatus()
		return nil
	case commission.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	}
	return fmt.Errorf("unknown Commission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m._order != nil {
		edges = append(edges, commission.EdgeOrder)
	}
	if m.employee != nil {
		edges = append(edges, commission.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case commission.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	case commission.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleared_order {
		edges = append(edges, commission.EdgeOrder)
	}
	if m.clearedemployee {
		edges = append(edges, commission.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommissionMutation) EdgeCleared(name string) bool {
	switch name {
	case commission.EdgeOrder:
		return m.cleared_order
	case commission.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommissionMutation) ClearEdge(name string) error {
	switch name {
	case commission.EdgeOrder:
		m.ClearOrder()
		return nil
	case commission.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown Commission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommissionMutation) ResetEdge(name string) error {
	switch name {
	case commission.EdgeOrder:
		m.ResetOrder()
		return nil
	case commission.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Commission edge %s", name)
}

// ContractMutation represents an operation that mutates the Contract nodes in the graph.
type ContractMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	creator       **model.Modifier
	last_modifier **model.Modifier
	remark        *string
	status        *uint8
	addstatus     *int8
	flow_id       *string
	sn            *string
	files         *[]string
	effective     *bool
	clearedFields map[string]struct{}
	rider         *uint64
	clearedrider  bool
	done          bool
	oldValue      func(context.Context) (*Contract, error)
	predicates    []predicate.Contract
}

var _ ent.Mutation = (*ContractMutation)(nil)

// contractOption allows management of the mutation configuration using functional options.
type contractOption func(*ContractMutation)

// newContractMutation creates new mutation for the Contract entity.
func newContractMutation(c config, op Op, opts ...contractOption) *ContractMutation {
	m := &ContractMutation{
		config:        c,
		op:            op,
		typ:           TypeContract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContractID sets the ID field of the mutation.
func withContractID(id uint64) contractOption {
	return func(m *ContractMutation) {
		var (
			err   error
			once  sync.Once
			value *Contract
		)
		m.oldValue = func(ctx context.Context) (*Contract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContract sets the old Contract of the mutation.
func withContract(node *Contract) contractOption {
	return func(m *ContractMutation) {
		m.oldValue = func(context.Context) (*Contract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContractMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContractMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Contract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ContractMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContractMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContractMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ContractMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ContractMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ContractMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ContractMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ContractMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ContractMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[contract.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ContractMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[contract.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ContractMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, contract.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *ContractMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *ContractMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *ContractMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[contract.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *ContractMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[contract.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *ContractMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, contract.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *ContractMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *ContractMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *ContractMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[contract.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *ContractMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[contract.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *ContractMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, contract.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *ContractMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ContractMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ContractMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[contract.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ContractMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[contract.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ContractMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, contract.FieldRemark)
}

// SetStatus sets the "status" field.
func (m *ContractMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ContractMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *ContractMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ContractMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ContractMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetRiderID sets the "rider_id" field.
func (m *ContractMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *ContractMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *ContractMutation) ResetRiderID() {
	m.rider = nil
}

// SetFlowID sets the "flow_id" field.
func (m *ContractMutation) SetFlowID(s string) {
	m.flow_id = &s
}

// FlowID returns the value of the "flow_id" field in the mutation.
func (m *ContractMutation) FlowID() (r string, exists bool) {
	v := m.flow_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowID returns the old "flow_id" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldFlowID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowID: %w", err)
	}
	return oldValue.FlowID, nil
}

// ResetFlowID resets all changes to the "flow_id" field.
func (m *ContractMutation) ResetFlowID() {
	m.flow_id = nil
}

// SetSn sets the "sn" field.
func (m *ContractMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *ContractMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *ContractMutation) ResetSn() {
	m.sn = nil
}

// SetFiles sets the "files" field.
func (m *ContractMutation) SetFiles(s []string) {
	m.files = &s
}

// Files returns the value of the "files" field in the mutation.
func (m *ContractMutation) Files() (r []string, exists bool) {
	v := m.files
	if v == nil {
		return
	}
	return *v, true
}

// OldFiles returns the old "files" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldFiles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFiles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFiles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFiles: %w", err)
	}
	return oldValue.Files, nil
}

// ClearFiles clears the value of the "files" field.
func (m *ContractMutation) ClearFiles() {
	m.files = nil
	m.clearedFields[contract.FieldFiles] = struct{}{}
}

// FilesCleared returns if the "files" field was cleared in this mutation.
func (m *ContractMutation) FilesCleared() bool {
	_, ok := m.clearedFields[contract.FieldFiles]
	return ok
}

// ResetFiles resets all changes to the "files" field.
func (m *ContractMutation) ResetFiles() {
	m.files = nil
	delete(m.clearedFields, contract.FieldFiles)
}

// SetEffective sets the "effective" field.
func (m *ContractMutation) SetEffective(b bool) {
	m.effective = &b
}

// Effective returns the value of the "effective" field in the mutation.
func (m *ContractMutation) Effective() (r bool, exists bool) {
	v := m.effective
	if v == nil {
		return
	}
	return *v, true
}

// OldEffective returns the old "effective" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldEffective(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffective is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffective requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffective: %w", err)
	}
	return oldValue.Effective, nil
}

// ResetEffective resets all changes to the "effective" field.
func (m *ContractMutation) ResetEffective() {
	m.effective = nil
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *ContractMutation) ClearRider() {
	m.clearedrider = true
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *ContractMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *ContractMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *ContractMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// Where appends a list predicates to the ContractMutation builder.
func (m *ContractMutation) Where(ps ...predicate.Contract) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ContractMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Contract).
func (m *ContractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContractMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, contract.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, contract.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, contract.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, contract.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, contract.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, contract.FieldRemark)
	}
	if m.status != nil {
		fields = append(fields, contract.FieldStatus)
	}
	if m.rider != nil {
		fields = append(fields, contract.FieldRiderID)
	}
	if m.flow_id != nil {
		fields = append(fields, contract.FieldFlowID)
	}
	if m.sn != nil {
		fields = append(fields, contract.FieldSn)
	}
	if m.files != nil {
		fields = append(fields, contract.FieldFiles)
	}
	if m.effective != nil {
		fields = append(fields, contract.FieldEffective)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contract.FieldCreatedAt:
		return m.CreatedAt()
	case contract.FieldUpdatedAt:
		return m.UpdatedAt()
	case contract.FieldDeletedAt:
		return m.DeletedAt()
	case contract.FieldCreator:
		return m.Creator()
	case contract.FieldLastModifier:
		return m.LastModifier()
	case contract.FieldRemark:
		return m.Remark()
	case contract.FieldStatus:
		return m.Status()
	case contract.FieldRiderID:
		return m.RiderID()
	case contract.FieldFlowID:
		return m.FlowID()
	case contract.FieldSn:
		return m.Sn()
	case contract.FieldFiles:
		return m.Files()
	case contract.FieldEffective:
		return m.Effective()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contract.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case contract.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case contract.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case contract.FieldCreator:
		return m.OldCreator(ctx)
	case contract.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case contract.FieldRemark:
		return m.OldRemark(ctx)
	case contract.FieldStatus:
		return m.OldStatus(ctx)
	case contract.FieldRiderID:
		return m.OldRiderID(ctx)
	case contract.FieldFlowID:
		return m.OldFlowID(ctx)
	case contract.FieldSn:
		return m.OldSn(ctx)
	case contract.FieldFiles:
		return m.OldFiles(ctx)
	case contract.FieldEffective:
		return m.OldEffective(ctx)
	}
	return nil, fmt.Errorf("unknown Contract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contract.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case contract.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case contract.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case contract.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case contract.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case contract.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case contract.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case contract.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case contract.FieldFlowID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowID(v)
		return nil
	case contract.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case contract.FieldFiles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFiles(v)
		return nil
	case contract.FieldEffective:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffective(v)
		return nil
	}
	return fmt.Errorf("unknown Contract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContractMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, contract.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContractMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contract.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContractMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contract.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Contract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContractMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contract.FieldDeletedAt) {
		fields = append(fields, contract.FieldDeletedAt)
	}
	if m.FieldCleared(contract.FieldCreator) {
		fields = append(fields, contract.FieldCreator)
	}
	if m.FieldCleared(contract.FieldLastModifier) {
		fields = append(fields, contract.FieldLastModifier)
	}
	if m.FieldCleared(contract.FieldRemark) {
		fields = append(fields, contract.FieldRemark)
	}
	if m.FieldCleared(contract.FieldFiles) {
		fields = append(fields, contract.FieldFiles)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContractMutation) ClearField(name string) error {
	switch name {
	case contract.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case contract.FieldCreator:
		m.ClearCreator()
		return nil
	case contract.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case contract.FieldRemark:
		m.ClearRemark()
		return nil
	case contract.FieldFiles:
		m.ClearFiles()
		return nil
	}
	return fmt.Errorf("unknown Contract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContractMutation) ResetField(name string) error {
	switch name {
	case contract.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case contract.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case contract.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case contract.FieldCreator:
		m.ResetCreator()
		return nil
	case contract.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case contract.FieldRemark:
		m.ResetRemark()
		return nil
	case contract.FieldStatus:
		m.ResetStatus()
		return nil
	case contract.FieldRiderID:
		m.ResetRiderID()
		return nil
	case contract.FieldFlowID:
		m.ResetFlowID()
		return nil
	case contract.FieldSn:
		m.ResetSn()
		return nil
	case contract.FieldFiles:
		m.ResetFiles()
		return nil
	case contract.FieldEffective:
		m.ResetEffective()
		return nil
	}
	return fmt.Errorf("unknown Contract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContractMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.rider != nil {
		edges = append(edges, contract.EdgeRider)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContractMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contract.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContractMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrider {
		edges = append(edges, contract.EdgeRider)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContractMutation) EdgeCleared(name string) bool {
	switch name {
	case contract.EdgeRider:
		return m.clearedrider
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContractMutation) ClearEdge(name string) error {
	switch name {
	case contract.EdgeRider:
		m.ClearRider()
		return nil
	}
	return fmt.Errorf("unknown Contract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContractMutation) ResetEdge(name string) error {
	switch name {
	case contract.EdgeRider:
		m.ResetRider()
		return nil
	}
	return fmt.Errorf("unknown Contract edge %s", name)
}

// EmployeeMutation represents an operation that mutates the Employee nodes in the graph.
type EmployeeMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint64
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	creator            **model.Modifier
	last_modifier      **model.Modifier
	remark             *string
	sn                 *uuid.UUID
	name               *string
	phone              *string
	clearedFields      map[string]struct{}
	city               *uint64
	clearedcity        bool
	store              *uint64
	clearedstore       bool
	attendances        map[uint64]struct{}
	removedattendances map[uint64]struct{}
	clearedattendances bool
	stocks             map[uint64]struct{}
	removedstocks      map[uint64]struct{}
	clearedstocks      bool
	exchanges          map[uint64]struct{}
	removedexchanges   map[uint64]struct{}
	clearedexchanges   bool
	commissions        map[uint64]struct{}
	removedcommissions map[uint64]struct{}
	clearedcommissions bool
	done               bool
	oldValue           func(context.Context) (*Employee, error)
	predicates         []predicate.Employee
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows management of the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for the Employee entity.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the ID field of the mutation.
func withEmployeeID(id uint64) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeeMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeeMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Employee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EmployeeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmployeeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmployeeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmployeeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmployeeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmployeeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EmployeeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EmployeeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EmployeeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[employee.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EmployeeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[employee.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EmployeeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, employee.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *EmployeeMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *EmployeeMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *EmployeeMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[employee.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *EmployeeMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[employee.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *EmployeeMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, employee.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *EmployeeMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *EmployeeMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *EmployeeMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[employee.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *EmployeeMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[employee.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *EmployeeMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, employee.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *EmployeeMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *EmployeeMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *EmployeeMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[employee.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *EmployeeMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[employee.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *EmployeeMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, employee.FieldRemark)
}

// SetCityID sets the "city_id" field.
func (m *EmployeeMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *EmployeeMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *EmployeeMutation) ResetCityID() {
	m.city = nil
}

// SetSn sets the "sn" field.
func (m *EmployeeMutation) SetSn(u uuid.UUID) {
	m.sn = &u
}

// Sn returns the value of the "sn" field in the mutation.
func (m *EmployeeMutation) Sn() (r uuid.UUID, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldSn(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ClearSn clears the value of the "sn" field.
func (m *EmployeeMutation) ClearSn() {
	m.sn = nil
	m.clearedFields[employee.FieldSn] = struct{}{}
}

// SnCleared returns if the "sn" field was cleared in this mutation.
func (m *EmployeeMutation) SnCleared() bool {
	_, ok := m.clearedFields[employee.FieldSn]
	return ok
}

// ResetSn resets all changes to the "sn" field.
func (m *EmployeeMutation) ResetSn() {
	m.sn = nil
	delete(m.clearedFields, employee.FieldSn)
}

// SetName sets the "name" field.
func (m *EmployeeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EmployeeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EmployeeMutation) ResetName() {
	m.name = nil
}

// SetPhone sets the "phone" field.
func (m *EmployeeMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *EmployeeMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *EmployeeMutation) ResetPhone() {
	m.phone = nil
}

// ClearCity clears the "city" edge to the City entity.
func (m *EmployeeMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *EmployeeMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *EmployeeMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// SetStoreID sets the "store" edge to the Store entity by id.
func (m *EmployeeMutation) SetStoreID(id uint64) {
	m.store = &id
}

// ClearStore clears the "store" edge to the Store entity.
func (m *EmployeeMutation) ClearStore() {
	m.clearedstore = true
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *EmployeeMutation) StoreCleared() bool {
	return m.clearedstore
}

// StoreID returns the "store" edge ID in the mutation.
func (m *EmployeeMutation) StoreID() (id uint64, exists bool) {
	if m.store != nil {
		return *m.store, true
	}
	return
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) StoreIDs() (ids []uint64) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *EmployeeMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// AddAttendanceIDs adds the "attendances" edge to the Attendance entity by ids.
func (m *EmployeeMutation) AddAttendanceIDs(ids ...uint64) {
	if m.attendances == nil {
		m.attendances = make(map[uint64]struct{})
	}
	for i := range ids {
		m.attendances[ids[i]] = struct{}{}
	}
}

// ClearAttendances clears the "attendances" edge to the Attendance entity.
func (m *EmployeeMutation) ClearAttendances() {
	m.clearedattendances = true
}

// AttendancesCleared reports if the "attendances" edge to the Attendance entity was cleared.
func (m *EmployeeMutation) AttendancesCleared() bool {
	return m.clearedattendances
}

// RemoveAttendanceIDs removes the "attendances" edge to the Attendance entity by IDs.
func (m *EmployeeMutation) RemoveAttendanceIDs(ids ...uint64) {
	if m.removedattendances == nil {
		m.removedattendances = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.attendances, ids[i])
		m.removedattendances[ids[i]] = struct{}{}
	}
}

// RemovedAttendances returns the removed IDs of the "attendances" edge to the Attendance entity.
func (m *EmployeeMutation) RemovedAttendancesIDs() (ids []uint64) {
	for id := range m.removedattendances {
		ids = append(ids, id)
	}
	return
}

// AttendancesIDs returns the "attendances" edge IDs in the mutation.
func (m *EmployeeMutation) AttendancesIDs() (ids []uint64) {
	for id := range m.attendances {
		ids = append(ids, id)
	}
	return
}

// ResetAttendances resets all changes to the "attendances" edge.
func (m *EmployeeMutation) ResetAttendances() {
	m.attendances = nil
	m.clearedattendances = false
	m.removedattendances = nil
}

// AddStockIDs adds the "stocks" edge to the Stock entity by ids.
func (m *EmployeeMutation) AddStockIDs(ids ...uint64) {
	if m.stocks == nil {
		m.stocks = make(map[uint64]struct{})
	}
	for i := range ids {
		m.stocks[ids[i]] = struct{}{}
	}
}

// ClearStocks clears the "stocks" edge to the Stock entity.
func (m *EmployeeMutation) ClearStocks() {
	m.clearedstocks = true
}

// StocksCleared reports if the "stocks" edge to the Stock entity was cleared.
func (m *EmployeeMutation) StocksCleared() bool {
	return m.clearedstocks
}

// RemoveStockIDs removes the "stocks" edge to the Stock entity by IDs.
func (m *EmployeeMutation) RemoveStockIDs(ids ...uint64) {
	if m.removedstocks == nil {
		m.removedstocks = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.stocks, ids[i])
		m.removedstocks[ids[i]] = struct{}{}
	}
}

// RemovedStocks returns the removed IDs of the "stocks" edge to the Stock entity.
func (m *EmployeeMutation) RemovedStocksIDs() (ids []uint64) {
	for id := range m.removedstocks {
		ids = append(ids, id)
	}
	return
}

// StocksIDs returns the "stocks" edge IDs in the mutation.
func (m *EmployeeMutation) StocksIDs() (ids []uint64) {
	for id := range m.stocks {
		ids = append(ids, id)
	}
	return
}

// ResetStocks resets all changes to the "stocks" edge.
func (m *EmployeeMutation) ResetStocks() {
	m.stocks = nil
	m.clearedstocks = false
	m.removedstocks = nil
}

// AddExchangeIDs adds the "exchanges" edge to the Exchange entity by ids.
func (m *EmployeeMutation) AddExchangeIDs(ids ...uint64) {
	if m.exchanges == nil {
		m.exchanges = make(map[uint64]struct{})
	}
	for i := range ids {
		m.exchanges[ids[i]] = struct{}{}
	}
}

// ClearExchanges clears the "exchanges" edge to the Exchange entity.
func (m *EmployeeMutation) ClearExchanges() {
	m.clearedexchanges = true
}

// ExchangesCleared reports if the "exchanges" edge to the Exchange entity was cleared.
func (m *EmployeeMutation) ExchangesCleared() bool {
	return m.clearedexchanges
}

// RemoveExchangeIDs removes the "exchanges" edge to the Exchange entity by IDs.
func (m *EmployeeMutation) RemoveExchangeIDs(ids ...uint64) {
	if m.removedexchanges == nil {
		m.removedexchanges = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.exchanges, ids[i])
		m.removedexchanges[ids[i]] = struct{}{}
	}
}

// RemovedExchanges returns the removed IDs of the "exchanges" edge to the Exchange entity.
func (m *EmployeeMutation) RemovedExchangesIDs() (ids []uint64) {
	for id := range m.removedexchanges {
		ids = append(ids, id)
	}
	return
}

// ExchangesIDs returns the "exchanges" edge IDs in the mutation.
func (m *EmployeeMutation) ExchangesIDs() (ids []uint64) {
	for id := range m.exchanges {
		ids = append(ids, id)
	}
	return
}

// ResetExchanges resets all changes to the "exchanges" edge.
func (m *EmployeeMutation) ResetExchanges() {
	m.exchanges = nil
	m.clearedexchanges = false
	m.removedexchanges = nil
}

// AddCommissionIDs adds the "commissions" edge to the Commission entity by ids.
func (m *EmployeeMutation) AddCommissionIDs(ids ...uint64) {
	if m.commissions == nil {
		m.commissions = make(map[uint64]struct{})
	}
	for i := range ids {
		m.commissions[ids[i]] = struct{}{}
	}
}

// ClearCommissions clears the "commissions" edge to the Commission entity.
func (m *EmployeeMutation) ClearCommissions() {
	m.clearedcommissions = true
}

// CommissionsCleared reports if the "commissions" edge to the Commission entity was cleared.
func (m *EmployeeMutation) CommissionsCleared() bool {
	return m.clearedcommissions
}

// RemoveCommissionIDs removes the "commissions" edge to the Commission entity by IDs.
func (m *EmployeeMutation) RemoveCommissionIDs(ids ...uint64) {
	if m.removedcommissions == nil {
		m.removedcommissions = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.commissions, ids[i])
		m.removedcommissions[ids[i]] = struct{}{}
	}
}

// RemovedCommissions returns the removed IDs of the "commissions" edge to the Commission entity.
func (m *EmployeeMutation) RemovedCommissionsIDs() (ids []uint64) {
	for id := range m.removedcommissions {
		ids = append(ids, id)
	}
	return
}

// CommissionsIDs returns the "commissions" edge IDs in the mutation.
func (m *EmployeeMutation) CommissionsIDs() (ids []uint64) {
	for id := range m.commissions {
		ids = append(ids, id)
	}
	return
}

// ResetCommissions resets all changes to the "commissions" edge.
func (m *EmployeeMutation) ResetCommissions() {
	m.commissions = nil
	m.clearedcommissions = false
	m.removedcommissions = nil
}

// Where appends a list predicates to the EmployeeMutation builder.
func (m *EmployeeMutation) Where(ps ...predicate.Employee) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, employee.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, employee.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, employee.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, employee.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, employee.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, employee.FieldRemark)
	}
	if m.city != nil {
		fields = append(fields, employee.FieldCityID)
	}
	if m.sn != nil {
		fields = append(fields, employee.FieldSn)
	}
	if m.name != nil {
		fields = append(fields, employee.FieldName)
	}
	if m.phone != nil {
		fields = append(fields, employee.FieldPhone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldCreatedAt:
		return m.CreatedAt()
	case employee.FieldUpdatedAt:
		return m.UpdatedAt()
	case employee.FieldDeletedAt:
		return m.DeletedAt()
	case employee.FieldCreator:
		return m.Creator()
	case employee.FieldLastModifier:
		return m.LastModifier()
	case employee.FieldRemark:
		return m.Remark()
	case employee.FieldCityID:
		return m.CityID()
	case employee.FieldSn:
		return m.Sn()
	case employee.FieldName:
		return m.Name()
	case employee.FieldPhone:
		return m.Phone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case employee.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case employee.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case employee.FieldCreator:
		return m.OldCreator(ctx)
	case employee.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case employee.FieldRemark:
		return m.OldRemark(ctx)
	case employee.FieldCityID:
		return m.OldCityID(ctx)
	case employee.FieldSn:
		return m.OldSn(ctx)
	case employee.FieldName:
		return m.OldName(ctx)
	case employee.FieldPhone:
		return m.OldPhone(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case employee.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case employee.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case employee.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case employee.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case employee.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case employee.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case employee.FieldSn:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case employee.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case employee.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(employee.FieldDeletedAt) {
		fields = append(fields, employee.FieldDeletedAt)
	}
	if m.FieldCleared(employee.FieldCreator) {
		fields = append(fields, employee.FieldCreator)
	}
	if m.FieldCleared(employee.FieldLastModifier) {
		fields = append(fields, employee.FieldLastModifier)
	}
	if m.FieldCleared(employee.FieldRemark) {
		fields = append(fields, employee.FieldRemark)
	}
	if m.FieldCleared(employee.FieldSn) {
		fields = append(fields, employee.FieldSn)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	switch name {
	case employee.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case employee.FieldCreator:
		m.ClearCreator()
		return nil
	case employee.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case employee.FieldRemark:
		m.ClearRemark()
		return nil
	case employee.FieldSn:
		m.ClearSn()
		return nil
	}
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case employee.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case employee.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case employee.FieldCreator:
		m.ResetCreator()
		return nil
	case employee.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case employee.FieldRemark:
		m.ResetRemark()
		return nil
	case employee.FieldCityID:
		m.ResetCityID()
		return nil
	case employee.FieldSn:
		m.ResetSn()
		return nil
	case employee.FieldName:
		m.ResetName()
		return nil
	case employee.FieldPhone:
		m.ResetPhone()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.city != nil {
		edges = append(edges, employee.EdgeCity)
	}
	if m.store != nil {
		edges = append(edges, employee.EdgeStore)
	}
	if m.attendances != nil {
		edges = append(edges, employee.EdgeAttendances)
	}
	if m.stocks != nil {
		edges = append(edges, employee.EdgeStocks)
	}
	if m.exchanges != nil {
		edges = append(edges, employee.EdgeExchanges)
	}
	if m.commissions != nil {
		edges = append(edges, employee.EdgeCommissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeAttendances:
		ids := make([]ent.Value, 0, len(m.attendances))
		for id := range m.attendances {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.stocks))
		for id := range m.stocks {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeExchanges:
		ids := make([]ent.Value, 0, len(m.exchanges))
		for id := range m.exchanges {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeCommissions:
		ids := make([]ent.Value, 0, len(m.commissions))
		for id := range m.commissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedattendances != nil {
		edges = append(edges, employee.EdgeAttendances)
	}
	if m.removedstocks != nil {
		edges = append(edges, employee.EdgeStocks)
	}
	if m.removedexchanges != nil {
		edges = append(edges, employee.EdgeExchanges)
	}
	if m.removedcommissions != nil {
		edges = append(edges, employee.EdgeCommissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeAttendances:
		ids := make([]ent.Value, 0, len(m.removedattendances))
		for id := range m.removedattendances {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.removedstocks))
		for id := range m.removedstocks {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeExchanges:
		ids := make([]ent.Value, 0, len(m.removedexchanges))
		for id := range m.removedexchanges {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeCommissions:
		ids := make([]ent.Value, 0, len(m.removedcommissions))
		for id := range m.removedcommissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcity {
		edges = append(edges, employee.EdgeCity)
	}
	if m.clearedstore {
		edges = append(edges, employee.EdgeStore)
	}
	if m.clearedattendances {
		edges = append(edges, employee.EdgeAttendances)
	}
	if m.clearedstocks {
		edges = append(edges, employee.EdgeStocks)
	}
	if m.clearedexchanges {
		edges = append(edges, employee.EdgeExchanges)
	}
	if m.clearedcommissions {
		edges = append(edges, employee.EdgeCommissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	case employee.EdgeCity:
		return m.clearedcity
	case employee.EdgeStore:
		return m.clearedstore
	case employee.EdgeAttendances:
		return m.clearedattendances
	case employee.EdgeStocks:
		return m.clearedstocks
	case employee.EdgeExchanges:
		return m.clearedexchanges
	case employee.EdgeCommissions:
		return m.clearedcommissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	case employee.EdgeCity:
		m.ClearCity()
		return nil
	case employee.EdgeStore:
		m.ClearStore()
		return nil
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeCity:
		m.ResetCity()
		return nil
	case employee.EdgeStore:
		m.ResetStore()
		return nil
	case employee.EdgeAttendances:
		m.ResetAttendances()
		return nil
	case employee.EdgeStocks:
		m.ResetStocks()
		return nil
	case employee.EdgeExchanges:
		m.ResetExchanges()
		return nil
	case employee.EdgeCommissions:
		m.ResetCommissions()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// EnterpriseMutation represents an operation that mutates the Enterprise nodes in the graph.
type EnterpriseMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	name              *string
	status            *uint8
	addstatus         *int8
	contact_name      *string
	contact_phone     *string
	idcard_number     *string
	address           *string
	payment           *uint8
	addpayment        *int8
	deposit           *float64
	adddeposit        *float64
	balance           *float64
	addbalance        *float64
	suspensed_at      *time.Time
	clearedFields     map[string]struct{}
	city              *uint64
	clearedcity       bool
	riders            map[uint64]struct{}
	removedriders     map[uint64]struct{}
	clearedriders     bool
	contracts         map[uint64]struct{}
	removedcontracts  map[uint64]struct{}
	clearedcontracts  bool
	prices            map[uint64]struct{}
	removedprices     map[uint64]struct{}
	clearedprices     bool
	subscribes        map[uint64]struct{}
	removedsubscribes map[uint64]struct{}
	clearedsubscribes bool
	statements        map[uint64]struct{}
	removedstatements map[uint64]struct{}
	clearedstatements bool
	stations          map[uint64]struct{}
	removedstations   map[uint64]struct{}
	clearedstations   bool
	bills             map[uint64]struct{}
	removedbills      map[uint64]struct{}
	clearedbills      bool
	done              bool
	oldValue          func(context.Context) (*Enterprise, error)
	predicates        []predicate.Enterprise
}

var _ ent.Mutation = (*EnterpriseMutation)(nil)

// enterpriseOption allows management of the mutation configuration using functional options.
type enterpriseOption func(*EnterpriseMutation)

// newEnterpriseMutation creates new mutation for the Enterprise entity.
func newEnterpriseMutation(c config, op Op, opts ...enterpriseOption) *EnterpriseMutation {
	m := &EnterpriseMutation{
		config:        c,
		op:            op,
		typ:           TypeEnterprise,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnterpriseID sets the ID field of the mutation.
func withEnterpriseID(id uint64) enterpriseOption {
	return func(m *EnterpriseMutation) {
		var (
			err   error
			once  sync.Once
			value *Enterprise
		)
		m.oldValue = func(ctx context.Context) (*Enterprise, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Enterprise.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnterprise sets the old Enterprise of the mutation.
func withEnterprise(node *Enterprise) enterpriseOption {
	return func(m *EnterpriseMutation) {
		m.oldValue = func(context.Context) (*Enterprise, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnterpriseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnterpriseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnterpriseMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnterpriseMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Enterprise.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EnterpriseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnterpriseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnterpriseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnterpriseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnterpriseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnterpriseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EnterpriseMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EnterpriseMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EnterpriseMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[enterprise.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EnterpriseMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[enterprise.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EnterpriseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, enterprise.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *EnterpriseMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *EnterpriseMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *EnterpriseMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[enterprise.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *EnterpriseMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[enterprise.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *EnterpriseMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, enterprise.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *EnterpriseMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *EnterpriseMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *EnterpriseMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[enterprise.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *EnterpriseMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[enterprise.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *EnterpriseMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, enterprise.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *EnterpriseMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *EnterpriseMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *EnterpriseMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[enterprise.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *EnterpriseMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[enterprise.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *EnterpriseMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, enterprise.FieldRemark)
}

// SetCityID sets the "city_id" field.
func (m *EnterpriseMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *EnterpriseMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *EnterpriseMutation) ResetCityID() {
	m.city = nil
}

// SetName sets the "name" field.
func (m *EnterpriseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EnterpriseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EnterpriseMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *EnterpriseMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *EnterpriseMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *EnterpriseMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *EnterpriseMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *EnterpriseMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetContactName sets the "contact_name" field.
func (m *EnterpriseMutation) SetContactName(s string) {
	m.contact_name = &s
}

// ContactName returns the value of the "contact_name" field in the mutation.
func (m *EnterpriseMutation) ContactName() (r string, exists bool) {
	v := m.contact_name
	if v == nil {
		return
	}
	return *v, true
}

// OldContactName returns the old "contact_name" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldContactName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactName: %w", err)
	}
	return oldValue.ContactName, nil
}

// ResetContactName resets all changes to the "contact_name" field.
func (m *EnterpriseMutation) ResetContactName() {
	m.contact_name = nil
}

// SetContactPhone sets the "contact_phone" field.
func (m *EnterpriseMutation) SetContactPhone(s string) {
	m.contact_phone = &s
}

// ContactPhone returns the value of the "contact_phone" field in the mutation.
func (m *EnterpriseMutation) ContactPhone() (r string, exists bool) {
	v := m.contact_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPhone returns the old "contact_phone" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldContactPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPhone: %w", err)
	}
	return oldValue.ContactPhone, nil
}

// ResetContactPhone resets all changes to the "contact_phone" field.
func (m *EnterpriseMutation) ResetContactPhone() {
	m.contact_phone = nil
}

// SetIdcardNumber sets the "idcard_number" field.
func (m *EnterpriseMutation) SetIdcardNumber(s string) {
	m.idcard_number = &s
}

// IdcardNumber returns the value of the "idcard_number" field in the mutation.
func (m *EnterpriseMutation) IdcardNumber() (r string, exists bool) {
	v := m.idcard_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIdcardNumber returns the old "idcard_number" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldIdcardNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdcardNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdcardNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdcardNumber: %w", err)
	}
	return oldValue.IdcardNumber, nil
}

// ResetIdcardNumber resets all changes to the "idcard_number" field.
func (m *EnterpriseMutation) ResetIdcardNumber() {
	m.idcard_number = nil
}

// SetAddress sets the "address" field.
func (m *EnterpriseMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *EnterpriseMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *EnterpriseMutation) ResetAddress() {
	m.address = nil
}

// SetPayment sets the "payment" field.
func (m *EnterpriseMutation) SetPayment(u uint8) {
	m.payment = &u
	m.addpayment = nil
}

// Payment returns the value of the "payment" field in the mutation.
func (m *EnterpriseMutation) Payment() (r uint8, exists bool) {
	v := m.payment
	if v == nil {
		return
	}
	return *v, true
}

// OldPayment returns the old "payment" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldPayment(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayment: %w", err)
	}
	return oldValue.Payment, nil
}

// AddPayment adds u to the "payment" field.
func (m *EnterpriseMutation) AddPayment(u int8) {
	if m.addpayment != nil {
		*m.addpayment += u
	} else {
		m.addpayment = &u
	}
}

// AddedPayment returns the value that was added to the "payment" field in this mutation.
func (m *EnterpriseMutation) AddedPayment() (r int8, exists bool) {
	v := m.addpayment
	if v == nil {
		return
	}
	return *v, true
}

// ResetPayment resets all changes to the "payment" field.
func (m *EnterpriseMutation) ResetPayment() {
	m.payment = nil
	m.addpayment = nil
}

// SetDeposit sets the "deposit" field.
func (m *EnterpriseMutation) SetDeposit(f float64) {
	m.deposit = &f
	m.adddeposit = nil
}

// Deposit returns the value of the "deposit" field in the mutation.
func (m *EnterpriseMutation) Deposit() (r float64, exists bool) {
	v := m.deposit
	if v == nil {
		return
	}
	return *v, true
}

// OldDeposit returns the old "deposit" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldDeposit(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeposit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeposit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeposit: %w", err)
	}
	return oldValue.Deposit, nil
}

// AddDeposit adds f to the "deposit" field.
func (m *EnterpriseMutation) AddDeposit(f float64) {
	if m.adddeposit != nil {
		*m.adddeposit += f
	} else {
		m.adddeposit = &f
	}
}

// AddedDeposit returns the value that was added to the "deposit" field in this mutation.
func (m *EnterpriseMutation) AddedDeposit() (r float64, exists bool) {
	v := m.adddeposit
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeposit resets all changes to the "deposit" field.
func (m *EnterpriseMutation) ResetDeposit() {
	m.deposit = nil
	m.adddeposit = nil
}

// SetBalance sets the "balance" field.
func (m *EnterpriseMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *EnterpriseMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *EnterpriseMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *EnterpriseMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *EnterpriseMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetSuspensedAt sets the "suspensed_at" field.
func (m *EnterpriseMutation) SetSuspensedAt(t time.Time) {
	m.suspensed_at = &t
}

// SuspensedAt returns the value of the "suspensed_at" field in the mutation.
func (m *EnterpriseMutation) SuspensedAt() (r time.Time, exists bool) {
	v := m.suspensed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSuspensedAt returns the old "suspensed_at" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldSuspensedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuspensedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuspensedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuspensedAt: %w", err)
	}
	return oldValue.SuspensedAt, nil
}

// ClearSuspensedAt clears the value of the "suspensed_at" field.
func (m *EnterpriseMutation) ClearSuspensedAt() {
	m.suspensed_at = nil
	m.clearedFields[enterprise.FieldSuspensedAt] = struct{}{}
}

// SuspensedAtCleared returns if the "suspensed_at" field was cleared in this mutation.
func (m *EnterpriseMutation) SuspensedAtCleared() bool {
	_, ok := m.clearedFields[enterprise.FieldSuspensedAt]
	return ok
}

// ResetSuspensedAt resets all changes to the "suspensed_at" field.
func (m *EnterpriseMutation) ResetSuspensedAt() {
	m.suspensed_at = nil
	delete(m.clearedFields, enterprise.FieldSuspensedAt)
}

// ClearCity clears the "city" edge to the City entity.
func (m *EnterpriseMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *EnterpriseMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *EnterpriseMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *EnterpriseMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// AddRiderIDs adds the "riders" edge to the Rider entity by ids.
func (m *EnterpriseMutation) AddRiderIDs(ids ...uint64) {
	if m.riders == nil {
		m.riders = make(map[uint64]struct{})
	}
	for i := range ids {
		m.riders[ids[i]] = struct{}{}
	}
}

// ClearRiders clears the "riders" edge to the Rider entity.
func (m *EnterpriseMutation) ClearRiders() {
	m.clearedriders = true
}

// RidersCleared reports if the "riders" edge to the Rider entity was cleared.
func (m *EnterpriseMutation) RidersCleared() bool {
	return m.clearedriders
}

// RemoveRiderIDs removes the "riders" edge to the Rider entity by IDs.
func (m *EnterpriseMutation) RemoveRiderIDs(ids ...uint64) {
	if m.removedriders == nil {
		m.removedriders = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.riders, ids[i])
		m.removedriders[ids[i]] = struct{}{}
	}
}

// RemovedRiders returns the removed IDs of the "riders" edge to the Rider entity.
func (m *EnterpriseMutation) RemovedRidersIDs() (ids []uint64) {
	for id := range m.removedriders {
		ids = append(ids, id)
	}
	return
}

// RidersIDs returns the "riders" edge IDs in the mutation.
func (m *EnterpriseMutation) RidersIDs() (ids []uint64) {
	for id := range m.riders {
		ids = append(ids, id)
	}
	return
}

// ResetRiders resets all changes to the "riders" edge.
func (m *EnterpriseMutation) ResetRiders() {
	m.riders = nil
	m.clearedriders = false
	m.removedriders = nil
}

// AddContractIDs adds the "contracts" edge to the EnterpriseContract entity by ids.
func (m *EnterpriseMutation) AddContractIDs(ids ...uint64) {
	if m.contracts == nil {
		m.contracts = make(map[uint64]struct{})
	}
	for i := range ids {
		m.contracts[ids[i]] = struct{}{}
	}
}

// ClearContracts clears the "contracts" edge to the EnterpriseContract entity.
func (m *EnterpriseMutation) ClearContracts() {
	m.clearedcontracts = true
}

// ContractsCleared reports if the "contracts" edge to the EnterpriseContract entity was cleared.
func (m *EnterpriseMutation) ContractsCleared() bool {
	return m.clearedcontracts
}

// RemoveContractIDs removes the "contracts" edge to the EnterpriseContract entity by IDs.
func (m *EnterpriseMutation) RemoveContractIDs(ids ...uint64) {
	if m.removedcontracts == nil {
		m.removedcontracts = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.contracts, ids[i])
		m.removedcontracts[ids[i]] = struct{}{}
	}
}

// RemovedContracts returns the removed IDs of the "contracts" edge to the EnterpriseContract entity.
func (m *EnterpriseMutation) RemovedContractsIDs() (ids []uint64) {
	for id := range m.removedcontracts {
		ids = append(ids, id)
	}
	return
}

// ContractsIDs returns the "contracts" edge IDs in the mutation.
func (m *EnterpriseMutation) ContractsIDs() (ids []uint64) {
	for id := range m.contracts {
		ids = append(ids, id)
	}
	return
}

// ResetContracts resets all changes to the "contracts" edge.
func (m *EnterpriseMutation) ResetContracts() {
	m.contracts = nil
	m.clearedcontracts = false
	m.removedcontracts = nil
}

// AddPriceIDs adds the "prices" edge to the EnterprisePrice entity by ids.
func (m *EnterpriseMutation) AddPriceIDs(ids ...uint64) {
	if m.prices == nil {
		m.prices = make(map[uint64]struct{})
	}
	for i := range ids {
		m.prices[ids[i]] = struct{}{}
	}
}

// ClearPrices clears the "prices" edge to the EnterprisePrice entity.
func (m *EnterpriseMutation) ClearPrices() {
	m.clearedprices = true
}

// PricesCleared reports if the "prices" edge to the EnterprisePrice entity was cleared.
func (m *EnterpriseMutation) PricesCleared() bool {
	return m.clearedprices
}

// RemovePriceIDs removes the "prices" edge to the EnterprisePrice entity by IDs.
func (m *EnterpriseMutation) RemovePriceIDs(ids ...uint64) {
	if m.removedprices == nil {
		m.removedprices = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.prices, ids[i])
		m.removedprices[ids[i]] = struct{}{}
	}
}

// RemovedPrices returns the removed IDs of the "prices" edge to the EnterprisePrice entity.
func (m *EnterpriseMutation) RemovedPricesIDs() (ids []uint64) {
	for id := range m.removedprices {
		ids = append(ids, id)
	}
	return
}

// PricesIDs returns the "prices" edge IDs in the mutation.
func (m *EnterpriseMutation) PricesIDs() (ids []uint64) {
	for id := range m.prices {
		ids = append(ids, id)
	}
	return
}

// ResetPrices resets all changes to the "prices" edge.
func (m *EnterpriseMutation) ResetPrices() {
	m.prices = nil
	m.clearedprices = false
	m.removedprices = nil
}

// AddSubscribeIDs adds the "subscribes" edge to the Subscribe entity by ids.
func (m *EnterpriseMutation) AddSubscribeIDs(ids ...uint64) {
	if m.subscribes == nil {
		m.subscribes = make(map[uint64]struct{})
	}
	for i := range ids {
		m.subscribes[ids[i]] = struct{}{}
	}
}

// ClearSubscribes clears the "subscribes" edge to the Subscribe entity.
func (m *EnterpriseMutation) ClearSubscribes() {
	m.clearedsubscribes = true
}

// SubscribesCleared reports if the "subscribes" edge to the Subscribe entity was cleared.
func (m *EnterpriseMutation) SubscribesCleared() bool {
	return m.clearedsubscribes
}

// RemoveSubscribeIDs removes the "subscribes" edge to the Subscribe entity by IDs.
func (m *EnterpriseMutation) RemoveSubscribeIDs(ids ...uint64) {
	if m.removedsubscribes == nil {
		m.removedsubscribes = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.subscribes, ids[i])
		m.removedsubscribes[ids[i]] = struct{}{}
	}
}

// RemovedSubscribes returns the removed IDs of the "subscribes" edge to the Subscribe entity.
func (m *EnterpriseMutation) RemovedSubscribesIDs() (ids []uint64) {
	for id := range m.removedsubscribes {
		ids = append(ids, id)
	}
	return
}

// SubscribesIDs returns the "subscribes" edge IDs in the mutation.
func (m *EnterpriseMutation) SubscribesIDs() (ids []uint64) {
	for id := range m.subscribes {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribes resets all changes to the "subscribes" edge.
func (m *EnterpriseMutation) ResetSubscribes() {
	m.subscribes = nil
	m.clearedsubscribes = false
	m.removedsubscribes = nil
}

// AddStatementIDs adds the "statements" edge to the EnterpriseStatement entity by ids.
func (m *EnterpriseMutation) AddStatementIDs(ids ...uint64) {
	if m.statements == nil {
		m.statements = make(map[uint64]struct{})
	}
	for i := range ids {
		m.statements[ids[i]] = struct{}{}
	}
}

// ClearStatements clears the "statements" edge to the EnterpriseStatement entity.
func (m *EnterpriseMutation) ClearStatements() {
	m.clearedstatements = true
}

// StatementsCleared reports if the "statements" edge to the EnterpriseStatement entity was cleared.
func (m *EnterpriseMutation) StatementsCleared() bool {
	return m.clearedstatements
}

// RemoveStatementIDs removes the "statements" edge to the EnterpriseStatement entity by IDs.
func (m *EnterpriseMutation) RemoveStatementIDs(ids ...uint64) {
	if m.removedstatements == nil {
		m.removedstatements = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.statements, ids[i])
		m.removedstatements[ids[i]] = struct{}{}
	}
}

// RemovedStatements returns the removed IDs of the "statements" edge to the EnterpriseStatement entity.
func (m *EnterpriseMutation) RemovedStatementsIDs() (ids []uint64) {
	for id := range m.removedstatements {
		ids = append(ids, id)
	}
	return
}

// StatementsIDs returns the "statements" edge IDs in the mutation.
func (m *EnterpriseMutation) StatementsIDs() (ids []uint64) {
	for id := range m.statements {
		ids = append(ids, id)
	}
	return
}

// ResetStatements resets all changes to the "statements" edge.
func (m *EnterpriseMutation) ResetStatements() {
	m.statements = nil
	m.clearedstatements = false
	m.removedstatements = nil
}

// AddStationIDs adds the "stations" edge to the EnterpriseStation entity by ids.
func (m *EnterpriseMutation) AddStationIDs(ids ...uint64) {
	if m.stations == nil {
		m.stations = make(map[uint64]struct{})
	}
	for i := range ids {
		m.stations[ids[i]] = struct{}{}
	}
}

// ClearStations clears the "stations" edge to the EnterpriseStation entity.
func (m *EnterpriseMutation) ClearStations() {
	m.clearedstations = true
}

// StationsCleared reports if the "stations" edge to the EnterpriseStation entity was cleared.
func (m *EnterpriseMutation) StationsCleared() bool {
	return m.clearedstations
}

// RemoveStationIDs removes the "stations" edge to the EnterpriseStation entity by IDs.
func (m *EnterpriseMutation) RemoveStationIDs(ids ...uint64) {
	if m.removedstations == nil {
		m.removedstations = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.stations, ids[i])
		m.removedstations[ids[i]] = struct{}{}
	}
}

// RemovedStations returns the removed IDs of the "stations" edge to the EnterpriseStation entity.
func (m *EnterpriseMutation) RemovedStationsIDs() (ids []uint64) {
	for id := range m.removedstations {
		ids = append(ids, id)
	}
	return
}

// StationsIDs returns the "stations" edge IDs in the mutation.
func (m *EnterpriseMutation) StationsIDs() (ids []uint64) {
	for id := range m.stations {
		ids = append(ids, id)
	}
	return
}

// ResetStations resets all changes to the "stations" edge.
func (m *EnterpriseMutation) ResetStations() {
	m.stations = nil
	m.clearedstations = false
	m.removedstations = nil
}

// AddBillIDs adds the "bills" edge to the EnterpriseBill entity by ids.
func (m *EnterpriseMutation) AddBillIDs(ids ...uint64) {
	if m.bills == nil {
		m.bills = make(map[uint64]struct{})
	}
	for i := range ids {
		m.bills[ids[i]] = struct{}{}
	}
}

// ClearBills clears the "bills" edge to the EnterpriseBill entity.
func (m *EnterpriseMutation) ClearBills() {
	m.clearedbills = true
}

// BillsCleared reports if the "bills" edge to the EnterpriseBill entity was cleared.
func (m *EnterpriseMutation) BillsCleared() bool {
	return m.clearedbills
}

// RemoveBillIDs removes the "bills" edge to the EnterpriseBill entity by IDs.
func (m *EnterpriseMutation) RemoveBillIDs(ids ...uint64) {
	if m.removedbills == nil {
		m.removedbills = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.bills, ids[i])
		m.removedbills[ids[i]] = struct{}{}
	}
}

// RemovedBills returns the removed IDs of the "bills" edge to the EnterpriseBill entity.
func (m *EnterpriseMutation) RemovedBillsIDs() (ids []uint64) {
	for id := range m.removedbills {
		ids = append(ids, id)
	}
	return
}

// BillsIDs returns the "bills" edge IDs in the mutation.
func (m *EnterpriseMutation) BillsIDs() (ids []uint64) {
	for id := range m.bills {
		ids = append(ids, id)
	}
	return
}

// ResetBills resets all changes to the "bills" edge.
func (m *EnterpriseMutation) ResetBills() {
	m.bills = nil
	m.clearedbills = false
	m.removedbills = nil
}

// Where appends a list predicates to the EnterpriseMutation builder.
func (m *EnterpriseMutation) Where(ps ...predicate.Enterprise) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EnterpriseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Enterprise).
func (m *EnterpriseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnterpriseMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, enterprise.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enterprise.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, enterprise.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, enterprise.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, enterprise.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, enterprise.FieldRemark)
	}
	if m.city != nil {
		fields = append(fields, enterprise.FieldCityID)
	}
	if m.name != nil {
		fields = append(fields, enterprise.FieldName)
	}
	if m.status != nil {
		fields = append(fields, enterprise.FieldStatus)
	}
	if m.contact_name != nil {
		fields = append(fields, enterprise.FieldContactName)
	}
	if m.contact_phone != nil {
		fields = append(fields, enterprise.FieldContactPhone)
	}
	if m.idcard_number != nil {
		fields = append(fields, enterprise.FieldIdcardNumber)
	}
	if m.address != nil {
		fields = append(fields, enterprise.FieldAddress)
	}
	if m.payment != nil {
		fields = append(fields, enterprise.FieldPayment)
	}
	if m.deposit != nil {
		fields = append(fields, enterprise.FieldDeposit)
	}
	if m.balance != nil {
		fields = append(fields, enterprise.FieldBalance)
	}
	if m.suspensed_at != nil {
		fields = append(fields, enterprise.FieldSuspensedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnterpriseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enterprise.FieldCreatedAt:
		return m.CreatedAt()
	case enterprise.FieldUpdatedAt:
		return m.UpdatedAt()
	case enterprise.FieldDeletedAt:
		return m.DeletedAt()
	case enterprise.FieldCreator:
		return m.Creator()
	case enterprise.FieldLastModifier:
		return m.LastModifier()
	case enterprise.FieldRemark:
		return m.Remark()
	case enterprise.FieldCityID:
		return m.CityID()
	case enterprise.FieldName:
		return m.Name()
	case enterprise.FieldStatus:
		return m.Status()
	case enterprise.FieldContactName:
		return m.ContactName()
	case enterprise.FieldContactPhone:
		return m.ContactPhone()
	case enterprise.FieldIdcardNumber:
		return m.IdcardNumber()
	case enterprise.FieldAddress:
		return m.Address()
	case enterprise.FieldPayment:
		return m.Payment()
	case enterprise.FieldDeposit:
		return m.Deposit()
	case enterprise.FieldBalance:
		return m.Balance()
	case enterprise.FieldSuspensedAt:
		return m.SuspensedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnterpriseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enterprise.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enterprise.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case enterprise.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case enterprise.FieldCreator:
		return m.OldCreator(ctx)
	case enterprise.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case enterprise.FieldRemark:
		return m.OldRemark(ctx)
	case enterprise.FieldCityID:
		return m.OldCityID(ctx)
	case enterprise.FieldName:
		return m.OldName(ctx)
	case enterprise.FieldStatus:
		return m.OldStatus(ctx)
	case enterprise.FieldContactName:
		return m.OldContactName(ctx)
	case enterprise.FieldContactPhone:
		return m.OldContactPhone(ctx)
	case enterprise.FieldIdcardNumber:
		return m.OldIdcardNumber(ctx)
	case enterprise.FieldAddress:
		return m.OldAddress(ctx)
	case enterprise.FieldPayment:
		return m.OldPayment(ctx)
	case enterprise.FieldDeposit:
		return m.OldDeposit(ctx)
	case enterprise.FieldBalance:
		return m.OldBalance(ctx)
	case enterprise.FieldSuspensedAt:
		return m.OldSuspensedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Enterprise field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enterprise.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enterprise.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case enterprise.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case enterprise.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case enterprise.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case enterprise.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case enterprise.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case enterprise.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case enterprise.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case enterprise.FieldContactName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactName(v)
		return nil
	case enterprise.FieldContactPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPhone(v)
		return nil
	case enterprise.FieldIdcardNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdcardNumber(v)
		return nil
	case enterprise.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case enterprise.FieldPayment:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayment(v)
		return nil
	case enterprise.FieldDeposit:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeposit(v)
		return nil
	case enterprise.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case enterprise.FieldSuspensedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuspensedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Enterprise field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnterpriseMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, enterprise.FieldStatus)
	}
	if m.addpayment != nil {
		fields = append(fields, enterprise.FieldPayment)
	}
	if m.adddeposit != nil {
		fields = append(fields, enterprise.FieldDeposit)
	}
	if m.addbalance != nil {
		fields = append(fields, enterprise.FieldBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnterpriseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case enterprise.FieldStatus:
		return m.AddedStatus()
	case enterprise.FieldPayment:
		return m.AddedPayment()
	case enterprise.FieldDeposit:
		return m.AddedDeposit()
	case enterprise.FieldBalance:
		return m.AddedBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case enterprise.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case enterprise.FieldPayment:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayment(v)
		return nil
	case enterprise.FieldDeposit:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeposit(v)
		return nil
	case enterprise.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	}
	return fmt.Errorf("unknown Enterprise numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnterpriseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(enterprise.FieldDeletedAt) {
		fields = append(fields, enterprise.FieldDeletedAt)
	}
	if m.FieldCleared(enterprise.FieldCreator) {
		fields = append(fields, enterprise.FieldCreator)
	}
	if m.FieldCleared(enterprise.FieldLastModifier) {
		fields = append(fields, enterprise.FieldLastModifier)
	}
	if m.FieldCleared(enterprise.FieldRemark) {
		fields = append(fields, enterprise.FieldRemark)
	}
	if m.FieldCleared(enterprise.FieldSuspensedAt) {
		fields = append(fields, enterprise.FieldSuspensedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnterpriseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnterpriseMutation) ClearField(name string) error {
	switch name {
	case enterprise.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case enterprise.FieldCreator:
		m.ClearCreator()
		return nil
	case enterprise.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case enterprise.FieldRemark:
		m.ClearRemark()
		return nil
	case enterprise.FieldSuspensedAt:
		m.ClearSuspensedAt()
		return nil
	}
	return fmt.Errorf("unknown Enterprise nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnterpriseMutation) ResetField(name string) error {
	switch name {
	case enterprise.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enterprise.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case enterprise.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case enterprise.FieldCreator:
		m.ResetCreator()
		return nil
	case enterprise.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case enterprise.FieldRemark:
		m.ResetRemark()
		return nil
	case enterprise.FieldCityID:
		m.ResetCityID()
		return nil
	case enterprise.FieldName:
		m.ResetName()
		return nil
	case enterprise.FieldStatus:
		m.ResetStatus()
		return nil
	case enterprise.FieldContactName:
		m.ResetContactName()
		return nil
	case enterprise.FieldContactPhone:
		m.ResetContactPhone()
		return nil
	case enterprise.FieldIdcardNumber:
		m.ResetIdcardNumber()
		return nil
	case enterprise.FieldAddress:
		m.ResetAddress()
		return nil
	case enterprise.FieldPayment:
		m.ResetPayment()
		return nil
	case enterprise.FieldDeposit:
		m.ResetDeposit()
		return nil
	case enterprise.FieldBalance:
		m.ResetBalance()
		return nil
	case enterprise.FieldSuspensedAt:
		m.ResetSuspensedAt()
		return nil
	}
	return fmt.Errorf("unknown Enterprise field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnterpriseMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.city != nil {
		edges = append(edges, enterprise.EdgeCity)
	}
	if m.riders != nil {
		edges = append(edges, enterprise.EdgeRiders)
	}
	if m.contracts != nil {
		edges = append(edges, enterprise.EdgeContracts)
	}
	if m.prices != nil {
		edges = append(edges, enterprise.EdgePrices)
	}
	if m.subscribes != nil {
		edges = append(edges, enterprise.EdgeSubscribes)
	}
	if m.statements != nil {
		edges = append(edges, enterprise.EdgeStatements)
	}
	if m.stations != nil {
		edges = append(edges, enterprise.EdgeStations)
	}
	if m.bills != nil {
		edges = append(edges, enterprise.EdgeBills)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnterpriseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enterprise.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case enterprise.EdgeRiders:
		ids := make([]ent.Value, 0, len(m.riders))
		for id := range m.riders {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeContracts:
		ids := make([]ent.Value, 0, len(m.contracts))
		for id := range m.contracts {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgePrices:
		ids := make([]ent.Value, 0, len(m.prices))
		for id := range m.prices {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeSubscribes:
		ids := make([]ent.Value, 0, len(m.subscribes))
		for id := range m.subscribes {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeStatements:
		ids := make([]ent.Value, 0, len(m.statements))
		for id := range m.statements {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeStations:
		ids := make([]ent.Value, 0, len(m.stations))
		for id := range m.stations {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeBills:
		ids := make([]ent.Value, 0, len(m.bills))
		for id := range m.bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnterpriseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedriders != nil {
		edges = append(edges, enterprise.EdgeRiders)
	}
	if m.removedcontracts != nil {
		edges = append(edges, enterprise.EdgeContracts)
	}
	if m.removedprices != nil {
		edges = append(edges, enterprise.EdgePrices)
	}
	if m.removedsubscribes != nil {
		edges = append(edges, enterprise.EdgeSubscribes)
	}
	if m.removedstatements != nil {
		edges = append(edges, enterprise.EdgeStatements)
	}
	if m.removedstations != nil {
		edges = append(edges, enterprise.EdgeStations)
	}
	if m.removedbills != nil {
		edges = append(edges, enterprise.EdgeBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnterpriseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case enterprise.EdgeRiders:
		ids := make([]ent.Value, 0, len(m.removedriders))
		for id := range m.removedriders {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeContracts:
		ids := make([]ent.Value, 0, len(m.removedcontracts))
		for id := range m.removedcontracts {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgePrices:
		ids := make([]ent.Value, 0, len(m.removedprices))
		for id := range m.removedprices {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeSubscribes:
		ids := make([]ent.Value, 0, len(m.removedsubscribes))
		for id := range m.removedsubscribes {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeStatements:
		ids := make([]ent.Value, 0, len(m.removedstatements))
		for id := range m.removedstatements {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeStations:
		ids := make([]ent.Value, 0, len(m.removedstations))
		for id := range m.removedstations {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeBills:
		ids := make([]ent.Value, 0, len(m.removedbills))
		for id := range m.removedbills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnterpriseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedcity {
		edges = append(edges, enterprise.EdgeCity)
	}
	if m.clearedriders {
		edges = append(edges, enterprise.EdgeRiders)
	}
	if m.clearedcontracts {
		edges = append(edges, enterprise.EdgeContracts)
	}
	if m.clearedprices {
		edges = append(edges, enterprise.EdgePrices)
	}
	if m.clearedsubscribes {
		edges = append(edges, enterprise.EdgeSubscribes)
	}
	if m.clearedstatements {
		edges = append(edges, enterprise.EdgeStatements)
	}
	if m.clearedstations {
		edges = append(edges, enterprise.EdgeStations)
	}
	if m.clearedbills {
		edges = append(edges, enterprise.EdgeBills)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnterpriseMutation) EdgeCleared(name string) bool {
	switch name {
	case enterprise.EdgeCity:
		return m.clearedcity
	case enterprise.EdgeRiders:
		return m.clearedriders
	case enterprise.EdgeContracts:
		return m.clearedcontracts
	case enterprise.EdgePrices:
		return m.clearedprices
	case enterprise.EdgeSubscribes:
		return m.clearedsubscribes
	case enterprise.EdgeStatements:
		return m.clearedstatements
	case enterprise.EdgeStations:
		return m.clearedstations
	case enterprise.EdgeBills:
		return m.clearedbills
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnterpriseMutation) ClearEdge(name string) error {
	switch name {
	case enterprise.EdgeCity:
		m.ClearCity()
		return nil
	}
	return fmt.Errorf("unknown Enterprise unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnterpriseMutation) ResetEdge(name string) error {
	switch name {
	case enterprise.EdgeCity:
		m.ResetCity()
		return nil
	case enterprise.EdgeRiders:
		m.ResetRiders()
		return nil
	case enterprise.EdgeContracts:
		m.ResetContracts()
		return nil
	case enterprise.EdgePrices:
		m.ResetPrices()
		return nil
	case enterprise.EdgeSubscribes:
		m.ResetSubscribes()
		return nil
	case enterprise.EdgeStatements:
		m.ResetStatements()
		return nil
	case enterprise.EdgeStations:
		m.ResetStations()
		return nil
	case enterprise.EdgeBills:
		m.ResetBills()
		return nil
	}
	return fmt.Errorf("unknown Enterprise edge %s", name)
}

// EnterpriseBillMutation represents an operation that mutates the EnterpriseBill nodes in the graph.
type EnterpriseBillMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	start             *time.Time
	end               *time.Time
	days              *int
	adddays           *int
	price             *float64
	addprice          *float64
	cost              *float64
	addcost           *float64
	voltage           *float64
	addvoltage        *float64
	clearedFields     map[string]struct{}
	rider             *uint64
	clearedrider      bool
	subscribe         *uint64
	clearedsubscribe  bool
	city              *uint64
	clearedcity       bool
	enterprise        *uint64
	clearedenterprise bool
	statement         *uint64
	clearedstatement  bool
	done              bool
	oldValue          func(context.Context) (*EnterpriseBill, error)
	predicates        []predicate.EnterpriseBill
}

var _ ent.Mutation = (*EnterpriseBillMutation)(nil)

// enterprisebillOption allows management of the mutation configuration using functional options.
type enterprisebillOption func(*EnterpriseBillMutation)

// newEnterpriseBillMutation creates new mutation for the EnterpriseBill entity.
func newEnterpriseBillMutation(c config, op Op, opts ...enterprisebillOption) *EnterpriseBillMutation {
	m := &EnterpriseBillMutation{
		config:        c,
		op:            op,
		typ:           TypeEnterpriseBill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnterpriseBillID sets the ID field of the mutation.
func withEnterpriseBillID(id uint64) enterprisebillOption {
	return func(m *EnterpriseBillMutation) {
		var (
			err   error
			once  sync.Once
			value *EnterpriseBill
		)
		m.oldValue = func(ctx context.Context) (*EnterpriseBill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnterpriseBill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnterpriseBill sets the old EnterpriseBill of the mutation.
func withEnterpriseBill(node *EnterpriseBill) enterprisebillOption {
	return func(m *EnterpriseBillMutation) {
		m.oldValue = func(context.Context) (*EnterpriseBill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnterpriseBillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnterpriseBillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnterpriseBillMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnterpriseBillMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnterpriseBill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EnterpriseBillMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnterpriseBillMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnterpriseBillMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnterpriseBillMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnterpriseBillMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnterpriseBillMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EnterpriseBillMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EnterpriseBillMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EnterpriseBillMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[enterprisebill.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EnterpriseBillMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[enterprisebill.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EnterpriseBillMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, enterprisebill.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *EnterpriseBillMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *EnterpriseBillMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *EnterpriseBillMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[enterprisebill.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *EnterpriseBillMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[enterprisebill.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *EnterpriseBillMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, enterprisebill.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *EnterpriseBillMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *EnterpriseBillMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *EnterpriseBillMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[enterprisebill.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *EnterpriseBillMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[enterprisebill.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *EnterpriseBillMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, enterprisebill.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *EnterpriseBillMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *EnterpriseBillMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *EnterpriseBillMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[enterprisebill.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *EnterpriseBillMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[enterprisebill.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *EnterpriseBillMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, enterprisebill.FieldRemark)
}

// SetRiderID sets the "rider_id" field.
func (m *EnterpriseBillMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *EnterpriseBillMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *EnterpriseBillMutation) ResetRiderID() {
	m.rider = nil
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *EnterpriseBillMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *EnterpriseBillMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldSubscribeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *EnterpriseBillMutation) ResetSubscribeID() {
	m.subscribe = nil
}

// SetCityID sets the "city_id" field.
func (m *EnterpriseBillMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *EnterpriseBillMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *EnterpriseBillMutation) ResetCityID() {
	m.city = nil
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *EnterpriseBillMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *EnterpriseBillMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldEnterpriseID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *EnterpriseBillMutation) ResetEnterpriseID() {
	m.enterprise = nil
}

// SetStatementID sets the "statement_id" field.
func (m *EnterpriseBillMutation) SetStatementID(u uint64) {
	m.statement = &u
}

// StatementID returns the value of the "statement_id" field in the mutation.
func (m *EnterpriseBillMutation) StatementID() (r uint64, exists bool) {
	v := m.statement
	if v == nil {
		return
	}
	return *v, true
}

// OldStatementID returns the old "statement_id" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldStatementID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatementID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatementID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatementID: %w", err)
	}
	return oldValue.StatementID, nil
}

// ResetStatementID resets all changes to the "statement_id" field.
func (m *EnterpriseBillMutation) ResetStatementID() {
	m.statement = nil
}

// SetStart sets the "start" field.
func (m *EnterpriseBillMutation) SetStart(t time.Time) {
	m.start = &t
}

// Start returns the value of the "start" field in the mutation.
func (m *EnterpriseBillMutation) Start() (r time.Time, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// ResetStart resets all changes to the "start" field.
func (m *EnterpriseBillMutation) ResetStart() {
	m.start = nil
}

// SetEnd sets the "end" field.
func (m *EnterpriseBillMutation) SetEnd(t time.Time) {
	m.end = &t
}

// End returns the value of the "end" field in the mutation.
func (m *EnterpriseBillMutation) End() (r time.Time, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// ResetEnd resets all changes to the "end" field.
func (m *EnterpriseBillMutation) ResetEnd() {
	m.end = nil
}

// SetDays sets the "days" field.
func (m *EnterpriseBillMutation) SetDays(i int) {
	m.days = &i
	m.adddays = nil
}

// Days returns the value of the "days" field in the mutation.
func (m *EnterpriseBillMutation) Days() (r int, exists bool) {
	v := m.days
	if v == nil {
		return
	}
	return *v, true
}

// OldDays returns the old "days" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDays: %w", err)
	}
	return oldValue.Days, nil
}

// AddDays adds i to the "days" field.
func (m *EnterpriseBillMutation) AddDays(i int) {
	if m.adddays != nil {
		*m.adddays += i
	} else {
		m.adddays = &i
	}
}

// AddedDays returns the value that was added to the "days" field in this mutation.
func (m *EnterpriseBillMutation) AddedDays() (r int, exists bool) {
	v := m.adddays
	if v == nil {
		return
	}
	return *v, true
}

// ResetDays resets all changes to the "days" field.
func (m *EnterpriseBillMutation) ResetDays() {
	m.days = nil
	m.adddays = nil
}

// SetPrice sets the "price" field.
func (m *EnterpriseBillMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *EnterpriseBillMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *EnterpriseBillMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *EnterpriseBillMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *EnterpriseBillMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetCost sets the "cost" field.
func (m *EnterpriseBillMutation) SetCost(f float64) {
	m.cost = &f
	m.addcost = nil
}

// Cost returns the value of the "cost" field in the mutation.
func (m *EnterpriseBillMutation) Cost() (r float64, exists bool) {
	v := m.cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCost returns the old "cost" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCost: %w", err)
	}
	return oldValue.Cost, nil
}

// AddCost adds f to the "cost" field.
func (m *EnterpriseBillMutation) AddCost(f float64) {
	if m.addcost != nil {
		*m.addcost += f
	} else {
		m.addcost = &f
	}
}

// AddedCost returns the value that was added to the "cost" field in this mutation.
func (m *EnterpriseBillMutation) AddedCost() (r float64, exists bool) {
	v := m.addcost
	if v == nil {
		return
	}
	return *v, true
}

// ResetCost resets all changes to the "cost" field.
func (m *EnterpriseBillMutation) ResetCost() {
	m.cost = nil
	m.addcost = nil
}

// SetVoltage sets the "voltage" field.
func (m *EnterpriseBillMutation) SetVoltage(f float64) {
	m.voltage = &f
	m.addvoltage = nil
}

// Voltage returns the value of the "voltage" field in the mutation.
func (m *EnterpriseBillMutation) Voltage() (r float64, exists bool) {
	v := m.voltage
	if v == nil {
		return
	}
	return *v, true
}

// OldVoltage returns the old "voltage" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldVoltage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoltage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoltage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoltage: %w", err)
	}
	return oldValue.Voltage, nil
}

// AddVoltage adds f to the "voltage" field.
func (m *EnterpriseBillMutation) AddVoltage(f float64) {
	if m.addvoltage != nil {
		*m.addvoltage += f
	} else {
		m.addvoltage = &f
	}
}

// AddedVoltage returns the value that was added to the "voltage" field in this mutation.
func (m *EnterpriseBillMutation) AddedVoltage() (r float64, exists bool) {
	v := m.addvoltage
	if v == nil {
		return
	}
	return *v, true
}

// ResetVoltage resets all changes to the "voltage" field.
func (m *EnterpriseBillMutation) ResetVoltage() {
	m.voltage = nil
	m.addvoltage = nil
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *EnterpriseBillMutation) ClearRider() {
	m.clearedrider = true
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *EnterpriseBillMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *EnterpriseBillMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *EnterpriseBillMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *EnterpriseBillMutation) ClearSubscribe() {
	m.clearedsubscribe = true
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *EnterpriseBillMutation) SubscribeCleared() bool {
	return m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *EnterpriseBillMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *EnterpriseBillMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *EnterpriseBillMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *EnterpriseBillMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *EnterpriseBillMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *EnterpriseBillMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *EnterpriseBillMutation) ClearEnterprise() {
	m.clearedenterprise = true
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *EnterpriseBillMutation) EnterpriseCleared() bool {
	return m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *EnterpriseBillMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *EnterpriseBillMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// ClearStatement clears the "statement" edge to the EnterpriseStatement entity.
func (m *EnterpriseBillMutation) ClearStatement() {
	m.clearedstatement = true
}

// StatementCleared reports if the "statement" edge to the EnterpriseStatement entity was cleared.
func (m *EnterpriseBillMutation) StatementCleared() bool {
	return m.clearedstatement
}

// StatementIDs returns the "statement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatementID instead. It exists only for internal usage by the builders.
func (m *EnterpriseBillMutation) StatementIDs() (ids []uint64) {
	if id := m.statement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatement resets all changes to the "statement" edge.
func (m *EnterpriseBillMutation) ResetStatement() {
	m.statement = nil
	m.clearedstatement = false
}

// Where appends a list predicates to the EnterpriseBillMutation builder.
func (m *EnterpriseBillMutation) Where(ps ...predicate.EnterpriseBill) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EnterpriseBillMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EnterpriseBill).
func (m *EnterpriseBillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnterpriseBillMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, enterprisebill.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enterprisebill.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, enterprisebill.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, enterprisebill.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, enterprisebill.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, enterprisebill.FieldRemark)
	}
	if m.rider != nil {
		fields = append(fields, enterprisebill.FieldRiderID)
	}
	if m.subscribe != nil {
		fields = append(fields, enterprisebill.FieldSubscribeID)
	}
	if m.city != nil {
		fields = append(fields, enterprisebill.FieldCityID)
	}
	if m.enterprise != nil {
		fields = append(fields, enterprisebill.FieldEnterpriseID)
	}
	if m.statement != nil {
		fields = append(fields, enterprisebill.FieldStatementID)
	}
	if m.start != nil {
		fields = append(fields, enterprisebill.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, enterprisebill.FieldEnd)
	}
	if m.days != nil {
		fields = append(fields, enterprisebill.FieldDays)
	}
	if m.price != nil {
		fields = append(fields, enterprisebill.FieldPrice)
	}
	if m.cost != nil {
		fields = append(fields, enterprisebill.FieldCost)
	}
	if m.voltage != nil {
		fields = append(fields, enterprisebill.FieldVoltage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnterpriseBillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enterprisebill.FieldCreatedAt:
		return m.CreatedAt()
	case enterprisebill.FieldUpdatedAt:
		return m.UpdatedAt()
	case enterprisebill.FieldDeletedAt:
		return m.DeletedAt()
	case enterprisebill.FieldCreator:
		return m.Creator()
	case enterprisebill.FieldLastModifier:
		return m.LastModifier()
	case enterprisebill.FieldRemark:
		return m.Remark()
	case enterprisebill.FieldRiderID:
		return m.RiderID()
	case enterprisebill.FieldSubscribeID:
		return m.SubscribeID()
	case enterprisebill.FieldCityID:
		return m.CityID()
	case enterprisebill.FieldEnterpriseID:
		return m.EnterpriseID()
	case enterprisebill.FieldStatementID:
		return m.StatementID()
	case enterprisebill.FieldStart:
		return m.Start()
	case enterprisebill.FieldEnd:
		return m.End()
	case enterprisebill.FieldDays:
		return m.Days()
	case enterprisebill.FieldPrice:
		return m.Price()
	case enterprisebill.FieldCost:
		return m.Cost()
	case enterprisebill.FieldVoltage:
		return m.Voltage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnterpriseBillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enterprisebill.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enterprisebill.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case enterprisebill.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case enterprisebill.FieldCreator:
		return m.OldCreator(ctx)
	case enterprisebill.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case enterprisebill.FieldRemark:
		return m.OldRemark(ctx)
	case enterprisebill.FieldRiderID:
		return m.OldRiderID(ctx)
	case enterprisebill.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case enterprisebill.FieldCityID:
		return m.OldCityID(ctx)
	case enterprisebill.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case enterprisebill.FieldStatementID:
		return m.OldStatementID(ctx)
	case enterprisebill.FieldStart:
		return m.OldStart(ctx)
	case enterprisebill.FieldEnd:
		return m.OldEnd(ctx)
	case enterprisebill.FieldDays:
		return m.OldDays(ctx)
	case enterprisebill.FieldPrice:
		return m.OldPrice(ctx)
	case enterprisebill.FieldCost:
		return m.OldCost(ctx)
	case enterprisebill.FieldVoltage:
		return m.OldVoltage(ctx)
	}
	return nil, fmt.Errorf("unknown EnterpriseBill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseBillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enterprisebill.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enterprisebill.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case enterprisebill.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case enterprisebill.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case enterprisebill.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case enterprisebill.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case enterprisebill.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case enterprisebill.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case enterprisebill.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case enterprisebill.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case enterprisebill.FieldStatementID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatementID(v)
		return nil
	case enterprisebill.FieldStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case enterprisebill.FieldEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case enterprisebill.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDays(v)
		return nil
	case enterprisebill.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case enterprisebill.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCost(v)
		return nil
	case enterprisebill.FieldVoltage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoltage(v)
		return nil
	}
	return fmt.Errorf("unknown EnterpriseBill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnterpriseBillMutation) AddedFields() []string {
	var fields []string
	if m.adddays != nil {
		fields = append(fields, enterprisebill.FieldDays)
	}
	if m.addprice != nil {
		fields = append(fields, enterprisebill.FieldPrice)
	}
	if m.addcost != nil {
		fields = append(fields, enterprisebill.FieldCost)
	}
	if m.addvoltage != nil {
		fields = append(fields, enterprisebill.FieldVoltage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnterpriseBillMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case enterprisebill.FieldDays:
		return m.AddedDays()
	case enterprisebill.FieldPrice:
		return m.AddedPrice()
	case enterprisebill.FieldCost:
		return m.AddedCost()
	case enterprisebill.FieldVoltage:
		return m.AddedVoltage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseBillMutation) AddField(name string, value ent.Value) error {
	switch name {
	case enterprisebill.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDays(v)
		return nil
	case enterprisebill.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case enterprisebill.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCost(v)
		return nil
	case enterprisebill.FieldVoltage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVoltage(v)
		return nil
	}
	return fmt.Errorf("unknown EnterpriseBill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnterpriseBillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(enterprisebill.FieldDeletedAt) {
		fields = append(fields, enterprisebill.FieldDeletedAt)
	}
	if m.FieldCleared(enterprisebill.FieldCreator) {
		fields = append(fields, enterprisebill.FieldCreator)
	}
	if m.FieldCleared(enterprisebill.FieldLastModifier) {
		fields = append(fields, enterprisebill.FieldLastModifier)
	}
	if m.FieldCleared(enterprisebill.FieldRemark) {
		fields = append(fields, enterprisebill.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnterpriseBillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnterpriseBillMutation) ClearField(name string) error {
	switch name {
	case enterprisebill.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case enterprisebill.FieldCreator:
		m.ClearCreator()
		return nil
	case enterprisebill.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case enterprisebill.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseBill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnterpriseBillMutation) ResetField(name string) error {
	switch name {
	case enterprisebill.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enterprisebill.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case enterprisebill.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case enterprisebill.FieldCreator:
		m.ResetCreator()
		return nil
	case enterprisebill.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case enterprisebill.FieldRemark:
		m.ResetRemark()
		return nil
	case enterprisebill.FieldRiderID:
		m.ResetRiderID()
		return nil
	case enterprisebill.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case enterprisebill.FieldCityID:
		m.ResetCityID()
		return nil
	case enterprisebill.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case enterprisebill.FieldStatementID:
		m.ResetStatementID()
		return nil
	case enterprisebill.FieldStart:
		m.ResetStart()
		return nil
	case enterprisebill.FieldEnd:
		m.ResetEnd()
		return nil
	case enterprisebill.FieldDays:
		m.ResetDays()
		return nil
	case enterprisebill.FieldPrice:
		m.ResetPrice()
		return nil
	case enterprisebill.FieldCost:
		m.ResetCost()
		return nil
	case enterprisebill.FieldVoltage:
		m.ResetVoltage()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseBill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnterpriseBillMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.rider != nil {
		edges = append(edges, enterprisebill.EdgeRider)
	}
	if m.subscribe != nil {
		edges = append(edges, enterprisebill.EdgeSubscribe)
	}
	if m.city != nil {
		edges = append(edges, enterprisebill.EdgeCity)
	}
	if m.enterprise != nil {
		edges = append(edges, enterprisebill.EdgeEnterprise)
	}
	if m.statement != nil {
		edges = append(edges, enterprisebill.EdgeStatement)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnterpriseBillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enterprisebill.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case enterprisebill.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	case enterprisebill.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case enterprisebill.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	case enterprisebill.EdgeStatement:
		if id := m.statement; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnterpriseBillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnterpriseBillMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnterpriseBillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedrider {
		edges = append(edges, enterprisebill.EdgeRider)
	}
	if m.clearedsubscribe {
		edges = append(edges, enterprisebill.EdgeSubscribe)
	}
	if m.clearedcity {
		edges = append(edges, enterprisebill.EdgeCity)
	}
	if m.clearedenterprise {
		edges = append(edges, enterprisebill.EdgeEnterprise)
	}
	if m.clearedstatement {
		edges = append(edges, enterprisebill.EdgeStatement)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnterpriseBillMutation) EdgeCleared(name string) bool {
	switch name {
	case enterprisebill.EdgeRider:
		return m.clearedrider
	case enterprisebill.EdgeSubscribe:
		return m.clearedsubscribe
	case enterprisebill.EdgeCity:
		return m.clearedcity
	case enterprisebill.EdgeEnterprise:
		return m.clearedenterprise
	case enterprisebill.EdgeStatement:
		return m.clearedstatement
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnterpriseBillMutation) ClearEdge(name string) error {
	switch name {
	case enterprisebill.EdgeRider:
		m.ClearRider()
		return nil
	case enterprisebill.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	case enterprisebill.EdgeCity:
		m.ClearCity()
		return nil
	case enterprisebill.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	case enterprisebill.EdgeStatement:
		m.ClearStatement()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseBill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnterpriseBillMutation) ResetEdge(name string) error {
	switch name {
	case enterprisebill.EdgeRider:
		m.ResetRider()
		return nil
	case enterprisebill.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	case enterprisebill.EdgeCity:
		m.ResetCity()
		return nil
	case enterprisebill.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	case enterprisebill.EdgeStatement:
		m.ResetStatement()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseBill edge %s", name)
}

// EnterpriseContractMutation represents an operation that mutates the EnterpriseContract nodes in the graph.
type EnterpriseContractMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	start             *time.Time
	end               *time.Time
	file              *string
	clearedFields     map[string]struct{}
	enterprise        *uint64
	clearedenterprise bool
	done              bool
	oldValue          func(context.Context) (*EnterpriseContract, error)
	predicates        []predicate.EnterpriseContract
}

var _ ent.Mutation = (*EnterpriseContractMutation)(nil)

// enterprisecontractOption allows management of the mutation configuration using functional options.
type enterprisecontractOption func(*EnterpriseContractMutation)

// newEnterpriseContractMutation creates new mutation for the EnterpriseContract entity.
func newEnterpriseContractMutation(c config, op Op, opts ...enterprisecontractOption) *EnterpriseContractMutation {
	m := &EnterpriseContractMutation{
		config:        c,
		op:            op,
		typ:           TypeEnterpriseContract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnterpriseContractID sets the ID field of the mutation.
func withEnterpriseContractID(id uint64) enterprisecontractOption {
	return func(m *EnterpriseContractMutation) {
		var (
			err   error
			once  sync.Once
			value *EnterpriseContract
		)
		m.oldValue = func(ctx context.Context) (*EnterpriseContract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnterpriseContract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnterpriseContract sets the old EnterpriseContract of the mutation.
func withEnterpriseContract(node *EnterpriseContract) enterprisecontractOption {
	return func(m *EnterpriseContractMutation) {
		m.oldValue = func(context.Context) (*EnterpriseContract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnterpriseContractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnterpriseContractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnterpriseContractMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnterpriseContractMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnterpriseContract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EnterpriseContractMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnterpriseContractMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EnterpriseContract entity.
// If the EnterpriseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseContractMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnterpriseContractMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnterpriseContractMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnterpriseContractMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EnterpriseContract entity.
// If the EnterpriseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseContractMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnterpriseContractMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EnterpriseContractMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EnterpriseContractMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EnterpriseContract entity.
// If the EnterpriseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseContractMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EnterpriseContractMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[enterprisecontract.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EnterpriseContractMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[enterprisecontract.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EnterpriseContractMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, enterprisecontract.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *EnterpriseContractMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *EnterpriseContractMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the EnterpriseContract entity.
// If the EnterpriseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseContractMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *EnterpriseContractMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[enterprisecontract.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *EnterpriseContractMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[enterprisecontract.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *EnterpriseContractMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, enterprisecontract.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *EnterpriseContractMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *EnterpriseContractMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the EnterpriseContract entity.
// If the EnterpriseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseContractMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *EnterpriseContractMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[enterprisecontract.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *EnterpriseContractMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[enterprisecontract.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *EnterpriseContractMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, enterprisecontract.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *EnterpriseContractMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *EnterpriseContractMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the EnterpriseContract entity.
// If the EnterpriseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseContractMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *EnterpriseContractMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[enterprisecontract.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *EnterpriseContractMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[enterprisecontract.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *EnterpriseContractMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, enterprisecontract.FieldRemark)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *EnterpriseContractMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *EnterpriseContractMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the EnterpriseContract entity.
// If the EnterpriseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseContractMutation) OldEnterpriseID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *EnterpriseContractMutation) ResetEnterpriseID() {
	m.enterprise = nil
}

// SetStart sets the "start" field.
func (m *EnterpriseContractMutation) SetStart(t time.Time) {
	m.start = &t
}

// Start returns the value of the "start" field in the mutation.
func (m *EnterpriseContractMutation) Start() (r time.Time, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the EnterpriseContract entity.
// If the EnterpriseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseContractMutation) OldStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// ResetStart resets all changes to the "start" field.
func (m *EnterpriseContractMutation) ResetStart() {
	m.start = nil
}

// SetEnd sets the "end" field.
func (m *EnterpriseContractMutation) SetEnd(t time.Time) {
	m.end = &t
}

// End returns the value of the "end" field in the mutation.
func (m *EnterpriseContractMutation) End() (r time.Time, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the EnterpriseContract entity.
// If the EnterpriseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseContractMutation) OldEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// ResetEnd resets all changes to the "end" field.
func (m *EnterpriseContractMutation) ResetEnd() {
	m.end = nil
}

// SetFile sets the "file" field.
func (m *EnterpriseContractMutation) SetFile(s string) {
	m.file = &s
}

// File returns the value of the "file" field in the mutation.
func (m *EnterpriseContractMutation) File() (r string, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldFile returns the old "file" field's value of the EnterpriseContract entity.
// If the EnterpriseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseContractMutation) OldFile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFile: %w", err)
	}
	return oldValue.File, nil
}

// ResetFile resets all changes to the "file" field.
func (m *EnterpriseContractMutation) ResetFile() {
	m.file = nil
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *EnterpriseContractMutation) ClearEnterprise() {
	m.clearedenterprise = true
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *EnterpriseContractMutation) EnterpriseCleared() bool {
	return m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *EnterpriseContractMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *EnterpriseContractMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// Where appends a list predicates to the EnterpriseContractMutation builder.
func (m *EnterpriseContractMutation) Where(ps ...predicate.EnterpriseContract) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EnterpriseContractMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EnterpriseContract).
func (m *EnterpriseContractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnterpriseContractMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, enterprisecontract.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enterprisecontract.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, enterprisecontract.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, enterprisecontract.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, enterprisecontract.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, enterprisecontract.FieldRemark)
	}
	if m.enterprise != nil {
		fields = append(fields, enterprisecontract.FieldEnterpriseID)
	}
	if m.start != nil {
		fields = append(fields, enterprisecontract.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, enterprisecontract.FieldEnd)
	}
	if m.file != nil {
		fields = append(fields, enterprisecontract.FieldFile)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnterpriseContractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enterprisecontract.FieldCreatedAt:
		return m.CreatedAt()
	case enterprisecontract.FieldUpdatedAt:
		return m.UpdatedAt()
	case enterprisecontract.FieldDeletedAt:
		return m.DeletedAt()
	case enterprisecontract.FieldCreator:
		return m.Creator()
	case enterprisecontract.FieldLastModifier:
		return m.LastModifier()
	case enterprisecontract.FieldRemark:
		return m.Remark()
	case enterprisecontract.FieldEnterpriseID:
		return m.EnterpriseID()
	case enterprisecontract.FieldStart:
		return m.Start()
	case enterprisecontract.FieldEnd:
		return m.End()
	case enterprisecontract.FieldFile:
		return m.File()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnterpriseContractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enterprisecontract.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enterprisecontract.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case enterprisecontract.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case enterprisecontract.FieldCreator:
		return m.OldCreator(ctx)
	case enterprisecontract.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case enterprisecontract.FieldRemark:
		return m.OldRemark(ctx)
	case enterprisecontract.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case enterprisecontract.FieldStart:
		return m.OldStart(ctx)
	case enterprisecontract.FieldEnd:
		return m.OldEnd(ctx)
	case enterprisecontract.FieldFile:
		return m.OldFile(ctx)
	}
	return nil, fmt.Errorf("unknown EnterpriseContract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseContractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enterprisecontract.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enterprisecontract.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case enterprisecontract.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case enterprisecontract.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case enterprisecontract.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case enterprisecontract.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case enterprisecontract.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case enterprisecontract.FieldStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case enterprisecontract.FieldEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case enterprisecontract.FieldFile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFile(v)
		return nil
	}
	return fmt.Errorf("unknown EnterpriseContract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnterpriseContractMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnterpriseContractMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseContractMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EnterpriseContract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnterpriseContractMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(enterprisecontract.FieldDeletedAt) {
		fields = append(fields, enterprisecontract.FieldDeletedAt)
	}
	if m.FieldCleared(enterprisecontract.FieldCreator) {
		fields = append(fields, enterprisecontract.FieldCreator)
	}
	if m.FieldCleared(enterprisecontract.FieldLastModifier) {
		fields = append(fields, enterprisecontract.FieldLastModifier)
	}
	if m.FieldCleared(enterprisecontract.FieldRemark) {
		fields = append(fields, enterprisecontract.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnterpriseContractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnterpriseContractMutation) ClearField(name string) error {
	switch name {
	case enterprisecontract.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case enterprisecontract.FieldCreator:
		m.ClearCreator()
		return nil
	case enterprisecontract.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case enterprisecontract.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseContract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnterpriseContractMutation) ResetField(name string) error {
	switch name {
	case enterprisecontract.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enterprisecontract.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case enterprisecontract.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case enterprisecontract.FieldCreator:
		m.ResetCreator()
		return nil
	case enterprisecontract.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case enterprisecontract.FieldRemark:
		m.ResetRemark()
		return nil
	case enterprisecontract.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case enterprisecontract.FieldStart:
		m.ResetStart()
		return nil
	case enterprisecontract.FieldEnd:
		m.ResetEnd()
		return nil
	case enterprisecontract.FieldFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseContract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnterpriseContractMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.enterprise != nil {
		edges = append(edges, enterprisecontract.EdgeEnterprise)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnterpriseContractMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enterprisecontract.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnterpriseContractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnterpriseContractMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnterpriseContractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedenterprise {
		edges = append(edges, enterprisecontract.EdgeEnterprise)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnterpriseContractMutation) EdgeCleared(name string) bool {
	switch name {
	case enterprisecontract.EdgeEnterprise:
		return m.clearedenterprise
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnterpriseContractMutation) ClearEdge(name string) error {
	switch name {
	case enterprisecontract.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseContract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnterpriseContractMutation) ResetEdge(name string) error {
	switch name {
	case enterprisecontract.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseContract edge %s", name)
}

// EnterprisePrepaymentMutation represents an operation that mutates the EnterprisePrepayment nodes in the graph.
type EnterprisePrepaymentMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	amount            *float64
	addamount         *float64
	clearedFields     map[string]struct{}
	enterprise        *uint64
	clearedenterprise bool
	done              bool
	oldValue          func(context.Context) (*EnterprisePrepayment, error)
	predicates        []predicate.EnterprisePrepayment
}

var _ ent.Mutation = (*EnterprisePrepaymentMutation)(nil)

// enterpriseprepaymentOption allows management of the mutation configuration using functional options.
type enterpriseprepaymentOption func(*EnterprisePrepaymentMutation)

// newEnterprisePrepaymentMutation creates new mutation for the EnterprisePrepayment entity.
func newEnterprisePrepaymentMutation(c config, op Op, opts ...enterpriseprepaymentOption) *EnterprisePrepaymentMutation {
	m := &EnterprisePrepaymentMutation{
		config:        c,
		op:            op,
		typ:           TypeEnterprisePrepayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnterprisePrepaymentID sets the ID field of the mutation.
func withEnterprisePrepaymentID(id uint64) enterpriseprepaymentOption {
	return func(m *EnterprisePrepaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *EnterprisePrepayment
		)
		m.oldValue = func(ctx context.Context) (*EnterprisePrepayment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnterprisePrepayment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnterprisePrepayment sets the old EnterprisePrepayment of the mutation.
func withEnterprisePrepayment(node *EnterprisePrepayment) enterpriseprepaymentOption {
	return func(m *EnterprisePrepaymentMutation) {
		m.oldValue = func(context.Context) (*EnterprisePrepayment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnterprisePrepaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnterprisePrepaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnterprisePrepaymentMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnterprisePrepaymentMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnterprisePrepayment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EnterprisePrepaymentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnterprisePrepaymentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EnterprisePrepayment entity.
// If the EnterprisePrepayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePrepaymentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnterprisePrepaymentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnterprisePrepaymentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnterprisePrepaymentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EnterprisePrepayment entity.
// If the EnterprisePrepayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePrepaymentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnterprisePrepaymentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EnterprisePrepaymentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EnterprisePrepaymentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EnterprisePrepayment entity.
// If the EnterprisePrepayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePrepaymentMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EnterprisePrepaymentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[enterpriseprepayment.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EnterprisePrepaymentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[enterpriseprepayment.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EnterprisePrepaymentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, enterpriseprepayment.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *EnterprisePrepaymentMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *EnterprisePrepaymentMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the EnterprisePrepayment entity.
// If the EnterprisePrepayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePrepaymentMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *EnterprisePrepaymentMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[enterpriseprepayment.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *EnterprisePrepaymentMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[enterpriseprepayment.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *EnterprisePrepaymentMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, enterpriseprepayment.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *EnterprisePrepaymentMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *EnterprisePrepaymentMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the EnterprisePrepayment entity.
// If the EnterprisePrepayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePrepaymentMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *EnterprisePrepaymentMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[enterpriseprepayment.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *EnterprisePrepaymentMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[enterpriseprepayment.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *EnterprisePrepaymentMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, enterpriseprepayment.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *EnterprisePrepaymentMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *EnterprisePrepaymentMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the EnterprisePrepayment entity.
// If the EnterprisePrepayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePrepaymentMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *EnterprisePrepaymentMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[enterpriseprepayment.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *EnterprisePrepaymentMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[enterpriseprepayment.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *EnterprisePrepaymentMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, enterpriseprepayment.FieldRemark)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *EnterprisePrepaymentMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *EnterprisePrepaymentMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the EnterprisePrepayment entity.
// If the EnterprisePrepayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePrepaymentMutation) OldEnterpriseID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *EnterprisePrepaymentMutation) ResetEnterpriseID() {
	m.enterprise = nil
}

// SetAmount sets the "amount" field.
func (m *EnterprisePrepaymentMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *EnterprisePrepaymentMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the EnterprisePrepayment entity.
// If the EnterprisePrepayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePrepaymentMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *EnterprisePrepaymentMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *EnterprisePrepaymentMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *EnterprisePrepaymentMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *EnterprisePrepaymentMutation) ClearEnterprise() {
	m.clearedenterprise = true
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *EnterprisePrepaymentMutation) EnterpriseCleared() bool {
	return m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *EnterprisePrepaymentMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *EnterprisePrepaymentMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// Where appends a list predicates to the EnterprisePrepaymentMutation builder.
func (m *EnterprisePrepaymentMutation) Where(ps ...predicate.EnterprisePrepayment) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EnterprisePrepaymentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EnterprisePrepayment).
func (m *EnterprisePrepaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnterprisePrepaymentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, enterpriseprepayment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enterpriseprepayment.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, enterpriseprepayment.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, enterpriseprepayment.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, enterpriseprepayment.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, enterpriseprepayment.FieldRemark)
	}
	if m.enterprise != nil {
		fields = append(fields, enterpriseprepayment.FieldEnterpriseID)
	}
	if m.amount != nil {
		fields = append(fields, enterpriseprepayment.FieldAmount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnterprisePrepaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enterpriseprepayment.FieldCreatedAt:
		return m.CreatedAt()
	case enterpriseprepayment.FieldUpdatedAt:
		return m.UpdatedAt()
	case enterpriseprepayment.FieldDeletedAt:
		return m.DeletedAt()
	case enterpriseprepayment.FieldCreator:
		return m.Creator()
	case enterpriseprepayment.FieldLastModifier:
		return m.LastModifier()
	case enterpriseprepayment.FieldRemark:
		return m.Remark()
	case enterpriseprepayment.FieldEnterpriseID:
		return m.EnterpriseID()
	case enterpriseprepayment.FieldAmount:
		return m.Amount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnterprisePrepaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enterpriseprepayment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enterpriseprepayment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case enterpriseprepayment.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case enterpriseprepayment.FieldCreator:
		return m.OldCreator(ctx)
	case enterpriseprepayment.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case enterpriseprepayment.FieldRemark:
		return m.OldRemark(ctx)
	case enterpriseprepayment.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case enterpriseprepayment.FieldAmount:
		return m.OldAmount(ctx)
	}
	return nil, fmt.Errorf("unknown EnterprisePrepayment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterprisePrepaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enterpriseprepayment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enterpriseprepayment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case enterpriseprepayment.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case enterpriseprepayment.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case enterpriseprepayment.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case enterpriseprepayment.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case enterpriseprepayment.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case enterpriseprepayment.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrepayment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnterprisePrepaymentMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, enterpriseprepayment.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnterprisePrepaymentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case enterpriseprepayment.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterprisePrepaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case enterpriseprepayment.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrepayment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnterprisePrepaymentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(enterpriseprepayment.FieldDeletedAt) {
		fields = append(fields, enterpriseprepayment.FieldDeletedAt)
	}
	if m.FieldCleared(enterpriseprepayment.FieldCreator) {
		fields = append(fields, enterpriseprepayment.FieldCreator)
	}
	if m.FieldCleared(enterpriseprepayment.FieldLastModifier) {
		fields = append(fields, enterpriseprepayment.FieldLastModifier)
	}
	if m.FieldCleared(enterpriseprepayment.FieldRemark) {
		fields = append(fields, enterpriseprepayment.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnterprisePrepaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnterprisePrepaymentMutation) ClearField(name string) error {
	switch name {
	case enterpriseprepayment.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case enterpriseprepayment.FieldCreator:
		m.ClearCreator()
		return nil
	case enterpriseprepayment.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case enterpriseprepayment.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrepayment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnterprisePrepaymentMutation) ResetField(name string) error {
	switch name {
	case enterpriseprepayment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enterpriseprepayment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case enterpriseprepayment.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case enterpriseprepayment.FieldCreator:
		m.ResetCreator()
		return nil
	case enterpriseprepayment.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case enterpriseprepayment.FieldRemark:
		m.ResetRemark()
		return nil
	case enterpriseprepayment.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case enterpriseprepayment.FieldAmount:
		m.ResetAmount()
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrepayment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnterprisePrepaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.enterprise != nil {
		edges = append(edges, enterpriseprepayment.EdgeEnterprise)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnterprisePrepaymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enterpriseprepayment.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnterprisePrepaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnterprisePrepaymentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnterprisePrepaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedenterprise {
		edges = append(edges, enterpriseprepayment.EdgeEnterprise)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnterprisePrepaymentMutation) EdgeCleared(name string) bool {
	switch name {
	case enterpriseprepayment.EdgeEnterprise:
		return m.clearedenterprise
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnterprisePrepaymentMutation) ClearEdge(name string) error {
	switch name {
	case enterpriseprepayment.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrepayment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnterprisePrepaymentMutation) ResetEdge(name string) error {
	switch name {
	case enterpriseprepayment.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrepayment edge %s", name)
}

// EnterprisePriceMutation represents an operation that mutates the EnterprisePrice nodes in the graph.
type EnterprisePriceMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	price             *float64
	addprice          *float64
	voltage           *float64
	addvoltage        *float64
	clearedFields     map[string]struct{}
	city              *uint64
	clearedcity       bool
	enterprise        *uint64
	clearedenterprise bool
	done              bool
	oldValue          func(context.Context) (*EnterprisePrice, error)
	predicates        []predicate.EnterprisePrice
}

var _ ent.Mutation = (*EnterprisePriceMutation)(nil)

// enterprisepriceOption allows management of the mutation configuration using functional options.
type enterprisepriceOption func(*EnterprisePriceMutation)

// newEnterprisePriceMutation creates new mutation for the EnterprisePrice entity.
func newEnterprisePriceMutation(c config, op Op, opts ...enterprisepriceOption) *EnterprisePriceMutation {
	m := &EnterprisePriceMutation{
		config:        c,
		op:            op,
		typ:           TypeEnterprisePrice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnterprisePriceID sets the ID field of the mutation.
func withEnterprisePriceID(id uint64) enterprisepriceOption {
	return func(m *EnterprisePriceMutation) {
		var (
			err   error
			once  sync.Once
			value *EnterprisePrice
		)
		m.oldValue = func(ctx context.Context) (*EnterprisePrice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnterprisePrice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnterprisePrice sets the old EnterprisePrice of the mutation.
func withEnterprisePrice(node *EnterprisePrice) enterprisepriceOption {
	return func(m *EnterprisePriceMutation) {
		m.oldValue = func(context.Context) (*EnterprisePrice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnterprisePriceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnterprisePriceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnterprisePriceMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnterprisePriceMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnterprisePrice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EnterprisePriceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnterprisePriceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EnterprisePrice entity.
// If the EnterprisePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePriceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnterprisePriceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnterprisePriceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnterprisePriceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EnterprisePrice entity.
// If the EnterprisePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePriceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnterprisePriceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EnterprisePriceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EnterprisePriceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EnterprisePrice entity.
// If the EnterprisePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePriceMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EnterprisePriceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[enterpriseprice.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EnterprisePriceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[enterpriseprice.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EnterprisePriceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, enterpriseprice.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *EnterprisePriceMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *EnterprisePriceMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the EnterprisePrice entity.
// If the EnterprisePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePriceMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *EnterprisePriceMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[enterpriseprice.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *EnterprisePriceMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[enterpriseprice.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *EnterprisePriceMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, enterpriseprice.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *EnterprisePriceMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *EnterprisePriceMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the EnterprisePrice entity.
// If the EnterprisePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePriceMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *EnterprisePriceMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[enterpriseprice.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *EnterprisePriceMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[enterpriseprice.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *EnterprisePriceMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, enterpriseprice.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *EnterprisePriceMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *EnterprisePriceMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the EnterprisePrice entity.
// If the EnterprisePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePriceMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *EnterprisePriceMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[enterpriseprice.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *EnterprisePriceMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[enterpriseprice.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *EnterprisePriceMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, enterpriseprice.FieldRemark)
}

// SetCityID sets the "city_id" field.
func (m *EnterprisePriceMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *EnterprisePriceMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the EnterprisePrice entity.
// If the EnterprisePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePriceMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *EnterprisePriceMutation) ResetCityID() {
	m.city = nil
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *EnterprisePriceMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *EnterprisePriceMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the EnterprisePrice entity.
// If the EnterprisePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePriceMutation) OldEnterpriseID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *EnterprisePriceMutation) ResetEnterpriseID() {
	m.enterprise = nil
}

// SetPrice sets the "price" field.
func (m *EnterprisePriceMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *EnterprisePriceMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the EnterprisePrice entity.
// If the EnterprisePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePriceMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *EnterprisePriceMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *EnterprisePriceMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *EnterprisePriceMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetVoltage sets the "voltage" field.
func (m *EnterprisePriceMutation) SetVoltage(f float64) {
	m.voltage = &f
	m.addvoltage = nil
}

// Voltage returns the value of the "voltage" field in the mutation.
func (m *EnterprisePriceMutation) Voltage() (r float64, exists bool) {
	v := m.voltage
	if v == nil {
		return
	}
	return *v, true
}

// OldVoltage returns the old "voltage" field's value of the EnterprisePrice entity.
// If the EnterprisePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePriceMutation) OldVoltage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoltage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoltage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoltage: %w", err)
	}
	return oldValue.Voltage, nil
}

// AddVoltage adds f to the "voltage" field.
func (m *EnterprisePriceMutation) AddVoltage(f float64) {
	if m.addvoltage != nil {
		*m.addvoltage += f
	} else {
		m.addvoltage = &f
	}
}

// AddedVoltage returns the value that was added to the "voltage" field in this mutation.
func (m *EnterprisePriceMutation) AddedVoltage() (r float64, exists bool) {
	v := m.addvoltage
	if v == nil {
		return
	}
	return *v, true
}

// ResetVoltage resets all changes to the "voltage" field.
func (m *EnterprisePriceMutation) ResetVoltage() {
	m.voltage = nil
	m.addvoltage = nil
}

// ClearCity clears the "city" edge to the City entity.
func (m *EnterprisePriceMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *EnterprisePriceMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *EnterprisePriceMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *EnterprisePriceMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *EnterprisePriceMutation) ClearEnterprise() {
	m.clearedenterprise = true
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *EnterprisePriceMutation) EnterpriseCleared() bool {
	return m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *EnterprisePriceMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *EnterprisePriceMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// Where appends a list predicates to the EnterprisePriceMutation builder.
func (m *EnterprisePriceMutation) Where(ps ...predicate.EnterprisePrice) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EnterprisePriceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EnterprisePrice).
func (m *EnterprisePriceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnterprisePriceMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, enterpriseprice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enterpriseprice.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, enterpriseprice.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, enterpriseprice.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, enterpriseprice.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, enterpriseprice.FieldRemark)
	}
	if m.city != nil {
		fields = append(fields, enterpriseprice.FieldCityID)
	}
	if m.enterprise != nil {
		fields = append(fields, enterpriseprice.FieldEnterpriseID)
	}
	if m.price != nil {
		fields = append(fields, enterpriseprice.FieldPrice)
	}
	if m.voltage != nil {
		fields = append(fields, enterpriseprice.FieldVoltage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnterprisePriceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enterpriseprice.FieldCreatedAt:
		return m.CreatedAt()
	case enterpriseprice.FieldUpdatedAt:
		return m.UpdatedAt()
	case enterpriseprice.FieldDeletedAt:
		return m.DeletedAt()
	case enterpriseprice.FieldCreator:
		return m.Creator()
	case enterpriseprice.FieldLastModifier:
		return m.LastModifier()
	case enterpriseprice.FieldRemark:
		return m.Remark()
	case enterpriseprice.FieldCityID:
		return m.CityID()
	case enterpriseprice.FieldEnterpriseID:
		return m.EnterpriseID()
	case enterpriseprice.FieldPrice:
		return m.Price()
	case enterpriseprice.FieldVoltage:
		return m.Voltage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnterprisePriceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enterpriseprice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enterpriseprice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case enterpriseprice.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case enterpriseprice.FieldCreator:
		return m.OldCreator(ctx)
	case enterpriseprice.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case enterpriseprice.FieldRemark:
		return m.OldRemark(ctx)
	case enterpriseprice.FieldCityID:
		return m.OldCityID(ctx)
	case enterpriseprice.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case enterpriseprice.FieldPrice:
		return m.OldPrice(ctx)
	case enterpriseprice.FieldVoltage:
		return m.OldVoltage(ctx)
	}
	return nil, fmt.Errorf("unknown EnterprisePrice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterprisePriceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enterpriseprice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enterpriseprice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case enterpriseprice.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case enterpriseprice.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case enterpriseprice.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case enterpriseprice.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case enterpriseprice.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case enterpriseprice.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case enterpriseprice.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case enterpriseprice.FieldVoltage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoltage(v)
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnterprisePriceMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, enterpriseprice.FieldPrice)
	}
	if m.addvoltage != nil {
		fields = append(fields, enterpriseprice.FieldVoltage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnterprisePriceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case enterpriseprice.FieldPrice:
		return m.AddedPrice()
	case enterpriseprice.FieldVoltage:
		return m.AddedVoltage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterprisePriceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case enterpriseprice.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case enterpriseprice.FieldVoltage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVoltage(v)
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnterprisePriceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(enterpriseprice.FieldDeletedAt) {
		fields = append(fields, enterpriseprice.FieldDeletedAt)
	}
	if m.FieldCleared(enterpriseprice.FieldCreator) {
		fields = append(fields, enterpriseprice.FieldCreator)
	}
	if m.FieldCleared(enterpriseprice.FieldLastModifier) {
		fields = append(fields, enterpriseprice.FieldLastModifier)
	}
	if m.FieldCleared(enterpriseprice.FieldRemark) {
		fields = append(fields, enterpriseprice.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnterprisePriceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnterprisePriceMutation) ClearField(name string) error {
	switch name {
	case enterpriseprice.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case enterpriseprice.FieldCreator:
		m.ClearCreator()
		return nil
	case enterpriseprice.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case enterpriseprice.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnterprisePriceMutation) ResetField(name string) error {
	switch name {
	case enterpriseprice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enterpriseprice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case enterpriseprice.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case enterpriseprice.FieldCreator:
		m.ResetCreator()
		return nil
	case enterpriseprice.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case enterpriseprice.FieldRemark:
		m.ResetRemark()
		return nil
	case enterpriseprice.FieldCityID:
		m.ResetCityID()
		return nil
	case enterpriseprice.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case enterpriseprice.FieldPrice:
		m.ResetPrice()
		return nil
	case enterpriseprice.FieldVoltage:
		m.ResetVoltage()
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnterprisePriceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.city != nil {
		edges = append(edges, enterpriseprice.EdgeCity)
	}
	if m.enterprise != nil {
		edges = append(edges, enterpriseprice.EdgeEnterprise)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnterprisePriceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enterpriseprice.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case enterpriseprice.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnterprisePriceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnterprisePriceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnterprisePriceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcity {
		edges = append(edges, enterpriseprice.EdgeCity)
	}
	if m.clearedenterprise {
		edges = append(edges, enterpriseprice.EdgeEnterprise)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnterprisePriceMutation) EdgeCleared(name string) bool {
	switch name {
	case enterpriseprice.EdgeCity:
		return m.clearedcity
	case enterpriseprice.EdgeEnterprise:
		return m.clearedenterprise
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnterprisePriceMutation) ClearEdge(name string) error {
	switch name {
	case enterpriseprice.EdgeCity:
		m.ClearCity()
		return nil
	case enterpriseprice.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnterprisePriceMutation) ResetEdge(name string) error {
	switch name {
	case enterpriseprice.EdgeCity:
		m.ResetCity()
		return nil
	case enterpriseprice.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrice edge %s", name)
}

// EnterpriseStatementMutation represents an operation that mutates the EnterpriseStatement nodes in the graph.
type EnterpriseStatementMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	cost              *float64
	addcost           *float64
	balance           *float64
	addbalance        *float64
	settled_at        *time.Time
	days              *int
	adddays           *int
	rider_number      *int
	addrider_number   *int
	date              *time.Time
	start             *time.Time
	end               *time.Time
	clearedFields     map[string]struct{}
	enterprise        *uint64
	clearedenterprise bool
	bills             map[uint64]struct{}
	removedbills      map[uint64]struct{}
	clearedbills      bool
	done              bool
	oldValue          func(context.Context) (*EnterpriseStatement, error)
	predicates        []predicate.EnterpriseStatement
}

var _ ent.Mutation = (*EnterpriseStatementMutation)(nil)

// enterprisestatementOption allows management of the mutation configuration using functional options.
type enterprisestatementOption func(*EnterpriseStatementMutation)

// newEnterpriseStatementMutation creates new mutation for the EnterpriseStatement entity.
func newEnterpriseStatementMutation(c config, op Op, opts ...enterprisestatementOption) *EnterpriseStatementMutation {
	m := &EnterpriseStatementMutation{
		config:        c,
		op:            op,
		typ:           TypeEnterpriseStatement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnterpriseStatementID sets the ID field of the mutation.
func withEnterpriseStatementID(id uint64) enterprisestatementOption {
	return func(m *EnterpriseStatementMutation) {
		var (
			err   error
			once  sync.Once
			value *EnterpriseStatement
		)
		m.oldValue = func(ctx context.Context) (*EnterpriseStatement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnterpriseStatement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnterpriseStatement sets the old EnterpriseStatement of the mutation.
func withEnterpriseStatement(node *EnterpriseStatement) enterprisestatementOption {
	return func(m *EnterpriseStatementMutation) {
		m.oldValue = func(context.Context) (*EnterpriseStatement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnterpriseStatementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnterpriseStatementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnterpriseStatementMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnterpriseStatementMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnterpriseStatement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EnterpriseStatementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnterpriseStatementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnterpriseStatementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnterpriseStatementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnterpriseStatementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnterpriseStatementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EnterpriseStatementMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EnterpriseStatementMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EnterpriseStatementMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[enterprisestatement.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EnterpriseStatementMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[enterprisestatement.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EnterpriseStatementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, enterprisestatement.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *EnterpriseStatementMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *EnterpriseStatementMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *EnterpriseStatementMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[enterprisestatement.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *EnterpriseStatementMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[enterprisestatement.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *EnterpriseStatementMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, enterprisestatement.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *EnterpriseStatementMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *EnterpriseStatementMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *EnterpriseStatementMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[enterprisestatement.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *EnterpriseStatementMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[enterprisestatement.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *EnterpriseStatementMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, enterprisestatement.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *EnterpriseStatementMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *EnterpriseStatementMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *EnterpriseStatementMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[enterprisestatement.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *EnterpriseStatementMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[enterprisestatement.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *EnterpriseStatementMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, enterprisestatement.FieldRemark)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *EnterpriseStatementMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *EnterpriseStatementMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldEnterpriseID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *EnterpriseStatementMutation) ResetEnterpriseID() {
	m.enterprise = nil
}

// SetCost sets the "cost" field.
func (m *EnterpriseStatementMutation) SetCost(f float64) {
	m.cost = &f
	m.addcost = nil
}

// Cost returns the value of the "cost" field in the mutation.
func (m *EnterpriseStatementMutation) Cost() (r float64, exists bool) {
	v := m.cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCost returns the old "cost" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCost: %w", err)
	}
	return oldValue.Cost, nil
}

// AddCost adds f to the "cost" field.
func (m *EnterpriseStatementMutation) AddCost(f float64) {
	if m.addcost != nil {
		*m.addcost += f
	} else {
		m.addcost = &f
	}
}

// AddedCost returns the value that was added to the "cost" field in this mutation.
func (m *EnterpriseStatementMutation) AddedCost() (r float64, exists bool) {
	v := m.addcost
	if v == nil {
		return
	}
	return *v, true
}

// ResetCost resets all changes to the "cost" field.
func (m *EnterpriseStatementMutation) ResetCost() {
	m.cost = nil
	m.addcost = nil
}

// SetBalance sets the "balance" field.
func (m *EnterpriseStatementMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *EnterpriseStatementMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *EnterpriseStatementMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *EnterpriseStatementMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *EnterpriseStatementMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetSettledAt sets the "settled_at" field.
func (m *EnterpriseStatementMutation) SetSettledAt(t time.Time) {
	m.settled_at = &t
}

// SettledAt returns the value of the "settled_at" field in the mutation.
func (m *EnterpriseStatementMutation) SettledAt() (r time.Time, exists bool) {
	v := m.settled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSettledAt returns the old "settled_at" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldSettledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettledAt: %w", err)
	}
	return oldValue.SettledAt, nil
}

// ClearSettledAt clears the value of the "settled_at" field.
func (m *EnterpriseStatementMutation) ClearSettledAt() {
	m.settled_at = nil
	m.clearedFields[enterprisestatement.FieldSettledAt] = struct{}{}
}

// SettledAtCleared returns if the "settled_at" field was cleared in this mutation.
func (m *EnterpriseStatementMutation) SettledAtCleared() bool {
	_, ok := m.clearedFields[enterprisestatement.FieldSettledAt]
	return ok
}

// ResetSettledAt resets all changes to the "settled_at" field.
func (m *EnterpriseStatementMutation) ResetSettledAt() {
	m.settled_at = nil
	delete(m.clearedFields, enterprisestatement.FieldSettledAt)
}

// SetDays sets the "days" field.
func (m *EnterpriseStatementMutation) SetDays(i int) {
	m.days = &i
	m.adddays = nil
}

// Days returns the value of the "days" field in the mutation.
func (m *EnterpriseStatementMutation) Days() (r int, exists bool) {
	v := m.days
	if v == nil {
		return
	}
	return *v, true
}

// OldDays returns the old "days" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDays: %w", err)
	}
	return oldValue.Days, nil
}

// AddDays adds i to the "days" field.
func (m *EnterpriseStatementMutation) AddDays(i int) {
	if m.adddays != nil {
		*m.adddays += i
	} else {
		m.adddays = &i
	}
}

// AddedDays returns the value that was added to the "days" field in this mutation.
func (m *EnterpriseStatementMutation) AddedDays() (r int, exists bool) {
	v := m.adddays
	if v == nil {
		return
	}
	return *v, true
}

// ResetDays resets all changes to the "days" field.
func (m *EnterpriseStatementMutation) ResetDays() {
	m.days = nil
	m.adddays = nil
}

// SetRiderNumber sets the "rider_number" field.
func (m *EnterpriseStatementMutation) SetRiderNumber(i int) {
	m.rider_number = &i
	m.addrider_number = nil
}

// RiderNumber returns the value of the "rider_number" field in the mutation.
func (m *EnterpriseStatementMutation) RiderNumber() (r int, exists bool) {
	v := m.rider_number
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderNumber returns the old "rider_number" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldRiderNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderNumber: %w", err)
	}
	return oldValue.RiderNumber, nil
}

// AddRiderNumber adds i to the "rider_number" field.
func (m *EnterpriseStatementMutation) AddRiderNumber(i int) {
	if m.addrider_number != nil {
		*m.addrider_number += i
	} else {
		m.addrider_number = &i
	}
}

// AddedRiderNumber returns the value that was added to the "rider_number" field in this mutation.
func (m *EnterpriseStatementMutation) AddedRiderNumber() (r int, exists bool) {
	v := m.addrider_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetRiderNumber resets all changes to the "rider_number" field.
func (m *EnterpriseStatementMutation) ResetRiderNumber() {
	m.rider_number = nil
	m.addrider_number = nil
}

// SetDate sets the "date" field.
func (m *EnterpriseStatementMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *EnterpriseStatementMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ClearDate clears the value of the "date" field.
func (m *EnterpriseStatementMutation) ClearDate() {
	m.date = nil
	m.clearedFields[enterprisestatement.FieldDate] = struct{}{}
}

// DateCleared returns if the "date" field was cleared in this mutation.
func (m *EnterpriseStatementMutation) DateCleared() bool {
	_, ok := m.clearedFields[enterprisestatement.FieldDate]
	return ok
}

// ResetDate resets all changes to the "date" field.
func (m *EnterpriseStatementMutation) ResetDate() {
	m.date = nil
	delete(m.clearedFields, enterprisestatement.FieldDate)
}

// SetStart sets the "start" field.
func (m *EnterpriseStatementMutation) SetStart(t time.Time) {
	m.start = &t
}

// Start returns the value of the "start" field in the mutation.
func (m *EnterpriseStatementMutation) Start() (r time.Time, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// ResetStart resets all changes to the "start" field.
func (m *EnterpriseStatementMutation) ResetStart() {
	m.start = nil
}

// SetEnd sets the "end" field.
func (m *EnterpriseStatementMutation) SetEnd(t time.Time) {
	m.end = &t
}

// End returns the value of the "end" field in the mutation.
func (m *EnterpriseStatementMutation) End() (r time.Time, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldEnd(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// ClearEnd clears the value of the "end" field.
func (m *EnterpriseStatementMutation) ClearEnd() {
	m.end = nil
	m.clearedFields[enterprisestatement.FieldEnd] = struct{}{}
}

// EndCleared returns if the "end" field was cleared in this mutation.
func (m *EnterpriseStatementMutation) EndCleared() bool {
	_, ok := m.clearedFields[enterprisestatement.FieldEnd]
	return ok
}

// ResetEnd resets all changes to the "end" field.
func (m *EnterpriseStatementMutation) ResetEnd() {
	m.end = nil
	delete(m.clearedFields, enterprisestatement.FieldEnd)
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *EnterpriseStatementMutation) ClearEnterprise() {
	m.clearedenterprise = true
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *EnterpriseStatementMutation) EnterpriseCleared() bool {
	return m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *EnterpriseStatementMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *EnterpriseStatementMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// AddBillIDs adds the "bills" edge to the EnterpriseBill entity by ids.
func (m *EnterpriseStatementMutation) AddBillIDs(ids ...uint64) {
	if m.bills == nil {
		m.bills = make(map[uint64]struct{})
	}
	for i := range ids {
		m.bills[ids[i]] = struct{}{}
	}
}

// ClearBills clears the "bills" edge to the EnterpriseBill entity.
func (m *EnterpriseStatementMutation) ClearBills() {
	m.clearedbills = true
}

// BillsCleared reports if the "bills" edge to the EnterpriseBill entity was cleared.
func (m *EnterpriseStatementMutation) BillsCleared() bool {
	return m.clearedbills
}

// RemoveBillIDs removes the "bills" edge to the EnterpriseBill entity by IDs.
func (m *EnterpriseStatementMutation) RemoveBillIDs(ids ...uint64) {
	if m.removedbills == nil {
		m.removedbills = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.bills, ids[i])
		m.removedbills[ids[i]] = struct{}{}
	}
}

// RemovedBills returns the removed IDs of the "bills" edge to the EnterpriseBill entity.
func (m *EnterpriseStatementMutation) RemovedBillsIDs() (ids []uint64) {
	for id := range m.removedbills {
		ids = append(ids, id)
	}
	return
}

// BillsIDs returns the "bills" edge IDs in the mutation.
func (m *EnterpriseStatementMutation) BillsIDs() (ids []uint64) {
	for id := range m.bills {
		ids = append(ids, id)
	}
	return
}

// ResetBills resets all changes to the "bills" edge.
func (m *EnterpriseStatementMutation) ResetBills() {
	m.bills = nil
	m.clearedbills = false
	m.removedbills = nil
}

// Where appends a list predicates to the EnterpriseStatementMutation builder.
func (m *EnterpriseStatementMutation) Where(ps ...predicate.EnterpriseStatement) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EnterpriseStatementMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EnterpriseStatement).
func (m *EnterpriseStatementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnterpriseStatementMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, enterprisestatement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enterprisestatement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, enterprisestatement.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, enterprisestatement.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, enterprisestatement.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, enterprisestatement.FieldRemark)
	}
	if m.enterprise != nil {
		fields = append(fields, enterprisestatement.FieldEnterpriseID)
	}
	if m.cost != nil {
		fields = append(fields, enterprisestatement.FieldCost)
	}
	if m.balance != nil {
		fields = append(fields, enterprisestatement.FieldBalance)
	}
	if m.settled_at != nil {
		fields = append(fields, enterprisestatement.FieldSettledAt)
	}
	if m.days != nil {
		fields = append(fields, enterprisestatement.FieldDays)
	}
	if m.rider_number != nil {
		fields = append(fields, enterprisestatement.FieldRiderNumber)
	}
	if m.date != nil {
		fields = append(fields, enterprisestatement.FieldDate)
	}
	if m.start != nil {
		fields = append(fields, enterprisestatement.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, enterprisestatement.FieldEnd)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnterpriseStatementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enterprisestatement.FieldCreatedAt:
		return m.CreatedAt()
	case enterprisestatement.FieldUpdatedAt:
		return m.UpdatedAt()
	case enterprisestatement.FieldDeletedAt:
		return m.DeletedAt()
	case enterprisestatement.FieldCreator:
		return m.Creator()
	case enterprisestatement.FieldLastModifier:
		return m.LastModifier()
	case enterprisestatement.FieldRemark:
		return m.Remark()
	case enterprisestatement.FieldEnterpriseID:
		return m.EnterpriseID()
	case enterprisestatement.FieldCost:
		return m.Cost()
	case enterprisestatement.FieldBalance:
		return m.Balance()
	case enterprisestatement.FieldSettledAt:
		return m.SettledAt()
	case enterprisestatement.FieldDays:
		return m.Days()
	case enterprisestatement.FieldRiderNumber:
		return m.RiderNumber()
	case enterprisestatement.FieldDate:
		return m.Date()
	case enterprisestatement.FieldStart:
		return m.Start()
	case enterprisestatement.FieldEnd:
		return m.End()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnterpriseStatementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enterprisestatement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enterprisestatement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case enterprisestatement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case enterprisestatement.FieldCreator:
		return m.OldCreator(ctx)
	case enterprisestatement.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case enterprisestatement.FieldRemark:
		return m.OldRemark(ctx)
	case enterprisestatement.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case enterprisestatement.FieldCost:
		return m.OldCost(ctx)
	case enterprisestatement.FieldBalance:
		return m.OldBalance(ctx)
	case enterprisestatement.FieldSettledAt:
		return m.OldSettledAt(ctx)
	case enterprisestatement.FieldDays:
		return m.OldDays(ctx)
	case enterprisestatement.FieldRiderNumber:
		return m.OldRiderNumber(ctx)
	case enterprisestatement.FieldDate:
		return m.OldDate(ctx)
	case enterprisestatement.FieldStart:
		return m.OldStart(ctx)
	case enterprisestatement.FieldEnd:
		return m.OldEnd(ctx)
	}
	return nil, fmt.Errorf("unknown EnterpriseStatement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseStatementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enterprisestatement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enterprisestatement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case enterprisestatement.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case enterprisestatement.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case enterprisestatement.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case enterprisestatement.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case enterprisestatement.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case enterprisestatement.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCost(v)
		return nil
	case enterprisestatement.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case enterprisestatement.FieldSettledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettledAt(v)
		return nil
	case enterprisestatement.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDays(v)
		return nil
	case enterprisestatement.FieldRiderNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderNumber(v)
		return nil
	case enterprisestatement.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case enterprisestatement.FieldStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case enterprisestatement.FieldEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	}
	return fmt.Errorf("unknown EnterpriseStatement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnterpriseStatementMutation) AddedFields() []string {
	var fields []string
	if m.addcost != nil {
		fields = append(fields, enterprisestatement.FieldCost)
	}
	if m.addbalance != nil {
		fields = append(fields, enterprisestatement.FieldBalance)
	}
	if m.adddays != nil {
		fields = append(fields, enterprisestatement.FieldDays)
	}
	if m.addrider_number != nil {
		fields = append(fields, enterprisestatement.FieldRiderNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnterpriseStatementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case enterprisestatement.FieldCost:
		return m.AddedCost()
	case enterprisestatement.FieldBalance:
		return m.AddedBalance()
	case enterprisestatement.FieldDays:
		return m.AddedDays()
	case enterprisestatement.FieldRiderNumber:
		return m.AddedRiderNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseStatementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case enterprisestatement.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCost(v)
		return nil
	case enterprisestatement.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case enterprisestatement.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDays(v)
		return nil
	case enterprisestatement.FieldRiderNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRiderNumber(v)
		return nil
	}
	return fmt.Errorf("unknown EnterpriseStatement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnterpriseStatementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(enterprisestatement.FieldDeletedAt) {
		fields = append(fields, enterprisestatement.FieldDeletedAt)
	}
	if m.FieldCleared(enterprisestatement.FieldCreator) {
		fields = append(fields, enterprisestatement.FieldCreator)
	}
	if m.FieldCleared(enterprisestatement.FieldLastModifier) {
		fields = append(fields, enterprisestatement.FieldLastModifier)
	}
	if m.FieldCleared(enterprisestatement.FieldRemark) {
		fields = append(fields, enterprisestatement.FieldRemark)
	}
	if m.FieldCleared(enterprisestatement.FieldSettledAt) {
		fields = append(fields, enterprisestatement.FieldSettledAt)
	}
	if m.FieldCleared(enterprisestatement.FieldDate) {
		fields = append(fields, enterprisestatement.FieldDate)
	}
	if m.FieldCleared(enterprisestatement.FieldEnd) {
		fields = append(fields, enterprisestatement.FieldEnd)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnterpriseStatementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnterpriseStatementMutation) ClearField(name string) error {
	switch name {
	case enterprisestatement.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case enterprisestatement.FieldCreator:
		m.ClearCreator()
		return nil
	case enterprisestatement.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case enterprisestatement.FieldRemark:
		m.ClearRemark()
		return nil
	case enterprisestatement.FieldSettledAt:
		m.ClearSettledAt()
		return nil
	case enterprisestatement.FieldDate:
		m.ClearDate()
		return nil
	case enterprisestatement.FieldEnd:
		m.ClearEnd()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseStatement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnterpriseStatementMutation) ResetField(name string) error {
	switch name {
	case enterprisestatement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enterprisestatement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case enterprisestatement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case enterprisestatement.FieldCreator:
		m.ResetCreator()
		return nil
	case enterprisestatement.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case enterprisestatement.FieldRemark:
		m.ResetRemark()
		return nil
	case enterprisestatement.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case enterprisestatement.FieldCost:
		m.ResetCost()
		return nil
	case enterprisestatement.FieldBalance:
		m.ResetBalance()
		return nil
	case enterprisestatement.FieldSettledAt:
		m.ResetSettledAt()
		return nil
	case enterprisestatement.FieldDays:
		m.ResetDays()
		return nil
	case enterprisestatement.FieldRiderNumber:
		m.ResetRiderNumber()
		return nil
	case enterprisestatement.FieldDate:
		m.ResetDate()
		return nil
	case enterprisestatement.FieldStart:
		m.ResetStart()
		return nil
	case enterprisestatement.FieldEnd:
		m.ResetEnd()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseStatement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnterpriseStatementMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.enterprise != nil {
		edges = append(edges, enterprisestatement.EdgeEnterprise)
	}
	if m.bills != nil {
		edges = append(edges, enterprisestatement.EdgeBills)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnterpriseStatementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enterprisestatement.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	case enterprisestatement.EdgeBills:
		ids := make([]ent.Value, 0, len(m.bills))
		for id := range m.bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnterpriseStatementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbills != nil {
		edges = append(edges, enterprisestatement.EdgeBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnterpriseStatementMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case enterprisestatement.EdgeBills:
		ids := make([]ent.Value, 0, len(m.removedbills))
		for id := range m.removedbills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnterpriseStatementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedenterprise {
		edges = append(edges, enterprisestatement.EdgeEnterprise)
	}
	if m.clearedbills {
		edges = append(edges, enterprisestatement.EdgeBills)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnterpriseStatementMutation) EdgeCleared(name string) bool {
	switch name {
	case enterprisestatement.EdgeEnterprise:
		return m.clearedenterprise
	case enterprisestatement.EdgeBills:
		return m.clearedbills
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnterpriseStatementMutation) ClearEdge(name string) error {
	switch name {
	case enterprisestatement.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseStatement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnterpriseStatementMutation) ResetEdge(name string) error {
	switch name {
	case enterprisestatement.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	case enterprisestatement.EdgeBills:
		m.ResetBills()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseStatement edge %s", name)
}

// EnterpriseStationMutation represents an operation that mutates the EnterpriseStation nodes in the graph.
type EnterpriseStationMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	name              *string
	clearedFields     map[string]struct{}
	enterprise        *uint64
	clearedenterprise bool
	done              bool
	oldValue          func(context.Context) (*EnterpriseStation, error)
	predicates        []predicate.EnterpriseStation
}

var _ ent.Mutation = (*EnterpriseStationMutation)(nil)

// enterprisestationOption allows management of the mutation configuration using functional options.
type enterprisestationOption func(*EnterpriseStationMutation)

// newEnterpriseStationMutation creates new mutation for the EnterpriseStation entity.
func newEnterpriseStationMutation(c config, op Op, opts ...enterprisestationOption) *EnterpriseStationMutation {
	m := &EnterpriseStationMutation{
		config:        c,
		op:            op,
		typ:           TypeEnterpriseStation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnterpriseStationID sets the ID field of the mutation.
func withEnterpriseStationID(id uint64) enterprisestationOption {
	return func(m *EnterpriseStationMutation) {
		var (
			err   error
			once  sync.Once
			value *EnterpriseStation
		)
		m.oldValue = func(ctx context.Context) (*EnterpriseStation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnterpriseStation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnterpriseStation sets the old EnterpriseStation of the mutation.
func withEnterpriseStation(node *EnterpriseStation) enterprisestationOption {
	return func(m *EnterpriseStationMutation) {
		m.oldValue = func(context.Context) (*EnterpriseStation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnterpriseStationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnterpriseStationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnterpriseStationMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnterpriseStationMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnterpriseStation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EnterpriseStationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnterpriseStationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EnterpriseStation entity.
// If the EnterpriseStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnterpriseStationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnterpriseStationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnterpriseStationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EnterpriseStation entity.
// If the EnterpriseStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnterpriseStationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EnterpriseStationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EnterpriseStationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EnterpriseStation entity.
// If the EnterpriseStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStationMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EnterpriseStationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[enterprisestation.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EnterpriseStationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[enterprisestation.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EnterpriseStationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, enterprisestation.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *EnterpriseStationMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *EnterpriseStationMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the EnterpriseStation entity.
// If the EnterpriseStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStationMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *EnterpriseStationMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[enterprisestation.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *EnterpriseStationMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[enterprisestation.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *EnterpriseStationMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, enterprisestation.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *EnterpriseStationMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *EnterpriseStationMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the EnterpriseStation entity.
// If the EnterpriseStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStationMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *EnterpriseStationMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[enterprisestation.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *EnterpriseStationMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[enterprisestation.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *EnterpriseStationMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, enterprisestation.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *EnterpriseStationMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *EnterpriseStationMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the EnterpriseStation entity.
// If the EnterpriseStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStationMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *EnterpriseStationMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[enterprisestation.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *EnterpriseStationMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[enterprisestation.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *EnterpriseStationMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, enterprisestation.FieldRemark)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *EnterpriseStationMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *EnterpriseStationMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the EnterpriseStation entity.
// If the EnterpriseStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStationMutation) OldEnterpriseID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *EnterpriseStationMutation) ResetEnterpriseID() {
	m.enterprise = nil
}

// SetName sets the "name" field.
func (m *EnterpriseStationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EnterpriseStationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EnterpriseStation entity.
// If the EnterpriseStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EnterpriseStationMutation) ResetName() {
	m.name = nil
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *EnterpriseStationMutation) ClearEnterprise() {
	m.clearedenterprise = true
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *EnterpriseStationMutation) EnterpriseCleared() bool {
	return m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *EnterpriseStationMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *EnterpriseStationMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// Where appends a list predicates to the EnterpriseStationMutation builder.
func (m *EnterpriseStationMutation) Where(ps ...predicate.EnterpriseStation) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EnterpriseStationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EnterpriseStation).
func (m *EnterpriseStationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnterpriseStationMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, enterprisestation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enterprisestation.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, enterprisestation.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, enterprisestation.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, enterprisestation.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, enterprisestation.FieldRemark)
	}
	if m.enterprise != nil {
		fields = append(fields, enterprisestation.FieldEnterpriseID)
	}
	if m.name != nil {
		fields = append(fields, enterprisestation.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnterpriseStationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enterprisestation.FieldCreatedAt:
		return m.CreatedAt()
	case enterprisestation.FieldUpdatedAt:
		return m.UpdatedAt()
	case enterprisestation.FieldDeletedAt:
		return m.DeletedAt()
	case enterprisestation.FieldCreator:
		return m.Creator()
	case enterprisestation.FieldLastModifier:
		return m.LastModifier()
	case enterprisestation.FieldRemark:
		return m.Remark()
	case enterprisestation.FieldEnterpriseID:
		return m.EnterpriseID()
	case enterprisestation.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnterpriseStationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enterprisestation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enterprisestation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case enterprisestation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case enterprisestation.FieldCreator:
		return m.OldCreator(ctx)
	case enterprisestation.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case enterprisestation.FieldRemark:
		return m.OldRemark(ctx)
	case enterprisestation.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case enterprisestation.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown EnterpriseStation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseStationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enterprisestation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enterprisestation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case enterprisestation.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case enterprisestation.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case enterprisestation.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case enterprisestation.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case enterprisestation.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case enterprisestation.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown EnterpriseStation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnterpriseStationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnterpriseStationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseStationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EnterpriseStation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnterpriseStationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(enterprisestation.FieldDeletedAt) {
		fields = append(fields, enterprisestation.FieldDeletedAt)
	}
	if m.FieldCleared(enterprisestation.FieldCreator) {
		fields = append(fields, enterprisestation.FieldCreator)
	}
	if m.FieldCleared(enterprisestation.FieldLastModifier) {
		fields = append(fields, enterprisestation.FieldLastModifier)
	}
	if m.FieldCleared(enterprisestation.FieldRemark) {
		fields = append(fields, enterprisestation.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnterpriseStationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnterpriseStationMutation) ClearField(name string) error {
	switch name {
	case enterprisestation.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case enterprisestation.FieldCreator:
		m.ClearCreator()
		return nil
	case enterprisestation.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case enterprisestation.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseStation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnterpriseStationMutation) ResetField(name string) error {
	switch name {
	case enterprisestation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enterprisestation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case enterprisestation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case enterprisestation.FieldCreator:
		m.ResetCreator()
		return nil
	case enterprisestation.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case enterprisestation.FieldRemark:
		m.ResetRemark()
		return nil
	case enterprisestation.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case enterprisestation.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseStation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnterpriseStationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.enterprise != nil {
		edges = append(edges, enterprisestation.EdgeEnterprise)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnterpriseStationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enterprisestation.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnterpriseStationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnterpriseStationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnterpriseStationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedenterprise {
		edges = append(edges, enterprisestation.EdgeEnterprise)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnterpriseStationMutation) EdgeCleared(name string) bool {
	switch name {
	case enterprisestation.EdgeEnterprise:
		return m.clearedenterprise
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnterpriseStationMutation) ClearEdge(name string) error {
	switch name {
	case enterprisestation.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseStation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnterpriseStationMutation) ResetEdge(name string) error {
	switch name {
	case enterprisestation.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseStation edge %s", name)
}

// ExceptionMutation represents an operation that mutates the Exception nodes in the graph.
type ExceptionMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	creator         **model.Modifier
	last_modifier   **model.Modifier
	remark          *string
	status          *uint8
	addstatus       *int8
	name            *string
	voltage         *float64
	addvoltage      *float64
	num             *int
	addnum          *int
	reason          *string
	description     *string
	attachments     *[]string
	clearedFields   map[string]struct{}
	city            *uint64
	clearedcity     bool
	employee        *uint64
	clearedemployee bool
	store           *uint64
	clearedstore    bool
	done            bool
	oldValue        func(context.Context) (*Exception, error)
	predicates      []predicate.Exception
}

var _ ent.Mutation = (*ExceptionMutation)(nil)

// exceptionOption allows management of the mutation configuration using functional options.
type exceptionOption func(*ExceptionMutation)

// newExceptionMutation creates new mutation for the Exception entity.
func newExceptionMutation(c config, op Op, opts ...exceptionOption) *ExceptionMutation {
	m := &ExceptionMutation{
		config:        c,
		op:            op,
		typ:           TypeException,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExceptionID sets the ID field of the mutation.
func withExceptionID(id uint64) exceptionOption {
	return func(m *ExceptionMutation) {
		var (
			err   error
			once  sync.Once
			value *Exception
		)
		m.oldValue = func(ctx context.Context) (*Exception, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exception.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withException sets the old Exception of the mutation.
func withException(node *Exception) exceptionOption {
	return func(m *ExceptionMutation) {
		m.oldValue = func(context.Context) (*Exception, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExceptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExceptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExceptionMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExceptionMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exception.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ExceptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExceptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExceptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExceptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExceptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExceptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ExceptionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ExceptionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ExceptionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[exception.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ExceptionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[exception.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ExceptionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, exception.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *ExceptionMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *ExceptionMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *ExceptionMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[exception.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *ExceptionMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[exception.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *ExceptionMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, exception.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *ExceptionMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *ExceptionMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *ExceptionMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[exception.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *ExceptionMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[exception.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *ExceptionMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, exception.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *ExceptionMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ExceptionMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ExceptionMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[exception.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ExceptionMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[exception.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ExceptionMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, exception.FieldRemark)
}

// SetCityID sets the "city_id" field.
func (m *ExceptionMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *ExceptionMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *ExceptionMutation) ResetCityID() {
	m.city = nil
}

// SetEmployeeID sets the "employee_id" field.
func (m *ExceptionMutation) SetEmployeeID(u uint64) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *ExceptionMutation) EmployeeID() (r uint64, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldEmployeeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *ExceptionMutation) ResetEmployeeID() {
	m.employee = nil
}

// SetStatus sets the "status" field.
func (m *ExceptionMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ExceptionMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *ExceptionMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ExceptionMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ExceptionMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetStoreID sets the "store_id" field.
func (m *ExceptionMutation) SetStoreID(u uint64) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *ExceptionMutation) StoreID() (r uint64, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldStoreID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *ExceptionMutation) ResetStoreID() {
	m.store = nil
}

// SetName sets the "name" field.
func (m *ExceptionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ExceptionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ExceptionMutation) ResetName() {
	m.name = nil
}

// SetVoltage sets the "voltage" field.
func (m *ExceptionMutation) SetVoltage(f float64) {
	m.voltage = &f
	m.addvoltage = nil
}

// Voltage returns the value of the "voltage" field in the mutation.
func (m *ExceptionMutation) Voltage() (r float64, exists bool) {
	v := m.voltage
	if v == nil {
		return
	}
	return *v, true
}

// OldVoltage returns the old "voltage" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldVoltage(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoltage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoltage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoltage: %w", err)
	}
	return oldValue.Voltage, nil
}

// AddVoltage adds f to the "voltage" field.
func (m *ExceptionMutation) AddVoltage(f float64) {
	if m.addvoltage != nil {
		*m.addvoltage += f
	} else {
		m.addvoltage = &f
	}
}

// AddedVoltage returns the value that was added to the "voltage" field in this mutation.
func (m *ExceptionMutation) AddedVoltage() (r float64, exists bool) {
	v := m.addvoltage
	if v == nil {
		return
	}
	return *v, true
}

// ClearVoltage clears the value of the "voltage" field.
func (m *ExceptionMutation) ClearVoltage() {
	m.voltage = nil
	m.addvoltage = nil
	m.clearedFields[exception.FieldVoltage] = struct{}{}
}

// VoltageCleared returns if the "voltage" field was cleared in this mutation.
func (m *ExceptionMutation) VoltageCleared() bool {
	_, ok := m.clearedFields[exception.FieldVoltage]
	return ok
}

// ResetVoltage resets all changes to the "voltage" field.
func (m *ExceptionMutation) ResetVoltage() {
	m.voltage = nil
	m.addvoltage = nil
	delete(m.clearedFields, exception.FieldVoltage)
}

// SetNum sets the "num" field.
func (m *ExceptionMutation) SetNum(i int) {
	m.num = &i
	m.addnum = nil
}

// Num returns the value of the "num" field in the mutation.
func (m *ExceptionMutation) Num() (r int, exists bool) {
	v := m.num
	if v == nil {
		return
	}
	return *v, true
}

// OldNum returns the old "num" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNum: %w", err)
	}
	return oldValue.Num, nil
}

// AddNum adds i to the "num" field.
func (m *ExceptionMutation) AddNum(i int) {
	if m.addnum != nil {
		*m.addnum += i
	} else {
		m.addnum = &i
	}
}

// AddedNum returns the value that was added to the "num" field in this mutation.
func (m *ExceptionMutation) AddedNum() (r int, exists bool) {
	v := m.addnum
	if v == nil {
		return
	}
	return *v, true
}

// ResetNum resets all changes to the "num" field.
func (m *ExceptionMutation) ResetNum() {
	m.num = nil
	m.addnum = nil
}

// SetReason sets the "reason" field.
func (m *ExceptionMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *ExceptionMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *ExceptionMutation) ResetReason() {
	m.reason = nil
}

// SetDescription sets the "description" field.
func (m *ExceptionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ExceptionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ExceptionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[exception.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ExceptionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[exception.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ExceptionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, exception.FieldDescription)
}

// SetAttachments sets the "attachments" field.
func (m *ExceptionMutation) SetAttachments(s []string) {
	m.attachments = &s
}

// Attachments returns the value of the "attachments" field in the mutation.
func (m *ExceptionMutation) Attachments() (r []string, exists bool) {
	v := m.attachments
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachments returns the old "attachments" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldAttachments(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttachments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttachments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachments: %w", err)
	}
	return oldValue.Attachments, nil
}

// ClearAttachments clears the value of the "attachments" field.
func (m *ExceptionMutation) ClearAttachments() {
	m.attachments = nil
	m.clearedFields[exception.FieldAttachments] = struct{}{}
}

// AttachmentsCleared returns if the "attachments" field was cleared in this mutation.
func (m *ExceptionMutation) AttachmentsCleared() bool {
	_, ok := m.clearedFields[exception.FieldAttachments]
	return ok
}

// ResetAttachments resets all changes to the "attachments" field.
func (m *ExceptionMutation) ResetAttachments() {
	m.attachments = nil
	delete(m.clearedFields, exception.FieldAttachments)
}

// ClearCity clears the "city" edge to the City entity.
func (m *ExceptionMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *ExceptionMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *ExceptionMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *ExceptionMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *ExceptionMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *ExceptionMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *ExceptionMutation) EmployeeIDs() (ids []uint64) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *ExceptionMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// ClearStore clears the "store" edge to the Store entity.
func (m *ExceptionMutation) ClearStore() {
	m.clearedstore = true
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *ExceptionMutation) StoreCleared() bool {
	return m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *ExceptionMutation) StoreIDs() (ids []uint64) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *ExceptionMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// Where appends a list predicates to the ExceptionMutation builder.
func (m *ExceptionMutation) Where(ps ...predicate.Exception) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ExceptionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Exception).
func (m *ExceptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExceptionMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, exception.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, exception.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, exception.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, exception.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, exception.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, exception.FieldRemark)
	}
	if m.city != nil {
		fields = append(fields, exception.FieldCityID)
	}
	if m.employee != nil {
		fields = append(fields, exception.FieldEmployeeID)
	}
	if m.status != nil {
		fields = append(fields, exception.FieldStatus)
	}
	if m.store != nil {
		fields = append(fields, exception.FieldStoreID)
	}
	if m.name != nil {
		fields = append(fields, exception.FieldName)
	}
	if m.voltage != nil {
		fields = append(fields, exception.FieldVoltage)
	}
	if m.num != nil {
		fields = append(fields, exception.FieldNum)
	}
	if m.reason != nil {
		fields = append(fields, exception.FieldReason)
	}
	if m.description != nil {
		fields = append(fields, exception.FieldDescription)
	}
	if m.attachments != nil {
		fields = append(fields, exception.FieldAttachments)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExceptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exception.FieldCreatedAt:
		return m.CreatedAt()
	case exception.FieldUpdatedAt:
		return m.UpdatedAt()
	case exception.FieldDeletedAt:
		return m.DeletedAt()
	case exception.FieldCreator:
		return m.Creator()
	case exception.FieldLastModifier:
		return m.LastModifier()
	case exception.FieldRemark:
		return m.Remark()
	case exception.FieldCityID:
		return m.CityID()
	case exception.FieldEmployeeID:
		return m.EmployeeID()
	case exception.FieldStatus:
		return m.Status()
	case exception.FieldStoreID:
		return m.StoreID()
	case exception.FieldName:
		return m.Name()
	case exception.FieldVoltage:
		return m.Voltage()
	case exception.FieldNum:
		return m.Num()
	case exception.FieldReason:
		return m.Reason()
	case exception.FieldDescription:
		return m.Description()
	case exception.FieldAttachments:
		return m.Attachments()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExceptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exception.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case exception.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case exception.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case exception.FieldCreator:
		return m.OldCreator(ctx)
	case exception.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case exception.FieldRemark:
		return m.OldRemark(ctx)
	case exception.FieldCityID:
		return m.OldCityID(ctx)
	case exception.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case exception.FieldStatus:
		return m.OldStatus(ctx)
	case exception.FieldStoreID:
		return m.OldStoreID(ctx)
	case exception.FieldName:
		return m.OldName(ctx)
	case exception.FieldVoltage:
		return m.OldVoltage(ctx)
	case exception.FieldNum:
		return m.OldNum(ctx)
	case exception.FieldReason:
		return m.OldReason(ctx)
	case exception.FieldDescription:
		return m.OldDescription(ctx)
	case exception.FieldAttachments:
		return m.OldAttachments(ctx)
	}
	return nil, fmt.Errorf("unknown Exception field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExceptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exception.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case exception.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case exception.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case exception.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case exception.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case exception.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case exception.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case exception.FieldEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case exception.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case exception.FieldStoreID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case exception.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case exception.FieldVoltage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoltage(v)
		return nil
	case exception.FieldNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNum(v)
		return nil
	case exception.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case exception.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case exception.FieldAttachments:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachments(v)
		return nil
	}
	return fmt.Errorf("unknown Exception field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExceptionMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, exception.FieldStatus)
	}
	if m.addvoltage != nil {
		fields = append(fields, exception.FieldVoltage)
	}
	if m.addnum != nil {
		fields = append(fields, exception.FieldNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExceptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case exception.FieldStatus:
		return m.AddedStatus()
	case exception.FieldVoltage:
		return m.AddedVoltage()
	case exception.FieldNum:
		return m.AddedNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExceptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case exception.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case exception.FieldVoltage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVoltage(v)
		return nil
	case exception.FieldNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNum(v)
		return nil
	}
	return fmt.Errorf("unknown Exception numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExceptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exception.FieldDeletedAt) {
		fields = append(fields, exception.FieldDeletedAt)
	}
	if m.FieldCleared(exception.FieldCreator) {
		fields = append(fields, exception.FieldCreator)
	}
	if m.FieldCleared(exception.FieldLastModifier) {
		fields = append(fields, exception.FieldLastModifier)
	}
	if m.FieldCleared(exception.FieldRemark) {
		fields = append(fields, exception.FieldRemark)
	}
	if m.FieldCleared(exception.FieldVoltage) {
		fields = append(fields, exception.FieldVoltage)
	}
	if m.FieldCleared(exception.FieldDescription) {
		fields = append(fields, exception.FieldDescription)
	}
	if m.FieldCleared(exception.FieldAttachments) {
		fields = append(fields, exception.FieldAttachments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExceptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExceptionMutation) ClearField(name string) error {
	switch name {
	case exception.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case exception.FieldCreator:
		m.ClearCreator()
		return nil
	case exception.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case exception.FieldRemark:
		m.ClearRemark()
		return nil
	case exception.FieldVoltage:
		m.ClearVoltage()
		return nil
	case exception.FieldDescription:
		m.ClearDescription()
		return nil
	case exception.FieldAttachments:
		m.ClearAttachments()
		return nil
	}
	return fmt.Errorf("unknown Exception nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExceptionMutation) ResetField(name string) error {
	switch name {
	case exception.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case exception.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case exception.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case exception.FieldCreator:
		m.ResetCreator()
		return nil
	case exception.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case exception.FieldRemark:
		m.ResetRemark()
		return nil
	case exception.FieldCityID:
		m.ResetCityID()
		return nil
	case exception.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case exception.FieldStatus:
		m.ResetStatus()
		return nil
	case exception.FieldStoreID:
		m.ResetStoreID()
		return nil
	case exception.FieldName:
		m.ResetName()
		return nil
	case exception.FieldVoltage:
		m.ResetVoltage()
		return nil
	case exception.FieldNum:
		m.ResetNum()
		return nil
	case exception.FieldReason:
		m.ResetReason()
		return nil
	case exception.FieldDescription:
		m.ResetDescription()
		return nil
	case exception.FieldAttachments:
		m.ResetAttachments()
		return nil
	}
	return fmt.Errorf("unknown Exception field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExceptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.city != nil {
		edges = append(edges, exception.EdgeCity)
	}
	if m.employee != nil {
		edges = append(edges, exception.EdgeEmployee)
	}
	if m.store != nil {
		edges = append(edges, exception.EdgeStore)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExceptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exception.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case exception.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case exception.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExceptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExceptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExceptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcity {
		edges = append(edges, exception.EdgeCity)
	}
	if m.clearedemployee {
		edges = append(edges, exception.EdgeEmployee)
	}
	if m.clearedstore {
		edges = append(edges, exception.EdgeStore)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExceptionMutation) EdgeCleared(name string) bool {
	switch name {
	case exception.EdgeCity:
		return m.clearedcity
	case exception.EdgeEmployee:
		return m.clearedemployee
	case exception.EdgeStore:
		return m.clearedstore
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExceptionMutation) ClearEdge(name string) error {
	switch name {
	case exception.EdgeCity:
		m.ClearCity()
		return nil
	case exception.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case exception.EdgeStore:
		m.ClearStore()
		return nil
	}
	return fmt.Errorf("unknown Exception unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExceptionMutation) ResetEdge(name string) error {
	switch name {
	case exception.EdgeCity:
		m.ResetCity()
		return nil
	case exception.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case exception.EdgeStore:
		m.ResetStore()
		return nil
	}
	return fmt.Errorf("unknown Exception edge %s", name)
}

// ExchangeMutation represents an operation that mutates the Exchange nodes in the graph.
type ExchangeMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	uuid              *string
	success           *bool
	detail            **model.ExchangeCabinet
	voltage           *float64
	addvoltage        *float64
	clearedFields     map[string]struct{}
	subscribe         *uint64
	clearedsubscribe  bool
	city              *uint64
	clearedcity       bool
	store             *uint64
	clearedstore      bool
	enterprise        *uint64
	clearedenterprise bool
	station           *uint64
	clearedstation    bool
	cabinet           *uint64
	clearedcabinet    bool
	rider             *uint64
	clearedrider      bool
	employee          *uint64
	clearedemployee   bool
	done              bool
	oldValue          func(context.Context) (*Exchange, error)
	predicates        []predicate.Exchange
}

var _ ent.Mutation = (*ExchangeMutation)(nil)

// exchangeOption allows management of the mutation configuration using functional options.
type exchangeOption func(*ExchangeMutation)

// newExchangeMutation creates new mutation for the Exchange entity.
func newExchangeMutation(c config, op Op, opts ...exchangeOption) *ExchangeMutation {
	m := &ExchangeMutation{
		config:        c,
		op:            op,
		typ:           TypeExchange,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExchangeID sets the ID field of the mutation.
func withExchangeID(id uint64) exchangeOption {
	return func(m *ExchangeMutation) {
		var (
			err   error
			once  sync.Once
			value *Exchange
		)
		m.oldValue = func(ctx context.Context) (*Exchange, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exchange.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExchange sets the old Exchange of the mutation.
func withExchange(node *Exchange) exchangeOption {
	return func(m *ExchangeMutation) {
		m.oldValue = func(context.Context) (*Exchange, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExchangeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExchangeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExchangeMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExchangeMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exchange.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ExchangeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExchangeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExchangeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExchangeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExchangeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExchangeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ExchangeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ExchangeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ExchangeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[exchange.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ExchangeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[exchange.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ExchangeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, exchange.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *ExchangeMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *ExchangeMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *ExchangeMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[exchange.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *ExchangeMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[exchange.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *ExchangeMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, exchange.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *ExchangeMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *ExchangeMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *ExchangeMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[exchange.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *ExchangeMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[exchange.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *ExchangeMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, exchange.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *ExchangeMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ExchangeMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ExchangeMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[exchange.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ExchangeMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[exchange.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ExchangeMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, exchange.FieldRemark)
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *ExchangeMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *ExchangeMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldSubscribeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *ExchangeMutation) ResetSubscribeID() {
	m.subscribe = nil
}

// SetCityID sets the "city_id" field.
func (m *ExchangeMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *ExchangeMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *ExchangeMutation) ResetCityID() {
	m.city = nil
}

// SetStoreID sets the "store_id" field.
func (m *ExchangeMutation) SetStoreID(u uint64) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *ExchangeMutation) StoreID() (r uint64, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldStoreID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *ExchangeMutation) ClearStoreID() {
	m.store = nil
	m.clearedFields[exchange.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *ExchangeMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[exchange.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *ExchangeMutation) ResetStoreID() {
	m.store = nil
	delete(m.clearedFields, exchange.FieldStoreID)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *ExchangeMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *ExchangeMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldEnterpriseID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ClearEnterpriseID clears the value of the "enterprise_id" field.
func (m *ExchangeMutation) ClearEnterpriseID() {
	m.enterprise = nil
	m.clearedFields[exchange.FieldEnterpriseID] = struct{}{}
}

// EnterpriseIDCleared returns if the "enterprise_id" field was cleared in this mutation.
func (m *ExchangeMutation) EnterpriseIDCleared() bool {
	_, ok := m.clearedFields[exchange.FieldEnterpriseID]
	return ok
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *ExchangeMutation) ResetEnterpriseID() {
	m.enterprise = nil
	delete(m.clearedFields, exchange.FieldEnterpriseID)
}

// SetStationID sets the "station_id" field.
func (m *ExchangeMutation) SetStationID(u uint64) {
	m.station = &u
}

// StationID returns the value of the "station_id" field in the mutation.
func (m *ExchangeMutation) StationID() (r uint64, exists bool) {
	v := m.station
	if v == nil {
		return
	}
	return *v, true
}

// OldStationID returns the old "station_id" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldStationID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStationID: %w", err)
	}
	return oldValue.StationID, nil
}

// ClearStationID clears the value of the "station_id" field.
func (m *ExchangeMutation) ClearStationID() {
	m.station = nil
	m.clearedFields[exchange.FieldStationID] = struct{}{}
}

// StationIDCleared returns if the "station_id" field was cleared in this mutation.
func (m *ExchangeMutation) StationIDCleared() bool {
	_, ok := m.clearedFields[exchange.FieldStationID]
	return ok
}

// ResetStationID resets all changes to the "station_id" field.
func (m *ExchangeMutation) ResetStationID() {
	m.station = nil
	delete(m.clearedFields, exchange.FieldStationID)
}

// SetRiderID sets the "rider_id" field.
func (m *ExchangeMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *ExchangeMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *ExchangeMutation) ResetRiderID() {
	m.rider = nil
}

// SetEmployeeID sets the "employee_id" field.
func (m *ExchangeMutation) SetEmployeeID(u uint64) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *ExchangeMutation) EmployeeID() (r uint64, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldEmployeeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *ExchangeMutation) ClearEmployeeID() {
	m.employee = nil
	m.clearedFields[exchange.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *ExchangeMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[exchange.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *ExchangeMutation) ResetEmployeeID() {
	m.employee = nil
	delete(m.clearedFields, exchange.FieldEmployeeID)
}

// SetUUID sets the "uuid" field.
func (m *ExchangeMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *ExchangeMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *ExchangeMutation) ResetUUID() {
	m.uuid = nil
}

// SetCabinetID sets the "cabinet_id" field.
func (m *ExchangeMutation) SetCabinetID(u uint64) {
	m.cabinet = &u
}

// CabinetID returns the value of the "cabinet_id" field in the mutation.
func (m *ExchangeMutation) CabinetID() (r uint64, exists bool) {
	v := m.cabinet
	if v == nil {
		return
	}
	return *v, true
}

// OldCabinetID returns the old "cabinet_id" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldCabinetID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCabinetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCabinetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCabinetID: %w", err)
	}
	return oldValue.CabinetID, nil
}

// ClearCabinetID clears the value of the "cabinet_id" field.
func (m *ExchangeMutation) ClearCabinetID() {
	m.cabinet = nil
	m.clearedFields[exchange.FieldCabinetID] = struct{}{}
}

// CabinetIDCleared returns if the "cabinet_id" field was cleared in this mutation.
func (m *ExchangeMutation) CabinetIDCleared() bool {
	_, ok := m.clearedFields[exchange.FieldCabinetID]
	return ok
}

// ResetCabinetID resets all changes to the "cabinet_id" field.
func (m *ExchangeMutation) ResetCabinetID() {
	m.cabinet = nil
	delete(m.clearedFields, exchange.FieldCabinetID)
}

// SetSuccess sets the "success" field.
func (m *ExchangeMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *ExchangeMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *ExchangeMutation) ResetSuccess() {
	m.success = nil
}

// SetDetail sets the "detail" field.
func (m *ExchangeMutation) SetDetail(mc *model.ExchangeCabinet) {
	m.detail = &mc
}

// Detail returns the value of the "detail" field in the mutation.
func (m *ExchangeMutation) Detail() (r *model.ExchangeCabinet, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldDetail(ctx context.Context) (v *model.ExchangeCabinet, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ClearDetail clears the value of the "detail" field.
func (m *ExchangeMutation) ClearDetail() {
	m.detail = nil
	m.clearedFields[exchange.FieldDetail] = struct{}{}
}

// DetailCleared returns if the "detail" field was cleared in this mutation.
func (m *ExchangeMutation) DetailCleared() bool {
	_, ok := m.clearedFields[exchange.FieldDetail]
	return ok
}

// ResetDetail resets all changes to the "detail" field.
func (m *ExchangeMutation) ResetDetail() {
	m.detail = nil
	delete(m.clearedFields, exchange.FieldDetail)
}

// SetVoltage sets the "voltage" field.
func (m *ExchangeMutation) SetVoltage(f float64) {
	m.voltage = &f
	m.addvoltage = nil
}

// Voltage returns the value of the "voltage" field in the mutation.
func (m *ExchangeMutation) Voltage() (r float64, exists bool) {
	v := m.voltage
	if v == nil {
		return
	}
	return *v, true
}

// OldVoltage returns the old "voltage" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldVoltage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoltage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoltage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoltage: %w", err)
	}
	return oldValue.Voltage, nil
}

// AddVoltage adds f to the "voltage" field.
func (m *ExchangeMutation) AddVoltage(f float64) {
	if m.addvoltage != nil {
		*m.addvoltage += f
	} else {
		m.addvoltage = &f
	}
}

// AddedVoltage returns the value that was added to the "voltage" field in this mutation.
func (m *ExchangeMutation) AddedVoltage() (r float64, exists bool) {
	v := m.addvoltage
	if v == nil {
		return
	}
	return *v, true
}

// ResetVoltage resets all changes to the "voltage" field.
func (m *ExchangeMutation) ResetVoltage() {
	m.voltage = nil
	m.addvoltage = nil
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *ExchangeMutation) ClearSubscribe() {
	m.clearedsubscribe = true
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *ExchangeMutation) SubscribeCleared() bool {
	return m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *ExchangeMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *ExchangeMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *ExchangeMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *ExchangeMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *ExchangeMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *ExchangeMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearStore clears the "store" edge to the Store entity.
func (m *ExchangeMutation) ClearStore() {
	m.clearedstore = true
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *ExchangeMutation) StoreCleared() bool {
	return m.StoreIDCleared() || m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *ExchangeMutation) StoreIDs() (ids []uint64) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *ExchangeMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *ExchangeMutation) ClearEnterprise() {
	m.clearedenterprise = true
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *ExchangeMutation) EnterpriseCleared() bool {
	return m.EnterpriseIDCleared() || m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *ExchangeMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *ExchangeMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// ClearStation clears the "station" edge to the EnterpriseStation entity.
func (m *ExchangeMutation) ClearStation() {
	m.clearedstation = true
}

// StationCleared reports if the "station" edge to the EnterpriseStation entity was cleared.
func (m *ExchangeMutation) StationCleared() bool {
	return m.StationIDCleared() || m.clearedstation
}

// StationIDs returns the "station" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StationID instead. It exists only for internal usage by the builders.
func (m *ExchangeMutation) StationIDs() (ids []uint64) {
	if id := m.station; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStation resets all changes to the "station" edge.
func (m *ExchangeMutation) ResetStation() {
	m.station = nil
	m.clearedstation = false
}

// ClearCabinet clears the "cabinet" edge to the Cabinet entity.
func (m *ExchangeMutation) ClearCabinet() {
	m.clearedcabinet = true
}

// CabinetCleared reports if the "cabinet" edge to the Cabinet entity was cleared.
func (m *ExchangeMutation) CabinetCleared() bool {
	return m.CabinetIDCleared() || m.clearedcabinet
}

// CabinetIDs returns the "cabinet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CabinetID instead. It exists only for internal usage by the builders.
func (m *ExchangeMutation) CabinetIDs() (ids []uint64) {
	if id := m.cabinet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCabinet resets all changes to the "cabinet" edge.
func (m *ExchangeMutation) ResetCabinet() {
	m.cabinet = nil
	m.clearedcabinet = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *ExchangeMutation) ClearRider() {
	m.clearedrider = true
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *ExchangeMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *ExchangeMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *ExchangeMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *ExchangeMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *ExchangeMutation) EmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *ExchangeMutation) EmployeeIDs() (ids []uint64) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *ExchangeMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// Where appends a list predicates to the ExchangeMutation builder.
func (m *ExchangeMutation) Where(ps ...predicate.Exchange) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ExchangeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Exchange).
func (m *ExchangeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExchangeMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, exchange.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, exchange.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, exchange.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, exchange.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, exchange.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, exchange.FieldRemark)
	}
	if m.subscribe != nil {
		fields = append(fields, exchange.FieldSubscribeID)
	}
	if m.city != nil {
		fields = append(fields, exchange.FieldCityID)
	}
	if m.store != nil {
		fields = append(fields, exchange.FieldStoreID)
	}
	if m.enterprise != nil {
		fields = append(fields, exchange.FieldEnterpriseID)
	}
	if m.station != nil {
		fields = append(fields, exchange.FieldStationID)
	}
	if m.rider != nil {
		fields = append(fields, exchange.FieldRiderID)
	}
	if m.employee != nil {
		fields = append(fields, exchange.FieldEmployeeID)
	}
	if m.uuid != nil {
		fields = append(fields, exchange.FieldUUID)
	}
	if m.cabinet != nil {
		fields = append(fields, exchange.FieldCabinetID)
	}
	if m.success != nil {
		fields = append(fields, exchange.FieldSuccess)
	}
	if m.detail != nil {
		fields = append(fields, exchange.FieldDetail)
	}
	if m.voltage != nil {
		fields = append(fields, exchange.FieldVoltage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExchangeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exchange.FieldCreatedAt:
		return m.CreatedAt()
	case exchange.FieldUpdatedAt:
		return m.UpdatedAt()
	case exchange.FieldDeletedAt:
		return m.DeletedAt()
	case exchange.FieldCreator:
		return m.Creator()
	case exchange.FieldLastModifier:
		return m.LastModifier()
	case exchange.FieldRemark:
		return m.Remark()
	case exchange.FieldSubscribeID:
		return m.SubscribeID()
	case exchange.FieldCityID:
		return m.CityID()
	case exchange.FieldStoreID:
		return m.StoreID()
	case exchange.FieldEnterpriseID:
		return m.EnterpriseID()
	case exchange.FieldStationID:
		return m.StationID()
	case exchange.FieldRiderID:
		return m.RiderID()
	case exchange.FieldEmployeeID:
		return m.EmployeeID()
	case exchange.FieldUUID:
		return m.UUID()
	case exchange.FieldCabinetID:
		return m.CabinetID()
	case exchange.FieldSuccess:
		return m.Success()
	case exchange.FieldDetail:
		return m.Detail()
	case exchange.FieldVoltage:
		return m.Voltage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExchangeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exchange.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case exchange.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case exchange.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case exchange.FieldCreator:
		return m.OldCreator(ctx)
	case exchange.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case exchange.FieldRemark:
		return m.OldRemark(ctx)
	case exchange.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case exchange.FieldCityID:
		return m.OldCityID(ctx)
	case exchange.FieldStoreID:
		return m.OldStoreID(ctx)
	case exchange.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case exchange.FieldStationID:
		return m.OldStationID(ctx)
	case exchange.FieldRiderID:
		return m.OldRiderID(ctx)
	case exchange.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case exchange.FieldUUID:
		return m.OldUUID(ctx)
	case exchange.FieldCabinetID:
		return m.OldCabinetID(ctx)
	case exchange.FieldSuccess:
		return m.OldSuccess(ctx)
	case exchange.FieldDetail:
		return m.OldDetail(ctx)
	case exchange.FieldVoltage:
		return m.OldVoltage(ctx)
	}
	return nil, fmt.Errorf("unknown Exchange field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exchange.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case exchange.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case exchange.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case exchange.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case exchange.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case exchange.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case exchange.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case exchange.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case exchange.FieldStoreID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case exchange.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case exchange.FieldStationID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStationID(v)
		return nil
	case exchange.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case exchange.FieldEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case exchange.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case exchange.FieldCabinetID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCabinetID(v)
		return nil
	case exchange.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case exchange.FieldDetail:
		v, ok := value.(*model.ExchangeCabinet)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case exchange.FieldVoltage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoltage(v)
		return nil
	}
	return fmt.Errorf("unknown Exchange field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExchangeMutation) AddedFields() []string {
	var fields []string
	if m.addvoltage != nil {
		fields = append(fields, exchange.FieldVoltage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExchangeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case exchange.FieldVoltage:
		return m.AddedVoltage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case exchange.FieldVoltage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVoltage(v)
		return nil
	}
	return fmt.Errorf("unknown Exchange numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExchangeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exchange.FieldDeletedAt) {
		fields = append(fields, exchange.FieldDeletedAt)
	}
	if m.FieldCleared(exchange.FieldCreator) {
		fields = append(fields, exchange.FieldCreator)
	}
	if m.FieldCleared(exchange.FieldLastModifier) {
		fields = append(fields, exchange.FieldLastModifier)
	}
	if m.FieldCleared(exchange.FieldRemark) {
		fields = append(fields, exchange.FieldRemark)
	}
	if m.FieldCleared(exchange.FieldStoreID) {
		fields = append(fields, exchange.FieldStoreID)
	}
	if m.FieldCleared(exchange.FieldEnterpriseID) {
		fields = append(fields, exchange.FieldEnterpriseID)
	}
	if m.FieldCleared(exchange.FieldStationID) {
		fields = append(fields, exchange.FieldStationID)
	}
	if m.FieldCleared(exchange.FieldEmployeeID) {
		fields = append(fields, exchange.FieldEmployeeID)
	}
	if m.FieldCleared(exchange.FieldCabinetID) {
		fields = append(fields, exchange.FieldCabinetID)
	}
	if m.FieldCleared(exchange.FieldDetail) {
		fields = append(fields, exchange.FieldDetail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExchangeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExchangeMutation) ClearField(name string) error {
	switch name {
	case exchange.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case exchange.FieldCreator:
		m.ClearCreator()
		return nil
	case exchange.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case exchange.FieldRemark:
		m.ClearRemark()
		return nil
	case exchange.FieldStoreID:
		m.ClearStoreID()
		return nil
	case exchange.FieldEnterpriseID:
		m.ClearEnterpriseID()
		return nil
	case exchange.FieldStationID:
		m.ClearStationID()
		return nil
	case exchange.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case exchange.FieldCabinetID:
		m.ClearCabinetID()
		return nil
	case exchange.FieldDetail:
		m.ClearDetail()
		return nil
	}
	return fmt.Errorf("unknown Exchange nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExchangeMutation) ResetField(name string) error {
	switch name {
	case exchange.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case exchange.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case exchange.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case exchange.FieldCreator:
		m.ResetCreator()
		return nil
	case exchange.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case exchange.FieldRemark:
		m.ResetRemark()
		return nil
	case exchange.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case exchange.FieldCityID:
		m.ResetCityID()
		return nil
	case exchange.FieldStoreID:
		m.ResetStoreID()
		return nil
	case exchange.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case exchange.FieldStationID:
		m.ResetStationID()
		return nil
	case exchange.FieldRiderID:
		m.ResetRiderID()
		return nil
	case exchange.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case exchange.FieldUUID:
		m.ResetUUID()
		return nil
	case exchange.FieldCabinetID:
		m.ResetCabinetID()
		return nil
	case exchange.FieldSuccess:
		m.ResetSuccess()
		return nil
	case exchange.FieldDetail:
		m.ResetDetail()
		return nil
	case exchange.FieldVoltage:
		m.ResetVoltage()
		return nil
	}
	return fmt.Errorf("unknown Exchange field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExchangeMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.subscribe != nil {
		edges = append(edges, exchange.EdgeSubscribe)
	}
	if m.city != nil {
		edges = append(edges, exchange.EdgeCity)
	}
	if m.store != nil {
		edges = append(edges, exchange.EdgeStore)
	}
	if m.enterprise != nil {
		edges = append(edges, exchange.EdgeEnterprise)
	}
	if m.station != nil {
		edges = append(edges, exchange.EdgeStation)
	}
	if m.cabinet != nil {
		edges = append(edges, exchange.EdgeCabinet)
	}
	if m.rider != nil {
		edges = append(edges, exchange.EdgeRider)
	}
	if m.employee != nil {
		edges = append(edges, exchange.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExchangeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exchange.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	case exchange.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case exchange.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	case exchange.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	case exchange.EdgeStation:
		if id := m.station; id != nil {
			return []ent.Value{*id}
		}
	case exchange.EdgeCabinet:
		if id := m.cabinet; id != nil {
			return []ent.Value{*id}
		}
	case exchange.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case exchange.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExchangeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExchangeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExchangeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedsubscribe {
		edges = append(edges, exchange.EdgeSubscribe)
	}
	if m.clearedcity {
		edges = append(edges, exchange.EdgeCity)
	}
	if m.clearedstore {
		edges = append(edges, exchange.EdgeStore)
	}
	if m.clearedenterprise {
		edges = append(edges, exchange.EdgeEnterprise)
	}
	if m.clearedstation {
		edges = append(edges, exchange.EdgeStation)
	}
	if m.clearedcabinet {
		edges = append(edges, exchange.EdgeCabinet)
	}
	if m.clearedrider {
		edges = append(edges, exchange.EdgeRider)
	}
	if m.clearedemployee {
		edges = append(edges, exchange.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExchangeMutation) EdgeCleared(name string) bool {
	switch name {
	case exchange.EdgeSubscribe:
		return m.clearedsubscribe
	case exchange.EdgeCity:
		return m.clearedcity
	case exchange.EdgeStore:
		return m.clearedstore
	case exchange.EdgeEnterprise:
		return m.clearedenterprise
	case exchange.EdgeStation:
		return m.clearedstation
	case exchange.EdgeCabinet:
		return m.clearedcabinet
	case exchange.EdgeRider:
		return m.clearedrider
	case exchange.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExchangeMutation) ClearEdge(name string) error {
	switch name {
	case exchange.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	case exchange.EdgeCity:
		m.ClearCity()
		return nil
	case exchange.EdgeStore:
		m.ClearStore()
		return nil
	case exchange.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	case exchange.EdgeStation:
		m.ClearStation()
		return nil
	case exchange.EdgeCabinet:
		m.ClearCabinet()
		return nil
	case exchange.EdgeRider:
		m.ClearRider()
		return nil
	case exchange.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown Exchange unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExchangeMutation) ResetEdge(name string) error {
	switch name {
	case exchange.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	case exchange.EdgeCity:
		m.ResetCity()
		return nil
	case exchange.EdgeStore:
		m.ResetStore()
		return nil
	case exchange.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	case exchange.EdgeStation:
		m.ResetStation()
		return nil
	case exchange.EdgeCabinet:
		m.ResetCabinet()
		return nil
	case exchange.EdgeRider:
		m.ResetRider()
		return nil
	case exchange.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Exchange edge %s", name)
}

// InventoryMutation represents an operation that mutates the Inventory nodes in the graph.
type InventoryMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	creator       **model.Modifier
	last_modifier **model.Modifier
	remark        *string
	name          *string
	count         *bool
	transfer      *bool
	purchase      *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Inventory, error)
	predicates    []predicate.Inventory
}

var _ ent.Mutation = (*InventoryMutation)(nil)

// inventoryOption allows management of the mutation configuration using functional options.
type inventoryOption func(*InventoryMutation)

// newInventoryMutation creates new mutation for the Inventory entity.
func newInventoryMutation(c config, op Op, opts ...inventoryOption) *InventoryMutation {
	m := &InventoryMutation{
		config:        c,
		op:            op,
		typ:           TypeInventory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInventoryID sets the ID field of the mutation.
func withInventoryID(id uint64) inventoryOption {
	return func(m *InventoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Inventory
		)
		m.oldValue = func(ctx context.Context) (*Inventory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Inventory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInventory sets the old Inventory of the mutation.
func withInventory(node *Inventory) inventoryOption {
	return func(m *InventoryMutation) {
		m.oldValue = func(context.Context) (*Inventory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InventoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InventoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InventoryMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InventoryMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Inventory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InventoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InventoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InventoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InventoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InventoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InventoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InventoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InventoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *InventoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[inventory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *InventoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[inventory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InventoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, inventory.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *InventoryMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *InventoryMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *InventoryMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[inventory.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *InventoryMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[inventory.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *InventoryMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, inventory.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *InventoryMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *InventoryMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *InventoryMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[inventory.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *InventoryMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[inventory.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *InventoryMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, inventory.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *InventoryMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *InventoryMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *InventoryMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[inventory.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *InventoryMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[inventory.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *InventoryMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, inventory.FieldRemark)
}

// SetName sets the "name" field.
func (m *InventoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InventoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *InventoryMutation) ResetName() {
	m.name = nil
}

// SetCount sets the "count" field.
func (m *InventoryMutation) SetCount(b bool) {
	m.count = &b
}

// Count returns the value of the "count" field in the mutation.
func (m *InventoryMutation) Count() (r bool, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldCount(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// ResetCount resets all changes to the "count" field.
func (m *InventoryMutation) ResetCount() {
	m.count = nil
}

// SetTransfer sets the "transfer" field.
func (m *InventoryMutation) SetTransfer(b bool) {
	m.transfer = &b
}

// Transfer returns the value of the "transfer" field in the mutation.
func (m *InventoryMutation) Transfer() (r bool, exists bool) {
	v := m.transfer
	if v == nil {
		return
	}
	return *v, true
}

// OldTransfer returns the old "transfer" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldTransfer(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransfer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransfer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransfer: %w", err)
	}
	return oldValue.Transfer, nil
}

// ResetTransfer resets all changes to the "transfer" field.
func (m *InventoryMutation) ResetTransfer() {
	m.transfer = nil
}

// SetPurchase sets the "purchase" field.
func (m *InventoryMutation) SetPurchase(b bool) {
	m.purchase = &b
}

// Purchase returns the value of the "purchase" field in the mutation.
func (m *InventoryMutation) Purchase() (r bool, exists bool) {
	v := m.purchase
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchase returns the old "purchase" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldPurchase(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchase is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchase requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchase: %w", err)
	}
	return oldValue.Purchase, nil
}

// ResetPurchase resets all changes to the "purchase" field.
func (m *InventoryMutation) ResetPurchase() {
	m.purchase = nil
}

// Where appends a list predicates to the InventoryMutation builder.
func (m *InventoryMutation) Where(ps ...predicate.Inventory) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InventoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Inventory).
func (m *InventoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InventoryMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, inventory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, inventory.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, inventory.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, inventory.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, inventory.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, inventory.FieldRemark)
	}
	if m.name != nil {
		fields = append(fields, inventory.FieldName)
	}
	if m.count != nil {
		fields = append(fields, inventory.FieldCount)
	}
	if m.transfer != nil {
		fields = append(fields, inventory.FieldTransfer)
	}
	if m.purchase != nil {
		fields = append(fields, inventory.FieldPurchase)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InventoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inventory.FieldCreatedAt:
		return m.CreatedAt()
	case inventory.FieldUpdatedAt:
		return m.UpdatedAt()
	case inventory.FieldDeletedAt:
		return m.DeletedAt()
	case inventory.FieldCreator:
		return m.Creator()
	case inventory.FieldLastModifier:
		return m.LastModifier()
	case inventory.FieldRemark:
		return m.Remark()
	case inventory.FieldName:
		return m.Name()
	case inventory.FieldCount:
		return m.Count()
	case inventory.FieldTransfer:
		return m.Transfer()
	case inventory.FieldPurchase:
		return m.Purchase()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InventoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inventory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case inventory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case inventory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case inventory.FieldCreator:
		return m.OldCreator(ctx)
	case inventory.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case inventory.FieldRemark:
		return m.OldRemark(ctx)
	case inventory.FieldName:
		return m.OldName(ctx)
	case inventory.FieldCount:
		return m.OldCount(ctx)
	case inventory.FieldTransfer:
		return m.OldTransfer(ctx)
	case inventory.FieldPurchase:
		return m.OldPurchase(ctx)
	}
	return nil, fmt.Errorf("unknown Inventory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inventory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case inventory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case inventory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case inventory.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case inventory.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case inventory.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case inventory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case inventory.FieldCount:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case inventory.FieldTransfer:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransfer(v)
		return nil
	case inventory.FieldPurchase:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchase(v)
		return nil
	}
	return fmt.Errorf("unknown Inventory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InventoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InventoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Inventory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InventoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inventory.FieldDeletedAt) {
		fields = append(fields, inventory.FieldDeletedAt)
	}
	if m.FieldCleared(inventory.FieldCreator) {
		fields = append(fields, inventory.FieldCreator)
	}
	if m.FieldCleared(inventory.FieldLastModifier) {
		fields = append(fields, inventory.FieldLastModifier)
	}
	if m.FieldCleared(inventory.FieldRemark) {
		fields = append(fields, inventory.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InventoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InventoryMutation) ClearField(name string) error {
	switch name {
	case inventory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case inventory.FieldCreator:
		m.ClearCreator()
		return nil
	case inventory.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case inventory.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Inventory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InventoryMutation) ResetField(name string) error {
	switch name {
	case inventory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case inventory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case inventory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case inventory.FieldCreator:
		m.ResetCreator()
		return nil
	case inventory.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case inventory.FieldRemark:
		m.ResetRemark()
		return nil
	case inventory.FieldName:
		m.ResetName()
		return nil
	case inventory.FieldCount:
		m.ResetCount()
		return nil
	case inventory.FieldTransfer:
		m.ResetTransfer()
		return nil
	case inventory.FieldPurchase:
		m.ResetPurchase()
		return nil
	}
	return fmt.Errorf("unknown Inventory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InventoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InventoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InventoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InventoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InventoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InventoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InventoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Inventory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InventoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Inventory edge %s", name)
}

// ManagerMutation represents an operation that mutates the Manager nodes in the graph.
type ManagerMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	creator        **model.Modifier
	last_modifier  **model.Modifier
	remark         *string
	phone          *string
	name           *string
	password       *string
	last_signin_at *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Manager, error)
	predicates     []predicate.Manager
}

var _ ent.Mutation = (*ManagerMutation)(nil)

// managerOption allows management of the mutation configuration using functional options.
type managerOption func(*ManagerMutation)

// newManagerMutation creates new mutation for the Manager entity.
func newManagerMutation(c config, op Op, opts ...managerOption) *ManagerMutation {
	m := &ManagerMutation{
		config:        c,
		op:            op,
		typ:           TypeManager,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withManagerID sets the ID field of the mutation.
func withManagerID(id uint64) managerOption {
	return func(m *ManagerMutation) {
		var (
			err   error
			once  sync.Once
			value *Manager
		)
		m.oldValue = func(ctx context.Context) (*Manager, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Manager.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withManager sets the old Manager of the mutation.
func withManager(node *Manager) managerOption {
	return func(m *ManagerMutation) {
		m.oldValue = func(context.Context) (*Manager, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ManagerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ManagerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ManagerMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ManagerMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Manager.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ManagerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ManagerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ManagerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ManagerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ManagerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ManagerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ManagerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ManagerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ManagerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[manager.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ManagerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[manager.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ManagerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, manager.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *ManagerMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *ManagerMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *ManagerMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[manager.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *ManagerMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[manager.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *ManagerMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, manager.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *ManagerMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *ManagerMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *ManagerMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[manager.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *ManagerMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[manager.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *ManagerMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, manager.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *ManagerMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ManagerMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ManagerMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[manager.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ManagerMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[manager.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ManagerMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, manager.FieldRemark)
}

// SetPhone sets the "phone" field.
func (m *ManagerMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *ManagerMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *ManagerMutation) ResetPhone() {
	m.phone = nil
}

// SetName sets the "name" field.
func (m *ManagerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ManagerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ManagerMutation) ResetName() {
	m.name = nil
}

// SetPassword sets the "password" field.
func (m *ManagerMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *ManagerMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *ManagerMutation) ResetPassword() {
	m.password = nil
}

// SetLastSigninAt sets the "last_signin_at" field.
func (m *ManagerMutation) SetLastSigninAt(t time.Time) {
	m.last_signin_at = &t
}

// LastSigninAt returns the value of the "last_signin_at" field in the mutation.
func (m *ManagerMutation) LastSigninAt() (r time.Time, exists bool) {
	v := m.last_signin_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSigninAt returns the old "last_signin_at" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldLastSigninAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSigninAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSigninAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSigninAt: %w", err)
	}
	return oldValue.LastSigninAt, nil
}

// ClearLastSigninAt clears the value of the "last_signin_at" field.
func (m *ManagerMutation) ClearLastSigninAt() {
	m.last_signin_at = nil
	m.clearedFields[manager.FieldLastSigninAt] = struct{}{}
}

// LastSigninAtCleared returns if the "last_signin_at" field was cleared in this mutation.
func (m *ManagerMutation) LastSigninAtCleared() bool {
	_, ok := m.clearedFields[manager.FieldLastSigninAt]
	return ok
}

// ResetLastSigninAt resets all changes to the "last_signin_at" field.
func (m *ManagerMutation) ResetLastSigninAt() {
	m.last_signin_at = nil
	delete(m.clearedFields, manager.FieldLastSigninAt)
}

// Where appends a list predicates to the ManagerMutation builder.
func (m *ManagerMutation) Where(ps ...predicate.Manager) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ManagerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Manager).
func (m *ManagerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ManagerMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, manager.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, manager.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, manager.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, manager.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, manager.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, manager.FieldRemark)
	}
	if m.phone != nil {
		fields = append(fields, manager.FieldPhone)
	}
	if m.name != nil {
		fields = append(fields, manager.FieldName)
	}
	if m.password != nil {
		fields = append(fields, manager.FieldPassword)
	}
	if m.last_signin_at != nil {
		fields = append(fields, manager.FieldLastSigninAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ManagerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case manager.FieldCreatedAt:
		return m.CreatedAt()
	case manager.FieldUpdatedAt:
		return m.UpdatedAt()
	case manager.FieldDeletedAt:
		return m.DeletedAt()
	case manager.FieldCreator:
		return m.Creator()
	case manager.FieldLastModifier:
		return m.LastModifier()
	case manager.FieldRemark:
		return m.Remark()
	case manager.FieldPhone:
		return m.Phone()
	case manager.FieldName:
		return m.Name()
	case manager.FieldPassword:
		return m.Password()
	case manager.FieldLastSigninAt:
		return m.LastSigninAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ManagerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case manager.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case manager.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case manager.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case manager.FieldCreator:
		return m.OldCreator(ctx)
	case manager.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case manager.FieldRemark:
		return m.OldRemark(ctx)
	case manager.FieldPhone:
		return m.OldPhone(ctx)
	case manager.FieldName:
		return m.OldName(ctx)
	case manager.FieldPassword:
		return m.OldPassword(ctx)
	case manager.FieldLastSigninAt:
		return m.OldLastSigninAt(ctx)
	}
	return nil, fmt.Errorf("unknown Manager field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ManagerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case manager.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case manager.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case manager.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case manager.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case manager.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case manager.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case manager.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case manager.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case manager.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case manager.FieldLastSigninAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSigninAt(v)
		return nil
	}
	return fmt.Errorf("unknown Manager field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ManagerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ManagerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ManagerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Manager numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ManagerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(manager.FieldDeletedAt) {
		fields = append(fields, manager.FieldDeletedAt)
	}
	if m.FieldCleared(manager.FieldCreator) {
		fields = append(fields, manager.FieldCreator)
	}
	if m.FieldCleared(manager.FieldLastModifier) {
		fields = append(fields, manager.FieldLastModifier)
	}
	if m.FieldCleared(manager.FieldRemark) {
		fields = append(fields, manager.FieldRemark)
	}
	if m.FieldCleared(manager.FieldLastSigninAt) {
		fields = append(fields, manager.FieldLastSigninAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ManagerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ManagerMutation) ClearField(name string) error {
	switch name {
	case manager.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case manager.FieldCreator:
		m.ClearCreator()
		return nil
	case manager.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case manager.FieldRemark:
		m.ClearRemark()
		return nil
	case manager.FieldLastSigninAt:
		m.ClearLastSigninAt()
		return nil
	}
	return fmt.Errorf("unknown Manager nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ManagerMutation) ResetField(name string) error {
	switch name {
	case manager.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case manager.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case manager.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case manager.FieldCreator:
		m.ResetCreator()
		return nil
	case manager.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case manager.FieldRemark:
		m.ResetRemark()
		return nil
	case manager.FieldPhone:
		m.ResetPhone()
		return nil
	case manager.FieldName:
		m.ResetName()
		return nil
	case manager.FieldPassword:
		m.ResetPassword()
		return nil
	case manager.FieldLastSigninAt:
		m.ResetLastSigninAt()
		return nil
	}
	return fmt.Errorf("unknown Manager field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ManagerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ManagerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ManagerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ManagerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ManagerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ManagerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ManagerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Manager unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ManagerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Manager edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	status            *uint8
	addstatus         *int8
	payway            *uint8
	addpayway         *int8
	_type             *uint
	add_type          *int
	out_trade_no      *string
	trade_no          *string
	amount            *float64
	addamount         *float64
	total             *float64
	addtotal          *float64
	refund_at         *time.Time
	initial_days      *int
	addinitial_days   *int
	clearedFields     map[string]struct{}
	plan              *uint64
	clearedplan       bool
	city              *uint64
	clearedcity       bool
	rider             *uint64
	clearedrider      bool
	subscribe         *uint64
	clearedsubscribe  bool
	commission        *uint64
	clearedcommission bool
	parent            *uint64
	clearedparent     bool
	children          map[uint64]struct{}
	removedchildren   map[uint64]struct{}
	clearedchildren   bool
	refund            *uint64
	clearedrefund     bool
	done              bool
	oldValue          func(context.Context) (*Order, error)
	predicates        []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id uint64) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrderMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[order.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrderMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[order.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, order.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *OrderMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *OrderMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *OrderMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[order.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *OrderMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[order.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *OrderMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, order.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *OrderMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *OrderMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *OrderMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[order.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *OrderMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[order.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *OrderMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, order.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *OrderMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *OrderMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *OrderMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[order.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *OrderMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[order.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *OrderMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, order.FieldRemark)
}

// SetPlanID sets the "plan_id" field.
func (m *OrderMutation) SetPlanID(u uint64) {
	m.plan = &u
}

// PlanID returns the value of the "plan_id" field in the mutation.
func (m *OrderMutation) PlanID() (r uint64, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanID returns the old "plan_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPlanID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanID: %w", err)
	}
	return oldValue.PlanID, nil
}

// ClearPlanID clears the value of the "plan_id" field.
func (m *OrderMutation) ClearPlanID() {
	m.plan = nil
	m.clearedFields[order.FieldPlanID] = struct{}{}
}

// PlanIDCleared returns if the "plan_id" field was cleared in this mutation.
func (m *OrderMutation) PlanIDCleared() bool {
	_, ok := m.clearedFields[order.FieldPlanID]
	return ok
}

// ResetPlanID resets all changes to the "plan_id" field.
func (m *OrderMutation) ResetPlanID() {
	m.plan = nil
	delete(m.clearedFields, order.FieldPlanID)
}

// SetCityID sets the "city_id" field.
func (m *OrderMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *OrderMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCityID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ClearCityID clears the value of the "city_id" field.
func (m *OrderMutation) ClearCityID() {
	m.city = nil
	m.clearedFields[order.FieldCityID] = struct{}{}
}

// CityIDCleared returns if the "city_id" field was cleared in this mutation.
func (m *OrderMutation) CityIDCleared() bool {
	_, ok := m.clearedFields[order.FieldCityID]
	return ok
}

// ResetCityID resets all changes to the "city_id" field.
func (m *OrderMutation) ResetCityID() {
	m.city = nil
	delete(m.clearedFields, order.FieldCityID)
}

// SetRiderID sets the "rider_id" field.
func (m *OrderMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *OrderMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *OrderMutation) ResetRiderID() {
	m.rider = nil
}

// SetParentID sets the "parent_id" field.
func (m *OrderMutation) SetParentID(u uint64) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *OrderMutation) ParentID() (r uint64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldParentID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *OrderMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[order.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *OrderMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[order.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *OrderMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, order.FieldParentID)
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *OrderMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *OrderMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSubscribeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ClearSubscribeID clears the value of the "subscribe_id" field.
func (m *OrderMutation) ClearSubscribeID() {
	m.subscribe = nil
	m.clearedFields[order.FieldSubscribeID] = struct{}{}
}

// SubscribeIDCleared returns if the "subscribe_id" field was cleared in this mutation.
func (m *OrderMutation) SubscribeIDCleared() bool {
	_, ok := m.clearedFields[order.FieldSubscribeID]
	return ok
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *OrderMutation) ResetSubscribeID() {
	m.subscribe = nil
	delete(m.clearedFields, order.FieldSubscribeID)
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *OrderMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OrderMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetPayway sets the "payway" field.
func (m *OrderMutation) SetPayway(u uint8) {
	m.payway = &u
	m.addpayway = nil
}

// Payway returns the value of the "payway" field in the mutation.
func (m *OrderMutation) Payway() (r uint8, exists bool) {
	v := m.payway
	if v == nil {
		return
	}
	return *v, true
}

// OldPayway returns the old "payway" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPayway(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayway: %w", err)
	}
	return oldValue.Payway, nil
}

// AddPayway adds u to the "payway" field.
func (m *OrderMutation) AddPayway(u int8) {
	if m.addpayway != nil {
		*m.addpayway += u
	} else {
		m.addpayway = &u
	}
}

// AddedPayway returns the value that was added to the "payway" field in this mutation.
func (m *OrderMutation) AddedPayway() (r int8, exists bool) {
	v := m.addpayway
	if v == nil {
		return
	}
	return *v, true
}

// ResetPayway resets all changes to the "payway" field.
func (m *OrderMutation) ResetPayway() {
	m.payway = nil
	m.addpayway = nil
}

// SetType sets the "type" field.
func (m *OrderMutation) SetType(u uint) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *OrderMutation) GetType() (r uint, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldType(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *OrderMutation) AddType(u int) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *OrderMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *OrderMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetOutTradeNo sets the "out_trade_no" field.
func (m *OrderMutation) SetOutTradeNo(s string) {
	m.out_trade_no = &s
}

// OutTradeNo returns the value of the "out_trade_no" field in the mutation.
func (m *OrderMutation) OutTradeNo() (r string, exists bool) {
	v := m.out_trade_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOutTradeNo returns the old "out_trade_no" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOutTradeNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutTradeNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutTradeNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutTradeNo: %w", err)
	}
	return oldValue.OutTradeNo, nil
}

// ResetOutTradeNo resets all changes to the "out_trade_no" field.
func (m *OrderMutation) ResetOutTradeNo() {
	m.out_trade_no = nil
}

// SetTradeNo sets the "trade_no" field.
func (m *OrderMutation) SetTradeNo(s string) {
	m.trade_no = &s
}

// TradeNo returns the value of the "trade_no" field in the mutation.
func (m *OrderMutation) TradeNo() (r string, exists bool) {
	v := m.trade_no
	if v == nil {
		return
	}
	return *v, true
}

// OldTradeNo returns the old "trade_no" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTradeNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTradeNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTradeNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTradeNo: %w", err)
	}
	return oldValue.TradeNo, nil
}

// ResetTradeNo resets all changes to the "trade_no" field.
func (m *OrderMutation) ResetTradeNo() {
	m.trade_no = nil
}

// SetAmount sets the "amount" field.
func (m *OrderMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *OrderMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *OrderMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *OrderMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *OrderMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetTotal sets the "total" field.
func (m *OrderMutation) SetTotal(f float64) {
	m.total = &f
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *OrderMutation) Total() (r float64, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTotal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds f to the "total" field.
func (m *OrderMutation) AddTotal(f float64) {
	if m.addtotal != nil {
		*m.addtotal += f
	} else {
		m.addtotal = &f
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *OrderMutation) AddedTotal() (r float64, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotal resets all changes to the "total" field.
func (m *OrderMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
}

// SetRefundAt sets the "refund_at" field.
func (m *OrderMutation) SetRefundAt(t time.Time) {
	m.refund_at = &t
}

// RefundAt returns the value of the "refund_at" field in the mutation.
func (m *OrderMutation) RefundAt() (r time.Time, exists bool) {
	v := m.refund_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundAt returns the old "refund_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldRefundAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundAt: %w", err)
	}
	return oldValue.RefundAt, nil
}

// ClearRefundAt clears the value of the "refund_at" field.
func (m *OrderMutation) ClearRefundAt() {
	m.refund_at = nil
	m.clearedFields[order.FieldRefundAt] = struct{}{}
}

// RefundAtCleared returns if the "refund_at" field was cleared in this mutation.
func (m *OrderMutation) RefundAtCleared() bool {
	_, ok := m.clearedFields[order.FieldRefundAt]
	return ok
}

// ResetRefundAt resets all changes to the "refund_at" field.
func (m *OrderMutation) ResetRefundAt() {
	m.refund_at = nil
	delete(m.clearedFields, order.FieldRefundAt)
}

// SetInitialDays sets the "initial_days" field.
func (m *OrderMutation) SetInitialDays(i int) {
	m.initial_days = &i
	m.addinitial_days = nil
}

// InitialDays returns the value of the "initial_days" field in the mutation.
func (m *OrderMutation) InitialDays() (r int, exists bool) {
	v := m.initial_days
	if v == nil {
		return
	}
	return *v, true
}

// OldInitialDays returns the old "initial_days" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldInitialDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitialDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitialDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitialDays: %w", err)
	}
	return oldValue.InitialDays, nil
}

// AddInitialDays adds i to the "initial_days" field.
func (m *OrderMutation) AddInitialDays(i int) {
	if m.addinitial_days != nil {
		*m.addinitial_days += i
	} else {
		m.addinitial_days = &i
	}
}

// AddedInitialDays returns the value that was added to the "initial_days" field in this mutation.
func (m *OrderMutation) AddedInitialDays() (r int, exists bool) {
	v := m.addinitial_days
	if v == nil {
		return
	}
	return *v, true
}

// ClearInitialDays clears the value of the "initial_days" field.
func (m *OrderMutation) ClearInitialDays() {
	m.initial_days = nil
	m.addinitial_days = nil
	m.clearedFields[order.FieldInitialDays] = struct{}{}
}

// InitialDaysCleared returns if the "initial_days" field was cleared in this mutation.
func (m *OrderMutation) InitialDaysCleared() bool {
	_, ok := m.clearedFields[order.FieldInitialDays]
	return ok
}

// ResetInitialDays resets all changes to the "initial_days" field.
func (m *OrderMutation) ResetInitialDays() {
	m.initial_days = nil
	m.addinitial_days = nil
	delete(m.clearedFields, order.FieldInitialDays)
}

// ClearPlan clears the "plan" edge to the Plan entity.
func (m *OrderMutation) ClearPlan() {
	m.clearedplan = true
}

// PlanCleared reports if the "plan" edge to the Plan entity was cleared.
func (m *OrderMutation) PlanCleared() bool {
	return m.PlanIDCleared() || m.clearedplan
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) PlanIDs() (ids []uint64) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *OrderMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *OrderMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *OrderMutation) CityCleared() bool {
	return m.CityIDCleared() || m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *OrderMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *OrderMutation) ClearRider() {
	m.clearedrider = true
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *OrderMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *OrderMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *OrderMutation) ClearSubscribe() {
	m.clearedsubscribe = true
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *OrderMutation) SubscribeCleared() bool {
	return m.SubscribeIDCleared() || m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *OrderMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// SetCommissionID sets the "commission" edge to the Commission entity by id.
func (m *OrderMutation) SetCommissionID(id uint64) {
	m.commission = &id
}

// ClearCommission clears the "commission" edge to the Commission entity.
func (m *OrderMutation) ClearCommission() {
	m.clearedcommission = true
}

// CommissionCleared reports if the "commission" edge to the Commission entity was cleared.
func (m *OrderMutation) CommissionCleared() bool {
	return m.clearedcommission
}

// CommissionID returns the "commission" edge ID in the mutation.
func (m *OrderMutation) CommissionID() (id uint64, exists bool) {
	if m.commission != nil {
		return *m.commission, true
	}
	return
}

// CommissionIDs returns the "commission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommissionID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) CommissionIDs() (ids []uint64) {
	if id := m.commission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCommission resets all changes to the "commission" edge.
func (m *OrderMutation) ResetCommission() {
	m.commission = nil
	m.clearedcommission = false
}

// ClearParent clears the "parent" edge to the Order entity.
func (m *OrderMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Order entity was cleared.
func (m *OrderMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) ParentIDs() (ids []uint64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OrderMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Order entity by ids.
func (m *OrderMutation) AddChildIDs(ids ...uint64) {
	if m.children == nil {
		m.children = make(map[uint64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Order entity.
func (m *OrderMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Order entity was cleared.
func (m *OrderMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Order entity by IDs.
func (m *OrderMutation) RemoveChildIDs(ids ...uint64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Order entity.
func (m *OrderMutation) RemovedChildrenIDs() (ids []uint64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *OrderMutation) ChildrenIDs() (ids []uint64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *OrderMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// SetRefundID sets the "refund" edge to the OrderRefund entity by id.
func (m *OrderMutation) SetRefundID(id uint64) {
	m.refund = &id
}

// ClearRefund clears the "refund" edge to the OrderRefund entity.
func (m *OrderMutation) ClearRefund() {
	m.clearedrefund = true
}

// RefundCleared reports if the "refund" edge to the OrderRefund entity was cleared.
func (m *OrderMutation) RefundCleared() bool {
	return m.clearedrefund
}

// RefundID returns the "refund" edge ID in the mutation.
func (m *OrderMutation) RefundID() (id uint64, exists bool) {
	if m.refund != nil {
		return *m.refund, true
	}
	return
}

// RefundIDs returns the "refund" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RefundID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) RefundIDs() (ids []uint64) {
	if id := m.refund; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRefund resets all changes to the "refund" edge.
func (m *OrderMutation) ResetRefund() {
	m.refund = nil
	m.clearedrefund = false
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, order.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, order.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, order.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, order.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, order.FieldRemark)
	}
	if m.plan != nil {
		fields = append(fields, order.FieldPlanID)
	}
	if m.city != nil {
		fields = append(fields, order.FieldCityID)
	}
	if m.rider != nil {
		fields = append(fields, order.FieldRiderID)
	}
	if m.parent != nil {
		fields = append(fields, order.FieldParentID)
	}
	if m.subscribe != nil {
		fields = append(fields, order.FieldSubscribeID)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.payway != nil {
		fields = append(fields, order.FieldPayway)
	}
	if m._type != nil {
		fields = append(fields, order.FieldType)
	}
	if m.out_trade_no != nil {
		fields = append(fields, order.FieldOutTradeNo)
	}
	if m.trade_no != nil {
		fields = append(fields, order.FieldTradeNo)
	}
	if m.amount != nil {
		fields = append(fields, order.FieldAmount)
	}
	if m.total != nil {
		fields = append(fields, order.FieldTotal)
	}
	if m.refund_at != nil {
		fields = append(fields, order.FieldRefundAt)
	}
	if m.initial_days != nil {
		fields = append(fields, order.FieldInitialDays)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldUpdatedAt:
		return m.UpdatedAt()
	case order.FieldDeletedAt:
		return m.DeletedAt()
	case order.FieldCreator:
		return m.Creator()
	case order.FieldLastModifier:
		return m.LastModifier()
	case order.FieldRemark:
		return m.Remark()
	case order.FieldPlanID:
		return m.PlanID()
	case order.FieldCityID:
		return m.CityID()
	case order.FieldRiderID:
		return m.RiderID()
	case order.FieldParentID:
		return m.ParentID()
	case order.FieldSubscribeID:
		return m.SubscribeID()
	case order.FieldStatus:
		return m.Status()
	case order.FieldPayway:
		return m.Payway()
	case order.FieldType:
		return m.GetType()
	case order.FieldOutTradeNo:
		return m.OutTradeNo()
	case order.FieldTradeNo:
		return m.TradeNo()
	case order.FieldAmount:
		return m.Amount()
	case order.FieldTotal:
		return m.Total()
	case order.FieldRefundAt:
		return m.RefundAt()
	case order.FieldInitialDays:
		return m.InitialDays()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case order.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case order.FieldCreator:
		return m.OldCreator(ctx)
	case order.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case order.FieldRemark:
		return m.OldRemark(ctx)
	case order.FieldPlanID:
		return m.OldPlanID(ctx)
	case order.FieldCityID:
		return m.OldCityID(ctx)
	case order.FieldRiderID:
		return m.OldRiderID(ctx)
	case order.FieldParentID:
		return m.OldParentID(ctx)
	case order.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	case order.FieldPayway:
		return m.OldPayway(ctx)
	case order.FieldType:
		return m.OldType(ctx)
	case order.FieldOutTradeNo:
		return m.OldOutTradeNo(ctx)
	case order.FieldTradeNo:
		return m.OldTradeNo(ctx)
	case order.FieldAmount:
		return m.OldAmount(ctx)
	case order.FieldTotal:
		return m.OldTotal(ctx)
	case order.FieldRefundAt:
		return m.OldRefundAt(ctx)
	case order.FieldInitialDays:
		return m.OldInitialDays(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case order.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case order.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case order.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case order.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case order.FieldPlanID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanID(v)
		return nil
	case order.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case order.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case order.FieldParentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case order.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case order.FieldPayway:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayway(v)
		return nil
	case order.FieldType:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case order.FieldOutTradeNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutTradeNo(v)
		return nil
	case order.FieldTradeNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTradeNo(v)
		return nil
	case order.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case order.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case order.FieldRefundAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundAt(v)
		return nil
	case order.FieldInitialDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitialDays(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.addpayway != nil {
		fields = append(fields, order.FieldPayway)
	}
	if m.add_type != nil {
		fields = append(fields, order.FieldType)
	}
	if m.addamount != nil {
		fields = append(fields, order.FieldAmount)
	}
	if m.addtotal != nil {
		fields = append(fields, order.FieldTotal)
	}
	if m.addinitial_days != nil {
		fields = append(fields, order.FieldInitialDays)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldStatus:
		return m.AddedStatus()
	case order.FieldPayway:
		return m.AddedPayway()
	case order.FieldType:
		return m.AddedType()
	case order.FieldAmount:
		return m.AddedAmount()
	case order.FieldTotal:
		return m.AddedTotal()
	case order.FieldInitialDays:
		return m.AddedInitialDays()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case order.FieldPayway:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayway(v)
		return nil
	case order.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case order.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case order.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	case order.FieldInitialDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInitialDays(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldDeletedAt) {
		fields = append(fields, order.FieldDeletedAt)
	}
	if m.FieldCleared(order.FieldCreator) {
		fields = append(fields, order.FieldCreator)
	}
	if m.FieldCleared(order.FieldLastModifier) {
		fields = append(fields, order.FieldLastModifier)
	}
	if m.FieldCleared(order.FieldRemark) {
		fields = append(fields, order.FieldRemark)
	}
	if m.FieldCleared(order.FieldPlanID) {
		fields = append(fields, order.FieldPlanID)
	}
	if m.FieldCleared(order.FieldCityID) {
		fields = append(fields, order.FieldCityID)
	}
	if m.FieldCleared(order.FieldParentID) {
		fields = append(fields, order.FieldParentID)
	}
	if m.FieldCleared(order.FieldSubscribeID) {
		fields = append(fields, order.FieldSubscribeID)
	}
	if m.FieldCleared(order.FieldRefundAt) {
		fields = append(fields, order.FieldRefundAt)
	}
	if m.FieldCleared(order.FieldInitialDays) {
		fields = append(fields, order.FieldInitialDays)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case order.FieldCreator:
		m.ClearCreator()
		return nil
	case order.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case order.FieldRemark:
		m.ClearRemark()
		return nil
	case order.FieldPlanID:
		m.ClearPlanID()
		return nil
	case order.FieldCityID:
		m.ClearCityID()
		return nil
	case order.FieldParentID:
		m.ClearParentID()
		return nil
	case order.FieldSubscribeID:
		m.ClearSubscribeID()
		return nil
	case order.FieldRefundAt:
		m.ClearRefundAt()
		return nil
	case order.FieldInitialDays:
		m.ClearInitialDays()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case order.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case order.FieldCreator:
		m.ResetCreator()
		return nil
	case order.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case order.FieldRemark:
		m.ResetRemark()
		return nil
	case order.FieldPlanID:
		m.ResetPlanID()
		return nil
	case order.FieldCityID:
		m.ResetCityID()
		return nil
	case order.FieldRiderID:
		m.ResetRiderID()
		return nil
	case order.FieldParentID:
		m.ResetParentID()
		return nil
	case order.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	case order.FieldPayway:
		m.ResetPayway()
		return nil
	case order.FieldType:
		m.ResetType()
		return nil
	case order.FieldOutTradeNo:
		m.ResetOutTradeNo()
		return nil
	case order.FieldTradeNo:
		m.ResetTradeNo()
		return nil
	case order.FieldAmount:
		m.ResetAmount()
		return nil
	case order.FieldTotal:
		m.ResetTotal()
		return nil
	case order.FieldRefundAt:
		m.ResetRefundAt()
		return nil
	case order.FieldInitialDays:
		m.ResetInitialDays()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.plan != nil {
		edges = append(edges, order.EdgePlan)
	}
	if m.city != nil {
		edges = append(edges, order.EdgeCity)
	}
	if m.rider != nil {
		edges = append(edges, order.EdgeRider)
	}
	if m.subscribe != nil {
		edges = append(edges, order.EdgeSubscribe)
	}
	if m.commission != nil {
		edges = append(edges, order.EdgeCommission)
	}
	if m.parent != nil {
		edges = append(edges, order.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, order.EdgeChildren)
	}
	if m.refund != nil {
		edges = append(edges, order.EdgeRefund)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeCommission:
		if id := m.commission; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeRefund:
		if id := m.refund; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedchildren != nil {
		edges = append(edges, order.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedplan {
		edges = append(edges, order.EdgePlan)
	}
	if m.clearedcity {
		edges = append(edges, order.EdgeCity)
	}
	if m.clearedrider {
		edges = append(edges, order.EdgeRider)
	}
	if m.clearedsubscribe {
		edges = append(edges, order.EdgeSubscribe)
	}
	if m.clearedcommission {
		edges = append(edges, order.EdgeCommission)
	}
	if m.clearedparent {
		edges = append(edges, order.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, order.EdgeChildren)
	}
	if m.clearedrefund {
		edges = append(edges, order.EdgeRefund)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgePlan:
		return m.clearedplan
	case order.EdgeCity:
		return m.clearedcity
	case order.EdgeRider:
		return m.clearedrider
	case order.EdgeSubscribe:
		return m.clearedsubscribe
	case order.EdgeCommission:
		return m.clearedcommission
	case order.EdgeParent:
		return m.clearedparent
	case order.EdgeChildren:
		return m.clearedchildren
	case order.EdgeRefund:
		return m.clearedrefund
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgePlan:
		m.ClearPlan()
		return nil
	case order.EdgeCity:
		m.ClearCity()
		return nil
	case order.EdgeRider:
		m.ClearRider()
		return nil
	case order.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	case order.EdgeCommission:
		m.ClearCommission()
		return nil
	case order.EdgeParent:
		m.ClearParent()
		return nil
	case order.EdgeRefund:
		m.ClearRefund()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgePlan:
		m.ResetPlan()
		return nil
	case order.EdgeCity:
		m.ResetCity()
		return nil
	case order.EdgeRider:
		m.ResetRider()
		return nil
	case order.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	case order.EdgeCommission:
		m.ResetCommission()
		return nil
	case order.EdgeParent:
		m.ResetParent()
		return nil
	case order.EdgeChildren:
		m.ResetChildren()
		return nil
	case order.EdgeRefund:
		m.ResetRefund()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderRefundMutation represents an operation that mutates the OrderRefund nodes in the graph.
type OrderRefundMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	creator       **model.Modifier
	last_modifier **model.Modifier
	remark        *string
	status        *uint8
	addstatus     *int8
	amount        *float64
	addamount     *float64
	out_refund_no *string
	reason        *string
	refund_at     *time.Time
	clearedFields map[string]struct{}
	_order        *uint64
	cleared_order bool
	done          bool
	oldValue      func(context.Context) (*OrderRefund, error)
	predicates    []predicate.OrderRefund
}

var _ ent.Mutation = (*OrderRefundMutation)(nil)

// orderrefundOption allows management of the mutation configuration using functional options.
type orderrefundOption func(*OrderRefundMutation)

// newOrderRefundMutation creates new mutation for the OrderRefund entity.
func newOrderRefundMutation(c config, op Op, opts ...orderrefundOption) *OrderRefundMutation {
	m := &OrderRefundMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderRefund,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderRefundID sets the ID field of the mutation.
func withOrderRefundID(id uint64) orderrefundOption {
	return func(m *OrderRefundMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderRefund
		)
		m.oldValue = func(ctx context.Context) (*OrderRefund, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderRefund.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderRefund sets the old OrderRefund of the mutation.
func withOrderRefund(node *OrderRefund) orderrefundOption {
	return func(m *OrderRefundMutation) {
		m.oldValue = func(context.Context) (*OrderRefund, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderRefundMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderRefundMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderRefundMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderRefundMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderRefund.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderRefundMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderRefundMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderRefundMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderRefundMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderRefundMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderRefundMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderRefundMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderRefundMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrderRefundMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[orderrefund.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrderRefundMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[orderrefund.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderRefundMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, orderrefund.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *OrderRefundMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *OrderRefundMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *OrderRefundMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[orderrefund.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *OrderRefundMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[orderrefund.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *OrderRefundMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, orderrefund.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *OrderRefundMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *OrderRefundMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *OrderRefundMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[orderrefund.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *OrderRefundMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[orderrefund.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *OrderRefundMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, orderrefund.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *OrderRefundMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *OrderRefundMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *OrderRefundMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[orderrefund.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *OrderRefundMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[orderrefund.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *OrderRefundMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, orderrefund.FieldRemark)
}

// SetOrderID sets the "order_id" field.
func (m *OrderRefundMutation) SetOrderID(u uint64) {
	m._order = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderRefundMutation) OrderID() (r uint64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldOrderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderRefundMutation) ResetOrderID() {
	m._order = nil
}

// SetStatus sets the "status" field.
func (m *OrderRefundMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderRefundMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *OrderRefundMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OrderRefundMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderRefundMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetAmount sets the "amount" field.
func (m *OrderRefundMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *OrderRefundMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *OrderRefundMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *OrderRefundMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *OrderRefundMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetOutRefundNo sets the "out_refund_no" field.
func (m *OrderRefundMutation) SetOutRefundNo(s string) {
	m.out_refund_no = &s
}

// OutRefundNo returns the value of the "out_refund_no" field in the mutation.
func (m *OrderRefundMutation) OutRefundNo() (r string, exists bool) {
	v := m.out_refund_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOutRefundNo returns the old "out_refund_no" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldOutRefundNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutRefundNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutRefundNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutRefundNo: %w", err)
	}
	return oldValue.OutRefundNo, nil
}

// ResetOutRefundNo resets all changes to the "out_refund_no" field.
func (m *OrderRefundMutation) ResetOutRefundNo() {
	m.out_refund_no = nil
}

// SetReason sets the "reason" field.
func (m *OrderRefundMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *OrderRefundMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *OrderRefundMutation) ResetReason() {
	m.reason = nil
}

// SetRefundAt sets the "refund_at" field.
func (m *OrderRefundMutation) SetRefundAt(t time.Time) {
	m.refund_at = &t
}

// RefundAt returns the value of the "refund_at" field in the mutation.
func (m *OrderRefundMutation) RefundAt() (r time.Time, exists bool) {
	v := m.refund_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundAt returns the old "refund_at" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldRefundAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundAt: %w", err)
	}
	return oldValue.RefundAt, nil
}

// ClearRefundAt clears the value of the "refund_at" field.
func (m *OrderRefundMutation) ClearRefundAt() {
	m.refund_at = nil
	m.clearedFields[orderrefund.FieldRefundAt] = struct{}{}
}

// RefundAtCleared returns if the "refund_at" field was cleared in this mutation.
func (m *OrderRefundMutation) RefundAtCleared() bool {
	_, ok := m.clearedFields[orderrefund.FieldRefundAt]
	return ok
}

// ResetRefundAt resets all changes to the "refund_at" field.
func (m *OrderRefundMutation) ResetRefundAt() {
	m.refund_at = nil
	delete(m.clearedFields, orderrefund.FieldRefundAt)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderRefundMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderRefundMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderRefundMutation) OrderIDs() (ids []uint64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderRefundMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderRefundMutation builder.
func (m *OrderRefundMutation) Where(ps ...predicate.OrderRefund) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OrderRefundMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OrderRefund).
func (m *OrderRefundMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderRefundMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, orderrefund.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderrefund.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, orderrefund.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, orderrefund.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, orderrefund.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, orderrefund.FieldRemark)
	}
	if m._order != nil {
		fields = append(fields, orderrefund.FieldOrderID)
	}
	if m.status != nil {
		fields = append(fields, orderrefund.FieldStatus)
	}
	if m.amount != nil {
		fields = append(fields, orderrefund.FieldAmount)
	}
	if m.out_refund_no != nil {
		fields = append(fields, orderrefund.FieldOutRefundNo)
	}
	if m.reason != nil {
		fields = append(fields, orderrefund.FieldReason)
	}
	if m.refund_at != nil {
		fields = append(fields, orderrefund.FieldRefundAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderRefundMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderrefund.FieldCreatedAt:
		return m.CreatedAt()
	case orderrefund.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderrefund.FieldDeletedAt:
		return m.DeletedAt()
	case orderrefund.FieldCreator:
		return m.Creator()
	case orderrefund.FieldLastModifier:
		return m.LastModifier()
	case orderrefund.FieldRemark:
		return m.Remark()
	case orderrefund.FieldOrderID:
		return m.OrderID()
	case orderrefund.FieldStatus:
		return m.Status()
	case orderrefund.FieldAmount:
		return m.Amount()
	case orderrefund.FieldOutRefundNo:
		return m.OutRefundNo()
	case orderrefund.FieldReason:
		return m.Reason()
	case orderrefund.FieldRefundAt:
		return m.RefundAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderRefundMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderrefund.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderrefund.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderrefund.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case orderrefund.FieldCreator:
		return m.OldCreator(ctx)
	case orderrefund.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case orderrefund.FieldRemark:
		return m.OldRemark(ctx)
	case orderrefund.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderrefund.FieldStatus:
		return m.OldStatus(ctx)
	case orderrefund.FieldAmount:
		return m.OldAmount(ctx)
	case orderrefund.FieldOutRefundNo:
		return m.OldOutRefundNo(ctx)
	case orderrefund.FieldReason:
		return m.OldReason(ctx)
	case orderrefund.FieldRefundAt:
		return m.OldRefundAt(ctx)
	}
	return nil, fmt.Errorf("unknown OrderRefund field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderRefundMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderrefund.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderrefund.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderrefund.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case orderrefund.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case orderrefund.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case orderrefund.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case orderrefund.FieldOrderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderrefund.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case orderrefund.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case orderrefund.FieldOutRefundNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutRefundNo(v)
		return nil
	case orderrefund.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case orderrefund.FieldRefundAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundAt(v)
		return nil
	}
	return fmt.Errorf("unknown OrderRefund field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderRefundMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, orderrefund.FieldStatus)
	}
	if m.addamount != nil {
		fields = append(fields, orderrefund.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderRefundMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderrefund.FieldStatus:
		return m.AddedStatus()
	case orderrefund.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderRefundMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderrefund.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case orderrefund.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown OrderRefund numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderRefundMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderrefund.FieldDeletedAt) {
		fields = append(fields, orderrefund.FieldDeletedAt)
	}
	if m.FieldCleared(orderrefund.FieldCreator) {
		fields = append(fields, orderrefund.FieldCreator)
	}
	if m.FieldCleared(orderrefund.FieldLastModifier) {
		fields = append(fields, orderrefund.FieldLastModifier)
	}
	if m.FieldCleared(orderrefund.FieldRemark) {
		fields = append(fields, orderrefund.FieldRemark)
	}
	if m.FieldCleared(orderrefund.FieldRefundAt) {
		fields = append(fields, orderrefund.FieldRefundAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderRefundMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderRefundMutation) ClearField(name string) error {
	switch name {
	case orderrefund.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case orderrefund.FieldCreator:
		m.ClearCreator()
		return nil
	case orderrefund.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case orderrefund.FieldRemark:
		m.ClearRemark()
		return nil
	case orderrefund.FieldRefundAt:
		m.ClearRefundAt()
		return nil
	}
	return fmt.Errorf("unknown OrderRefund nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderRefundMutation) ResetField(name string) error {
	switch name {
	case orderrefund.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderrefund.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderrefund.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case orderrefund.FieldCreator:
		m.ResetCreator()
		return nil
	case orderrefund.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case orderrefund.FieldRemark:
		m.ResetRemark()
		return nil
	case orderrefund.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderrefund.FieldStatus:
		m.ResetStatus()
		return nil
	case orderrefund.FieldAmount:
		m.ResetAmount()
		return nil
	case orderrefund.FieldOutRefundNo:
		m.ResetOutRefundNo()
		return nil
	case orderrefund.FieldReason:
		m.ResetReason()
		return nil
	case orderrefund.FieldRefundAt:
		m.ResetRefundAt()
		return nil
	}
	return fmt.Errorf("unknown OrderRefund field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderRefundMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, orderrefund.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderRefundMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderrefund.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderRefundMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderRefundMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderRefundMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, orderrefund.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderRefundMutation) EdgeCleared(name string) bool {
	switch name {
	case orderrefund.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderRefundMutation) ClearEdge(name string) error {
	switch name {
	case orderrefund.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderRefund unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderRefundMutation) ResetEdge(name string) error {
	switch name {
	case orderrefund.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderRefund edge %s", name)
}

// PersonMutation represents an operation that mutates the Person nodes in the graph.
type PersonMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	creator          **model.Modifier
	last_modifier    **model.Modifier
	remark           *string
	status           *uint8
	addstatus        *int8
	banned           *bool
	name             *string
	id_card_number   *string
	id_card_type     *uint8
	addid_card_type  *int8
	id_card_portrait *string
	id_card_national *string
	auth_face        *string
	auth_result      **model.FaceVerifyResult
	auth_at          *time.Time
	clearedFields    map[string]struct{}
	rider            map[uint64]struct{}
	removedrider     map[uint64]struct{}
	clearedrider     bool
	done             bool
	oldValue         func(context.Context) (*Person, error)
	predicates       []predicate.Person
}

var _ ent.Mutation = (*PersonMutation)(nil)

// personOption allows management of the mutation configuration using functional options.
type personOption func(*PersonMutation)

// newPersonMutation creates new mutation for the Person entity.
func newPersonMutation(c config, op Op, opts ...personOption) *PersonMutation {
	m := &PersonMutation{
		config:        c,
		op:            op,
		typ:           TypePerson,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonID sets the ID field of the mutation.
func withPersonID(id uint64) personOption {
	return func(m *PersonMutation) {
		var (
			err   error
			once  sync.Once
			value *Person
		)
		m.oldValue = func(ctx context.Context) (*Person, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Person.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPerson sets the old Person of the mutation.
func withPerson(node *Person) personOption {
	return func(m *PersonMutation) {
		m.oldValue = func(context.Context) (*Person, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PersonMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Person.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PersonMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PersonMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PersonMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PersonMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PersonMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PersonMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PersonMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PersonMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PersonMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[person.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PersonMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[person.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PersonMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, person.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *PersonMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *PersonMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *PersonMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[person.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *PersonMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[person.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *PersonMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, person.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *PersonMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *PersonMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *PersonMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[person.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *PersonMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[person.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *PersonMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, person.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *PersonMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PersonMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PersonMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[person.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PersonMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[person.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PersonMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, person.FieldRemark)
}

// SetStatus sets the "status" field.
func (m *PersonMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *PersonMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *PersonMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *PersonMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *PersonMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetBanned sets the "banned" field.
func (m *PersonMutation) SetBanned(b bool) {
	m.banned = &b
}

// Banned returns the value of the "banned" field in the mutation.
func (m *PersonMutation) Banned() (r bool, exists bool) {
	v := m.banned
	if v == nil {
		return
	}
	return *v, true
}

// OldBanned returns the old "banned" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldBanned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBanned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBanned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBanned: %w", err)
	}
	return oldValue.Banned, nil
}

// ResetBanned resets all changes to the "banned" field.
func (m *PersonMutation) ResetBanned() {
	m.banned = nil
}

// SetName sets the "name" field.
func (m *PersonMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PersonMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PersonMutation) ResetName() {
	m.name = nil
}

// SetIDCardNumber sets the "id_card_number" field.
func (m *PersonMutation) SetIDCardNumber(s string) {
	m.id_card_number = &s
}

// IDCardNumber returns the value of the "id_card_number" field in the mutation.
func (m *PersonMutation) IDCardNumber() (r string, exists bool) {
	v := m.id_card_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCardNumber returns the old "id_card_number" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldIDCardNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCardNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCardNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCardNumber: %w", err)
	}
	return oldValue.IDCardNumber, nil
}

// ClearIDCardNumber clears the value of the "id_card_number" field.
func (m *PersonMutation) ClearIDCardNumber() {
	m.id_card_number = nil
	m.clearedFields[person.FieldIDCardNumber] = struct{}{}
}

// IDCardNumberCleared returns if the "id_card_number" field was cleared in this mutation.
func (m *PersonMutation) IDCardNumberCleared() bool {
	_, ok := m.clearedFields[person.FieldIDCardNumber]
	return ok
}

// ResetIDCardNumber resets all changes to the "id_card_number" field.
func (m *PersonMutation) ResetIDCardNumber() {
	m.id_card_number = nil
	delete(m.clearedFields, person.FieldIDCardNumber)
}

// SetIDCardType sets the "id_card_type" field.
func (m *PersonMutation) SetIDCardType(u uint8) {
	m.id_card_type = &u
	m.addid_card_type = nil
}

// IDCardType returns the value of the "id_card_type" field in the mutation.
func (m *PersonMutation) IDCardType() (r uint8, exists bool) {
	v := m.id_card_type
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCardType returns the old "id_card_type" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldIDCardType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCardType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCardType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCardType: %w", err)
	}
	return oldValue.IDCardType, nil
}

// AddIDCardType adds u to the "id_card_type" field.
func (m *PersonMutation) AddIDCardType(u int8) {
	if m.addid_card_type != nil {
		*m.addid_card_type += u
	} else {
		m.addid_card_type = &u
	}
}

// AddedIDCardType returns the value that was added to the "id_card_type" field in this mutation.
func (m *PersonMutation) AddedIDCardType() (r int8, exists bool) {
	v := m.addid_card_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetIDCardType resets all changes to the "id_card_type" field.
func (m *PersonMutation) ResetIDCardType() {
	m.id_card_type = nil
	m.addid_card_type = nil
}

// SetIDCardPortrait sets the "id_card_portrait" field.
func (m *PersonMutation) SetIDCardPortrait(s string) {
	m.id_card_portrait = &s
}

// IDCardPortrait returns the value of the "id_card_portrait" field in the mutation.
func (m *PersonMutation) IDCardPortrait() (r string, exists bool) {
	v := m.id_card_portrait
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCardPortrait returns the old "id_card_portrait" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldIDCardPortrait(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCardPortrait is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCardPortrait requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCardPortrait: %w", err)
	}
	return oldValue.IDCardPortrait, nil
}

// ClearIDCardPortrait clears the value of the "id_card_portrait" field.
func (m *PersonMutation) ClearIDCardPortrait() {
	m.id_card_portrait = nil
	m.clearedFields[person.FieldIDCardPortrait] = struct{}{}
}

// IDCardPortraitCleared returns if the "id_card_portrait" field was cleared in this mutation.
func (m *PersonMutation) IDCardPortraitCleared() bool {
	_, ok := m.clearedFields[person.FieldIDCardPortrait]
	return ok
}

// ResetIDCardPortrait resets all changes to the "id_card_portrait" field.
func (m *PersonMutation) ResetIDCardPortrait() {
	m.id_card_portrait = nil
	delete(m.clearedFields, person.FieldIDCardPortrait)
}

// SetIDCardNational sets the "id_card_national" field.
func (m *PersonMutation) SetIDCardNational(s string) {
	m.id_card_national = &s
}

// IDCardNational returns the value of the "id_card_national" field in the mutation.
func (m *PersonMutation) IDCardNational() (r string, exists bool) {
	v := m.id_card_national
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCardNational returns the old "id_card_national" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldIDCardNational(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCardNational is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCardNational requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCardNational: %w", err)
	}
	return oldValue.IDCardNational, nil
}

// ClearIDCardNational clears the value of the "id_card_national" field.
func (m *PersonMutation) ClearIDCardNational() {
	m.id_card_national = nil
	m.clearedFields[person.FieldIDCardNational] = struct{}{}
}

// IDCardNationalCleared returns if the "id_card_national" field was cleared in this mutation.
func (m *PersonMutation) IDCardNationalCleared() bool {
	_, ok := m.clearedFields[person.FieldIDCardNational]
	return ok
}

// ResetIDCardNational resets all changes to the "id_card_national" field.
func (m *PersonMutation) ResetIDCardNational() {
	m.id_card_national = nil
	delete(m.clearedFields, person.FieldIDCardNational)
}

// SetAuthFace sets the "auth_face" field.
func (m *PersonMutation) SetAuthFace(s string) {
	m.auth_face = &s
}

// AuthFace returns the value of the "auth_face" field in the mutation.
func (m *PersonMutation) AuthFace() (r string, exists bool) {
	v := m.auth_face
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthFace returns the old "auth_face" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldAuthFace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthFace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthFace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthFace: %w", err)
	}
	return oldValue.AuthFace, nil
}

// ClearAuthFace clears the value of the "auth_face" field.
func (m *PersonMutation) ClearAuthFace() {
	m.auth_face = nil
	m.clearedFields[person.FieldAuthFace] = struct{}{}
}

// AuthFaceCleared returns if the "auth_face" field was cleared in this mutation.
func (m *PersonMutation) AuthFaceCleared() bool {
	_, ok := m.clearedFields[person.FieldAuthFace]
	return ok
}

// ResetAuthFace resets all changes to the "auth_face" field.
func (m *PersonMutation) ResetAuthFace() {
	m.auth_face = nil
	delete(m.clearedFields, person.FieldAuthFace)
}

// SetAuthResult sets the "auth_result" field.
func (m *PersonMutation) SetAuthResult(mvr *model.FaceVerifyResult) {
	m.auth_result = &mvr
}

// AuthResult returns the value of the "auth_result" field in the mutation.
func (m *PersonMutation) AuthResult() (r *model.FaceVerifyResult, exists bool) {
	v := m.auth_result
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthResult returns the old "auth_result" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldAuthResult(ctx context.Context) (v *model.FaceVerifyResult, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthResult: %w", err)
	}
	return oldValue.AuthResult, nil
}

// ClearAuthResult clears the value of the "auth_result" field.
func (m *PersonMutation) ClearAuthResult() {
	m.auth_result = nil
	m.clearedFields[person.FieldAuthResult] = struct{}{}
}

// AuthResultCleared returns if the "auth_result" field was cleared in this mutation.
func (m *PersonMutation) AuthResultCleared() bool {
	_, ok := m.clearedFields[person.FieldAuthResult]
	return ok
}

// ResetAuthResult resets all changes to the "auth_result" field.
func (m *PersonMutation) ResetAuthResult() {
	m.auth_result = nil
	delete(m.clearedFields, person.FieldAuthResult)
}

// SetAuthAt sets the "auth_at" field.
func (m *PersonMutation) SetAuthAt(t time.Time) {
	m.auth_at = &t
}

// AuthAt returns the value of the "auth_at" field in the mutation.
func (m *PersonMutation) AuthAt() (r time.Time, exists bool) {
	v := m.auth_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthAt returns the old "auth_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldAuthAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthAt: %w", err)
	}
	return oldValue.AuthAt, nil
}

// ClearAuthAt clears the value of the "auth_at" field.
func (m *PersonMutation) ClearAuthAt() {
	m.auth_at = nil
	m.clearedFields[person.FieldAuthAt] = struct{}{}
}

// AuthAtCleared returns if the "auth_at" field was cleared in this mutation.
func (m *PersonMutation) AuthAtCleared() bool {
	_, ok := m.clearedFields[person.FieldAuthAt]
	return ok
}

// ResetAuthAt resets all changes to the "auth_at" field.
func (m *PersonMutation) ResetAuthAt() {
	m.auth_at = nil
	delete(m.clearedFields, person.FieldAuthAt)
}

// AddRiderIDs adds the "rider" edge to the Rider entity by ids.
func (m *PersonMutation) AddRiderIDs(ids ...uint64) {
	if m.rider == nil {
		m.rider = make(map[uint64]struct{})
	}
	for i := range ids {
		m.rider[ids[i]] = struct{}{}
	}
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *PersonMutation) ClearRider() {
	m.clearedrider = true
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *PersonMutation) RiderCleared() bool {
	return m.clearedrider
}

// RemoveRiderIDs removes the "rider" edge to the Rider entity by IDs.
func (m *PersonMutation) RemoveRiderIDs(ids ...uint64) {
	if m.removedrider == nil {
		m.removedrider = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.rider, ids[i])
		m.removedrider[ids[i]] = struct{}{}
	}
}

// RemovedRider returns the removed IDs of the "rider" edge to the Rider entity.
func (m *PersonMutation) RemovedRiderIDs() (ids []uint64) {
	for id := range m.removedrider {
		ids = append(ids, id)
	}
	return
}

// RiderIDs returns the "rider" edge IDs in the mutation.
func (m *PersonMutation) RiderIDs() (ids []uint64) {
	for id := range m.rider {
		ids = append(ids, id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *PersonMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
	m.removedrider = nil
}

// Where appends a list predicates to the PersonMutation builder.
func (m *PersonMutation) Where(ps ...predicate.Person) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PersonMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Person).
func (m *PersonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, person.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, person.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, person.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, person.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, person.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, person.FieldRemark)
	}
	if m.status != nil {
		fields = append(fields, person.FieldStatus)
	}
	if m.banned != nil {
		fields = append(fields, person.FieldBanned)
	}
	if m.name != nil {
		fields = append(fields, person.FieldName)
	}
	if m.id_card_number != nil {
		fields = append(fields, person.FieldIDCardNumber)
	}
	if m.id_card_type != nil {
		fields = append(fields, person.FieldIDCardType)
	}
	if m.id_card_portrait != nil {
		fields = append(fields, person.FieldIDCardPortrait)
	}
	if m.id_card_national != nil {
		fields = append(fields, person.FieldIDCardNational)
	}
	if m.auth_face != nil {
		fields = append(fields, person.FieldAuthFace)
	}
	if m.auth_result != nil {
		fields = append(fields, person.FieldAuthResult)
	}
	if m.auth_at != nil {
		fields = append(fields, person.FieldAuthAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case person.FieldCreatedAt:
		return m.CreatedAt()
	case person.FieldUpdatedAt:
		return m.UpdatedAt()
	case person.FieldDeletedAt:
		return m.DeletedAt()
	case person.FieldCreator:
		return m.Creator()
	case person.FieldLastModifier:
		return m.LastModifier()
	case person.FieldRemark:
		return m.Remark()
	case person.FieldStatus:
		return m.Status()
	case person.FieldBanned:
		return m.Banned()
	case person.FieldName:
		return m.Name()
	case person.FieldIDCardNumber:
		return m.IDCardNumber()
	case person.FieldIDCardType:
		return m.IDCardType()
	case person.FieldIDCardPortrait:
		return m.IDCardPortrait()
	case person.FieldIDCardNational:
		return m.IDCardNational()
	case person.FieldAuthFace:
		return m.AuthFace()
	case person.FieldAuthResult:
		return m.AuthResult()
	case person.FieldAuthAt:
		return m.AuthAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case person.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case person.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case person.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case person.FieldCreator:
		return m.OldCreator(ctx)
	case person.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case person.FieldRemark:
		return m.OldRemark(ctx)
	case person.FieldStatus:
		return m.OldStatus(ctx)
	case person.FieldBanned:
		return m.OldBanned(ctx)
	case person.FieldName:
		return m.OldName(ctx)
	case person.FieldIDCardNumber:
		return m.OldIDCardNumber(ctx)
	case person.FieldIDCardType:
		return m.OldIDCardType(ctx)
	case person.FieldIDCardPortrait:
		return m.OldIDCardPortrait(ctx)
	case person.FieldIDCardNational:
		return m.OldIDCardNational(ctx)
	case person.FieldAuthFace:
		return m.OldAuthFace(ctx)
	case person.FieldAuthResult:
		return m.OldAuthResult(ctx)
	case person.FieldAuthAt:
		return m.OldAuthAt(ctx)
	}
	return nil, fmt.Errorf("unknown Person field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case person.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case person.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case person.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case person.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case person.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case person.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case person.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case person.FieldBanned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBanned(v)
		return nil
	case person.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case person.FieldIDCardNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCardNumber(v)
		return nil
	case person.FieldIDCardType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCardType(v)
		return nil
	case person.FieldIDCardPortrait:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCardPortrait(v)
		return nil
	case person.FieldIDCardNational:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCardNational(v)
		return nil
	case person.FieldAuthFace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthFace(v)
		return nil
	case person.FieldAuthResult:
		v, ok := value.(*model.FaceVerifyResult)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthResult(v)
		return nil
	case person.FieldAuthAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthAt(v)
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, person.FieldStatus)
	}
	if m.addid_card_type != nil {
		fields = append(fields, person.FieldIDCardType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case person.FieldStatus:
		return m.AddedStatus()
	case person.FieldIDCardType:
		return m.AddedIDCardType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case person.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case person.FieldIDCardType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIDCardType(v)
		return nil
	}
	return fmt.Errorf("unknown Person numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(person.FieldDeletedAt) {
		fields = append(fields, person.FieldDeletedAt)
	}
	if m.FieldCleared(person.FieldCreator) {
		fields = append(fields, person.FieldCreator)
	}
	if m.FieldCleared(person.FieldLastModifier) {
		fields = append(fields, person.FieldLastModifier)
	}
	if m.FieldCleared(person.FieldRemark) {
		fields = append(fields, person.FieldRemark)
	}
	if m.FieldCleared(person.FieldIDCardNumber) {
		fields = append(fields, person.FieldIDCardNumber)
	}
	if m.FieldCleared(person.FieldIDCardPortrait) {
		fields = append(fields, person.FieldIDCardPortrait)
	}
	if m.FieldCleared(person.FieldIDCardNational) {
		fields = append(fields, person.FieldIDCardNational)
	}
	if m.FieldCleared(person.FieldAuthFace) {
		fields = append(fields, person.FieldAuthFace)
	}
	if m.FieldCleared(person.FieldAuthResult) {
		fields = append(fields, person.FieldAuthResult)
	}
	if m.FieldCleared(person.FieldAuthAt) {
		fields = append(fields, person.FieldAuthAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonMutation) ClearField(name string) error {
	switch name {
	case person.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case person.FieldCreator:
		m.ClearCreator()
		return nil
	case person.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case person.FieldRemark:
		m.ClearRemark()
		return nil
	case person.FieldIDCardNumber:
		m.ClearIDCardNumber()
		return nil
	case person.FieldIDCardPortrait:
		m.ClearIDCardPortrait()
		return nil
	case person.FieldIDCardNational:
		m.ClearIDCardNational()
		return nil
	case person.FieldAuthFace:
		m.ClearAuthFace()
		return nil
	case person.FieldAuthResult:
		m.ClearAuthResult()
		return nil
	case person.FieldAuthAt:
		m.ClearAuthAt()
		return nil
	}
	return fmt.Errorf("unknown Person nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonMutation) ResetField(name string) error {
	switch name {
	case person.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case person.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case person.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case person.FieldCreator:
		m.ResetCreator()
		return nil
	case person.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case person.FieldRemark:
		m.ResetRemark()
		return nil
	case person.FieldStatus:
		m.ResetStatus()
		return nil
	case person.FieldBanned:
		m.ResetBanned()
		return nil
	case person.FieldName:
		m.ResetName()
		return nil
	case person.FieldIDCardNumber:
		m.ResetIDCardNumber()
		return nil
	case person.FieldIDCardType:
		m.ResetIDCardType()
		return nil
	case person.FieldIDCardPortrait:
		m.ResetIDCardPortrait()
		return nil
	case person.FieldIDCardNational:
		m.ResetIDCardNational()
		return nil
	case person.FieldAuthFace:
		m.ResetAuthFace()
		return nil
	case person.FieldAuthResult:
		m.ResetAuthResult()
		return nil
	case person.FieldAuthAt:
		m.ResetAuthAt()
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.rider != nil {
		edges = append(edges, person.EdgeRider)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeRider:
		ids := make([]ent.Value, 0, len(m.rider))
		for id := range m.rider {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrider != nil {
		edges = append(edges, person.EdgeRider)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeRider:
		ids := make([]ent.Value, 0, len(m.removedrider))
		for id := range m.removedrider {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrider {
		edges = append(edges, person.EdgeRider)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonMutation) EdgeCleared(name string) bool {
	switch name {
	case person.EdgeRider:
		return m.clearedrider
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Person unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonMutation) ResetEdge(name string) error {
	switch name {
	case person.EdgeRider:
		m.ResetRider()
		return nil
	}
	return fmt.Errorf("unknown Person edge %s", name)
}

// PlanMutation represents an operation that mutates the Plan nodes in the graph.
type PlanMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	creator          **model.Modifier
	last_modifier    **model.Modifier
	remark           *string
	enable           *bool
	name             *string
	start            *time.Time
	end              *time.Time
	price            *float64
	addprice         *float64
	days             *uint
	adddays          *int
	commission       *float64
	addcommission    *float64
	original         *float64
	addoriginal      *float64
	desc             *string
	clearedFields    map[string]struct{}
	pms              map[uint64]struct{}
	removedpms       map[uint64]struct{}
	clearedpms       bool
	cities           map[uint64]struct{}
	removedcities    map[uint64]struct{}
	clearedcities    bool
	parent           *uint64
	clearedparent    bool
	complexes        map[uint64]struct{}
	removedcomplexes map[uint64]struct{}
	clearedcomplexes bool
	done             bool
	oldValue         func(context.Context) (*Plan, error)
	predicates       []predicate.Plan
}

var _ ent.Mutation = (*PlanMutation)(nil)

// planOption allows management of the mutation configuration using functional options.
type planOption func(*PlanMutation)

// newPlanMutation creates new mutation for the Plan entity.
func newPlanMutation(c config, op Op, opts ...planOption) *PlanMutation {
	m := &PlanMutation{
		config:        c,
		op:            op,
		typ:           TypePlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanID sets the ID field of the mutation.
func withPlanID(id uint64) planOption {
	return func(m *PlanMutation) {
		var (
			err   error
			once  sync.Once
			value *Plan
		)
		m.oldValue = func(ctx context.Context) (*Plan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Plan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlan sets the old Plan of the mutation.
func withPlan(node *Plan) planOption {
	return func(m *PlanMutation) {
		m.oldValue = func(context.Context) (*Plan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Plan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PlanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlanMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlanMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlanMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlanMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PlanMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PlanMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PlanMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[plan.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PlanMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[plan.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PlanMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, plan.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *PlanMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *PlanMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *PlanMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[plan.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *PlanMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[plan.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *PlanMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, plan.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *PlanMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *PlanMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *PlanMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[plan.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *PlanMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[plan.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *PlanMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, plan.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *PlanMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PlanMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PlanMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[plan.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PlanMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[plan.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PlanMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, plan.FieldRemark)
}

// SetEnable sets the "enable" field.
func (m *PlanMutation) SetEnable(b bool) {
	m.enable = &b
}

// Enable returns the value of the "enable" field in the mutation.
func (m *PlanMutation) Enable() (r bool, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// ResetEnable resets all changes to the "enable" field.
func (m *PlanMutation) ResetEnable() {
	m.enable = nil
}

// SetName sets the "name" field.
func (m *PlanMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlanMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlanMutation) ResetName() {
	m.name = nil
}

// SetStart sets the "start" field.
func (m *PlanMutation) SetStart(t time.Time) {
	m.start = &t
}

// Start returns the value of the "start" field in the mutation.
func (m *PlanMutation) Start() (r time.Time, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// ResetStart resets all changes to the "start" field.
func (m *PlanMutation) ResetStart() {
	m.start = nil
}

// SetEnd sets the "end" field.
func (m *PlanMutation) SetEnd(t time.Time) {
	m.end = &t
}

// End returns the value of the "end" field in the mutation.
func (m *PlanMutation) End() (r time.Time, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// ResetEnd resets all changes to the "end" field.
func (m *PlanMutation) ResetEnd() {
	m.end = nil
}

// SetPrice sets the "price" field.
func (m *PlanMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *PlanMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *PlanMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *PlanMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *PlanMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetDays sets the "days" field.
func (m *PlanMutation) SetDays(u uint) {
	m.days = &u
	m.adddays = nil
}

// Days returns the value of the "days" field in the mutation.
func (m *PlanMutation) Days() (r uint, exists bool) {
	v := m.days
	if v == nil {
		return
	}
	return *v, true
}

// OldDays returns the old "days" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldDays(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDays: %w", err)
	}
	return oldValue.Days, nil
}

// AddDays adds u to the "days" field.
func (m *PlanMutation) AddDays(u int) {
	if m.adddays != nil {
		*m.adddays += u
	} else {
		m.adddays = &u
	}
}

// AddedDays returns the value that was added to the "days" field in this mutation.
func (m *PlanMutation) AddedDays() (r int, exists bool) {
	v := m.adddays
	if v == nil {
		return
	}
	return *v, true
}

// ResetDays resets all changes to the "days" field.
func (m *PlanMutation) ResetDays() {
	m.days = nil
	m.adddays = nil
}

// SetCommission sets the "commission" field.
func (m *PlanMutation) SetCommission(f float64) {
	m.commission = &f
	m.addcommission = nil
}

// Commission returns the value of the "commission" field in the mutation.
func (m *PlanMutation) Commission() (r float64, exists bool) {
	v := m.commission
	if v == nil {
		return
	}
	return *v, true
}

// OldCommission returns the old "commission" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldCommission(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommission: %w", err)
	}
	return oldValue.Commission, nil
}

// AddCommission adds f to the "commission" field.
func (m *PlanMutation) AddCommission(f float64) {
	if m.addcommission != nil {
		*m.addcommission += f
	} else {
		m.addcommission = &f
	}
}

// AddedCommission returns the value that was added to the "commission" field in this mutation.
func (m *PlanMutation) AddedCommission() (r float64, exists bool) {
	v := m.addcommission
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommission resets all changes to the "commission" field.
func (m *PlanMutation) ResetCommission() {
	m.commission = nil
	m.addcommission = nil
}

// SetOriginal sets the "original" field.
func (m *PlanMutation) SetOriginal(f float64) {
	m.original = &f
	m.addoriginal = nil
}

// Original returns the value of the "original" field in the mutation.
func (m *PlanMutation) Original() (r float64, exists bool) {
	v := m.original
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginal returns the old "original" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldOriginal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginal: %w", err)
	}
	return oldValue.Original, nil
}

// AddOriginal adds f to the "original" field.
func (m *PlanMutation) AddOriginal(f float64) {
	if m.addoriginal != nil {
		*m.addoriginal += f
	} else {
		m.addoriginal = &f
	}
}

// AddedOriginal returns the value that was added to the "original" field in this mutation.
func (m *PlanMutation) AddedOriginal() (r float64, exists bool) {
	v := m.addoriginal
	if v == nil {
		return
	}
	return *v, true
}

// ClearOriginal clears the value of the "original" field.
func (m *PlanMutation) ClearOriginal() {
	m.original = nil
	m.addoriginal = nil
	m.clearedFields[plan.FieldOriginal] = struct{}{}
}

// OriginalCleared returns if the "original" field was cleared in this mutation.
func (m *PlanMutation) OriginalCleared() bool {
	_, ok := m.clearedFields[plan.FieldOriginal]
	return ok
}

// ResetOriginal resets all changes to the "original" field.
func (m *PlanMutation) ResetOriginal() {
	m.original = nil
	m.addoriginal = nil
	delete(m.clearedFields, plan.FieldOriginal)
}

// SetDesc sets the "desc" field.
func (m *PlanMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *PlanMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ClearDesc clears the value of the "desc" field.
func (m *PlanMutation) ClearDesc() {
	m.desc = nil
	m.clearedFields[plan.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *PlanMutation) DescCleared() bool {
	_, ok := m.clearedFields[plan.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *PlanMutation) ResetDesc() {
	m.desc = nil
	delete(m.clearedFields, plan.FieldDesc)
}

// SetParentID sets the "parent_id" field.
func (m *PlanMutation) SetParentID(u uint64) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *PlanMutation) ParentID() (r uint64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldParentID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *PlanMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[plan.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *PlanMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[plan.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *PlanMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, plan.FieldParentID)
}

// AddPmIDs adds the "pms" edge to the BatteryModel entity by ids.
func (m *PlanMutation) AddPmIDs(ids ...uint64) {
	if m.pms == nil {
		m.pms = make(map[uint64]struct{})
	}
	for i := range ids {
		m.pms[ids[i]] = struct{}{}
	}
}

// ClearPms clears the "pms" edge to the BatteryModel entity.
func (m *PlanMutation) ClearPms() {
	m.clearedpms = true
}

// PmsCleared reports if the "pms" edge to the BatteryModel entity was cleared.
func (m *PlanMutation) PmsCleared() bool {
	return m.clearedpms
}

// RemovePmIDs removes the "pms" edge to the BatteryModel entity by IDs.
func (m *PlanMutation) RemovePmIDs(ids ...uint64) {
	if m.removedpms == nil {
		m.removedpms = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.pms, ids[i])
		m.removedpms[ids[i]] = struct{}{}
	}
}

// RemovedPms returns the removed IDs of the "pms" edge to the BatteryModel entity.
func (m *PlanMutation) RemovedPmsIDs() (ids []uint64) {
	for id := range m.removedpms {
		ids = append(ids, id)
	}
	return
}

// PmsIDs returns the "pms" edge IDs in the mutation.
func (m *PlanMutation) PmsIDs() (ids []uint64) {
	for id := range m.pms {
		ids = append(ids, id)
	}
	return
}

// ResetPms resets all changes to the "pms" edge.
func (m *PlanMutation) ResetPms() {
	m.pms = nil
	m.clearedpms = false
	m.removedpms = nil
}

// AddCityIDs adds the "cities" edge to the City entity by ids.
func (m *PlanMutation) AddCityIDs(ids ...uint64) {
	if m.cities == nil {
		m.cities = make(map[uint64]struct{})
	}
	for i := range ids {
		m.cities[ids[i]] = struct{}{}
	}
}

// ClearCities clears the "cities" edge to the City entity.
func (m *PlanMutation) ClearCities() {
	m.clearedcities = true
}

// CitiesCleared reports if the "cities" edge to the City entity was cleared.
func (m *PlanMutation) CitiesCleared() bool {
	return m.clearedcities
}

// RemoveCityIDs removes the "cities" edge to the City entity by IDs.
func (m *PlanMutation) RemoveCityIDs(ids ...uint64) {
	if m.removedcities == nil {
		m.removedcities = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.cities, ids[i])
		m.removedcities[ids[i]] = struct{}{}
	}
}

// RemovedCities returns the removed IDs of the "cities" edge to the City entity.
func (m *PlanMutation) RemovedCitiesIDs() (ids []uint64) {
	for id := range m.removedcities {
		ids = append(ids, id)
	}
	return
}

// CitiesIDs returns the "cities" edge IDs in the mutation.
func (m *PlanMutation) CitiesIDs() (ids []uint64) {
	for id := range m.cities {
		ids = append(ids, id)
	}
	return
}

// ResetCities resets all changes to the "cities" edge.
func (m *PlanMutation) ResetCities() {
	m.cities = nil
	m.clearedcities = false
	m.removedcities = nil
}

// ClearParent clears the "parent" edge to the Plan entity.
func (m *PlanMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Plan entity was cleared.
func (m *PlanMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *PlanMutation) ParentIDs() (ids []uint64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *PlanMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddComplexIDs adds the "complexes" edge to the Plan entity by ids.
func (m *PlanMutation) AddComplexIDs(ids ...uint64) {
	if m.complexes == nil {
		m.complexes = make(map[uint64]struct{})
	}
	for i := range ids {
		m.complexes[ids[i]] = struct{}{}
	}
}

// ClearComplexes clears the "complexes" edge to the Plan entity.
func (m *PlanMutation) ClearComplexes() {
	m.clearedcomplexes = true
}

// ComplexesCleared reports if the "complexes" edge to the Plan entity was cleared.
func (m *PlanMutation) ComplexesCleared() bool {
	return m.clearedcomplexes
}

// RemoveComplexIDs removes the "complexes" edge to the Plan entity by IDs.
func (m *PlanMutation) RemoveComplexIDs(ids ...uint64) {
	if m.removedcomplexes == nil {
		m.removedcomplexes = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.complexes, ids[i])
		m.removedcomplexes[ids[i]] = struct{}{}
	}
}

// RemovedComplexes returns the removed IDs of the "complexes" edge to the Plan entity.
func (m *PlanMutation) RemovedComplexesIDs() (ids []uint64) {
	for id := range m.removedcomplexes {
		ids = append(ids, id)
	}
	return
}

// ComplexesIDs returns the "complexes" edge IDs in the mutation.
func (m *PlanMutation) ComplexesIDs() (ids []uint64) {
	for id := range m.complexes {
		ids = append(ids, id)
	}
	return
}

// ResetComplexes resets all changes to the "complexes" edge.
func (m *PlanMutation) ResetComplexes() {
	m.complexes = nil
	m.clearedcomplexes = false
	m.removedcomplexes = nil
}

// Where appends a list predicates to the PlanMutation builder.
func (m *PlanMutation) Where(ps ...predicate.Plan) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PlanMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Plan).
func (m *PlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, plan.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, plan.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, plan.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, plan.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, plan.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, plan.FieldRemark)
	}
	if m.enable != nil {
		fields = append(fields, plan.FieldEnable)
	}
	if m.name != nil {
		fields = append(fields, plan.FieldName)
	}
	if m.start != nil {
		fields = append(fields, plan.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, plan.FieldEnd)
	}
	if m.price != nil {
		fields = append(fields, plan.FieldPrice)
	}
	if m.days != nil {
		fields = append(fields, plan.FieldDays)
	}
	if m.commission != nil {
		fields = append(fields, plan.FieldCommission)
	}
	if m.original != nil {
		fields = append(fields, plan.FieldOriginal)
	}
	if m.desc != nil {
		fields = append(fields, plan.FieldDesc)
	}
	if m.parent != nil {
		fields = append(fields, plan.FieldParentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plan.FieldCreatedAt:
		return m.CreatedAt()
	case plan.FieldUpdatedAt:
		return m.UpdatedAt()
	case plan.FieldDeletedAt:
		return m.DeletedAt()
	case plan.FieldCreator:
		return m.Creator()
	case plan.FieldLastModifier:
		return m.LastModifier()
	case plan.FieldRemark:
		return m.Remark()
	case plan.FieldEnable:
		return m.Enable()
	case plan.FieldName:
		return m.Name()
	case plan.FieldStart:
		return m.Start()
	case plan.FieldEnd:
		return m.End()
	case plan.FieldPrice:
		return m.Price()
	case plan.FieldDays:
		return m.Days()
	case plan.FieldCommission:
		return m.Commission()
	case plan.FieldOriginal:
		return m.Original()
	case plan.FieldDesc:
		return m.Desc()
	case plan.FieldParentID:
		return m.ParentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case plan.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case plan.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case plan.FieldCreator:
		return m.OldCreator(ctx)
	case plan.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case plan.FieldRemark:
		return m.OldRemark(ctx)
	case plan.FieldEnable:
		return m.OldEnable(ctx)
	case plan.FieldName:
		return m.OldName(ctx)
	case plan.FieldStart:
		return m.OldStart(ctx)
	case plan.FieldEnd:
		return m.OldEnd(ctx)
	case plan.FieldPrice:
		return m.OldPrice(ctx)
	case plan.FieldDays:
		return m.OldDays(ctx)
	case plan.FieldCommission:
		return m.OldCommission(ctx)
	case plan.FieldOriginal:
		return m.OldOriginal(ctx)
	case plan.FieldDesc:
		return m.OldDesc(ctx)
	case plan.FieldParentID:
		return m.OldParentID(ctx)
	}
	return nil, fmt.Errorf("unknown Plan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plan.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case plan.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case plan.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case plan.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case plan.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case plan.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case plan.FieldEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case plan.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case plan.FieldStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case plan.FieldEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case plan.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case plan.FieldDays:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDays(v)
		return nil
	case plan.FieldCommission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommission(v)
		return nil
	case plan.FieldOriginal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginal(v)
		return nil
	case plan.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case plan.FieldParentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, plan.FieldPrice)
	}
	if m.adddays != nil {
		fields = append(fields, plan.FieldDays)
	}
	if m.addcommission != nil {
		fields = append(fields, plan.FieldCommission)
	}
	if m.addoriginal != nil {
		fields = append(fields, plan.FieldOriginal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case plan.FieldPrice:
		return m.AddedPrice()
	case plan.FieldDays:
		return m.AddedDays()
	case plan.FieldCommission:
		return m.AddedCommission()
	case plan.FieldOriginal:
		return m.AddedOriginal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case plan.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case plan.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDays(v)
		return nil
	case plan.FieldCommission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommission(v)
		return nil
	case plan.FieldOriginal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOriginal(v)
		return nil
	}
	return fmt.Errorf("unknown Plan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(plan.FieldDeletedAt) {
		fields = append(fields, plan.FieldDeletedAt)
	}
	if m.FieldCleared(plan.FieldCreator) {
		fields = append(fields, plan.FieldCreator)
	}
	if m.FieldCleared(plan.FieldLastModifier) {
		fields = append(fields, plan.FieldLastModifier)
	}
	if m.FieldCleared(plan.FieldRemark) {
		fields = append(fields, plan.FieldRemark)
	}
	if m.FieldCleared(plan.FieldOriginal) {
		fields = append(fields, plan.FieldOriginal)
	}
	if m.FieldCleared(plan.FieldDesc) {
		fields = append(fields, plan.FieldDesc)
	}
	if m.FieldCleared(plan.FieldParentID) {
		fields = append(fields, plan.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanMutation) ClearField(name string) error {
	switch name {
	case plan.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case plan.FieldCreator:
		m.ClearCreator()
		return nil
	case plan.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case plan.FieldRemark:
		m.ClearRemark()
		return nil
	case plan.FieldOriginal:
		m.ClearOriginal()
		return nil
	case plan.FieldDesc:
		m.ClearDesc()
		return nil
	case plan.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown Plan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanMutation) ResetField(name string) error {
	switch name {
	case plan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case plan.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case plan.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case plan.FieldCreator:
		m.ResetCreator()
		return nil
	case plan.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case plan.FieldRemark:
		m.ResetRemark()
		return nil
	case plan.FieldEnable:
		m.ResetEnable()
		return nil
	case plan.FieldName:
		m.ResetName()
		return nil
	case plan.FieldStart:
		m.ResetStart()
		return nil
	case plan.FieldEnd:
		m.ResetEnd()
		return nil
	case plan.FieldPrice:
		m.ResetPrice()
		return nil
	case plan.FieldDays:
		m.ResetDays()
		return nil
	case plan.FieldCommission:
		m.ResetCommission()
		return nil
	case plan.FieldOriginal:
		m.ResetOriginal()
		return nil
	case plan.FieldDesc:
		m.ResetDesc()
		return nil
	case plan.FieldParentID:
		m.ResetParentID()
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.pms != nil {
		edges = append(edges, plan.EdgePms)
	}
	if m.cities != nil {
		edges = append(edges, plan.EdgeCities)
	}
	if m.parent != nil {
		edges = append(edges, plan.EdgeParent)
	}
	if m.complexes != nil {
		edges = append(edges, plan.EdgeComplexes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case plan.EdgePms:
		ids := make([]ent.Value, 0, len(m.pms))
		for id := range m.pms {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeCities:
		ids := make([]ent.Value, 0, len(m.cities))
		for id := range m.cities {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case plan.EdgeComplexes:
		ids := make([]ent.Value, 0, len(m.complexes))
		for id := range m.complexes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedpms != nil {
		edges = append(edges, plan.EdgePms)
	}
	if m.removedcities != nil {
		edges = append(edges, plan.EdgeCities)
	}
	if m.removedcomplexes != nil {
		edges = append(edges, plan.EdgeComplexes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case plan.EdgePms:
		ids := make([]ent.Value, 0, len(m.removedpms))
		for id := range m.removedpms {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeCities:
		ids := make([]ent.Value, 0, len(m.removedcities))
		for id := range m.removedcities {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeComplexes:
		ids := make([]ent.Value, 0, len(m.removedcomplexes))
		for id := range m.removedcomplexes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedpms {
		edges = append(edges, plan.EdgePms)
	}
	if m.clearedcities {
		edges = append(edges, plan.EdgeCities)
	}
	if m.clearedparent {
		edges = append(edges, plan.EdgeParent)
	}
	if m.clearedcomplexes {
		edges = append(edges, plan.EdgeComplexes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanMutation) EdgeCleared(name string) bool {
	switch name {
	case plan.EdgePms:
		return m.clearedpms
	case plan.EdgeCities:
		return m.clearedcities
	case plan.EdgeParent:
		return m.clearedparent
	case plan.EdgeComplexes:
		return m.clearedcomplexes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanMutation) ClearEdge(name string) error {
	switch name {
	case plan.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Plan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanMutation) ResetEdge(name string) error {
	switch name {
	case plan.EdgePms:
		m.ResetPms()
		return nil
	case plan.EdgeCities:
		m.ResetCities()
		return nil
	case plan.EdgeParent:
		m.ResetParent()
		return nil
	case plan.EdgeComplexes:
		m.ResetComplexes()
		return nil
	}
	return fmt.Errorf("unknown Plan edge %s", name)
}

// RiderMutation represents an operation that mutates the Rider nodes in the graph.
type RiderMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	phone             *string
	contact           **model.RiderContact
	device_type       *uint8
	adddevice_type    *int8
	last_device       *string
	is_new_device     *bool
	last_face         *string
	push_id           *string
	last_signin_at    *time.Time
	esign_account_id  *string
	plan_at           *time.Time
	blocked           *bool
	clearedFields     map[string]struct{}
	station           *uint64
	clearedstation    bool
	person            *uint64
	clearedperson     bool
	enterprise        *uint64
	clearedenterprise bool
	contracts         map[uint64]struct{}
	removedcontracts  map[uint64]struct{}
	clearedcontracts  bool
	faults            map[uint64]struct{}
	removedfaults     map[uint64]struct{}
	clearedfaults     bool
	orders            map[uint64]struct{}
	removedorders     map[uint64]struct{}
	clearedorders     bool
	exchanges         map[uint64]struct{}
	removedexchanges  map[uint64]struct{}
	clearedexchanges  bool
	subscribes        map[uint64]struct{}
	removedsubscribes map[uint64]struct{}
	clearedsubscribes bool
	stocks            map[uint64]struct{}
	removedstocks     map[uint64]struct{}
	clearedstocks     bool
	done              bool
	oldValue          func(context.Context) (*Rider, error)
	predicates        []predicate.Rider
}

var _ ent.Mutation = (*RiderMutation)(nil)

// riderOption allows management of the mutation configuration using functional options.
type riderOption func(*RiderMutation)

// newRiderMutation creates new mutation for the Rider entity.
func newRiderMutation(c config, op Op, opts ...riderOption) *RiderMutation {
	m := &RiderMutation{
		config:        c,
		op:            op,
		typ:           TypeRider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRiderID sets the ID field of the mutation.
func withRiderID(id uint64) riderOption {
	return func(m *RiderMutation) {
		var (
			err   error
			once  sync.Once
			value *Rider
		)
		m.oldValue = func(ctx context.Context) (*Rider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Rider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRider sets the old Rider of the mutation.
func withRider(node *Rider) riderOption {
	return func(m *RiderMutation) {
		m.oldValue = func(context.Context) (*Rider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RiderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RiderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RiderMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RiderMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Rider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RiderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RiderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RiderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RiderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RiderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RiderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RiderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RiderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RiderMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[rider.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RiderMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[rider.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RiderMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, rider.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *RiderMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *RiderMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *RiderMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[rider.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *RiderMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[rider.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *RiderMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, rider.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *RiderMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *RiderMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *RiderMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[rider.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *RiderMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[rider.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *RiderMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, rider.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *RiderMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *RiderMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *RiderMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[rider.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *RiderMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[rider.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *RiderMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, rider.FieldRemark)
}

// SetStationID sets the "station_id" field.
func (m *RiderMutation) SetStationID(u uint64) {
	m.station = &u
}

// StationID returns the value of the "station_id" field in the mutation.
func (m *RiderMutation) StationID() (r uint64, exists bool) {
	v := m.station
	if v == nil {
		return
	}
	return *v, true
}

// OldStationID returns the old "station_id" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldStationID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStationID: %w", err)
	}
	return oldValue.StationID, nil
}

// ClearStationID clears the value of the "station_id" field.
func (m *RiderMutation) ClearStationID() {
	m.station = nil
	m.clearedFields[rider.FieldStationID] = struct{}{}
}

// StationIDCleared returns if the "station_id" field was cleared in this mutation.
func (m *RiderMutation) StationIDCleared() bool {
	_, ok := m.clearedFields[rider.FieldStationID]
	return ok
}

// ResetStationID resets all changes to the "station_id" field.
func (m *RiderMutation) ResetStationID() {
	m.station = nil
	delete(m.clearedFields, rider.FieldStationID)
}

// SetPersonID sets the "person_id" field.
func (m *RiderMutation) SetPersonID(u uint64) {
	m.person = &u
}

// PersonID returns the value of the "person_id" field in the mutation.
func (m *RiderMutation) PersonID() (r uint64, exists bool) {
	v := m.person
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonID returns the old "person_id" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldPersonID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonID: %w", err)
	}
	return oldValue.PersonID, nil
}

// ClearPersonID clears the value of the "person_id" field.
func (m *RiderMutation) ClearPersonID() {
	m.person = nil
	m.clearedFields[rider.FieldPersonID] = struct{}{}
}

// PersonIDCleared returns if the "person_id" field was cleared in this mutation.
func (m *RiderMutation) PersonIDCleared() bool {
	_, ok := m.clearedFields[rider.FieldPersonID]
	return ok
}

// ResetPersonID resets all changes to the "person_id" field.
func (m *RiderMutation) ResetPersonID() {
	m.person = nil
	delete(m.clearedFields, rider.FieldPersonID)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *RiderMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *RiderMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldEnterpriseID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ClearEnterpriseID clears the value of the "enterprise_id" field.
func (m *RiderMutation) ClearEnterpriseID() {
	m.enterprise = nil
	m.clearedFields[rider.FieldEnterpriseID] = struct{}{}
}

// EnterpriseIDCleared returns if the "enterprise_id" field was cleared in this mutation.
func (m *RiderMutation) EnterpriseIDCleared() bool {
	_, ok := m.clearedFields[rider.FieldEnterpriseID]
	return ok
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *RiderMutation) ResetEnterpriseID() {
	m.enterprise = nil
	delete(m.clearedFields, rider.FieldEnterpriseID)
}

// SetPhone sets the "phone" field.
func (m *RiderMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *RiderMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *RiderMutation) ResetPhone() {
	m.phone = nil
}

// SetContact sets the "contact" field.
func (m *RiderMutation) SetContact(mc *model.RiderContact) {
	m.contact = &mc
}

// Contact returns the value of the "contact" field in the mutation.
func (m *RiderMutation) Contact() (r *model.RiderContact, exists bool) {
	v := m.contact
	if v == nil {
		return
	}
	return *v, true
}

// OldContact returns the old "contact" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldContact(ctx context.Context) (v *model.RiderContact, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContact: %w", err)
	}
	return oldValue.Contact, nil
}

// ClearContact clears the value of the "contact" field.
func (m *RiderMutation) ClearContact() {
	m.contact = nil
	m.clearedFields[rider.FieldContact] = struct{}{}
}

// ContactCleared returns if the "contact" field was cleared in this mutation.
func (m *RiderMutation) ContactCleared() bool {
	_, ok := m.clearedFields[rider.FieldContact]
	return ok
}

// ResetContact resets all changes to the "contact" field.
func (m *RiderMutation) ResetContact() {
	m.contact = nil
	delete(m.clearedFields, rider.FieldContact)
}

// SetDeviceType sets the "device_type" field.
func (m *RiderMutation) SetDeviceType(u uint8) {
	m.device_type = &u
	m.adddevice_type = nil
}

// DeviceType returns the value of the "device_type" field in the mutation.
func (m *RiderMutation) DeviceType() (r uint8, exists bool) {
	v := m.device_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceType returns the old "device_type" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldDeviceType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceType: %w", err)
	}
	return oldValue.DeviceType, nil
}

// AddDeviceType adds u to the "device_type" field.
func (m *RiderMutation) AddDeviceType(u int8) {
	if m.adddevice_type != nil {
		*m.adddevice_type += u
	} else {
		m.adddevice_type = &u
	}
}

// AddedDeviceType returns the value that was added to the "device_type" field in this mutation.
func (m *RiderMutation) AddedDeviceType() (r int8, exists bool) {
	v := m.adddevice_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeviceType clears the value of the "device_type" field.
func (m *RiderMutation) ClearDeviceType() {
	m.device_type = nil
	m.adddevice_type = nil
	m.clearedFields[rider.FieldDeviceType] = struct{}{}
}

// DeviceTypeCleared returns if the "device_type" field was cleared in this mutation.
func (m *RiderMutation) DeviceTypeCleared() bool {
	_, ok := m.clearedFields[rider.FieldDeviceType]
	return ok
}

// ResetDeviceType resets all changes to the "device_type" field.
func (m *RiderMutation) ResetDeviceType() {
	m.device_type = nil
	m.adddevice_type = nil
	delete(m.clearedFields, rider.FieldDeviceType)
}

// SetLastDevice sets the "last_device" field.
func (m *RiderMutation) SetLastDevice(s string) {
	m.last_device = &s
}

// LastDevice returns the value of the "last_device" field in the mutation.
func (m *RiderMutation) LastDevice() (r string, exists bool) {
	v := m.last_device
	if v == nil {
		return
	}
	return *v, true
}

// OldLastDevice returns the old "last_device" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldLastDevice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastDevice: %w", err)
	}
	return oldValue.LastDevice, nil
}

// ClearLastDevice clears the value of the "last_device" field.
func (m *RiderMutation) ClearLastDevice() {
	m.last_device = nil
	m.clearedFields[rider.FieldLastDevice] = struct{}{}
}

// LastDeviceCleared returns if the "last_device" field was cleared in this mutation.
func (m *RiderMutation) LastDeviceCleared() bool {
	_, ok := m.clearedFields[rider.FieldLastDevice]
	return ok
}

// ResetLastDevice resets all changes to the "last_device" field.
func (m *RiderMutation) ResetLastDevice() {
	m.last_device = nil
	delete(m.clearedFields, rider.FieldLastDevice)
}

// SetIsNewDevice sets the "is_new_device" field.
func (m *RiderMutation) SetIsNewDevice(b bool) {
	m.is_new_device = &b
}

// IsNewDevice returns the value of the "is_new_device" field in the mutation.
func (m *RiderMutation) IsNewDevice() (r bool, exists bool) {
	v := m.is_new_device
	if v == nil {
		return
	}
	return *v, true
}

// OldIsNewDevice returns the old "is_new_device" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldIsNewDevice(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsNewDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsNewDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsNewDevice: %w", err)
	}
	return oldValue.IsNewDevice, nil
}

// ResetIsNewDevice resets all changes to the "is_new_device" field.
func (m *RiderMutation) ResetIsNewDevice() {
	m.is_new_device = nil
}

// SetLastFace sets the "last_face" field.
func (m *RiderMutation) SetLastFace(s string) {
	m.last_face = &s
}

// LastFace returns the value of the "last_face" field in the mutation.
func (m *RiderMutation) LastFace() (r string, exists bool) {
	v := m.last_face
	if v == nil {
		return
	}
	return *v, true
}

// OldLastFace returns the old "last_face" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldLastFace(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastFace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastFace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastFace: %w", err)
	}
	return oldValue.LastFace, nil
}

// ClearLastFace clears the value of the "last_face" field.
func (m *RiderMutation) ClearLastFace() {
	m.last_face = nil
	m.clearedFields[rider.FieldLastFace] = struct{}{}
}

// LastFaceCleared returns if the "last_face" field was cleared in this mutation.
func (m *RiderMutation) LastFaceCleared() bool {
	_, ok := m.clearedFields[rider.FieldLastFace]
	return ok
}

// ResetLastFace resets all changes to the "last_face" field.
func (m *RiderMutation) ResetLastFace() {
	m.last_face = nil
	delete(m.clearedFields, rider.FieldLastFace)
}

// SetPushID sets the "push_id" field.
func (m *RiderMutation) SetPushID(s string) {
	m.push_id = &s
}

// PushID returns the value of the "push_id" field in the mutation.
func (m *RiderMutation) PushID() (r string, exists bool) {
	v := m.push_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPushID returns the old "push_id" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldPushID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPushID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPushID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPushID: %w", err)
	}
	return oldValue.PushID, nil
}

// ClearPushID clears the value of the "push_id" field.
func (m *RiderMutation) ClearPushID() {
	m.push_id = nil
	m.clearedFields[rider.FieldPushID] = struct{}{}
}

// PushIDCleared returns if the "push_id" field was cleared in this mutation.
func (m *RiderMutation) PushIDCleared() bool {
	_, ok := m.clearedFields[rider.FieldPushID]
	return ok
}

// ResetPushID resets all changes to the "push_id" field.
func (m *RiderMutation) ResetPushID() {
	m.push_id = nil
	delete(m.clearedFields, rider.FieldPushID)
}

// SetLastSigninAt sets the "last_signin_at" field.
func (m *RiderMutation) SetLastSigninAt(t time.Time) {
	m.last_signin_at = &t
}

// LastSigninAt returns the value of the "last_signin_at" field in the mutation.
func (m *RiderMutation) LastSigninAt() (r time.Time, exists bool) {
	v := m.last_signin_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSigninAt returns the old "last_signin_at" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldLastSigninAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSigninAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSigninAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSigninAt: %w", err)
	}
	return oldValue.LastSigninAt, nil
}

// ClearLastSigninAt clears the value of the "last_signin_at" field.
func (m *RiderMutation) ClearLastSigninAt() {
	m.last_signin_at = nil
	m.clearedFields[rider.FieldLastSigninAt] = struct{}{}
}

// LastSigninAtCleared returns if the "last_signin_at" field was cleared in this mutation.
func (m *RiderMutation) LastSigninAtCleared() bool {
	_, ok := m.clearedFields[rider.FieldLastSigninAt]
	return ok
}

// ResetLastSigninAt resets all changes to the "last_signin_at" field.
func (m *RiderMutation) ResetLastSigninAt() {
	m.last_signin_at = nil
	delete(m.clearedFields, rider.FieldLastSigninAt)
}

// SetEsignAccountID sets the "esign_account_id" field.
func (m *RiderMutation) SetEsignAccountID(s string) {
	m.esign_account_id = &s
}

// EsignAccountID returns the value of the "esign_account_id" field in the mutation.
func (m *RiderMutation) EsignAccountID() (r string, exists bool) {
	v := m.esign_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEsignAccountID returns the old "esign_account_id" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldEsignAccountID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEsignAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEsignAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEsignAccountID: %w", err)
	}
	return oldValue.EsignAccountID, nil
}

// ClearEsignAccountID clears the value of the "esign_account_id" field.
func (m *RiderMutation) ClearEsignAccountID() {
	m.esign_account_id = nil
	m.clearedFields[rider.FieldEsignAccountID] = struct{}{}
}

// EsignAccountIDCleared returns if the "esign_account_id" field was cleared in this mutation.
func (m *RiderMutation) EsignAccountIDCleared() bool {
	_, ok := m.clearedFields[rider.FieldEsignAccountID]
	return ok
}

// ResetEsignAccountID resets all changes to the "esign_account_id" field.
func (m *RiderMutation) ResetEsignAccountID() {
	m.esign_account_id = nil
	delete(m.clearedFields, rider.FieldEsignAccountID)
}

// SetPlanAt sets the "plan_at" field.
func (m *RiderMutation) SetPlanAt(t time.Time) {
	m.plan_at = &t
}

// PlanAt returns the value of the "plan_at" field in the mutation.
func (m *RiderMutation) PlanAt() (r time.Time, exists bool) {
	v := m.plan_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanAt returns the old "plan_at" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldPlanAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanAt: %w", err)
	}
	return oldValue.PlanAt, nil
}

// ClearPlanAt clears the value of the "plan_at" field.
func (m *RiderMutation) ClearPlanAt() {
	m.plan_at = nil
	m.clearedFields[rider.FieldPlanAt] = struct{}{}
}

// PlanAtCleared returns if the "plan_at" field was cleared in this mutation.
func (m *RiderMutation) PlanAtCleared() bool {
	_, ok := m.clearedFields[rider.FieldPlanAt]
	return ok
}

// ResetPlanAt resets all changes to the "plan_at" field.
func (m *RiderMutation) ResetPlanAt() {
	m.plan_at = nil
	delete(m.clearedFields, rider.FieldPlanAt)
}

// SetBlocked sets the "blocked" field.
func (m *RiderMutation) SetBlocked(b bool) {
	m.blocked = &b
}

// Blocked returns the value of the "blocked" field in the mutation.
func (m *RiderMutation) Blocked() (r bool, exists bool) {
	v := m.blocked
	if v == nil {
		return
	}
	return *v, true
}

// OldBlocked returns the old "blocked" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldBlocked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlocked: %w", err)
	}
	return oldValue.Blocked, nil
}

// ResetBlocked resets all changes to the "blocked" field.
func (m *RiderMutation) ResetBlocked() {
	m.blocked = nil
}

// ClearStation clears the "station" edge to the EnterpriseStation entity.
func (m *RiderMutation) ClearStation() {
	m.clearedstation = true
}

// StationCleared reports if the "station" edge to the EnterpriseStation entity was cleared.
func (m *RiderMutation) StationCleared() bool {
	return m.StationIDCleared() || m.clearedstation
}

// StationIDs returns the "station" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StationID instead. It exists only for internal usage by the builders.
func (m *RiderMutation) StationIDs() (ids []uint64) {
	if id := m.station; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStation resets all changes to the "station" edge.
func (m *RiderMutation) ResetStation() {
	m.station = nil
	m.clearedstation = false
}

// ClearPerson clears the "person" edge to the Person entity.
func (m *RiderMutation) ClearPerson() {
	m.clearedperson = true
}

// PersonCleared reports if the "person" edge to the Person entity was cleared.
func (m *RiderMutation) PersonCleared() bool {
	return m.PersonIDCleared() || m.clearedperson
}

// PersonIDs returns the "person" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PersonID instead. It exists only for internal usage by the builders.
func (m *RiderMutation) PersonIDs() (ids []uint64) {
	if id := m.person; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPerson resets all changes to the "person" edge.
func (m *RiderMutation) ResetPerson() {
	m.person = nil
	m.clearedperson = false
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *RiderMutation) ClearEnterprise() {
	m.clearedenterprise = true
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *RiderMutation) EnterpriseCleared() bool {
	return m.EnterpriseIDCleared() || m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *RiderMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *RiderMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// AddContractIDs adds the "contracts" edge to the Contract entity by ids.
func (m *RiderMutation) AddContractIDs(ids ...uint64) {
	if m.contracts == nil {
		m.contracts = make(map[uint64]struct{})
	}
	for i := range ids {
		m.contracts[ids[i]] = struct{}{}
	}
}

// ClearContracts clears the "contracts" edge to the Contract entity.
func (m *RiderMutation) ClearContracts() {
	m.clearedcontracts = true
}

// ContractsCleared reports if the "contracts" edge to the Contract entity was cleared.
func (m *RiderMutation) ContractsCleared() bool {
	return m.clearedcontracts
}

// RemoveContractIDs removes the "contracts" edge to the Contract entity by IDs.
func (m *RiderMutation) RemoveContractIDs(ids ...uint64) {
	if m.removedcontracts == nil {
		m.removedcontracts = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.contracts, ids[i])
		m.removedcontracts[ids[i]] = struct{}{}
	}
}

// RemovedContracts returns the removed IDs of the "contracts" edge to the Contract entity.
func (m *RiderMutation) RemovedContractsIDs() (ids []uint64) {
	for id := range m.removedcontracts {
		ids = append(ids, id)
	}
	return
}

// ContractsIDs returns the "contracts" edge IDs in the mutation.
func (m *RiderMutation) ContractsIDs() (ids []uint64) {
	for id := range m.contracts {
		ids = append(ids, id)
	}
	return
}

// ResetContracts resets all changes to the "contracts" edge.
func (m *RiderMutation) ResetContracts() {
	m.contracts = nil
	m.clearedcontracts = false
	m.removedcontracts = nil
}

// AddFaultIDs adds the "faults" edge to the CabinetFault entity by ids.
func (m *RiderMutation) AddFaultIDs(ids ...uint64) {
	if m.faults == nil {
		m.faults = make(map[uint64]struct{})
	}
	for i := range ids {
		m.faults[ids[i]] = struct{}{}
	}
}

// ClearFaults clears the "faults" edge to the CabinetFault entity.
func (m *RiderMutation) ClearFaults() {
	m.clearedfaults = true
}

// FaultsCleared reports if the "faults" edge to the CabinetFault entity was cleared.
func (m *RiderMutation) FaultsCleared() bool {
	return m.clearedfaults
}

// RemoveFaultIDs removes the "faults" edge to the CabinetFault entity by IDs.
func (m *RiderMutation) RemoveFaultIDs(ids ...uint64) {
	if m.removedfaults == nil {
		m.removedfaults = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.faults, ids[i])
		m.removedfaults[ids[i]] = struct{}{}
	}
}

// RemovedFaults returns the removed IDs of the "faults" edge to the CabinetFault entity.
func (m *RiderMutation) RemovedFaultsIDs() (ids []uint64) {
	for id := range m.removedfaults {
		ids = append(ids, id)
	}
	return
}

// FaultsIDs returns the "faults" edge IDs in the mutation.
func (m *RiderMutation) FaultsIDs() (ids []uint64) {
	for id := range m.faults {
		ids = append(ids, id)
	}
	return
}

// ResetFaults resets all changes to the "faults" edge.
func (m *RiderMutation) ResetFaults() {
	m.faults = nil
	m.clearedfaults = false
	m.removedfaults = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *RiderMutation) AddOrderIDs(ids ...uint64) {
	if m.orders == nil {
		m.orders = make(map[uint64]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *RiderMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *RiderMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *RiderMutation) RemoveOrderIDs(ids ...uint64) {
	if m.removedorders == nil {
		m.removedorders = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *RiderMutation) RemovedOrdersIDs() (ids []uint64) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *RiderMutation) OrdersIDs() (ids []uint64) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *RiderMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// AddExchangeIDs adds the "exchanges" edge to the Exchange entity by ids.
func (m *RiderMutation) AddExchangeIDs(ids ...uint64) {
	if m.exchanges == nil {
		m.exchanges = make(map[uint64]struct{})
	}
	for i := range ids {
		m.exchanges[ids[i]] = struct{}{}
	}
}

// ClearExchanges clears the "exchanges" edge to the Exchange entity.
func (m *RiderMutation) ClearExchanges() {
	m.clearedexchanges = true
}

// ExchangesCleared reports if the "exchanges" edge to the Exchange entity was cleared.
func (m *RiderMutation) ExchangesCleared() bool {
	return m.clearedexchanges
}

// RemoveExchangeIDs removes the "exchanges" edge to the Exchange entity by IDs.
func (m *RiderMutation) RemoveExchangeIDs(ids ...uint64) {
	if m.removedexchanges == nil {
		m.removedexchanges = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.exchanges, ids[i])
		m.removedexchanges[ids[i]] = struct{}{}
	}
}

// RemovedExchanges returns the removed IDs of the "exchanges" edge to the Exchange entity.
func (m *RiderMutation) RemovedExchangesIDs() (ids []uint64) {
	for id := range m.removedexchanges {
		ids = append(ids, id)
	}
	return
}

// ExchangesIDs returns the "exchanges" edge IDs in the mutation.
func (m *RiderMutation) ExchangesIDs() (ids []uint64) {
	for id := range m.exchanges {
		ids = append(ids, id)
	}
	return
}

// ResetExchanges resets all changes to the "exchanges" edge.
func (m *RiderMutation) ResetExchanges() {
	m.exchanges = nil
	m.clearedexchanges = false
	m.removedexchanges = nil
}

// AddSubscribeIDs adds the "subscribes" edge to the Subscribe entity by ids.
func (m *RiderMutation) AddSubscribeIDs(ids ...uint64) {
	if m.subscribes == nil {
		m.subscribes = make(map[uint64]struct{})
	}
	for i := range ids {
		m.subscribes[ids[i]] = struct{}{}
	}
}

// ClearSubscribes clears the "subscribes" edge to the Subscribe entity.
func (m *RiderMutation) ClearSubscribes() {
	m.clearedsubscribes = true
}

// SubscribesCleared reports if the "subscribes" edge to the Subscribe entity was cleared.
func (m *RiderMutation) SubscribesCleared() bool {
	return m.clearedsubscribes
}

// RemoveSubscribeIDs removes the "subscribes" edge to the Subscribe entity by IDs.
func (m *RiderMutation) RemoveSubscribeIDs(ids ...uint64) {
	if m.removedsubscribes == nil {
		m.removedsubscribes = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.subscribes, ids[i])
		m.removedsubscribes[ids[i]] = struct{}{}
	}
}

// RemovedSubscribes returns the removed IDs of the "subscribes" edge to the Subscribe entity.
func (m *RiderMutation) RemovedSubscribesIDs() (ids []uint64) {
	for id := range m.removedsubscribes {
		ids = append(ids, id)
	}
	return
}

// SubscribesIDs returns the "subscribes" edge IDs in the mutation.
func (m *RiderMutation) SubscribesIDs() (ids []uint64) {
	for id := range m.subscribes {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribes resets all changes to the "subscribes" edge.
func (m *RiderMutation) ResetSubscribes() {
	m.subscribes = nil
	m.clearedsubscribes = false
	m.removedsubscribes = nil
}

// AddStockIDs adds the "stocks" edge to the Stock entity by ids.
func (m *RiderMutation) AddStockIDs(ids ...uint64) {
	if m.stocks == nil {
		m.stocks = make(map[uint64]struct{})
	}
	for i := range ids {
		m.stocks[ids[i]] = struct{}{}
	}
}

// ClearStocks clears the "stocks" edge to the Stock entity.
func (m *RiderMutation) ClearStocks() {
	m.clearedstocks = true
}

// StocksCleared reports if the "stocks" edge to the Stock entity was cleared.
func (m *RiderMutation) StocksCleared() bool {
	return m.clearedstocks
}

// RemoveStockIDs removes the "stocks" edge to the Stock entity by IDs.
func (m *RiderMutation) RemoveStockIDs(ids ...uint64) {
	if m.removedstocks == nil {
		m.removedstocks = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.stocks, ids[i])
		m.removedstocks[ids[i]] = struct{}{}
	}
}

// RemovedStocks returns the removed IDs of the "stocks" edge to the Stock entity.
func (m *RiderMutation) RemovedStocksIDs() (ids []uint64) {
	for id := range m.removedstocks {
		ids = append(ids, id)
	}
	return
}

// StocksIDs returns the "stocks" edge IDs in the mutation.
func (m *RiderMutation) StocksIDs() (ids []uint64) {
	for id := range m.stocks {
		ids = append(ids, id)
	}
	return
}

// ResetStocks resets all changes to the "stocks" edge.
func (m *RiderMutation) ResetStocks() {
	m.stocks = nil
	m.clearedstocks = false
	m.removedstocks = nil
}

// Where appends a list predicates to the RiderMutation builder.
func (m *RiderMutation) Where(ps ...predicate.Rider) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RiderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Rider).
func (m *RiderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RiderMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, rider.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, rider.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, rider.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, rider.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, rider.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, rider.FieldRemark)
	}
	if m.station != nil {
		fields = append(fields, rider.FieldStationID)
	}
	if m.person != nil {
		fields = append(fields, rider.FieldPersonID)
	}
	if m.enterprise != nil {
		fields = append(fields, rider.FieldEnterpriseID)
	}
	if m.phone != nil {
		fields = append(fields, rider.FieldPhone)
	}
	if m.contact != nil {
		fields = append(fields, rider.FieldContact)
	}
	if m.device_type != nil {
		fields = append(fields, rider.FieldDeviceType)
	}
	if m.last_device != nil {
		fields = append(fields, rider.FieldLastDevice)
	}
	if m.is_new_device != nil {
		fields = append(fields, rider.FieldIsNewDevice)
	}
	if m.last_face != nil {
		fields = append(fields, rider.FieldLastFace)
	}
	if m.push_id != nil {
		fields = append(fields, rider.FieldPushID)
	}
	if m.last_signin_at != nil {
		fields = append(fields, rider.FieldLastSigninAt)
	}
	if m.esign_account_id != nil {
		fields = append(fields, rider.FieldEsignAccountID)
	}
	if m.plan_at != nil {
		fields = append(fields, rider.FieldPlanAt)
	}
	if m.blocked != nil {
		fields = append(fields, rider.FieldBlocked)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RiderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rider.FieldCreatedAt:
		return m.CreatedAt()
	case rider.FieldUpdatedAt:
		return m.UpdatedAt()
	case rider.FieldDeletedAt:
		return m.DeletedAt()
	case rider.FieldCreator:
		return m.Creator()
	case rider.FieldLastModifier:
		return m.LastModifier()
	case rider.FieldRemark:
		return m.Remark()
	case rider.FieldStationID:
		return m.StationID()
	case rider.FieldPersonID:
		return m.PersonID()
	case rider.FieldEnterpriseID:
		return m.EnterpriseID()
	case rider.FieldPhone:
		return m.Phone()
	case rider.FieldContact:
		return m.Contact()
	case rider.FieldDeviceType:
		return m.DeviceType()
	case rider.FieldLastDevice:
		return m.LastDevice()
	case rider.FieldIsNewDevice:
		return m.IsNewDevice()
	case rider.FieldLastFace:
		return m.LastFace()
	case rider.FieldPushID:
		return m.PushID()
	case rider.FieldLastSigninAt:
		return m.LastSigninAt()
	case rider.FieldEsignAccountID:
		return m.EsignAccountID()
	case rider.FieldPlanAt:
		return m.PlanAt()
	case rider.FieldBlocked:
		return m.Blocked()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RiderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rider.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case rider.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case rider.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case rider.FieldCreator:
		return m.OldCreator(ctx)
	case rider.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case rider.FieldRemark:
		return m.OldRemark(ctx)
	case rider.FieldStationID:
		return m.OldStationID(ctx)
	case rider.FieldPersonID:
		return m.OldPersonID(ctx)
	case rider.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case rider.FieldPhone:
		return m.OldPhone(ctx)
	case rider.FieldContact:
		return m.OldContact(ctx)
	case rider.FieldDeviceType:
		return m.OldDeviceType(ctx)
	case rider.FieldLastDevice:
		return m.OldLastDevice(ctx)
	case rider.FieldIsNewDevice:
		return m.OldIsNewDevice(ctx)
	case rider.FieldLastFace:
		return m.OldLastFace(ctx)
	case rider.FieldPushID:
		return m.OldPushID(ctx)
	case rider.FieldLastSigninAt:
		return m.OldLastSigninAt(ctx)
	case rider.FieldEsignAccountID:
		return m.OldEsignAccountID(ctx)
	case rider.FieldPlanAt:
		return m.OldPlanAt(ctx)
	case rider.FieldBlocked:
		return m.OldBlocked(ctx)
	}
	return nil, fmt.Errorf("unknown Rider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rider.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case rider.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case rider.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case rider.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case rider.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case rider.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case rider.FieldStationID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStationID(v)
		return nil
	case rider.FieldPersonID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonID(v)
		return nil
	case rider.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case rider.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case rider.FieldContact:
		v, ok := value.(*model.RiderContact)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContact(v)
		return nil
	case rider.FieldDeviceType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceType(v)
		return nil
	case rider.FieldLastDevice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastDevice(v)
		return nil
	case rider.FieldIsNewDevice:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNewDevice(v)
		return nil
	case rider.FieldLastFace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastFace(v)
		return nil
	case rider.FieldPushID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPushID(v)
		return nil
	case rider.FieldLastSigninAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSigninAt(v)
		return nil
	case rider.FieldEsignAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEsignAccountID(v)
		return nil
	case rider.FieldPlanAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanAt(v)
		return nil
	case rider.FieldBlocked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlocked(v)
		return nil
	}
	return fmt.Errorf("unknown Rider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RiderMutation) AddedFields() []string {
	var fields []string
	if m.adddevice_type != nil {
		fields = append(fields, rider.FieldDeviceType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RiderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rider.FieldDeviceType:
		return m.AddedDeviceType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rider.FieldDeviceType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceType(v)
		return nil
	}
	return fmt.Errorf("unknown Rider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RiderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rider.FieldDeletedAt) {
		fields = append(fields, rider.FieldDeletedAt)
	}
	if m.FieldCleared(rider.FieldCreator) {
		fields = append(fields, rider.FieldCreator)
	}
	if m.FieldCleared(rider.FieldLastModifier) {
		fields = append(fields, rider.FieldLastModifier)
	}
	if m.FieldCleared(rider.FieldRemark) {
		fields = append(fields, rider.FieldRemark)
	}
	if m.FieldCleared(rider.FieldStationID) {
		fields = append(fields, rider.FieldStationID)
	}
	if m.FieldCleared(rider.FieldPersonID) {
		fields = append(fields, rider.FieldPersonID)
	}
	if m.FieldCleared(rider.FieldEnterpriseID) {
		fields = append(fields, rider.FieldEnterpriseID)
	}
	if m.FieldCleared(rider.FieldContact) {
		fields = append(fields, rider.FieldContact)
	}
	if m.FieldCleared(rider.FieldDeviceType) {
		fields = append(fields, rider.FieldDeviceType)
	}
	if m.FieldCleared(rider.FieldLastDevice) {
		fields = append(fields, rider.FieldLastDevice)
	}
	if m.FieldCleared(rider.FieldLastFace) {
		fields = append(fields, rider.FieldLastFace)
	}
	if m.FieldCleared(rider.FieldPushID) {
		fields = append(fields, rider.FieldPushID)
	}
	if m.FieldCleared(rider.FieldLastSigninAt) {
		fields = append(fields, rider.FieldLastSigninAt)
	}
	if m.FieldCleared(rider.FieldEsignAccountID) {
		fields = append(fields, rider.FieldEsignAccountID)
	}
	if m.FieldCleared(rider.FieldPlanAt) {
		fields = append(fields, rider.FieldPlanAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RiderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RiderMutation) ClearField(name string) error {
	switch name {
	case rider.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case rider.FieldCreator:
		m.ClearCreator()
		return nil
	case rider.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case rider.FieldRemark:
		m.ClearRemark()
		return nil
	case rider.FieldStationID:
		m.ClearStationID()
		return nil
	case rider.FieldPersonID:
		m.ClearPersonID()
		return nil
	case rider.FieldEnterpriseID:
		m.ClearEnterpriseID()
		return nil
	case rider.FieldContact:
		m.ClearContact()
		return nil
	case rider.FieldDeviceType:
		m.ClearDeviceType()
		return nil
	case rider.FieldLastDevice:
		m.ClearLastDevice()
		return nil
	case rider.FieldLastFace:
		m.ClearLastFace()
		return nil
	case rider.FieldPushID:
		m.ClearPushID()
		return nil
	case rider.FieldLastSigninAt:
		m.ClearLastSigninAt()
		return nil
	case rider.FieldEsignAccountID:
		m.ClearEsignAccountID()
		return nil
	case rider.FieldPlanAt:
		m.ClearPlanAt()
		return nil
	}
	return fmt.Errorf("unknown Rider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RiderMutation) ResetField(name string) error {
	switch name {
	case rider.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case rider.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case rider.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case rider.FieldCreator:
		m.ResetCreator()
		return nil
	case rider.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case rider.FieldRemark:
		m.ResetRemark()
		return nil
	case rider.FieldStationID:
		m.ResetStationID()
		return nil
	case rider.FieldPersonID:
		m.ResetPersonID()
		return nil
	case rider.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case rider.FieldPhone:
		m.ResetPhone()
		return nil
	case rider.FieldContact:
		m.ResetContact()
		return nil
	case rider.FieldDeviceType:
		m.ResetDeviceType()
		return nil
	case rider.FieldLastDevice:
		m.ResetLastDevice()
		return nil
	case rider.FieldIsNewDevice:
		m.ResetIsNewDevice()
		return nil
	case rider.FieldLastFace:
		m.ResetLastFace()
		return nil
	case rider.FieldPushID:
		m.ResetPushID()
		return nil
	case rider.FieldLastSigninAt:
		m.ResetLastSigninAt()
		return nil
	case rider.FieldEsignAccountID:
		m.ResetEsignAccountID()
		return nil
	case rider.FieldPlanAt:
		m.ResetPlanAt()
		return nil
	case rider.FieldBlocked:
		m.ResetBlocked()
		return nil
	}
	return fmt.Errorf("unknown Rider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RiderMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.station != nil {
		edges = append(edges, rider.EdgeStation)
	}
	if m.person != nil {
		edges = append(edges, rider.EdgePerson)
	}
	if m.enterprise != nil {
		edges = append(edges, rider.EdgeEnterprise)
	}
	if m.contracts != nil {
		edges = append(edges, rider.EdgeContracts)
	}
	if m.faults != nil {
		edges = append(edges, rider.EdgeFaults)
	}
	if m.orders != nil {
		edges = append(edges, rider.EdgeOrders)
	}
	if m.exchanges != nil {
		edges = append(edges, rider.EdgeExchanges)
	}
	if m.subscribes != nil {
		edges = append(edges, rider.EdgeSubscribes)
	}
	if m.stocks != nil {
		edges = append(edges, rider.EdgeStocks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RiderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rider.EdgeStation:
		if id := m.station; id != nil {
			return []ent.Value{*id}
		}
	case rider.EdgePerson:
		if id := m.person; id != nil {
			return []ent.Value{*id}
		}
	case rider.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	case rider.EdgeContracts:
		ids := make([]ent.Value, 0, len(m.contracts))
		for id := range m.contracts {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeFaults:
		ids := make([]ent.Value, 0, len(m.faults))
		for id := range m.faults {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeExchanges:
		ids := make([]ent.Value, 0, len(m.exchanges))
		for id := range m.exchanges {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeSubscribes:
		ids := make([]ent.Value, 0, len(m.subscribes))
		for id := range m.subscribes {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.stocks))
		for id := range m.stocks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RiderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedcontracts != nil {
		edges = append(edges, rider.EdgeContracts)
	}
	if m.removedfaults != nil {
		edges = append(edges, rider.EdgeFaults)
	}
	if m.removedorders != nil {
		edges = append(edges, rider.EdgeOrders)
	}
	if m.removedexchanges != nil {
		edges = append(edges, rider.EdgeExchanges)
	}
	if m.removedsubscribes != nil {
		edges = append(edges, rider.EdgeSubscribes)
	}
	if m.removedstocks != nil {
		edges = append(edges, rider.EdgeStocks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RiderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case rider.EdgeContracts:
		ids := make([]ent.Value, 0, len(m.removedcontracts))
		for id := range m.removedcontracts {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeFaults:
		ids := make([]ent.Value, 0, len(m.removedfaults))
		for id := range m.removedfaults {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeExchanges:
		ids := make([]ent.Value, 0, len(m.removedexchanges))
		for id := range m.removedexchanges {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeSubscribes:
		ids := make([]ent.Value, 0, len(m.removedsubscribes))
		for id := range m.removedsubscribes {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.removedstocks))
		for id := range m.removedstocks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RiderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedstation {
		edges = append(edges, rider.EdgeStation)
	}
	if m.clearedperson {
		edges = append(edges, rider.EdgePerson)
	}
	if m.clearedenterprise {
		edges = append(edges, rider.EdgeEnterprise)
	}
	if m.clearedcontracts {
		edges = append(edges, rider.EdgeContracts)
	}
	if m.clearedfaults {
		edges = append(edges, rider.EdgeFaults)
	}
	if m.clearedorders {
		edges = append(edges, rider.EdgeOrders)
	}
	if m.clearedexchanges {
		edges = append(edges, rider.EdgeExchanges)
	}
	if m.clearedsubscribes {
		edges = append(edges, rider.EdgeSubscribes)
	}
	if m.clearedstocks {
		edges = append(edges, rider.EdgeStocks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RiderMutation) EdgeCleared(name string) bool {
	switch name {
	case rider.EdgeStation:
		return m.clearedstation
	case rider.EdgePerson:
		return m.clearedperson
	case rider.EdgeEnterprise:
		return m.clearedenterprise
	case rider.EdgeContracts:
		return m.clearedcontracts
	case rider.EdgeFaults:
		return m.clearedfaults
	case rider.EdgeOrders:
		return m.clearedorders
	case rider.EdgeExchanges:
		return m.clearedexchanges
	case rider.EdgeSubscribes:
		return m.clearedsubscribes
	case rider.EdgeStocks:
		return m.clearedstocks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RiderMutation) ClearEdge(name string) error {
	switch name {
	case rider.EdgeStation:
		m.ClearStation()
		return nil
	case rider.EdgePerson:
		m.ClearPerson()
		return nil
	case rider.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	}
	return fmt.Errorf("unknown Rider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RiderMutation) ResetEdge(name string) error {
	switch name {
	case rider.EdgeStation:
		m.ResetStation()
		return nil
	case rider.EdgePerson:
		m.ResetPerson()
		return nil
	case rider.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	case rider.EdgeContracts:
		m.ResetContracts()
		return nil
	case rider.EdgeFaults:
		m.ResetFaults()
		return nil
	case rider.EdgeOrders:
		m.ResetOrders()
		return nil
	case rider.EdgeExchanges:
		m.ResetExchanges()
		return nil
	case rider.EdgeSubscribes:
		m.ResetSubscribes()
		return nil
	case rider.EdgeStocks:
		m.ResetStocks()
		return nil
	}
	return fmt.Errorf("unknown Rider edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	creator       **model.Modifier
	last_modifier **model.Modifier
	remark        *string
	key           *string
	desc          *string
	content       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id uint64) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SettingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreator sets the "creator" field.
func (m *SettingMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *SettingMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *SettingMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[setting.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *SettingMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[setting.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *SettingMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, setting.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *SettingMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *SettingMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *SettingMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[setting.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *SettingMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[setting.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *SettingMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, setting.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *SettingMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *SettingMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *SettingMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[setting.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *SettingMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[setting.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *SettingMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, setting.FieldRemark)
}

// SetKey sets the "key" field.
func (m *SettingMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SettingMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SettingMutation) ResetKey() {
	m.key = nil
}

// SetDesc sets the "desc" field.
func (m *SettingMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *SettingMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *SettingMutation) ResetDesc() {
	m.desc = nil
}

// SetContent sets the "content" field.
func (m *SettingMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *SettingMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *SettingMutation) ResetContent() {
	m.content = nil
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, setting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, setting.FieldUpdatedAt)
	}
	if m.creator != nil {
		fields = append(fields, setting.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, setting.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, setting.FieldRemark)
	}
	if m.key != nil {
		fields = append(fields, setting.FieldKey)
	}
	if m.desc != nil {
		fields = append(fields, setting.FieldDesc)
	}
	if m.content != nil {
		fields = append(fields, setting.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldCreatedAt:
		return m.CreatedAt()
	case setting.FieldUpdatedAt:
		return m.UpdatedAt()
	case setting.FieldCreator:
		return m.Creator()
	case setting.FieldLastModifier:
		return m.LastModifier()
	case setting.FieldRemark:
		return m.Remark()
	case setting.FieldKey:
		return m.Key()
	case setting.FieldDesc:
		return m.Desc()
	case setting.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case setting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case setting.FieldCreator:
		return m.OldCreator(ctx)
	case setting.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case setting.FieldRemark:
		return m.OldRemark(ctx)
	case setting.FieldKey:
		return m.OldKey(ctx)
	case setting.FieldDesc:
		return m.OldDesc(ctx)
	case setting.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case setting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case setting.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case setting.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case setting.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case setting.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case setting.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case setting.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(setting.FieldCreator) {
		fields = append(fields, setting.FieldCreator)
	}
	if m.FieldCleared(setting.FieldLastModifier) {
		fields = append(fields, setting.FieldLastModifier)
	}
	if m.FieldCleared(setting.FieldRemark) {
		fields = append(fields, setting.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	switch name {
	case setting.FieldCreator:
		m.ClearCreator()
		return nil
	case setting.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case setting.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case setting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case setting.FieldCreator:
		m.ResetCreator()
		return nil
	case setting.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case setting.FieldRemark:
		m.ResetRemark()
		return nil
	case setting.FieldKey:
		m.ResetKey()
		return nil
	case setting.FieldDesc:
		m.ResetDesc()
		return nil
	case setting.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// StockMutation represents an operation that mutates the Stock nodes in the graph.
type StockMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	creator         **model.Modifier
	last_modifier   **model.Modifier
	remark          *string
	sn              *string
	_type           *uint8
	add_type        *int8
	name            *string
	voltage         *float64
	addvoltage      *float64
	num             *int
	addnum          *int
	clearedFields   map[string]struct{}
	manager         *uint64
	clearedmanager  bool
	store           *uint64
	clearedstore    bool
	rider           *uint64
	clearedrider    bool
	employee        *uint64
	clearedemployee bool
	done            bool
	oldValue        func(context.Context) (*Stock, error)
	predicates      []predicate.Stock
}

var _ ent.Mutation = (*StockMutation)(nil)

// stockOption allows management of the mutation configuration using functional options.
type stockOption func(*StockMutation)

// newStockMutation creates new mutation for the Stock entity.
func newStockMutation(c config, op Op, opts ...stockOption) *StockMutation {
	m := &StockMutation{
		config:        c,
		op:            op,
		typ:           TypeStock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStockID sets the ID field of the mutation.
func withStockID(id uint64) stockOption {
	return func(m *StockMutation) {
		var (
			err   error
			once  sync.Once
			value *Stock
		)
		m.oldValue = func(ctx context.Context) (*Stock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Stock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStock sets the old Stock of the mutation.
func withStock(node *Stock) stockOption {
	return func(m *StockMutation) {
		m.oldValue = func(context.Context) (*Stock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StockMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StockMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Stock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StockMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StockMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StockMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StockMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StockMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StockMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StockMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StockMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *StockMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[stock.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *StockMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[stock.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StockMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, stock.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *StockMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *StockMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *StockMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[stock.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *StockMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[stock.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *StockMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, stock.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *StockMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *StockMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *StockMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[stock.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *StockMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[stock.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *StockMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, stock.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *StockMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *StockMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *StockMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[stock.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *StockMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[stock.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *StockMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, stock.FieldRemark)
}

// SetManagerID sets the "manager_id" field.
func (m *StockMutation) SetManagerID(u uint64) {
	m.manager = &u
}

// ManagerID returns the value of the "manager_id" field in the mutation.
func (m *StockMutation) ManagerID() (r uint64, exists bool) {
	v := m.manager
	if v == nil {
		return
	}
	return *v, true
}

// OldManagerID returns the old "manager_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldManagerID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagerID: %w", err)
	}
	return oldValue.ManagerID, nil
}

// ClearManagerID clears the value of the "manager_id" field.
func (m *StockMutation) ClearManagerID() {
	m.manager = nil
	m.clearedFields[stock.FieldManagerID] = struct{}{}
}

// ManagerIDCleared returns if the "manager_id" field was cleared in this mutation.
func (m *StockMutation) ManagerIDCleared() bool {
	_, ok := m.clearedFields[stock.FieldManagerID]
	return ok
}

// ResetManagerID resets all changes to the "manager_id" field.
func (m *StockMutation) ResetManagerID() {
	m.manager = nil
	delete(m.clearedFields, stock.FieldManagerID)
}

// SetSn sets the "sn" field.
func (m *StockMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *StockMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *StockMutation) ResetSn() {
	m.sn = nil
}

// SetType sets the "type" field.
func (m *StockMutation) SetType(u uint8) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *StockMutation) GetType() (r uint8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *StockMutation) AddType(u int8) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *StockMutation) AddedType() (r int8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *StockMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetStoreID sets the "store_id" field.
func (m *StockMutation) SetStoreID(u uint64) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *StockMutation) StoreID() (r uint64, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldStoreID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *StockMutation) ClearStoreID() {
	m.store = nil
	m.clearedFields[stock.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *StockMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[stock.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *StockMutation) ResetStoreID() {
	m.store = nil
	delete(m.clearedFields, stock.FieldStoreID)
}

// SetRiderID sets the "rider_id" field.
func (m *StockMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *StockMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldRiderID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ClearRiderID clears the value of the "rider_id" field.
func (m *StockMutation) ClearRiderID() {
	m.rider = nil
	m.clearedFields[stock.FieldRiderID] = struct{}{}
}

// RiderIDCleared returns if the "rider_id" field was cleared in this mutation.
func (m *StockMutation) RiderIDCleared() bool {
	_, ok := m.clearedFields[stock.FieldRiderID]
	return ok
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *StockMutation) ResetRiderID() {
	m.rider = nil
	delete(m.clearedFields, stock.FieldRiderID)
}

// SetEmployeeID sets the "employee_id" field.
func (m *StockMutation) SetEmployeeID(u uint64) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *StockMutation) EmployeeID() (r uint64, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldEmployeeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *StockMutation) ClearEmployeeID() {
	m.employee = nil
	m.clearedFields[stock.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *StockMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[stock.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *StockMutation) ResetEmployeeID() {
	m.employee = nil
	delete(m.clearedFields, stock.FieldEmployeeID)
}

// SetName sets the "name" field.
func (m *StockMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StockMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StockMutation) ResetName() {
	m.name = nil
}

// SetVoltage sets the "voltage" field.
func (m *StockMutation) SetVoltage(f float64) {
	m.voltage = &f
	m.addvoltage = nil
}

// Voltage returns the value of the "voltage" field in the mutation.
func (m *StockMutation) Voltage() (r float64, exists bool) {
	v := m.voltage
	if v == nil {
		return
	}
	return *v, true
}

// OldVoltage returns the old "voltage" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldVoltage(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoltage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoltage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoltage: %w", err)
	}
	return oldValue.Voltage, nil
}

// AddVoltage adds f to the "voltage" field.
func (m *StockMutation) AddVoltage(f float64) {
	if m.addvoltage != nil {
		*m.addvoltage += f
	} else {
		m.addvoltage = &f
	}
}

// AddedVoltage returns the value that was added to the "voltage" field in this mutation.
func (m *StockMutation) AddedVoltage() (r float64, exists bool) {
	v := m.addvoltage
	if v == nil {
		return
	}
	return *v, true
}

// ClearVoltage clears the value of the "voltage" field.
func (m *StockMutation) ClearVoltage() {
	m.voltage = nil
	m.addvoltage = nil
	m.clearedFields[stock.FieldVoltage] = struct{}{}
}

// VoltageCleared returns if the "voltage" field was cleared in this mutation.
func (m *StockMutation) VoltageCleared() bool {
	_, ok := m.clearedFields[stock.FieldVoltage]
	return ok
}

// ResetVoltage resets all changes to the "voltage" field.
func (m *StockMutation) ResetVoltage() {
	m.voltage = nil
	m.addvoltage = nil
	delete(m.clearedFields, stock.FieldVoltage)
}

// SetNum sets the "num" field.
func (m *StockMutation) SetNum(i int) {
	m.num = &i
	m.addnum = nil
}

// Num returns the value of the "num" field in the mutation.
func (m *StockMutation) Num() (r int, exists bool) {
	v := m.num
	if v == nil {
		return
	}
	return *v, true
}

// OldNum returns the old "num" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNum: %w", err)
	}
	return oldValue.Num, nil
}

// AddNum adds i to the "num" field.
func (m *StockMutation) AddNum(i int) {
	if m.addnum != nil {
		*m.addnum += i
	} else {
		m.addnum = &i
	}
}

// AddedNum returns the value that was added to the "num" field in this mutation.
func (m *StockMutation) AddedNum() (r int, exists bool) {
	v := m.addnum
	if v == nil {
		return
	}
	return *v, true
}

// ResetNum resets all changes to the "num" field.
func (m *StockMutation) ResetNum() {
	m.num = nil
	m.addnum = nil
}

// ClearManager clears the "manager" edge to the Manager entity.
func (m *StockMutation) ClearManager() {
	m.clearedmanager = true
}

// ManagerCleared reports if the "manager" edge to the Manager entity was cleared.
func (m *StockMutation) ManagerCleared() bool {
	return m.ManagerIDCleared() || m.clearedmanager
}

// ManagerIDs returns the "manager" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ManagerID instead. It exists only for internal usage by the builders.
func (m *StockMutation) ManagerIDs() (ids []uint64) {
	if id := m.manager; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetManager resets all changes to the "manager" edge.
func (m *StockMutation) ResetManager() {
	m.manager = nil
	m.clearedmanager = false
}

// ClearStore clears the "store" edge to the Store entity.
func (m *StockMutation) ClearStore() {
	m.clearedstore = true
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *StockMutation) StoreCleared() bool {
	return m.StoreIDCleared() || m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *StockMutation) StoreIDs() (ids []uint64) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *StockMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *StockMutation) ClearRider() {
	m.clearedrider = true
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *StockMutation) RiderCleared() bool {
	return m.RiderIDCleared() || m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *StockMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *StockMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *StockMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *StockMutation) EmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *StockMutation) EmployeeIDs() (ids []uint64) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *StockMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// Where appends a list predicates to the StockMutation builder.
func (m *StockMutation) Where(ps ...predicate.Stock) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StockMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Stock).
func (m *StockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StockMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, stock.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, stock.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, stock.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, stock.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, stock.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, stock.FieldRemark)
	}
	if m.manager != nil {
		fields = append(fields, stock.FieldManagerID)
	}
	if m.sn != nil {
		fields = append(fields, stock.FieldSn)
	}
	if m._type != nil {
		fields = append(fields, stock.FieldType)
	}
	if m.store != nil {
		fields = append(fields, stock.FieldStoreID)
	}
	if m.rider != nil {
		fields = append(fields, stock.FieldRiderID)
	}
	if m.employee != nil {
		fields = append(fields, stock.FieldEmployeeID)
	}
	if m.name != nil {
		fields = append(fields, stock.FieldName)
	}
	if m.voltage != nil {
		fields = append(fields, stock.FieldVoltage)
	}
	if m.num != nil {
		fields = append(fields, stock.FieldNum)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stock.FieldCreatedAt:
		return m.CreatedAt()
	case stock.FieldUpdatedAt:
		return m.UpdatedAt()
	case stock.FieldDeletedAt:
		return m.DeletedAt()
	case stock.FieldCreator:
		return m.Creator()
	case stock.FieldLastModifier:
		return m.LastModifier()
	case stock.FieldRemark:
		return m.Remark()
	case stock.FieldManagerID:
		return m.ManagerID()
	case stock.FieldSn:
		return m.Sn()
	case stock.FieldType:
		return m.GetType()
	case stock.FieldStoreID:
		return m.StoreID()
	case stock.FieldRiderID:
		return m.RiderID()
	case stock.FieldEmployeeID:
		return m.EmployeeID()
	case stock.FieldName:
		return m.Name()
	case stock.FieldVoltage:
		return m.Voltage()
	case stock.FieldNum:
		return m.Num()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stock.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case stock.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case stock.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case stock.FieldCreator:
		return m.OldCreator(ctx)
	case stock.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case stock.FieldRemark:
		return m.OldRemark(ctx)
	case stock.FieldManagerID:
		return m.OldManagerID(ctx)
	case stock.FieldSn:
		return m.OldSn(ctx)
	case stock.FieldType:
		return m.OldType(ctx)
	case stock.FieldStoreID:
		return m.OldStoreID(ctx)
	case stock.FieldRiderID:
		return m.OldRiderID(ctx)
	case stock.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case stock.FieldName:
		return m.OldName(ctx)
	case stock.FieldVoltage:
		return m.OldVoltage(ctx)
	case stock.FieldNum:
		return m.OldNum(ctx)
	}
	return nil, fmt.Errorf("unknown Stock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stock.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case stock.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case stock.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case stock.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case stock.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case stock.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case stock.FieldManagerID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagerID(v)
		return nil
	case stock.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case stock.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case stock.FieldStoreID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case stock.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case stock.FieldEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case stock.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case stock.FieldVoltage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoltage(v)
		return nil
	case stock.FieldNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNum(v)
		return nil
	}
	return fmt.Errorf("unknown Stock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StockMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, stock.FieldType)
	}
	if m.addvoltage != nil {
		fields = append(fields, stock.FieldVoltage)
	}
	if m.addnum != nil {
		fields = append(fields, stock.FieldNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case stock.FieldType:
		return m.AddedType()
	case stock.FieldVoltage:
		return m.AddedVoltage()
	case stock.FieldNum:
		return m.AddedNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockMutation) AddField(name string, value ent.Value) error {
	switch name {
	case stock.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case stock.FieldVoltage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVoltage(v)
		return nil
	case stock.FieldNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNum(v)
		return nil
	}
	return fmt.Errorf("unknown Stock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StockMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(stock.FieldDeletedAt) {
		fields = append(fields, stock.FieldDeletedAt)
	}
	if m.FieldCleared(stock.FieldCreator) {
		fields = append(fields, stock.FieldCreator)
	}
	if m.FieldCleared(stock.FieldLastModifier) {
		fields = append(fields, stock.FieldLastModifier)
	}
	if m.FieldCleared(stock.FieldRemark) {
		fields = append(fields, stock.FieldRemark)
	}
	if m.FieldCleared(stock.FieldManagerID) {
		fields = append(fields, stock.FieldManagerID)
	}
	if m.FieldCleared(stock.FieldStoreID) {
		fields = append(fields, stock.FieldStoreID)
	}
	if m.FieldCleared(stock.FieldRiderID) {
		fields = append(fields, stock.FieldRiderID)
	}
	if m.FieldCleared(stock.FieldEmployeeID) {
		fields = append(fields, stock.FieldEmployeeID)
	}
	if m.FieldCleared(stock.FieldVoltage) {
		fields = append(fields, stock.FieldVoltage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StockMutation) ClearField(name string) error {
	switch name {
	case stock.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case stock.FieldCreator:
		m.ClearCreator()
		return nil
	case stock.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case stock.FieldRemark:
		m.ClearRemark()
		return nil
	case stock.FieldManagerID:
		m.ClearManagerID()
		return nil
	case stock.FieldStoreID:
		m.ClearStoreID()
		return nil
	case stock.FieldRiderID:
		m.ClearRiderID()
		return nil
	case stock.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case stock.FieldVoltage:
		m.ClearVoltage()
		return nil
	}
	return fmt.Errorf("unknown Stock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StockMutation) ResetField(name string) error {
	switch name {
	case stock.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case stock.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case stock.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case stock.FieldCreator:
		m.ResetCreator()
		return nil
	case stock.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case stock.FieldRemark:
		m.ResetRemark()
		return nil
	case stock.FieldManagerID:
		m.ResetManagerID()
		return nil
	case stock.FieldSn:
		m.ResetSn()
		return nil
	case stock.FieldType:
		m.ResetType()
		return nil
	case stock.FieldStoreID:
		m.ResetStoreID()
		return nil
	case stock.FieldRiderID:
		m.ResetRiderID()
		return nil
	case stock.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case stock.FieldName:
		m.ResetName()
		return nil
	case stock.FieldVoltage:
		m.ResetVoltage()
		return nil
	case stock.FieldNum:
		m.ResetNum()
		return nil
	}
	return fmt.Errorf("unknown Stock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StockMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.manager != nil {
		edges = append(edges, stock.EdgeManager)
	}
	if m.store != nil {
		edges = append(edges, stock.EdgeStore)
	}
	if m.rider != nil {
		edges = append(edges, stock.EdgeRider)
	}
	if m.employee != nil {
		edges = append(edges, stock.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StockMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stock.EdgeManager:
		if id := m.manager; id != nil {
			return []ent.Value{*id}
		}
	case stock.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	case stock.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case stock.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StockMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedmanager {
		edges = append(edges, stock.EdgeManager)
	}
	if m.clearedstore {
		edges = append(edges, stock.EdgeStore)
	}
	if m.clearedrider {
		edges = append(edges, stock.EdgeRider)
	}
	if m.clearedemployee {
		edges = append(edges, stock.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StockMutation) EdgeCleared(name string) bool {
	switch name {
	case stock.EdgeManager:
		return m.clearedmanager
	case stock.EdgeStore:
		return m.clearedstore
	case stock.EdgeRider:
		return m.clearedrider
	case stock.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StockMutation) ClearEdge(name string) error {
	switch name {
	case stock.EdgeManager:
		m.ClearManager()
		return nil
	case stock.EdgeStore:
		m.ClearStore()
		return nil
	case stock.EdgeRider:
		m.ClearRider()
		return nil
	case stock.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown Stock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StockMutation) ResetEdge(name string) error {
	switch name {
	case stock.EdgeManager:
		m.ResetManager()
		return nil
	case stock.EdgeStore:
		m.ResetStore()
		return nil
	case stock.EdgeRider:
		m.ResetRider()
		return nil
	case stock.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Stock edge %s", name)
}

// StoreMutation represents an operation that mutates the Store nodes in the graph.
type StoreMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint64
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	creator            **model.Modifier
	last_modifier      **model.Modifier
	remark             *string
	sn                 *string
	name               *string
	status             *uint8
	addstatus          *int8
	clearedFields      map[string]struct{}
	city               *uint64
	clearedcity        bool
	branch             *uint64
	clearedbranch      bool
	employee           *uint64
	clearedemployee    bool
	stocks             map[uint64]struct{}
	removedstocks      map[uint64]struct{}
	clearedstocks      bool
	attendances        map[uint64]struct{}
	removedattendances map[uint64]struct{}
	clearedattendances bool
	exceptions         map[uint64]struct{}
	removedexceptions  map[uint64]struct{}
	clearedexceptions  bool
	done               bool
	oldValue           func(context.Context) (*Store, error)
	predicates         []predicate.Store
}

var _ ent.Mutation = (*StoreMutation)(nil)

// storeOption allows management of the mutation configuration using functional options.
type storeOption func(*StoreMutation)

// newStoreMutation creates new mutation for the Store entity.
func newStoreMutation(c config, op Op, opts ...storeOption) *StoreMutation {
	m := &StoreMutation{
		config:        c,
		op:            op,
		typ:           TypeStore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStoreID sets the ID field of the mutation.
func withStoreID(id uint64) storeOption {
	return func(m *StoreMutation) {
		var (
			err   error
			once  sync.Once
			value *Store
		)
		m.oldValue = func(ctx context.Context) (*Store, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Store.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStore sets the old Store of the mutation.
func withStore(node *Store) storeOption {
	return func(m *StoreMutation) {
		m.oldValue = func(context.Context) (*Store, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StoreMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StoreMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Store.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StoreMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StoreMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StoreMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StoreMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StoreMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StoreMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StoreMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StoreMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *StoreMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[store.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *StoreMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[store.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StoreMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, store.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *StoreMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *StoreMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *StoreMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[store.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *StoreMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[store.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *StoreMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, store.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *StoreMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *StoreMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *StoreMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[store.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *StoreMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[store.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *StoreMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, store.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *StoreMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *StoreMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *StoreMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[store.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *StoreMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[store.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *StoreMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, store.FieldRemark)
}

// SetCityID sets the "city_id" field.
func (m *StoreMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *StoreMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldCityID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ClearCityID clears the value of the "city_id" field.
func (m *StoreMutation) ClearCityID() {
	m.city = nil
	m.clearedFields[store.FieldCityID] = struct{}{}
}

// CityIDCleared returns if the "city_id" field was cleared in this mutation.
func (m *StoreMutation) CityIDCleared() bool {
	_, ok := m.clearedFields[store.FieldCityID]
	return ok
}

// ResetCityID resets all changes to the "city_id" field.
func (m *StoreMutation) ResetCityID() {
	m.city = nil
	delete(m.clearedFields, store.FieldCityID)
}

// SetEmployeeID sets the "employee_id" field.
func (m *StoreMutation) SetEmployeeID(u uint64) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *StoreMutation) EmployeeID() (r uint64, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldEmployeeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *StoreMutation) ClearEmployeeID() {
	m.employee = nil
	m.clearedFields[store.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *StoreMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[store.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *StoreMutation) ResetEmployeeID() {
	m.employee = nil
	delete(m.clearedFields, store.FieldEmployeeID)
}

// SetBranchID sets the "branch_id" field.
func (m *StoreMutation) SetBranchID(u uint64) {
	m.branch = &u
}

// BranchID returns the value of the "branch_id" field in the mutation.
func (m *StoreMutation) BranchID() (r uint64, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranchID returns the old "branch_id" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldBranchID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBranchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBranchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranchID: %w", err)
	}
	return oldValue.BranchID, nil
}

// ResetBranchID resets all changes to the "branch_id" field.
func (m *StoreMutation) ResetBranchID() {
	m.branch = nil
}

// SetSn sets the "sn" field.
func (m *StoreMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *StoreMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *StoreMutation) ResetSn() {
	m.sn = nil
}

// SetName sets the "name" field.
func (m *StoreMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StoreMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StoreMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *StoreMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *StoreMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *StoreMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *StoreMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *StoreMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// ClearCity clears the "city" edge to the City entity.
func (m *StoreMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *StoreMutation) CityCleared() bool {
	return m.CityIDCleared() || m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *StoreMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *StoreMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearBranch clears the "branch" edge to the Branch entity.
func (m *StoreMutation) ClearBranch() {
	m.clearedbranch = true
}

// BranchCleared reports if the "branch" edge to the Branch entity was cleared.
func (m *StoreMutation) BranchCleared() bool {
	return m.clearedbranch
}

// BranchIDs returns the "branch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BranchID instead. It exists only for internal usage by the builders.
func (m *StoreMutation) BranchIDs() (ids []uint64) {
	if id := m.branch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBranch resets all changes to the "branch" edge.
func (m *StoreMutation) ResetBranch() {
	m.branch = nil
	m.clearedbranch = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *StoreMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *StoreMutation) EmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *StoreMutation) EmployeeIDs() (ids []uint64) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *StoreMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// AddStockIDs adds the "stocks" edge to the Stock entity by ids.
func (m *StoreMutation) AddStockIDs(ids ...uint64) {
	if m.stocks == nil {
		m.stocks = make(map[uint64]struct{})
	}
	for i := range ids {
		m.stocks[ids[i]] = struct{}{}
	}
}

// ClearStocks clears the "stocks" edge to the Stock entity.
func (m *StoreMutation) ClearStocks() {
	m.clearedstocks = true
}

// StocksCleared reports if the "stocks" edge to the Stock entity was cleared.
func (m *StoreMutation) StocksCleared() bool {
	return m.clearedstocks
}

// RemoveStockIDs removes the "stocks" edge to the Stock entity by IDs.
func (m *StoreMutation) RemoveStockIDs(ids ...uint64) {
	if m.removedstocks == nil {
		m.removedstocks = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.stocks, ids[i])
		m.removedstocks[ids[i]] = struct{}{}
	}
}

// RemovedStocks returns the removed IDs of the "stocks" edge to the Stock entity.
func (m *StoreMutation) RemovedStocksIDs() (ids []uint64) {
	for id := range m.removedstocks {
		ids = append(ids, id)
	}
	return
}

// StocksIDs returns the "stocks" edge IDs in the mutation.
func (m *StoreMutation) StocksIDs() (ids []uint64) {
	for id := range m.stocks {
		ids = append(ids, id)
	}
	return
}

// ResetStocks resets all changes to the "stocks" edge.
func (m *StoreMutation) ResetStocks() {
	m.stocks = nil
	m.clearedstocks = false
	m.removedstocks = nil
}

// AddAttendanceIDs adds the "attendances" edge to the Attendance entity by ids.
func (m *StoreMutation) AddAttendanceIDs(ids ...uint64) {
	if m.attendances == nil {
		m.attendances = make(map[uint64]struct{})
	}
	for i := range ids {
		m.attendances[ids[i]] = struct{}{}
	}
}

// ClearAttendances clears the "attendances" edge to the Attendance entity.
func (m *StoreMutation) ClearAttendances() {
	m.clearedattendances = true
}

// AttendancesCleared reports if the "attendances" edge to the Attendance entity was cleared.
func (m *StoreMutation) AttendancesCleared() bool {
	return m.clearedattendances
}

// RemoveAttendanceIDs removes the "attendances" edge to the Attendance entity by IDs.
func (m *StoreMutation) RemoveAttendanceIDs(ids ...uint64) {
	if m.removedattendances == nil {
		m.removedattendances = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.attendances, ids[i])
		m.removedattendances[ids[i]] = struct{}{}
	}
}

// RemovedAttendances returns the removed IDs of the "attendances" edge to the Attendance entity.
func (m *StoreMutation) RemovedAttendancesIDs() (ids []uint64) {
	for id := range m.removedattendances {
		ids = append(ids, id)
	}
	return
}

// AttendancesIDs returns the "attendances" edge IDs in the mutation.
func (m *StoreMutation) AttendancesIDs() (ids []uint64) {
	for id := range m.attendances {
		ids = append(ids, id)
	}
	return
}

// ResetAttendances resets all changes to the "attendances" edge.
func (m *StoreMutation) ResetAttendances() {
	m.attendances = nil
	m.clearedattendances = false
	m.removedattendances = nil
}

// AddExceptionIDs adds the "exceptions" edge to the Exception entity by ids.
func (m *StoreMutation) AddExceptionIDs(ids ...uint64) {
	if m.exceptions == nil {
		m.exceptions = make(map[uint64]struct{})
	}
	for i := range ids {
		m.exceptions[ids[i]] = struct{}{}
	}
}

// ClearExceptions clears the "exceptions" edge to the Exception entity.
func (m *StoreMutation) ClearExceptions() {
	m.clearedexceptions = true
}

// ExceptionsCleared reports if the "exceptions" edge to the Exception entity was cleared.
func (m *StoreMutation) ExceptionsCleared() bool {
	return m.clearedexceptions
}

// RemoveExceptionIDs removes the "exceptions" edge to the Exception entity by IDs.
func (m *StoreMutation) RemoveExceptionIDs(ids ...uint64) {
	if m.removedexceptions == nil {
		m.removedexceptions = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.exceptions, ids[i])
		m.removedexceptions[ids[i]] = struct{}{}
	}
}

// RemovedExceptions returns the removed IDs of the "exceptions" edge to the Exception entity.
func (m *StoreMutation) RemovedExceptionsIDs() (ids []uint64) {
	for id := range m.removedexceptions {
		ids = append(ids, id)
	}
	return
}

// ExceptionsIDs returns the "exceptions" edge IDs in the mutation.
func (m *StoreMutation) ExceptionsIDs() (ids []uint64) {
	for id := range m.exceptions {
		ids = append(ids, id)
	}
	return
}

// ResetExceptions resets all changes to the "exceptions" edge.
func (m *StoreMutation) ResetExceptions() {
	m.exceptions = nil
	m.clearedexceptions = false
	m.removedexceptions = nil
}

// Where appends a list predicates to the StoreMutation builder.
func (m *StoreMutation) Where(ps ...predicate.Store) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StoreMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Store).
func (m *StoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StoreMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, store.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, store.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, store.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, store.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, store.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, store.FieldRemark)
	}
	if m.city != nil {
		fields = append(fields, store.FieldCityID)
	}
	if m.employee != nil {
		fields = append(fields, store.FieldEmployeeID)
	}
	if m.branch != nil {
		fields = append(fields, store.FieldBranchID)
	}
	if m.sn != nil {
		fields = append(fields, store.FieldSn)
	}
	if m.name != nil {
		fields = append(fields, store.FieldName)
	}
	if m.status != nil {
		fields = append(fields, store.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case store.FieldCreatedAt:
		return m.CreatedAt()
	case store.FieldUpdatedAt:
		return m.UpdatedAt()
	case store.FieldDeletedAt:
		return m.DeletedAt()
	case store.FieldCreator:
		return m.Creator()
	case store.FieldLastModifier:
		return m.LastModifier()
	case store.FieldRemark:
		return m.Remark()
	case store.FieldCityID:
		return m.CityID()
	case store.FieldEmployeeID:
		return m.EmployeeID()
	case store.FieldBranchID:
		return m.BranchID()
	case store.FieldSn:
		return m.Sn()
	case store.FieldName:
		return m.Name()
	case store.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case store.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case store.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case store.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case store.FieldCreator:
		return m.OldCreator(ctx)
	case store.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case store.FieldRemark:
		return m.OldRemark(ctx)
	case store.FieldCityID:
		return m.OldCityID(ctx)
	case store.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case store.FieldBranchID:
		return m.OldBranchID(ctx)
	case store.FieldSn:
		return m.OldSn(ctx)
	case store.FieldName:
		return m.OldName(ctx)
	case store.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Store field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case store.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case store.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case store.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case store.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case store.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case store.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case store.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case store.FieldEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case store.FieldBranchID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranchID(v)
		return nil
	case store.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case store.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case store.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Store field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StoreMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, store.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StoreMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case store.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	case store.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Store numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StoreMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(store.FieldDeletedAt) {
		fields = append(fields, store.FieldDeletedAt)
	}
	if m.FieldCleared(store.FieldCreator) {
		fields = append(fields, store.FieldCreator)
	}
	if m.FieldCleared(store.FieldLastModifier) {
		fields = append(fields, store.FieldLastModifier)
	}
	if m.FieldCleared(store.FieldRemark) {
		fields = append(fields, store.FieldRemark)
	}
	if m.FieldCleared(store.FieldCityID) {
		fields = append(fields, store.FieldCityID)
	}
	if m.FieldCleared(store.FieldEmployeeID) {
		fields = append(fields, store.FieldEmployeeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StoreMutation) ClearField(name string) error {
	switch name {
	case store.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case store.FieldCreator:
		m.ClearCreator()
		return nil
	case store.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case store.FieldRemark:
		m.ClearRemark()
		return nil
	case store.FieldCityID:
		m.ClearCityID()
		return nil
	case store.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	}
	return fmt.Errorf("unknown Store nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StoreMutation) ResetField(name string) error {
	switch name {
	case store.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case store.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case store.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case store.FieldCreator:
		m.ResetCreator()
		return nil
	case store.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case store.FieldRemark:
		m.ResetRemark()
		return nil
	case store.FieldCityID:
		m.ResetCityID()
		return nil
	case store.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case store.FieldBranchID:
		m.ResetBranchID()
		return nil
	case store.FieldSn:
		m.ResetSn()
		return nil
	case store.FieldName:
		m.ResetName()
		return nil
	case store.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Store field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.city != nil {
		edges = append(edges, store.EdgeCity)
	}
	if m.branch != nil {
		edges = append(edges, store.EdgeBranch)
	}
	if m.employee != nil {
		edges = append(edges, store.EdgeEmployee)
	}
	if m.stocks != nil {
		edges = append(edges, store.EdgeStocks)
	}
	if m.attendances != nil {
		edges = append(edges, store.EdgeAttendances)
	}
	if m.exceptions != nil {
		edges = append(edges, store.EdgeExceptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StoreMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case store.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case store.EdgeBranch:
		if id := m.branch; id != nil {
			return []ent.Value{*id}
		}
	case store.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case store.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.stocks))
		for id := range m.stocks {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeAttendances:
		ids := make([]ent.Value, 0, len(m.attendances))
		for id := range m.attendances {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeExceptions:
		ids := make([]ent.Value, 0, len(m.exceptions))
		for id := range m.exceptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedstocks != nil {
		edges = append(edges, store.EdgeStocks)
	}
	if m.removedattendances != nil {
		edges = append(edges, store.EdgeAttendances)
	}
	if m.removedexceptions != nil {
		edges = append(edges, store.EdgeExceptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StoreMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case store.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.removedstocks))
		for id := range m.removedstocks {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeAttendances:
		ids := make([]ent.Value, 0, len(m.removedattendances))
		for id := range m.removedattendances {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeExceptions:
		ids := make([]ent.Value, 0, len(m.removedexceptions))
		for id := range m.removedexceptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcity {
		edges = append(edges, store.EdgeCity)
	}
	if m.clearedbranch {
		edges = append(edges, store.EdgeBranch)
	}
	if m.clearedemployee {
		edges = append(edges, store.EdgeEmployee)
	}
	if m.clearedstocks {
		edges = append(edges, store.EdgeStocks)
	}
	if m.clearedattendances {
		edges = append(edges, store.EdgeAttendances)
	}
	if m.clearedexceptions {
		edges = append(edges, store.EdgeExceptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StoreMutation) EdgeCleared(name string) bool {
	switch name {
	case store.EdgeCity:
		return m.clearedcity
	case store.EdgeBranch:
		return m.clearedbranch
	case store.EdgeEmployee:
		return m.clearedemployee
	case store.EdgeStocks:
		return m.clearedstocks
	case store.EdgeAttendances:
		return m.clearedattendances
	case store.EdgeExceptions:
		return m.clearedexceptions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StoreMutation) ClearEdge(name string) error {
	switch name {
	case store.EdgeCity:
		m.ClearCity()
		return nil
	case store.EdgeBranch:
		m.ClearBranch()
		return nil
	case store.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown Store unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StoreMutation) ResetEdge(name string) error {
	switch name {
	case store.EdgeCity:
		m.ResetCity()
		return nil
	case store.EdgeBranch:
		m.ResetBranch()
		return nil
	case store.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case store.EdgeStocks:
		m.ResetStocks()
		return nil
	case store.EdgeAttendances:
		m.ResetAttendances()
		return nil
	case store.EdgeExceptions:
		m.ResetExceptions()
		return nil
	}
	return fmt.Errorf("unknown Store edge %s", name)
}

// SubscribeMutation represents an operation that mutates the Subscribe nodes in the graph.
type SubscribeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint64
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	creator              **model.Modifier
	last_modifier        **model.Modifier
	remark               *string
	status               *uint8
	addstatus            *int8
	_type                *uint
	add_type             *int
	voltage              *float64
	addvoltage           *float64
	initial_days         *int
	addinitial_days      *int
	alter_days           *int
	addalter_days        *int
	pause_days           *int
	addpause_days        *int
	renewal_days         *int
	addrenewal_days      *int
	overdue_days         *int
	addoverdue_days      *int
	remaining            *int
	addremaining         *int
	paused_at            *time.Time
	start_at             *time.Time
	end_at               *time.Time
	refund_at            *time.Time
	unsubscribe_reason   *string
	last_bill_date       *time.Time
	clearedFields        map[string]struct{}
	plan                 *uint64
	clearedplan          bool
	employee             *uint64
	clearedemployee      bool
	city                 *uint64
	clearedcity          bool
	station              *uint64
	clearedstation       bool
	store                *uint64
	clearedstore         bool
	rider                *uint64
	clearedrider         bool
	enterprise           *uint64
	clearedenterprise    bool
	pauses               map[uint64]struct{}
	removedpauses        map[uint64]struct{}
	clearedpauses        bool
	alters               map[uint64]struct{}
	removedalters        map[uint64]struct{}
	clearedalters        bool
	orders               map[uint64]struct{}
	removedorders        map[uint64]struct{}
	clearedorders        bool
	initial_order        *uint64
	clearedinitial_order bool
	done                 bool
	oldValue             func(context.Context) (*Subscribe, error)
	predicates           []predicate.Subscribe
}

var _ ent.Mutation = (*SubscribeMutation)(nil)

// subscribeOption allows management of the mutation configuration using functional options.
type subscribeOption func(*SubscribeMutation)

// newSubscribeMutation creates new mutation for the Subscribe entity.
func newSubscribeMutation(c config, op Op, opts ...subscribeOption) *SubscribeMutation {
	m := &SubscribeMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscribe,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscribeID sets the ID field of the mutation.
func withSubscribeID(id uint64) subscribeOption {
	return func(m *SubscribeMutation) {
		var (
			err   error
			once  sync.Once
			value *Subscribe
		)
		m.oldValue = func(ctx context.Context) (*Subscribe, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subscribe.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscribe sets the old Subscribe of the mutation.
func withSubscribe(node *Subscribe) subscribeOption {
	return func(m *SubscribeMutation) {
		m.oldValue = func(context.Context) (*Subscribe, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscribeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscribeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscribeMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscribeMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subscribe.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscribeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscribeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscribeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscribeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscribeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscribeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SubscribeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SubscribeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SubscribeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[subscribe.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SubscribeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SubscribeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, subscribe.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *SubscribeMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *SubscribeMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *SubscribeMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[subscribe.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *SubscribeMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *SubscribeMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, subscribe.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *SubscribeMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *SubscribeMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *SubscribeMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[subscribe.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *SubscribeMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *SubscribeMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, subscribe.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *SubscribeMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *SubscribeMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *SubscribeMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[subscribe.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *SubscribeMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *SubscribeMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, subscribe.FieldRemark)
}

// SetPlanID sets the "plan_id" field.
func (m *SubscribeMutation) SetPlanID(u uint64) {
	m.plan = &u
}

// PlanID returns the value of the "plan_id" field in the mutation.
func (m *SubscribeMutation) PlanID() (r uint64, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanID returns the old "plan_id" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldPlanID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanID: %w", err)
	}
	return oldValue.PlanID, nil
}

// ClearPlanID clears the value of the "plan_id" field.
func (m *SubscribeMutation) ClearPlanID() {
	m.plan = nil
	m.clearedFields[subscribe.FieldPlanID] = struct{}{}
}

// PlanIDCleared returns if the "plan_id" field was cleared in this mutation.
func (m *SubscribeMutation) PlanIDCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldPlanID]
	return ok
}

// ResetPlanID resets all changes to the "plan_id" field.
func (m *SubscribeMutation) ResetPlanID() {
	m.plan = nil
	delete(m.clearedFields, subscribe.FieldPlanID)
}

// SetEmployeeID sets the "employee_id" field.
func (m *SubscribeMutation) SetEmployeeID(u uint64) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *SubscribeMutation) EmployeeID() (r uint64, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldEmployeeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *SubscribeMutation) ClearEmployeeID() {
	m.employee = nil
	m.clearedFields[subscribe.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *SubscribeMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *SubscribeMutation) ResetEmployeeID() {
	m.employee = nil
	delete(m.clearedFields, subscribe.FieldEmployeeID)
}

// SetCityID sets the "city_id" field.
func (m *SubscribeMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *SubscribeMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *SubscribeMutation) ResetCityID() {
	m.city = nil
}

// SetStationID sets the "station_id" field.
func (m *SubscribeMutation) SetStationID(u uint64) {
	m.station = &u
}

// StationID returns the value of the "station_id" field in the mutation.
func (m *SubscribeMutation) StationID() (r uint64, exists bool) {
	v := m.station
	if v == nil {
		return
	}
	return *v, true
}

// OldStationID returns the old "station_id" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldStationID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStationID: %w", err)
	}
	return oldValue.StationID, nil
}

// ClearStationID clears the value of the "station_id" field.
func (m *SubscribeMutation) ClearStationID() {
	m.station = nil
	m.clearedFields[subscribe.FieldStationID] = struct{}{}
}

// StationIDCleared returns if the "station_id" field was cleared in this mutation.
func (m *SubscribeMutation) StationIDCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldStationID]
	return ok
}

// ResetStationID resets all changes to the "station_id" field.
func (m *SubscribeMutation) ResetStationID() {
	m.station = nil
	delete(m.clearedFields, subscribe.FieldStationID)
}

// SetStoreID sets the "store_id" field.
func (m *SubscribeMutation) SetStoreID(u uint64) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *SubscribeMutation) StoreID() (r uint64, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldStoreID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *SubscribeMutation) ClearStoreID() {
	m.store = nil
	m.clearedFields[subscribe.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *SubscribeMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *SubscribeMutation) ResetStoreID() {
	m.store = nil
	delete(m.clearedFields, subscribe.FieldStoreID)
}

// SetRiderID sets the "rider_id" field.
func (m *SubscribeMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *SubscribeMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *SubscribeMutation) ResetRiderID() {
	m.rider = nil
}

// SetInitialOrderID sets the "initial_order_id" field.
func (m *SubscribeMutation) SetInitialOrderID(u uint64) {
	m.initial_order = &u
}

// InitialOrderID returns the value of the "initial_order_id" field in the mutation.
func (m *SubscribeMutation) InitialOrderID() (r uint64, exists bool) {
	v := m.initial_order
	if v == nil {
		return
	}
	return *v, true
}

// OldInitialOrderID returns the old "initial_order_id" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldInitialOrderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitialOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitialOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitialOrderID: %w", err)
	}
	return oldValue.InitialOrderID, nil
}

// ClearInitialOrderID clears the value of the "initial_order_id" field.
func (m *SubscribeMutation) ClearInitialOrderID() {
	m.initial_order = nil
	m.clearedFields[subscribe.FieldInitialOrderID] = struct{}{}
}

// InitialOrderIDCleared returns if the "initial_order_id" field was cleared in this mutation.
func (m *SubscribeMutation) InitialOrderIDCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldInitialOrderID]
	return ok
}

// ResetInitialOrderID resets all changes to the "initial_order_id" field.
func (m *SubscribeMutation) ResetInitialOrderID() {
	m.initial_order = nil
	delete(m.clearedFields, subscribe.FieldInitialOrderID)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *SubscribeMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *SubscribeMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldEnterpriseID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ClearEnterpriseID clears the value of the "enterprise_id" field.
func (m *SubscribeMutation) ClearEnterpriseID() {
	m.enterprise = nil
	m.clearedFields[subscribe.FieldEnterpriseID] = struct{}{}
}

// EnterpriseIDCleared returns if the "enterprise_id" field was cleared in this mutation.
func (m *SubscribeMutation) EnterpriseIDCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldEnterpriseID]
	return ok
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *SubscribeMutation) ResetEnterpriseID() {
	m.enterprise = nil
	delete(m.clearedFields, subscribe.FieldEnterpriseID)
}

// SetStatus sets the "status" field.
func (m *SubscribeMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SubscribeMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *SubscribeMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SubscribeMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *SubscribeMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetType sets the "type" field.
func (m *SubscribeMutation) SetType(u uint) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *SubscribeMutation) GetType() (r uint, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldType(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *SubscribeMutation) AddType(u int) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *SubscribeMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *SubscribeMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetVoltage sets the "voltage" field.
func (m *SubscribeMutation) SetVoltage(f float64) {
	m.voltage = &f
	m.addvoltage = nil
}

// Voltage returns the value of the "voltage" field in the mutation.
func (m *SubscribeMutation) Voltage() (r float64, exists bool) {
	v := m.voltage
	if v == nil {
		return
	}
	return *v, true
}

// OldVoltage returns the old "voltage" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldVoltage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoltage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoltage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoltage: %w", err)
	}
	return oldValue.Voltage, nil
}

// AddVoltage adds f to the "voltage" field.
func (m *SubscribeMutation) AddVoltage(f float64) {
	if m.addvoltage != nil {
		*m.addvoltage += f
	} else {
		m.addvoltage = &f
	}
}

// AddedVoltage returns the value that was added to the "voltage" field in this mutation.
func (m *SubscribeMutation) AddedVoltage() (r float64, exists bool) {
	v := m.addvoltage
	if v == nil {
		return
	}
	return *v, true
}

// ResetVoltage resets all changes to the "voltage" field.
func (m *SubscribeMutation) ResetVoltage() {
	m.voltage = nil
	m.addvoltage = nil
}

// SetInitialDays sets the "initial_days" field.
func (m *SubscribeMutation) SetInitialDays(i int) {
	m.initial_days = &i
	m.addinitial_days = nil
}

// InitialDays returns the value of the "initial_days" field in the mutation.
func (m *SubscribeMutation) InitialDays() (r int, exists bool) {
	v := m.initial_days
	if v == nil {
		return
	}
	return *v, true
}

// OldInitialDays returns the old "initial_days" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldInitialDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitialDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitialDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitialDays: %w", err)
	}
	return oldValue.InitialDays, nil
}

// AddInitialDays adds i to the "initial_days" field.
func (m *SubscribeMutation) AddInitialDays(i int) {
	if m.addinitial_days != nil {
		*m.addinitial_days += i
	} else {
		m.addinitial_days = &i
	}
}

// AddedInitialDays returns the value that was added to the "initial_days" field in this mutation.
func (m *SubscribeMutation) AddedInitialDays() (r int, exists bool) {
	v := m.addinitial_days
	if v == nil {
		return
	}
	return *v, true
}

// ClearInitialDays clears the value of the "initial_days" field.
func (m *SubscribeMutation) ClearInitialDays() {
	m.initial_days = nil
	m.addinitial_days = nil
	m.clearedFields[subscribe.FieldInitialDays] = struct{}{}
}

// InitialDaysCleared returns if the "initial_days" field was cleared in this mutation.
func (m *SubscribeMutation) InitialDaysCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldInitialDays]
	return ok
}

// ResetInitialDays resets all changes to the "initial_days" field.
func (m *SubscribeMutation) ResetInitialDays() {
	m.initial_days = nil
	m.addinitial_days = nil
	delete(m.clearedFields, subscribe.FieldInitialDays)
}

// SetAlterDays sets the "alter_days" field.
func (m *SubscribeMutation) SetAlterDays(i int) {
	m.alter_days = &i
	m.addalter_days = nil
}

// AlterDays returns the value of the "alter_days" field in the mutation.
func (m *SubscribeMutation) AlterDays() (r int, exists bool) {
	v := m.alter_days
	if v == nil {
		return
	}
	return *v, true
}

// OldAlterDays returns the old "alter_days" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldAlterDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlterDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlterDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlterDays: %w", err)
	}
	return oldValue.AlterDays, nil
}

// AddAlterDays adds i to the "alter_days" field.
func (m *SubscribeMutation) AddAlterDays(i int) {
	if m.addalter_days != nil {
		*m.addalter_days += i
	} else {
		m.addalter_days = &i
	}
}

// AddedAlterDays returns the value that was added to the "alter_days" field in this mutation.
func (m *SubscribeMutation) AddedAlterDays() (r int, exists bool) {
	v := m.addalter_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetAlterDays resets all changes to the "alter_days" field.
func (m *SubscribeMutation) ResetAlterDays() {
	m.alter_days = nil
	m.addalter_days = nil
}

// SetPauseDays sets the "pause_days" field.
func (m *SubscribeMutation) SetPauseDays(i int) {
	m.pause_days = &i
	m.addpause_days = nil
}

// PauseDays returns the value of the "pause_days" field in the mutation.
func (m *SubscribeMutation) PauseDays() (r int, exists bool) {
	v := m.pause_days
	if v == nil {
		return
	}
	return *v, true
}

// OldPauseDays returns the old "pause_days" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldPauseDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPauseDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPauseDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPauseDays: %w", err)
	}
	return oldValue.PauseDays, nil
}

// AddPauseDays adds i to the "pause_days" field.
func (m *SubscribeMutation) AddPauseDays(i int) {
	if m.addpause_days != nil {
		*m.addpause_days += i
	} else {
		m.addpause_days = &i
	}
}

// AddedPauseDays returns the value that was added to the "pause_days" field in this mutation.
func (m *SubscribeMutation) AddedPauseDays() (r int, exists bool) {
	v := m.addpause_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetPauseDays resets all changes to the "pause_days" field.
func (m *SubscribeMutation) ResetPauseDays() {
	m.pause_days = nil
	m.addpause_days = nil
}

// SetRenewalDays sets the "renewal_days" field.
func (m *SubscribeMutation) SetRenewalDays(i int) {
	m.renewal_days = &i
	m.addrenewal_days = nil
}

// RenewalDays returns the value of the "renewal_days" field in the mutation.
func (m *SubscribeMutation) RenewalDays() (r int, exists bool) {
	v := m.renewal_days
	if v == nil {
		return
	}
	return *v, true
}

// OldRenewalDays returns the old "renewal_days" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldRenewalDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRenewalDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRenewalDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRenewalDays: %w", err)
	}
	return oldValue.RenewalDays, nil
}

// AddRenewalDays adds i to the "renewal_days" field.
func (m *SubscribeMutation) AddRenewalDays(i int) {
	if m.addrenewal_days != nil {
		*m.addrenewal_days += i
	} else {
		m.addrenewal_days = &i
	}
}

// AddedRenewalDays returns the value that was added to the "renewal_days" field in this mutation.
func (m *SubscribeMutation) AddedRenewalDays() (r int, exists bool) {
	v := m.addrenewal_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetRenewalDays resets all changes to the "renewal_days" field.
func (m *SubscribeMutation) ResetRenewalDays() {
	m.renewal_days = nil
	m.addrenewal_days = nil
}

// SetOverdueDays sets the "overdue_days" field.
func (m *SubscribeMutation) SetOverdueDays(i int) {
	m.overdue_days = &i
	m.addoverdue_days = nil
}

// OverdueDays returns the value of the "overdue_days" field in the mutation.
func (m *SubscribeMutation) OverdueDays() (r int, exists bool) {
	v := m.overdue_days
	if v == nil {
		return
	}
	return *v, true
}

// OldOverdueDays returns the old "overdue_days" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldOverdueDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverdueDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverdueDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverdueDays: %w", err)
	}
	return oldValue.OverdueDays, nil
}

// AddOverdueDays adds i to the "overdue_days" field.
func (m *SubscribeMutation) AddOverdueDays(i int) {
	if m.addoverdue_days != nil {
		*m.addoverdue_days += i
	} else {
		m.addoverdue_days = &i
	}
}

// AddedOverdueDays returns the value that was added to the "overdue_days" field in this mutation.
func (m *SubscribeMutation) AddedOverdueDays() (r int, exists bool) {
	v := m.addoverdue_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetOverdueDays resets all changes to the "overdue_days" field.
func (m *SubscribeMutation) ResetOverdueDays() {
	m.overdue_days = nil
	m.addoverdue_days = nil
}

// SetRemaining sets the "remaining" field.
func (m *SubscribeMutation) SetRemaining(i int) {
	m.remaining = &i
	m.addremaining = nil
}

// Remaining returns the value of the "remaining" field in the mutation.
func (m *SubscribeMutation) Remaining() (r int, exists bool) {
	v := m.remaining
	if v == nil {
		return
	}
	return *v, true
}

// OldRemaining returns the old "remaining" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldRemaining(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemaining is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemaining requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemaining: %w", err)
	}
	return oldValue.Remaining, nil
}

// AddRemaining adds i to the "remaining" field.
func (m *SubscribeMutation) AddRemaining(i int) {
	if m.addremaining != nil {
		*m.addremaining += i
	} else {
		m.addremaining = &i
	}
}

// AddedRemaining returns the value that was added to the "remaining" field in this mutation.
func (m *SubscribeMutation) AddedRemaining() (r int, exists bool) {
	v := m.addremaining
	if v == nil {
		return
	}
	return *v, true
}

// ResetRemaining resets all changes to the "remaining" field.
func (m *SubscribeMutation) ResetRemaining() {
	m.remaining = nil
	m.addremaining = nil
}

// SetPausedAt sets the "paused_at" field.
func (m *SubscribeMutation) SetPausedAt(t time.Time) {
	m.paused_at = &t
}

// PausedAt returns the value of the "paused_at" field in the mutation.
func (m *SubscribeMutation) PausedAt() (r time.Time, exists bool) {
	v := m.paused_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPausedAt returns the old "paused_at" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldPausedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPausedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPausedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPausedAt: %w", err)
	}
	return oldValue.PausedAt, nil
}

// ClearPausedAt clears the value of the "paused_at" field.
func (m *SubscribeMutation) ClearPausedAt() {
	m.paused_at = nil
	m.clearedFields[subscribe.FieldPausedAt] = struct{}{}
}

// PausedAtCleared returns if the "paused_at" field was cleared in this mutation.
func (m *SubscribeMutation) PausedAtCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldPausedAt]
	return ok
}

// ResetPausedAt resets all changes to the "paused_at" field.
func (m *SubscribeMutation) ResetPausedAt() {
	m.paused_at = nil
	delete(m.clearedFields, subscribe.FieldPausedAt)
}

// SetStartAt sets the "start_at" field.
func (m *SubscribeMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *SubscribeMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldStartAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *SubscribeMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[subscribe.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *SubscribeMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *SubscribeMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, subscribe.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *SubscribeMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *SubscribeMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldEndAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *SubscribeMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[subscribe.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *SubscribeMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *SubscribeMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, subscribe.FieldEndAt)
}

// SetRefundAt sets the "refund_at" field.
func (m *SubscribeMutation) SetRefundAt(t time.Time) {
	m.refund_at = &t
}

// RefundAt returns the value of the "refund_at" field in the mutation.
func (m *SubscribeMutation) RefundAt() (r time.Time, exists bool) {
	v := m.refund_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundAt returns the old "refund_at" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldRefundAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundAt: %w", err)
	}
	return oldValue.RefundAt, nil
}

// ClearRefundAt clears the value of the "refund_at" field.
func (m *SubscribeMutation) ClearRefundAt() {
	m.refund_at = nil
	m.clearedFields[subscribe.FieldRefundAt] = struct{}{}
}

// RefundAtCleared returns if the "refund_at" field was cleared in this mutation.
func (m *SubscribeMutation) RefundAtCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldRefundAt]
	return ok
}

// ResetRefundAt resets all changes to the "refund_at" field.
func (m *SubscribeMutation) ResetRefundAt() {
	m.refund_at = nil
	delete(m.clearedFields, subscribe.FieldRefundAt)
}

// SetUnsubscribeReason sets the "unsubscribe_reason" field.
func (m *SubscribeMutation) SetUnsubscribeReason(s string) {
	m.unsubscribe_reason = &s
}

// UnsubscribeReason returns the value of the "unsubscribe_reason" field in the mutation.
func (m *SubscribeMutation) UnsubscribeReason() (r string, exists bool) {
	v := m.unsubscribe_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldUnsubscribeReason returns the old "unsubscribe_reason" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldUnsubscribeReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnsubscribeReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnsubscribeReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnsubscribeReason: %w", err)
	}
	return oldValue.UnsubscribeReason, nil
}

// ClearUnsubscribeReason clears the value of the "unsubscribe_reason" field.
func (m *SubscribeMutation) ClearUnsubscribeReason() {
	m.unsubscribe_reason = nil
	m.clearedFields[subscribe.FieldUnsubscribeReason] = struct{}{}
}

// UnsubscribeReasonCleared returns if the "unsubscribe_reason" field was cleared in this mutation.
func (m *SubscribeMutation) UnsubscribeReasonCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldUnsubscribeReason]
	return ok
}

// ResetUnsubscribeReason resets all changes to the "unsubscribe_reason" field.
func (m *SubscribeMutation) ResetUnsubscribeReason() {
	m.unsubscribe_reason = nil
	delete(m.clearedFields, subscribe.FieldUnsubscribeReason)
}

// SetLastBillDate sets the "last_bill_date" field.
func (m *SubscribeMutation) SetLastBillDate(t time.Time) {
	m.last_bill_date = &t
}

// LastBillDate returns the value of the "last_bill_date" field in the mutation.
func (m *SubscribeMutation) LastBillDate() (r time.Time, exists bool) {
	v := m.last_bill_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLastBillDate returns the old "last_bill_date" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldLastBillDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastBillDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastBillDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastBillDate: %w", err)
	}
	return oldValue.LastBillDate, nil
}

// ClearLastBillDate clears the value of the "last_bill_date" field.
func (m *SubscribeMutation) ClearLastBillDate() {
	m.last_bill_date = nil
	m.clearedFields[subscribe.FieldLastBillDate] = struct{}{}
}

// LastBillDateCleared returns if the "last_bill_date" field was cleared in this mutation.
func (m *SubscribeMutation) LastBillDateCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldLastBillDate]
	return ok
}

// ResetLastBillDate resets all changes to the "last_bill_date" field.
func (m *SubscribeMutation) ResetLastBillDate() {
	m.last_bill_date = nil
	delete(m.clearedFields, subscribe.FieldLastBillDate)
}

// ClearPlan clears the "plan" edge to the Plan entity.
func (m *SubscribeMutation) ClearPlan() {
	m.clearedplan = true
}

// PlanCleared reports if the "plan" edge to the Plan entity was cleared.
func (m *SubscribeMutation) PlanCleared() bool {
	return m.PlanIDCleared() || m.clearedplan
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *SubscribeMutation) PlanIDs() (ids []uint64) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *SubscribeMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *SubscribeMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *SubscribeMutation) EmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *SubscribeMutation) EmployeeIDs() (ids []uint64) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *SubscribeMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *SubscribeMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *SubscribeMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *SubscribeMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *SubscribeMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearStation clears the "station" edge to the EnterpriseStation entity.
func (m *SubscribeMutation) ClearStation() {
	m.clearedstation = true
}

// StationCleared reports if the "station" edge to the EnterpriseStation entity was cleared.
func (m *SubscribeMutation) StationCleared() bool {
	return m.StationIDCleared() || m.clearedstation
}

// StationIDs returns the "station" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StationID instead. It exists only for internal usage by the builders.
func (m *SubscribeMutation) StationIDs() (ids []uint64) {
	if id := m.station; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStation resets all changes to the "station" edge.
func (m *SubscribeMutation) ResetStation() {
	m.station = nil
	m.clearedstation = false
}

// ClearStore clears the "store" edge to the Store entity.
func (m *SubscribeMutation) ClearStore() {
	m.clearedstore = true
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *SubscribeMutation) StoreCleared() bool {
	return m.StoreIDCleared() || m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *SubscribeMutation) StoreIDs() (ids []uint64) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *SubscribeMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *SubscribeMutation) ClearRider() {
	m.clearedrider = true
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *SubscribeMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *SubscribeMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *SubscribeMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *SubscribeMutation) ClearEnterprise() {
	m.clearedenterprise = true
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *SubscribeMutation) EnterpriseCleared() bool {
	return m.EnterpriseIDCleared() || m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *SubscribeMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *SubscribeMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// AddPauseIDs adds the "pauses" edge to the SubscribePause entity by ids.
func (m *SubscribeMutation) AddPauseIDs(ids ...uint64) {
	if m.pauses == nil {
		m.pauses = make(map[uint64]struct{})
	}
	for i := range ids {
		m.pauses[ids[i]] = struct{}{}
	}
}

// ClearPauses clears the "pauses" edge to the SubscribePause entity.
func (m *SubscribeMutation) ClearPauses() {
	m.clearedpauses = true
}

// PausesCleared reports if the "pauses" edge to the SubscribePause entity was cleared.
func (m *SubscribeMutation) PausesCleared() bool {
	return m.clearedpauses
}

// RemovePauseIDs removes the "pauses" edge to the SubscribePause entity by IDs.
func (m *SubscribeMutation) RemovePauseIDs(ids ...uint64) {
	if m.removedpauses == nil {
		m.removedpauses = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.pauses, ids[i])
		m.removedpauses[ids[i]] = struct{}{}
	}
}

// RemovedPauses returns the removed IDs of the "pauses" edge to the SubscribePause entity.
func (m *SubscribeMutation) RemovedPausesIDs() (ids []uint64) {
	for id := range m.removedpauses {
		ids = append(ids, id)
	}
	return
}

// PausesIDs returns the "pauses" edge IDs in the mutation.
func (m *SubscribeMutation) PausesIDs() (ids []uint64) {
	for id := range m.pauses {
		ids = append(ids, id)
	}
	return
}

// ResetPauses resets all changes to the "pauses" edge.
func (m *SubscribeMutation) ResetPauses() {
	m.pauses = nil
	m.clearedpauses = false
	m.removedpauses = nil
}

// AddAlterIDs adds the "alters" edge to the SubscribeAlter entity by ids.
func (m *SubscribeMutation) AddAlterIDs(ids ...uint64) {
	if m.alters == nil {
		m.alters = make(map[uint64]struct{})
	}
	for i := range ids {
		m.alters[ids[i]] = struct{}{}
	}
}

// ClearAlters clears the "alters" edge to the SubscribeAlter entity.
func (m *SubscribeMutation) ClearAlters() {
	m.clearedalters = true
}

// AltersCleared reports if the "alters" edge to the SubscribeAlter entity was cleared.
func (m *SubscribeMutation) AltersCleared() bool {
	return m.clearedalters
}

// RemoveAlterIDs removes the "alters" edge to the SubscribeAlter entity by IDs.
func (m *SubscribeMutation) RemoveAlterIDs(ids ...uint64) {
	if m.removedalters == nil {
		m.removedalters = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.alters, ids[i])
		m.removedalters[ids[i]] = struct{}{}
	}
}

// RemovedAlters returns the removed IDs of the "alters" edge to the SubscribeAlter entity.
func (m *SubscribeMutation) RemovedAltersIDs() (ids []uint64) {
	for id := range m.removedalters {
		ids = append(ids, id)
	}
	return
}

// AltersIDs returns the "alters" edge IDs in the mutation.
func (m *SubscribeMutation) AltersIDs() (ids []uint64) {
	for id := range m.alters {
		ids = append(ids, id)
	}
	return
}

// ResetAlters resets all changes to the "alters" edge.
func (m *SubscribeMutation) ResetAlters() {
	m.alters = nil
	m.clearedalters = false
	m.removedalters = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *SubscribeMutation) AddOrderIDs(ids ...uint64) {
	if m.orders == nil {
		m.orders = make(map[uint64]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *SubscribeMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *SubscribeMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *SubscribeMutation) RemoveOrderIDs(ids ...uint64) {
	if m.removedorders == nil {
		m.removedorders = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *SubscribeMutation) RemovedOrdersIDs() (ids []uint64) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *SubscribeMutation) OrdersIDs() (ids []uint64) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *SubscribeMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// ClearInitialOrder clears the "initial_order" edge to the Order entity.
func (m *SubscribeMutation) ClearInitialOrder() {
	m.clearedinitial_order = true
}

// InitialOrderCleared reports if the "initial_order" edge to the Order entity was cleared.
func (m *SubscribeMutation) InitialOrderCleared() bool {
	return m.InitialOrderIDCleared() || m.clearedinitial_order
}

// InitialOrderIDs returns the "initial_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InitialOrderID instead. It exists only for internal usage by the builders.
func (m *SubscribeMutation) InitialOrderIDs() (ids []uint64) {
	if id := m.initial_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInitialOrder resets all changes to the "initial_order" edge.
func (m *SubscribeMutation) ResetInitialOrder() {
	m.initial_order = nil
	m.clearedinitial_order = false
}

// Where appends a list predicates to the SubscribeMutation builder.
func (m *SubscribeMutation) Where(ps ...predicate.Subscribe) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SubscribeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Subscribe).
func (m *SubscribeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscribeMutation) Fields() []string {
	fields := make([]string, 0, 29)
	if m.created_at != nil {
		fields = append(fields, subscribe.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscribe.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, subscribe.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, subscribe.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, subscribe.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, subscribe.FieldRemark)
	}
	if m.plan != nil {
		fields = append(fields, subscribe.FieldPlanID)
	}
	if m.employee != nil {
		fields = append(fields, subscribe.FieldEmployeeID)
	}
	if m.city != nil {
		fields = append(fields, subscribe.FieldCityID)
	}
	if m.station != nil {
		fields = append(fields, subscribe.FieldStationID)
	}
	if m.store != nil {
		fields = append(fields, subscribe.FieldStoreID)
	}
	if m.rider != nil {
		fields = append(fields, subscribe.FieldRiderID)
	}
	if m.initial_order != nil {
		fields = append(fields, subscribe.FieldInitialOrderID)
	}
	if m.enterprise != nil {
		fields = append(fields, subscribe.FieldEnterpriseID)
	}
	if m.status != nil {
		fields = append(fields, subscribe.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, subscribe.FieldType)
	}
	if m.voltage != nil {
		fields = append(fields, subscribe.FieldVoltage)
	}
	if m.initial_days != nil {
		fields = append(fields, subscribe.FieldInitialDays)
	}
	if m.alter_days != nil {
		fields = append(fields, subscribe.FieldAlterDays)
	}
	if m.pause_days != nil {
		fields = append(fields, subscribe.FieldPauseDays)
	}
	if m.renewal_days != nil {
		fields = append(fields, subscribe.FieldRenewalDays)
	}
	if m.overdue_days != nil {
		fields = append(fields, subscribe.FieldOverdueDays)
	}
	if m.remaining != nil {
		fields = append(fields, subscribe.FieldRemaining)
	}
	if m.paused_at != nil {
		fields = append(fields, subscribe.FieldPausedAt)
	}
	if m.start_at != nil {
		fields = append(fields, subscribe.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, subscribe.FieldEndAt)
	}
	if m.refund_at != nil {
		fields = append(fields, subscribe.FieldRefundAt)
	}
	if m.unsubscribe_reason != nil {
		fields = append(fields, subscribe.FieldUnsubscribeReason)
	}
	if m.last_bill_date != nil {
		fields = append(fields, subscribe.FieldLastBillDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscribeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscribe.FieldCreatedAt:
		return m.CreatedAt()
	case subscribe.FieldUpdatedAt:
		return m.UpdatedAt()
	case subscribe.FieldDeletedAt:
		return m.DeletedAt()
	case subscribe.FieldCreator:
		return m.Creator()
	case subscribe.FieldLastModifier:
		return m.LastModifier()
	case subscribe.FieldRemark:
		return m.Remark()
	case subscribe.FieldPlanID:
		return m.PlanID()
	case subscribe.FieldEmployeeID:
		return m.EmployeeID()
	case subscribe.FieldCityID:
		return m.CityID()
	case subscribe.FieldStationID:
		return m.StationID()
	case subscribe.FieldStoreID:
		return m.StoreID()
	case subscribe.FieldRiderID:
		return m.RiderID()
	case subscribe.FieldInitialOrderID:
		return m.InitialOrderID()
	case subscribe.FieldEnterpriseID:
		return m.EnterpriseID()
	case subscribe.FieldStatus:
		return m.Status()
	case subscribe.FieldType:
		return m.GetType()
	case subscribe.FieldVoltage:
		return m.Voltage()
	case subscribe.FieldInitialDays:
		return m.InitialDays()
	case subscribe.FieldAlterDays:
		return m.AlterDays()
	case subscribe.FieldPauseDays:
		return m.PauseDays()
	case subscribe.FieldRenewalDays:
		return m.RenewalDays()
	case subscribe.FieldOverdueDays:
		return m.OverdueDays()
	case subscribe.FieldRemaining:
		return m.Remaining()
	case subscribe.FieldPausedAt:
		return m.PausedAt()
	case subscribe.FieldStartAt:
		return m.StartAt()
	case subscribe.FieldEndAt:
		return m.EndAt()
	case subscribe.FieldRefundAt:
		return m.RefundAt()
	case subscribe.FieldUnsubscribeReason:
		return m.UnsubscribeReason()
	case subscribe.FieldLastBillDate:
		return m.LastBillDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscribeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscribe.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscribe.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subscribe.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subscribe.FieldCreator:
		return m.OldCreator(ctx)
	case subscribe.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case subscribe.FieldRemark:
		return m.OldRemark(ctx)
	case subscribe.FieldPlanID:
		return m.OldPlanID(ctx)
	case subscribe.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case subscribe.FieldCityID:
		return m.OldCityID(ctx)
	case subscribe.FieldStationID:
		return m.OldStationID(ctx)
	case subscribe.FieldStoreID:
		return m.OldStoreID(ctx)
	case subscribe.FieldRiderID:
		return m.OldRiderID(ctx)
	case subscribe.FieldInitialOrderID:
		return m.OldInitialOrderID(ctx)
	case subscribe.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case subscribe.FieldStatus:
		return m.OldStatus(ctx)
	case subscribe.FieldType:
		return m.OldType(ctx)
	case subscribe.FieldVoltage:
		return m.OldVoltage(ctx)
	case subscribe.FieldInitialDays:
		return m.OldInitialDays(ctx)
	case subscribe.FieldAlterDays:
		return m.OldAlterDays(ctx)
	case subscribe.FieldPauseDays:
		return m.OldPauseDays(ctx)
	case subscribe.FieldRenewalDays:
		return m.OldRenewalDays(ctx)
	case subscribe.FieldOverdueDays:
		return m.OldOverdueDays(ctx)
	case subscribe.FieldRemaining:
		return m.OldRemaining(ctx)
	case subscribe.FieldPausedAt:
		return m.OldPausedAt(ctx)
	case subscribe.FieldStartAt:
		return m.OldStartAt(ctx)
	case subscribe.FieldEndAt:
		return m.OldEndAt(ctx)
	case subscribe.FieldRefundAt:
		return m.OldRefundAt(ctx)
	case subscribe.FieldUnsubscribeReason:
		return m.OldUnsubscribeReason(ctx)
	case subscribe.FieldLastBillDate:
		return m.OldLastBillDate(ctx)
	}
	return nil, fmt.Errorf("unknown Subscribe field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscribeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscribe.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscribe.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subscribe.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subscribe.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case subscribe.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case subscribe.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case subscribe.FieldPlanID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanID(v)
		return nil
	case subscribe.FieldEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case subscribe.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case subscribe.FieldStationID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStationID(v)
		return nil
	case subscribe.FieldStoreID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case subscribe.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case subscribe.FieldInitialOrderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitialOrderID(v)
		return nil
	case subscribe.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case subscribe.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case subscribe.FieldType:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case subscribe.FieldVoltage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoltage(v)
		return nil
	case subscribe.FieldInitialDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitialDays(v)
		return nil
	case subscribe.FieldAlterDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlterDays(v)
		return nil
	case subscribe.FieldPauseDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPauseDays(v)
		return nil
	case subscribe.FieldRenewalDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRenewalDays(v)
		return nil
	case subscribe.FieldOverdueDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverdueDays(v)
		return nil
	case subscribe.FieldRemaining:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemaining(v)
		return nil
	case subscribe.FieldPausedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPausedAt(v)
		return nil
	case subscribe.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case subscribe.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case subscribe.FieldRefundAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundAt(v)
		return nil
	case subscribe.FieldUnsubscribeReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnsubscribeReason(v)
		return nil
	case subscribe.FieldLastBillDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastBillDate(v)
		return nil
	}
	return fmt.Errorf("unknown Subscribe field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscribeMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, subscribe.FieldStatus)
	}
	if m.add_type != nil {
		fields = append(fields, subscribe.FieldType)
	}
	if m.addvoltage != nil {
		fields = append(fields, subscribe.FieldVoltage)
	}
	if m.addinitial_days != nil {
		fields = append(fields, subscribe.FieldInitialDays)
	}
	if m.addalter_days != nil {
		fields = append(fields, subscribe.FieldAlterDays)
	}
	if m.addpause_days != nil {
		fields = append(fields, subscribe.FieldPauseDays)
	}
	if m.addrenewal_days != nil {
		fields = append(fields, subscribe.FieldRenewalDays)
	}
	if m.addoverdue_days != nil {
		fields = append(fields, subscribe.FieldOverdueDays)
	}
	if m.addremaining != nil {
		fields = append(fields, subscribe.FieldRemaining)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscribeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subscribe.FieldStatus:
		return m.AddedStatus()
	case subscribe.FieldType:
		return m.AddedType()
	case subscribe.FieldVoltage:
		return m.AddedVoltage()
	case subscribe.FieldInitialDays:
		return m.AddedInitialDays()
	case subscribe.FieldAlterDays:
		return m.AddedAlterDays()
	case subscribe.FieldPauseDays:
		return m.AddedPauseDays()
	case subscribe.FieldRenewalDays:
		return m.AddedRenewalDays()
	case subscribe.FieldOverdueDays:
		return m.AddedOverdueDays()
	case subscribe.FieldRemaining:
		return m.AddedRemaining()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscribeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subscribe.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case subscribe.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case subscribe.FieldVoltage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVoltage(v)
		return nil
	case subscribe.FieldInitialDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInitialDays(v)
		return nil
	case subscribe.FieldAlterDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAlterDays(v)
		return nil
	case subscribe.FieldPauseDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPauseDays(v)
		return nil
	case subscribe.FieldRenewalDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRenewalDays(v)
		return nil
	case subscribe.FieldOverdueDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOverdueDays(v)
		return nil
	case subscribe.FieldRemaining:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemaining(v)
		return nil
	}
	return fmt.Errorf("unknown Subscribe numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscribeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscribe.FieldDeletedAt) {
		fields = append(fields, subscribe.FieldDeletedAt)
	}
	if m.FieldCleared(subscribe.FieldCreator) {
		fields = append(fields, subscribe.FieldCreator)
	}
	if m.FieldCleared(subscribe.FieldLastModifier) {
		fields = append(fields, subscribe.FieldLastModifier)
	}
	if m.FieldCleared(subscribe.FieldRemark) {
		fields = append(fields, subscribe.FieldRemark)
	}
	if m.FieldCleared(subscribe.FieldPlanID) {
		fields = append(fields, subscribe.FieldPlanID)
	}
	if m.FieldCleared(subscribe.FieldEmployeeID) {
		fields = append(fields, subscribe.FieldEmployeeID)
	}
	if m.FieldCleared(subscribe.FieldStationID) {
		fields = append(fields, subscribe.FieldStationID)
	}
	if m.FieldCleared(subscribe.FieldStoreID) {
		fields = append(fields, subscribe.FieldStoreID)
	}
	if m.FieldCleared(subscribe.FieldInitialOrderID) {
		fields = append(fields, subscribe.FieldInitialOrderID)
	}
	if m.FieldCleared(subscribe.FieldEnterpriseID) {
		fields = append(fields, subscribe.FieldEnterpriseID)
	}
	if m.FieldCleared(subscribe.FieldInitialDays) {
		fields = append(fields, subscribe.FieldInitialDays)
	}
	if m.FieldCleared(subscribe.FieldPausedAt) {
		fields = append(fields, subscribe.FieldPausedAt)
	}
	if m.FieldCleared(subscribe.FieldStartAt) {
		fields = append(fields, subscribe.FieldStartAt)
	}
	if m.FieldCleared(subscribe.FieldEndAt) {
		fields = append(fields, subscribe.FieldEndAt)
	}
	if m.FieldCleared(subscribe.FieldRefundAt) {
		fields = append(fields, subscribe.FieldRefundAt)
	}
	if m.FieldCleared(subscribe.FieldUnsubscribeReason) {
		fields = append(fields, subscribe.FieldUnsubscribeReason)
	}
	if m.FieldCleared(subscribe.FieldLastBillDate) {
		fields = append(fields, subscribe.FieldLastBillDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscribeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscribeMutation) ClearField(name string) error {
	switch name {
	case subscribe.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case subscribe.FieldCreator:
		m.ClearCreator()
		return nil
	case subscribe.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case subscribe.FieldRemark:
		m.ClearRemark()
		return nil
	case subscribe.FieldPlanID:
		m.ClearPlanID()
		return nil
	case subscribe.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case subscribe.FieldStationID:
		m.ClearStationID()
		return nil
	case subscribe.FieldStoreID:
		m.ClearStoreID()
		return nil
	case subscribe.FieldInitialOrderID:
		m.ClearInitialOrderID()
		return nil
	case subscribe.FieldEnterpriseID:
		m.ClearEnterpriseID()
		return nil
	case subscribe.FieldInitialDays:
		m.ClearInitialDays()
		return nil
	case subscribe.FieldPausedAt:
		m.ClearPausedAt()
		return nil
	case subscribe.FieldStartAt:
		m.ClearStartAt()
		return nil
	case subscribe.FieldEndAt:
		m.ClearEndAt()
		return nil
	case subscribe.FieldRefundAt:
		m.ClearRefundAt()
		return nil
	case subscribe.FieldUnsubscribeReason:
		m.ClearUnsubscribeReason()
		return nil
	case subscribe.FieldLastBillDate:
		m.ClearLastBillDate()
		return nil
	}
	return fmt.Errorf("unknown Subscribe nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscribeMutation) ResetField(name string) error {
	switch name {
	case subscribe.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscribe.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subscribe.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subscribe.FieldCreator:
		m.ResetCreator()
		return nil
	case subscribe.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case subscribe.FieldRemark:
		m.ResetRemark()
		return nil
	case subscribe.FieldPlanID:
		m.ResetPlanID()
		return nil
	case subscribe.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case subscribe.FieldCityID:
		m.ResetCityID()
		return nil
	case subscribe.FieldStationID:
		m.ResetStationID()
		return nil
	case subscribe.FieldStoreID:
		m.ResetStoreID()
		return nil
	case subscribe.FieldRiderID:
		m.ResetRiderID()
		return nil
	case subscribe.FieldInitialOrderID:
		m.ResetInitialOrderID()
		return nil
	case subscribe.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case subscribe.FieldStatus:
		m.ResetStatus()
		return nil
	case subscribe.FieldType:
		m.ResetType()
		return nil
	case subscribe.FieldVoltage:
		m.ResetVoltage()
		return nil
	case subscribe.FieldInitialDays:
		m.ResetInitialDays()
		return nil
	case subscribe.FieldAlterDays:
		m.ResetAlterDays()
		return nil
	case subscribe.FieldPauseDays:
		m.ResetPauseDays()
		return nil
	case subscribe.FieldRenewalDays:
		m.ResetRenewalDays()
		return nil
	case subscribe.FieldOverdueDays:
		m.ResetOverdueDays()
		return nil
	case subscribe.FieldRemaining:
		m.ResetRemaining()
		return nil
	case subscribe.FieldPausedAt:
		m.ResetPausedAt()
		return nil
	case subscribe.FieldStartAt:
		m.ResetStartAt()
		return nil
	case subscribe.FieldEndAt:
		m.ResetEndAt()
		return nil
	case subscribe.FieldRefundAt:
		m.ResetRefundAt()
		return nil
	case subscribe.FieldUnsubscribeReason:
		m.ResetUnsubscribeReason()
		return nil
	case subscribe.FieldLastBillDate:
		m.ResetLastBillDate()
		return nil
	}
	return fmt.Errorf("unknown Subscribe field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscribeMutation) AddedEdges() []string {
	edges := make([]string, 0, 11)
	if m.plan != nil {
		edges = append(edges, subscribe.EdgePlan)
	}
	if m.employee != nil {
		edges = append(edges, subscribe.EdgeEmployee)
	}
	if m.city != nil {
		edges = append(edges, subscribe.EdgeCity)
	}
	if m.station != nil {
		edges = append(edges, subscribe.EdgeStation)
	}
	if m.store != nil {
		edges = append(edges, subscribe.EdgeStore)
	}
	if m.rider != nil {
		edges = append(edges, subscribe.EdgeRider)
	}
	if m.enterprise != nil {
		edges = append(edges, subscribe.EdgeEnterprise)
	}
	if m.pauses != nil {
		edges = append(edges, subscribe.EdgePauses)
	}
	if m.alters != nil {
		edges = append(edges, subscribe.EdgeAlters)
	}
	if m.orders != nil {
		edges = append(edges, subscribe.EdgeOrders)
	}
	if m.initial_order != nil {
		edges = append(edges, subscribe.EdgeInitialOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscribeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscribe.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	case subscribe.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case subscribe.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case subscribe.EdgeStation:
		if id := m.station; id != nil {
			return []ent.Value{*id}
		}
	case subscribe.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	case subscribe.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case subscribe.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	case subscribe.EdgePauses:
		ids := make([]ent.Value, 0, len(m.pauses))
		for id := range m.pauses {
			ids = append(ids, id)
		}
		return ids
	case subscribe.EdgeAlters:
		ids := make([]ent.Value, 0, len(m.alters))
		for id := range m.alters {
			ids = append(ids, id)
		}
		return ids
	case subscribe.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case subscribe.EdgeInitialOrder:
		if id := m.initial_order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscribeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 11)
	if m.removedpauses != nil {
		edges = append(edges, subscribe.EdgePauses)
	}
	if m.removedalters != nil {
		edges = append(edges, subscribe.EdgeAlters)
	}
	if m.removedorders != nil {
		edges = append(edges, subscribe.EdgeOrders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscribeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subscribe.EdgePauses:
		ids := make([]ent.Value, 0, len(m.removedpauses))
		for id := range m.removedpauses {
			ids = append(ids, id)
		}
		return ids
	case subscribe.EdgeAlters:
		ids := make([]ent.Value, 0, len(m.removedalters))
		for id := range m.removedalters {
			ids = append(ids, id)
		}
		return ids
	case subscribe.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscribeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 11)
	if m.clearedplan {
		edges = append(edges, subscribe.EdgePlan)
	}
	if m.clearedemployee {
		edges = append(edges, subscribe.EdgeEmployee)
	}
	if m.clearedcity {
		edges = append(edges, subscribe.EdgeCity)
	}
	if m.clearedstation {
		edges = append(edges, subscribe.EdgeStation)
	}
	if m.clearedstore {
		edges = append(edges, subscribe.EdgeStore)
	}
	if m.clearedrider {
		edges = append(edges, subscribe.EdgeRider)
	}
	if m.clearedenterprise {
		edges = append(edges, subscribe.EdgeEnterprise)
	}
	if m.clearedpauses {
		edges = append(edges, subscribe.EdgePauses)
	}
	if m.clearedalters {
		edges = append(edges, subscribe.EdgeAlters)
	}
	if m.clearedorders {
		edges = append(edges, subscribe.EdgeOrders)
	}
	if m.clearedinitial_order {
		edges = append(edges, subscribe.EdgeInitialOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscribeMutation) EdgeCleared(name string) bool {
	switch name {
	case subscribe.EdgePlan:
		return m.clearedplan
	case subscribe.EdgeEmployee:
		return m.clearedemployee
	case subscribe.EdgeCity:
		return m.clearedcity
	case subscribe.EdgeStation:
		return m.clearedstation
	case subscribe.EdgeStore:
		return m.clearedstore
	case subscribe.EdgeRider:
		return m.clearedrider
	case subscribe.EdgeEnterprise:
		return m.clearedenterprise
	case subscribe.EdgePauses:
		return m.clearedpauses
	case subscribe.EdgeAlters:
		return m.clearedalters
	case subscribe.EdgeOrders:
		return m.clearedorders
	case subscribe.EdgeInitialOrder:
		return m.clearedinitial_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscribeMutation) ClearEdge(name string) error {
	switch name {
	case subscribe.EdgePlan:
		m.ClearPlan()
		return nil
	case subscribe.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case subscribe.EdgeCity:
		m.ClearCity()
		return nil
	case subscribe.EdgeStation:
		m.ClearStation()
		return nil
	case subscribe.EdgeStore:
		m.ClearStore()
		return nil
	case subscribe.EdgeRider:
		m.ClearRider()
		return nil
	case subscribe.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	case subscribe.EdgeInitialOrder:
		m.ClearInitialOrder()
		return nil
	}
	return fmt.Errorf("unknown Subscribe unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscribeMutation) ResetEdge(name string) error {
	switch name {
	case subscribe.EdgePlan:
		m.ResetPlan()
		return nil
	case subscribe.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case subscribe.EdgeCity:
		m.ResetCity()
		return nil
	case subscribe.EdgeStation:
		m.ResetStation()
		return nil
	case subscribe.EdgeStore:
		m.ResetStore()
		return nil
	case subscribe.EdgeRider:
		m.ResetRider()
		return nil
	case subscribe.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	case subscribe.EdgePauses:
		m.ResetPauses()
		return nil
	case subscribe.EdgeAlters:
		m.ResetAlters()
		return nil
	case subscribe.EdgeOrders:
		m.ResetOrders()
		return nil
	case subscribe.EdgeInitialOrder:
		m.ResetInitialOrder()
		return nil
	}
	return fmt.Errorf("unknown Subscribe edge %s", name)
}

// SubscribeAlterMutation represents an operation that mutates the SubscribeAlter nodes in the graph.
type SubscribeAlterMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	creator          **model.Modifier
	last_modifier    **model.Modifier
	remark           *string
	days             *int
	adddays          *int
	clearedFields    map[string]struct{}
	rider            *uint64
	clearedrider     bool
	manager          *uint64
	clearedmanager   bool
	subscribe        *uint64
	clearedsubscribe bool
	done             bool
	oldValue         func(context.Context) (*SubscribeAlter, error)
	predicates       []predicate.SubscribeAlter
}

var _ ent.Mutation = (*SubscribeAlterMutation)(nil)

// subscribealterOption allows management of the mutation configuration using functional options.
type subscribealterOption func(*SubscribeAlterMutation)

// newSubscribeAlterMutation creates new mutation for the SubscribeAlter entity.
func newSubscribeAlterMutation(c config, op Op, opts ...subscribealterOption) *SubscribeAlterMutation {
	m := &SubscribeAlterMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscribeAlter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscribeAlterID sets the ID field of the mutation.
func withSubscribeAlterID(id uint64) subscribealterOption {
	return func(m *SubscribeAlterMutation) {
		var (
			err   error
			once  sync.Once
			value *SubscribeAlter
		)
		m.oldValue = func(ctx context.Context) (*SubscribeAlter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubscribeAlter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscribeAlter sets the old SubscribeAlter of the mutation.
func withSubscribeAlter(node *SubscribeAlter) subscribealterOption {
	return func(m *SubscribeAlterMutation) {
		m.oldValue = func(context.Context) (*SubscribeAlter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscribeAlterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscribeAlterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscribeAlterMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscribeAlterMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubscribeAlter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscribeAlterMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscribeAlterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscribeAlterMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscribeAlterMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscribeAlterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscribeAlterMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SubscribeAlterMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SubscribeAlterMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SubscribeAlterMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[subscribealter.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SubscribeAlterMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[subscribealter.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SubscribeAlterMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, subscribealter.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *SubscribeAlterMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *SubscribeAlterMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *SubscribeAlterMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[subscribealter.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *SubscribeAlterMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[subscribealter.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *SubscribeAlterMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, subscribealter.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *SubscribeAlterMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *SubscribeAlterMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *SubscribeAlterMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[subscribealter.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *SubscribeAlterMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[subscribealter.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *SubscribeAlterMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, subscribealter.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *SubscribeAlterMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *SubscribeAlterMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *SubscribeAlterMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[subscribealter.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *SubscribeAlterMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[subscribealter.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *SubscribeAlterMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, subscribealter.FieldRemark)
}

// SetRiderID sets the "rider_id" field.
func (m *SubscribeAlterMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *SubscribeAlterMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *SubscribeAlterMutation) ResetRiderID() {
	m.rider = nil
}

// SetManagerID sets the "manager_id" field.
func (m *SubscribeAlterMutation) SetManagerID(u uint64) {
	m.manager = &u
}

// ManagerID returns the value of the "manager_id" field in the mutation.
func (m *SubscribeAlterMutation) ManagerID() (r uint64, exists bool) {
	v := m.manager
	if v == nil {
		return
	}
	return *v, true
}

// OldManagerID returns the old "manager_id" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldManagerID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagerID: %w", err)
	}
	return oldValue.ManagerID, nil
}

// ResetManagerID resets all changes to the "manager_id" field.
func (m *SubscribeAlterMutation) ResetManagerID() {
	m.manager = nil
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *SubscribeAlterMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *SubscribeAlterMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldSubscribeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *SubscribeAlterMutation) ResetSubscribeID() {
	m.subscribe = nil
}

// SetDays sets the "days" field.
func (m *SubscribeAlterMutation) SetDays(i int) {
	m.days = &i
	m.adddays = nil
}

// Days returns the value of the "days" field in the mutation.
func (m *SubscribeAlterMutation) Days() (r int, exists bool) {
	v := m.days
	if v == nil {
		return
	}
	return *v, true
}

// OldDays returns the old "days" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDays: %w", err)
	}
	return oldValue.Days, nil
}

// AddDays adds i to the "days" field.
func (m *SubscribeAlterMutation) AddDays(i int) {
	if m.adddays != nil {
		*m.adddays += i
	} else {
		m.adddays = &i
	}
}

// AddedDays returns the value that was added to the "days" field in this mutation.
func (m *SubscribeAlterMutation) AddedDays() (r int, exists bool) {
	v := m.adddays
	if v == nil {
		return
	}
	return *v, true
}

// ResetDays resets all changes to the "days" field.
func (m *SubscribeAlterMutation) ResetDays() {
	m.days = nil
	m.adddays = nil
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *SubscribeAlterMutation) ClearRider() {
	m.clearedrider = true
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *SubscribeAlterMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *SubscribeAlterMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *SubscribeAlterMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearManager clears the "manager" edge to the Manager entity.
func (m *SubscribeAlterMutation) ClearManager() {
	m.clearedmanager = true
}

// ManagerCleared reports if the "manager" edge to the Manager entity was cleared.
func (m *SubscribeAlterMutation) ManagerCleared() bool {
	return m.clearedmanager
}

// ManagerIDs returns the "manager" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ManagerID instead. It exists only for internal usage by the builders.
func (m *SubscribeAlterMutation) ManagerIDs() (ids []uint64) {
	if id := m.manager; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetManager resets all changes to the "manager" edge.
func (m *SubscribeAlterMutation) ResetManager() {
	m.manager = nil
	m.clearedmanager = false
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *SubscribeAlterMutation) ClearSubscribe() {
	m.clearedsubscribe = true
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *SubscribeAlterMutation) SubscribeCleared() bool {
	return m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *SubscribeAlterMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *SubscribeAlterMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// Where appends a list predicates to the SubscribeAlterMutation builder.
func (m *SubscribeAlterMutation) Where(ps ...predicate.SubscribeAlter) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SubscribeAlterMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SubscribeAlter).
func (m *SubscribeAlterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscribeAlterMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, subscribealter.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscribealter.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, subscribealter.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, subscribealter.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, subscribealter.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, subscribealter.FieldRemark)
	}
	if m.rider != nil {
		fields = append(fields, subscribealter.FieldRiderID)
	}
	if m.manager != nil {
		fields = append(fields, subscribealter.FieldManagerID)
	}
	if m.subscribe != nil {
		fields = append(fields, subscribealter.FieldSubscribeID)
	}
	if m.days != nil {
		fields = append(fields, subscribealter.FieldDays)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscribeAlterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscribealter.FieldCreatedAt:
		return m.CreatedAt()
	case subscribealter.FieldUpdatedAt:
		return m.UpdatedAt()
	case subscribealter.FieldDeletedAt:
		return m.DeletedAt()
	case subscribealter.FieldCreator:
		return m.Creator()
	case subscribealter.FieldLastModifier:
		return m.LastModifier()
	case subscribealter.FieldRemark:
		return m.Remark()
	case subscribealter.FieldRiderID:
		return m.RiderID()
	case subscribealter.FieldManagerID:
		return m.ManagerID()
	case subscribealter.FieldSubscribeID:
		return m.SubscribeID()
	case subscribealter.FieldDays:
		return m.Days()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscribeAlterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscribealter.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscribealter.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subscribealter.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subscribealter.FieldCreator:
		return m.OldCreator(ctx)
	case subscribealter.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case subscribealter.FieldRemark:
		return m.OldRemark(ctx)
	case subscribealter.FieldRiderID:
		return m.OldRiderID(ctx)
	case subscribealter.FieldManagerID:
		return m.OldManagerID(ctx)
	case subscribealter.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case subscribealter.FieldDays:
		return m.OldDays(ctx)
	}
	return nil, fmt.Errorf("unknown SubscribeAlter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscribeAlterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscribealter.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscribealter.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subscribealter.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subscribealter.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case subscribealter.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case subscribealter.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case subscribealter.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case subscribealter.FieldManagerID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagerID(v)
		return nil
	case subscribealter.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case subscribealter.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDays(v)
		return nil
	}
	return fmt.Errorf("unknown SubscribeAlter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscribeAlterMutation) AddedFields() []string {
	var fields []string
	if m.adddays != nil {
		fields = append(fields, subscribealter.FieldDays)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscribeAlterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subscribealter.FieldDays:
		return m.AddedDays()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscribeAlterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subscribealter.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDays(v)
		return nil
	}
	return fmt.Errorf("unknown SubscribeAlter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscribeAlterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscribealter.FieldDeletedAt) {
		fields = append(fields, subscribealter.FieldDeletedAt)
	}
	if m.FieldCleared(subscribealter.FieldCreator) {
		fields = append(fields, subscribealter.FieldCreator)
	}
	if m.FieldCleared(subscribealter.FieldLastModifier) {
		fields = append(fields, subscribealter.FieldLastModifier)
	}
	if m.FieldCleared(subscribealter.FieldRemark) {
		fields = append(fields, subscribealter.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscribeAlterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscribeAlterMutation) ClearField(name string) error {
	switch name {
	case subscribealter.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case subscribealter.FieldCreator:
		m.ClearCreator()
		return nil
	case subscribealter.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case subscribealter.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown SubscribeAlter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscribeAlterMutation) ResetField(name string) error {
	switch name {
	case subscribealter.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscribealter.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subscribealter.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subscribealter.FieldCreator:
		m.ResetCreator()
		return nil
	case subscribealter.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case subscribealter.FieldRemark:
		m.ResetRemark()
		return nil
	case subscribealter.FieldRiderID:
		m.ResetRiderID()
		return nil
	case subscribealter.FieldManagerID:
		m.ResetManagerID()
		return nil
	case subscribealter.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case subscribealter.FieldDays:
		m.ResetDays()
		return nil
	}
	return fmt.Errorf("unknown SubscribeAlter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscribeAlterMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.rider != nil {
		edges = append(edges, subscribealter.EdgeRider)
	}
	if m.manager != nil {
		edges = append(edges, subscribealter.EdgeManager)
	}
	if m.subscribe != nil {
		edges = append(edges, subscribealter.EdgeSubscribe)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscribeAlterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscribealter.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case subscribealter.EdgeManager:
		if id := m.manager; id != nil {
			return []ent.Value{*id}
		}
	case subscribealter.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscribeAlterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscribeAlterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscribeAlterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedrider {
		edges = append(edges, subscribealter.EdgeRider)
	}
	if m.clearedmanager {
		edges = append(edges, subscribealter.EdgeManager)
	}
	if m.clearedsubscribe {
		edges = append(edges, subscribealter.EdgeSubscribe)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscribeAlterMutation) EdgeCleared(name string) bool {
	switch name {
	case subscribealter.EdgeRider:
		return m.clearedrider
	case subscribealter.EdgeManager:
		return m.clearedmanager
	case subscribealter.EdgeSubscribe:
		return m.clearedsubscribe
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscribeAlterMutation) ClearEdge(name string) error {
	switch name {
	case subscribealter.EdgeRider:
		m.ClearRider()
		return nil
	case subscribealter.EdgeManager:
		m.ClearManager()
		return nil
	case subscribealter.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	}
	return fmt.Errorf("unknown SubscribeAlter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscribeAlterMutation) ResetEdge(name string) error {
	switch name {
	case subscribealter.EdgeRider:
		m.ResetRider()
		return nil
	case subscribealter.EdgeManager:
		m.ResetManager()
		return nil
	case subscribealter.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	}
	return fmt.Errorf("unknown SubscribeAlter edge %s", name)
}

// SubscribePauseMutation represents an operation that mutates the SubscribePause nodes in the graph.
type SubscribePauseMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uint64
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	creator                  **model.Modifier
	last_modifier            **model.Modifier
	remark                   *string
	start_at                 *time.Time
	end_at                   *time.Time
	days                     *int
	adddays                  *int
	clearedFields            map[string]struct{}
	rider                    *uint64
	clearedrider             bool
	employee                 *uint64
	clearedemployee          bool
	subscribe                *uint64
	clearedsubscribe         bool
	continue_employee        *uint64
	clearedcontinue_employee bool
	done                     bool
	oldValue                 func(context.Context) (*SubscribePause, error)
	predicates               []predicate.SubscribePause
}

var _ ent.Mutation = (*SubscribePauseMutation)(nil)

// subscribepauseOption allows management of the mutation configuration using functional options.
type subscribepauseOption func(*SubscribePauseMutation)

// newSubscribePauseMutation creates new mutation for the SubscribePause entity.
func newSubscribePauseMutation(c config, op Op, opts ...subscribepauseOption) *SubscribePauseMutation {
	m := &SubscribePauseMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscribePause,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscribePauseID sets the ID field of the mutation.
func withSubscribePauseID(id uint64) subscribepauseOption {
	return func(m *SubscribePauseMutation) {
		var (
			err   error
			once  sync.Once
			value *SubscribePause
		)
		m.oldValue = func(ctx context.Context) (*SubscribePause, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubscribePause.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscribePause sets the old SubscribePause of the mutation.
func withSubscribePause(node *SubscribePause) subscribepauseOption {
	return func(m *SubscribePauseMutation) {
		m.oldValue = func(context.Context) (*SubscribePause, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscribePauseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscribePauseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscribePauseMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscribePauseMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubscribePause.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscribePauseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscribePauseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscribePauseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscribePauseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscribePauseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscribePauseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SubscribePauseMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SubscribePauseMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SubscribePauseMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[subscribepause.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SubscribePauseMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[subscribepause.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SubscribePauseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, subscribepause.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *SubscribePauseMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *SubscribePauseMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *SubscribePauseMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[subscribepause.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *SubscribePauseMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[subscribepause.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *SubscribePauseMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, subscribepause.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *SubscribePauseMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *SubscribePauseMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *SubscribePauseMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[subscribepause.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *SubscribePauseMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[subscribepause.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *SubscribePauseMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, subscribepause.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *SubscribePauseMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *SubscribePauseMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *SubscribePauseMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[subscribepause.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *SubscribePauseMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[subscribepause.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *SubscribePauseMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, subscribepause.FieldRemark)
}

// SetRiderID sets the "rider_id" field.
func (m *SubscribePauseMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *SubscribePauseMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *SubscribePauseMutation) ResetRiderID() {
	m.rider = nil
}

// SetEmployeeID sets the "employee_id" field.
func (m *SubscribePauseMutation) SetEmployeeID(u uint64) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *SubscribePauseMutation) EmployeeID() (r uint64, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldEmployeeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *SubscribePauseMutation) ClearEmployeeID() {
	m.employee = nil
	m.clearedFields[subscribepause.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *SubscribePauseMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[subscribepause.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *SubscribePauseMutation) ResetEmployeeID() {
	m.employee = nil
	delete(m.clearedFields, subscribepause.FieldEmployeeID)
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *SubscribePauseMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *SubscribePauseMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldSubscribeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *SubscribePauseMutation) ResetSubscribeID() {
	m.subscribe = nil
}

// SetStartAt sets the "start_at" field.
func (m *SubscribePauseMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *SubscribePauseMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *SubscribePauseMutation) ResetStartAt() {
	m.start_at = nil
}

// SetEndAt sets the "end_at" field.
func (m *SubscribePauseMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *SubscribePauseMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *SubscribePauseMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[subscribepause.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *SubscribePauseMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[subscribepause.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *SubscribePauseMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, subscribepause.FieldEndAt)
}

// SetDays sets the "days" field.
func (m *SubscribePauseMutation) SetDays(i int) {
	m.days = &i
	m.adddays = nil
}

// Days returns the value of the "days" field in the mutation.
func (m *SubscribePauseMutation) Days() (r int, exists bool) {
	v := m.days
	if v == nil {
		return
	}
	return *v, true
}

// OldDays returns the old "days" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDays: %w", err)
	}
	return oldValue.Days, nil
}

// AddDays adds i to the "days" field.
func (m *SubscribePauseMutation) AddDays(i int) {
	if m.adddays != nil {
		*m.adddays += i
	} else {
		m.adddays = &i
	}
}

// AddedDays returns the value that was added to the "days" field in this mutation.
func (m *SubscribePauseMutation) AddedDays() (r int, exists bool) {
	v := m.adddays
	if v == nil {
		return
	}
	return *v, true
}

// ClearDays clears the value of the "days" field.
func (m *SubscribePauseMutation) ClearDays() {
	m.days = nil
	m.adddays = nil
	m.clearedFields[subscribepause.FieldDays] = struct{}{}
}

// DaysCleared returns if the "days" field was cleared in this mutation.
func (m *SubscribePauseMutation) DaysCleared() bool {
	_, ok := m.clearedFields[subscribepause.FieldDays]
	return ok
}

// ResetDays resets all changes to the "days" field.
func (m *SubscribePauseMutation) ResetDays() {
	m.days = nil
	m.adddays = nil
	delete(m.clearedFields, subscribepause.FieldDays)
}

// SetContinueEmployeeID sets the "continue_employee_id" field.
func (m *SubscribePauseMutation) SetContinueEmployeeID(u uint64) {
	m.continue_employee = &u
}

// ContinueEmployeeID returns the value of the "continue_employee_id" field in the mutation.
func (m *SubscribePauseMutation) ContinueEmployeeID() (r uint64, exists bool) {
	v := m.continue_employee
	if v == nil {
		return
	}
	return *v, true
}

// OldContinueEmployeeID returns the old "continue_employee_id" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldContinueEmployeeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContinueEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContinueEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContinueEmployeeID: %w", err)
	}
	return oldValue.ContinueEmployeeID, nil
}

// ClearContinueEmployeeID clears the value of the "continue_employee_id" field.
func (m *SubscribePauseMutation) ClearContinueEmployeeID() {
	m.continue_employee = nil
	m.clearedFields[subscribepause.FieldContinueEmployeeID] = struct{}{}
}

// ContinueEmployeeIDCleared returns if the "continue_employee_id" field was cleared in this mutation.
func (m *SubscribePauseMutation) ContinueEmployeeIDCleared() bool {
	_, ok := m.clearedFields[subscribepause.FieldContinueEmployeeID]
	return ok
}

// ResetContinueEmployeeID resets all changes to the "continue_employee_id" field.
func (m *SubscribePauseMutation) ResetContinueEmployeeID() {
	m.continue_employee = nil
	delete(m.clearedFields, subscribepause.FieldContinueEmployeeID)
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *SubscribePauseMutation) ClearRider() {
	m.clearedrider = true
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *SubscribePauseMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *SubscribePauseMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *SubscribePauseMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *SubscribePauseMutation) ClearEmployee() {
	m.clearedemployee = true
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *SubscribePauseMutation) EmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *SubscribePauseMutation) EmployeeIDs() (ids []uint64) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *SubscribePauseMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *SubscribePauseMutation) ClearSubscribe() {
	m.clearedsubscribe = true
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *SubscribePauseMutation) SubscribeCleared() bool {
	return m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *SubscribePauseMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *SubscribePauseMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// ClearContinueEmployee clears the "continue_employee" edge to the Employee entity.
func (m *SubscribePauseMutation) ClearContinueEmployee() {
	m.clearedcontinue_employee = true
}

// ContinueEmployeeCleared reports if the "continue_employee" edge to the Employee entity was cleared.
func (m *SubscribePauseMutation) ContinueEmployeeCleared() bool {
	return m.ContinueEmployeeIDCleared() || m.clearedcontinue_employee
}

// ContinueEmployeeIDs returns the "continue_employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContinueEmployeeID instead. It exists only for internal usage by the builders.
func (m *SubscribePauseMutation) ContinueEmployeeIDs() (ids []uint64) {
	if id := m.continue_employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContinueEmployee resets all changes to the "continue_employee" edge.
func (m *SubscribePauseMutation) ResetContinueEmployee() {
	m.continue_employee = nil
	m.clearedcontinue_employee = false
}

// Where appends a list predicates to the SubscribePauseMutation builder.
func (m *SubscribePauseMutation) Where(ps ...predicate.SubscribePause) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SubscribePauseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SubscribePause).
func (m *SubscribePauseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscribePauseMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, subscribepause.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscribepause.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, subscribepause.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, subscribepause.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, subscribepause.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, subscribepause.FieldRemark)
	}
	if m.rider != nil {
		fields = append(fields, subscribepause.FieldRiderID)
	}
	if m.employee != nil {
		fields = append(fields, subscribepause.FieldEmployeeID)
	}
	if m.subscribe != nil {
		fields = append(fields, subscribepause.FieldSubscribeID)
	}
	if m.start_at != nil {
		fields = append(fields, subscribepause.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, subscribepause.FieldEndAt)
	}
	if m.days != nil {
		fields = append(fields, subscribepause.FieldDays)
	}
	if m.continue_employee != nil {
		fields = append(fields, subscribepause.FieldContinueEmployeeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscribePauseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscribepause.FieldCreatedAt:
		return m.CreatedAt()
	case subscribepause.FieldUpdatedAt:
		return m.UpdatedAt()
	case subscribepause.FieldDeletedAt:
		return m.DeletedAt()
	case subscribepause.FieldCreator:
		return m.Creator()
	case subscribepause.FieldLastModifier:
		return m.LastModifier()
	case subscribepause.FieldRemark:
		return m.Remark()
	case subscribepause.FieldRiderID:
		return m.RiderID()
	case subscribepause.FieldEmployeeID:
		return m.EmployeeID()
	case subscribepause.FieldSubscribeID:
		return m.SubscribeID()
	case subscribepause.FieldStartAt:
		return m.StartAt()
	case subscribepause.FieldEndAt:
		return m.EndAt()
	case subscribepause.FieldDays:
		return m.Days()
	case subscribepause.FieldContinueEmployeeID:
		return m.ContinueEmployeeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscribePauseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscribepause.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscribepause.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subscribepause.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subscribepause.FieldCreator:
		return m.OldCreator(ctx)
	case subscribepause.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case subscribepause.FieldRemark:
		return m.OldRemark(ctx)
	case subscribepause.FieldRiderID:
		return m.OldRiderID(ctx)
	case subscribepause.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case subscribepause.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case subscribepause.FieldStartAt:
		return m.OldStartAt(ctx)
	case subscribepause.FieldEndAt:
		return m.OldEndAt(ctx)
	case subscribepause.FieldDays:
		return m.OldDays(ctx)
	case subscribepause.FieldContinueEmployeeID:
		return m.OldContinueEmployeeID(ctx)
	}
	return nil, fmt.Errorf("unknown SubscribePause field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscribePauseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscribepause.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscribepause.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subscribepause.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subscribepause.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case subscribepause.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case subscribepause.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case subscribepause.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case subscribepause.FieldEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case subscribepause.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case subscribepause.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case subscribepause.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case subscribepause.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDays(v)
		return nil
	case subscribepause.FieldContinueEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContinueEmployeeID(v)
		return nil
	}
	return fmt.Errorf("unknown SubscribePause field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscribePauseMutation) AddedFields() []string {
	var fields []string
	if m.adddays != nil {
		fields = append(fields, subscribepause.FieldDays)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscribePauseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subscribepause.FieldDays:
		return m.AddedDays()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscribePauseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subscribepause.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDays(v)
		return nil
	}
	return fmt.Errorf("unknown SubscribePause numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscribePauseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscribepause.FieldDeletedAt) {
		fields = append(fields, subscribepause.FieldDeletedAt)
	}
	if m.FieldCleared(subscribepause.FieldCreator) {
		fields = append(fields, subscribepause.FieldCreator)
	}
	if m.FieldCleared(subscribepause.FieldLastModifier) {
		fields = append(fields, subscribepause.FieldLastModifier)
	}
	if m.FieldCleared(subscribepause.FieldRemark) {
		fields = append(fields, subscribepause.FieldRemark)
	}
	if m.FieldCleared(subscribepause.FieldEmployeeID) {
		fields = append(fields, subscribepause.FieldEmployeeID)
	}
	if m.FieldCleared(subscribepause.FieldEndAt) {
		fields = append(fields, subscribepause.FieldEndAt)
	}
	if m.FieldCleared(subscribepause.FieldDays) {
		fields = append(fields, subscribepause.FieldDays)
	}
	if m.FieldCleared(subscribepause.FieldContinueEmployeeID) {
		fields = append(fields, subscribepause.FieldContinueEmployeeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscribePauseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscribePauseMutation) ClearField(name string) error {
	switch name {
	case subscribepause.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case subscribepause.FieldCreator:
		m.ClearCreator()
		return nil
	case subscribepause.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case subscribepause.FieldRemark:
		m.ClearRemark()
		return nil
	case subscribepause.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case subscribepause.FieldEndAt:
		m.ClearEndAt()
		return nil
	case subscribepause.FieldDays:
		m.ClearDays()
		return nil
	case subscribepause.FieldContinueEmployeeID:
		m.ClearContinueEmployeeID()
		return nil
	}
	return fmt.Errorf("unknown SubscribePause nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscribePauseMutation) ResetField(name string) error {
	switch name {
	case subscribepause.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscribepause.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subscribepause.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subscribepause.FieldCreator:
		m.ResetCreator()
		return nil
	case subscribepause.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case subscribepause.FieldRemark:
		m.ResetRemark()
		return nil
	case subscribepause.FieldRiderID:
		m.ResetRiderID()
		return nil
	case subscribepause.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case subscribepause.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case subscribepause.FieldStartAt:
		m.ResetStartAt()
		return nil
	case subscribepause.FieldEndAt:
		m.ResetEndAt()
		return nil
	case subscribepause.FieldDays:
		m.ResetDays()
		return nil
	case subscribepause.FieldContinueEmployeeID:
		m.ResetContinueEmployeeID()
		return nil
	}
	return fmt.Errorf("unknown SubscribePause field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscribePauseMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.rider != nil {
		edges = append(edges, subscribepause.EdgeRider)
	}
	if m.employee != nil {
		edges = append(edges, subscribepause.EdgeEmployee)
	}
	if m.subscribe != nil {
		edges = append(edges, subscribepause.EdgeSubscribe)
	}
	if m.continue_employee != nil {
		edges = append(edges, subscribepause.EdgeContinueEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscribePauseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscribepause.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case subscribepause.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case subscribepause.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	case subscribepause.EdgeContinueEmployee:
		if id := m.continue_employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscribePauseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscribePauseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscribePauseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedrider {
		edges = append(edges, subscribepause.EdgeRider)
	}
	if m.clearedemployee {
		edges = append(edges, subscribepause.EdgeEmployee)
	}
	if m.clearedsubscribe {
		edges = append(edges, subscribepause.EdgeSubscribe)
	}
	if m.clearedcontinue_employee {
		edges = append(edges, subscribepause.EdgeContinueEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscribePauseMutation) EdgeCleared(name string) bool {
	switch name {
	case subscribepause.EdgeRider:
		return m.clearedrider
	case subscribepause.EdgeEmployee:
		return m.clearedemployee
	case subscribepause.EdgeSubscribe:
		return m.clearedsubscribe
	case subscribepause.EdgeContinueEmployee:
		return m.clearedcontinue_employee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscribePauseMutation) ClearEdge(name string) error {
	switch name {
	case subscribepause.EdgeRider:
		m.ClearRider()
		return nil
	case subscribepause.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case subscribepause.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	case subscribepause.EdgeContinueEmployee:
		m.ClearContinueEmployee()
		return nil
	}
	return fmt.Errorf("unknown SubscribePause unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscribePauseMutation) ResetEdge(name string) error {
	switch name {
	case subscribepause.EdgeRider:
		m.ResetRider()
		return nil
	case subscribepause.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case subscribepause.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	case subscribepause.EdgeContinueEmployee:
		m.ResetContinueEmployee()
		return nil
	}
	return fmt.Errorf("unknown SubscribePause edge %s", name)
}
