// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/auroraride/adapter"
	"github.com/auroraride/aurservd/app/model"
	"github.com/auroraride/aurservd/app/model/promotion"
	"github.com/auroraride/aurservd/internal/ent/activity"
	"github.com/auroraride/aurservd/internal/ent/agent"
	"github.com/auroraride/aurservd/internal/ent/allocate"
	"github.com/auroraride/aurservd/internal/ent/assistance"
	"github.com/auroraride/aurservd/internal/ent/attendance"
	"github.com/auroraride/aurservd/internal/ent/battery"
	"github.com/auroraride/aurservd/internal/ent/batteryflow"
	"github.com/auroraride/aurservd/internal/ent/batterymodel"
	"github.com/auroraride/aurservd/internal/ent/branch"
	"github.com/auroraride/aurservd/internal/ent/branchcontract"
	"github.com/auroraride/aurservd/internal/ent/business"
	"github.com/auroraride/aurservd/internal/ent/cabinet"
	"github.com/auroraride/aurservd/internal/ent/cabinetfault"
	"github.com/auroraride/aurservd/internal/ent/city"
	"github.com/auroraride/aurservd/internal/ent/commission"
	"github.com/auroraride/aurservd/internal/ent/contract"
	"github.com/auroraride/aurservd/internal/ent/coupon"
	"github.com/auroraride/aurservd/internal/ent/couponassembly"
	"github.com/auroraride/aurservd/internal/ent/coupontemplate"
	"github.com/auroraride/aurservd/internal/ent/ebike"
	"github.com/auroraride/aurservd/internal/ent/ebikebrand"
	"github.com/auroraride/aurservd/internal/ent/employee"
	"github.com/auroraride/aurservd/internal/ent/enterprise"
	"github.com/auroraride/aurservd/internal/ent/enterprisebatteryswap"
	"github.com/auroraride/aurservd/internal/ent/enterprisebill"
	"github.com/auroraride/aurservd/internal/ent/enterprisecontract"
	"github.com/auroraride/aurservd/internal/ent/enterpriseprepayment"
	"github.com/auroraride/aurservd/internal/ent/enterpriseprice"
	"github.com/auroraride/aurservd/internal/ent/enterprisestatement"
	"github.com/auroraride/aurservd/internal/ent/enterprisestation"
	"github.com/auroraride/aurservd/internal/ent/exception"
	"github.com/auroraride/aurservd/internal/ent/exchange"
	"github.com/auroraride/aurservd/internal/ent/export"
	"github.com/auroraride/aurservd/internal/ent/feedback"
	"github.com/auroraride/aurservd/internal/ent/guide"
	"github.com/auroraride/aurservd/internal/ent/inventory"
	"github.com/auroraride/aurservd/internal/ent/maintainer"
	"github.com/auroraride/aurservd/internal/ent/manager"
	"github.com/auroraride/aurservd/internal/ent/order"
	"github.com/auroraride/aurservd/internal/ent/orderrefund"
	"github.com/auroraride/aurservd/internal/ent/person"
	"github.com/auroraride/aurservd/internal/ent/plan"
	"github.com/auroraride/aurservd/internal/ent/planintroduce"
	"github.com/auroraride/aurservd/internal/ent/pointlog"
	"github.com/auroraride/aurservd/internal/ent/predicate"
	"github.com/auroraride/aurservd/internal/ent/promotionachievement"
	"github.com/auroraride/aurservd/internal/ent/promotionbankcard"
	"github.com/auroraride/aurservd/internal/ent/promotioncommission"
	"github.com/auroraride/aurservd/internal/ent/promotioncommissionplan"
	"github.com/auroraride/aurservd/internal/ent/promotionearnings"
	"github.com/auroraride/aurservd/internal/ent/promotiongrowth"
	"github.com/auroraride/aurservd/internal/ent/promotionlevel"
	"github.com/auroraride/aurservd/internal/ent/promotionleveltask"
	"github.com/auroraride/aurservd/internal/ent/promotionmember"
	"github.com/auroraride/aurservd/internal/ent/promotionmembercommission"
	"github.com/auroraride/aurservd/internal/ent/promotionperson"
	"github.com/auroraride/aurservd/internal/ent/promotionprivilege"
	"github.com/auroraride/aurservd/internal/ent/promotionreferrals"
	"github.com/auroraride/aurservd/internal/ent/promotionreferralsprogress"
	"github.com/auroraride/aurservd/internal/ent/promotionsetting"
	"github.com/auroraride/aurservd/internal/ent/promotionwithdrawal"
	"github.com/auroraride/aurservd/internal/ent/pushmessage"
	"github.com/auroraride/aurservd/internal/ent/reserve"
	"github.com/auroraride/aurservd/internal/ent/rider"
	"github.com/auroraride/aurservd/internal/ent/riderfollowup"
	"github.com/auroraride/aurservd/internal/ent/role"
	"github.com/auroraride/aurservd/internal/ent/setting"
	"github.com/auroraride/aurservd/internal/ent/stock"
	"github.com/auroraride/aurservd/internal/ent/stocksummary"
	"github.com/auroraride/aurservd/internal/ent/store"
	"github.com/auroraride/aurservd/internal/ent/subscribe"
	"github.com/auroraride/aurservd/internal/ent/subscribealter"
	"github.com/auroraride/aurservd/internal/ent/subscribepause"
	"github.com/auroraride/aurservd/internal/ent/subscribereminder"
	"github.com/auroraride/aurservd/internal/ent/subscribesuspend"
	"github.com/auroraride/aurservd/internal/ent/version"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeActivity                   = "Activity"
	TypeAgent                      = "Agent"
	TypeAllocate                   = "Allocate"
	TypeAssistance                 = "Assistance"
	TypeAttendance                 = "Attendance"
	TypeBattery                    = "Battery"
	TypeBatteryFlow                = "BatteryFlow"
	TypeBatteryModel               = "BatteryModel"
	TypeBranch                     = "Branch"
	TypeBranchContract             = "BranchContract"
	TypeBusiness                   = "Business"
	TypeCabinet                    = "Cabinet"
	TypeCabinetFault               = "CabinetFault"
	TypeCity                       = "City"
	TypeCommission                 = "Commission"
	TypeContract                   = "Contract"
	TypeCoupon                     = "Coupon"
	TypeCouponAssembly             = "CouponAssembly"
	TypeCouponTemplate             = "CouponTemplate"
	TypeEbike                      = "Ebike"
	TypeEbikeBrand                 = "EbikeBrand"
	TypeEmployee                   = "Employee"
	TypeEnterprise                 = "Enterprise"
	TypeEnterpriseBatterySwap      = "EnterpriseBatterySwap"
	TypeEnterpriseBill             = "EnterpriseBill"
	TypeEnterpriseContract         = "EnterpriseContract"
	TypeEnterprisePrepayment       = "EnterprisePrepayment"
	TypeEnterprisePrice            = "EnterprisePrice"
	TypeEnterpriseStatement        = "EnterpriseStatement"
	TypeEnterpriseStation          = "EnterpriseStation"
	TypeException                  = "Exception"
	TypeExchange                   = "Exchange"
	TypeExport                     = "Export"
	TypeFeedback                   = "Feedback"
	TypeGuide                      = "Guide"
	TypeInventory                  = "Inventory"
	TypeMaintainer                 = "Maintainer"
	TypeManager                    = "Manager"
	TypeOrder                      = "Order"
	TypeOrderRefund                = "OrderRefund"
	TypePerson                     = "Person"
	TypePlan                       = "Plan"
	TypePlanIntroduce              = "PlanIntroduce"
	TypePointLog                   = "PointLog"
	TypePromotionAchievement       = "PromotionAchievement"
	TypePromotionBankCard          = "PromotionBankCard"
	TypePromotionCommission        = "PromotionCommission"
	TypePromotionCommissionPlan    = "PromotionCommissionPlan"
	TypePromotionEarnings          = "PromotionEarnings"
	TypePromotionGrowth            = "PromotionGrowth"
	TypePromotionLevel             = "PromotionLevel"
	TypePromotionLevelTask         = "PromotionLevelTask"
	TypePromotionMember            = "PromotionMember"
	TypePromotionMemberCommission  = "PromotionMemberCommission"
	TypePromotionPerson            = "PromotionPerson"
	TypePromotionPrivilege         = "PromotionPrivilege"
	TypePromotionReferrals         = "PromotionReferrals"
	TypePromotionReferralsProgress = "PromotionReferralsProgress"
	TypePromotionSetting           = "PromotionSetting"
	TypePromotionWithdrawal        = "PromotionWithdrawal"
	TypePushmessage                = "Pushmessage"
	TypeReserve                    = "Reserve"
	TypeRider                      = "Rider"
	TypeRiderFollowUp              = "RiderFollowUp"
	TypeRole                       = "Role"
	TypeSetting                    = "Setting"
	TypeStock                      = "Stock"
	TypeStockSummary               = "StockSummary"
	TypeStore                      = "Store"
	TypeSubscribe                  = "Subscribe"
	TypeSubscribeAlter             = "SubscribeAlter"
	TypeSubscribePause             = "SubscribePause"
	TypeSubscribeReminder          = "SubscribeReminder"
	TypeSubscribeSuspend           = "SubscribeSuspend"
	TypeVersion                    = "Version"
)

// ActivityMutation represents an operation that mutates the Activity nodes in the graph.
type ActivityMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	creator       **model.Modifier
	last_modifier **model.Modifier
	remark        *string
	name          *string
	image         *string
	link          *string
	sort          *int
	addsort       *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Activity, error)
	predicates    []predicate.Activity
}

var _ ent.Mutation = (*ActivityMutation)(nil)

// activityOption allows management of the mutation configuration using functional options.
type activityOption func(*ActivityMutation)

// newActivityMutation creates new mutation for the Activity entity.
func newActivityMutation(c config, op Op, opts ...activityOption) *ActivityMutation {
	m := &ActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withActivityID sets the ID field of the mutation.
func withActivityID(id uint64) activityOption {
	return func(m *ActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *Activity
		)
		m.oldValue = func(ctx context.Context) (*Activity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Activity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withActivity sets the old Activity of the mutation.
func withActivity(node *Activity) activityOption {
	return func(m *ActivityMutation) {
		m.oldValue = func(context.Context) (*Activity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ActivityMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ActivityMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Activity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ActivityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ActivityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ActivityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ActivityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ActivityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ActivityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ActivityMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ActivityMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ActivityMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[activity.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ActivityMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[activity.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ActivityMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, activity.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *ActivityMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *ActivityMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *ActivityMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[activity.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *ActivityMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[activity.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *ActivityMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, activity.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *ActivityMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *ActivityMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *ActivityMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[activity.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *ActivityMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[activity.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *ActivityMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, activity.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *ActivityMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ActivityMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ActivityMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[activity.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ActivityMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[activity.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ActivityMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, activity.FieldRemark)
}

// SetName sets the "name" field.
func (m *ActivityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ActivityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ActivityMutation) ResetName() {
	m.name = nil
}

// SetImage sets the "image" field.
func (m *ActivityMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *ActivityMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *ActivityMutation) ResetImage() {
	m.image = nil
}

// SetLink sets the "link" field.
func (m *ActivityMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *ActivityMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ResetLink resets all changes to the "link" field.
func (m *ActivityMutation) ResetLink() {
	m.link = nil
}

// SetSort sets the "sort" field.
func (m *ActivityMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *ActivityMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Activity entity.
// If the Activity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ActivityMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *ActivityMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *ActivityMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *ActivityMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// Where appends a list predicates to the ActivityMutation builder.
func (m *ActivityMutation) Where(ps ...predicate.Activity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ActivityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ActivityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Activity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ActivityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ActivityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Activity).
func (m *ActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ActivityMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, activity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, activity.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, activity.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, activity.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, activity.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, activity.FieldRemark)
	}
	if m.name != nil {
		fields = append(fields, activity.FieldName)
	}
	if m.image != nil {
		fields = append(fields, activity.FieldImage)
	}
	if m.link != nil {
		fields = append(fields, activity.FieldLink)
	}
	if m.sort != nil {
		fields = append(fields, activity.FieldSort)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case activity.FieldCreatedAt:
		return m.CreatedAt()
	case activity.FieldUpdatedAt:
		return m.UpdatedAt()
	case activity.FieldDeletedAt:
		return m.DeletedAt()
	case activity.FieldCreator:
		return m.Creator()
	case activity.FieldLastModifier:
		return m.LastModifier()
	case activity.FieldRemark:
		return m.Remark()
	case activity.FieldName:
		return m.Name()
	case activity.FieldImage:
		return m.Image()
	case activity.FieldLink:
		return m.Link()
	case activity.FieldSort:
		return m.Sort()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case activity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case activity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case activity.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case activity.FieldCreator:
		return m.OldCreator(ctx)
	case activity.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case activity.FieldRemark:
		return m.OldRemark(ctx)
	case activity.FieldName:
		return m.OldName(ctx)
	case activity.FieldImage:
		return m.OldImage(ctx)
	case activity.FieldLink:
		return m.OldLink(ctx)
	case activity.FieldSort:
		return m.OldSort(ctx)
	}
	return nil, fmt.Errorf("unknown Activity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case activity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case activity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case activity.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case activity.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case activity.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case activity.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case activity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case activity.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case activity.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case activity.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ActivityMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, activity.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ActivityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case activity.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case activity.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Activity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ActivityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(activity.FieldDeletedAt) {
		fields = append(fields, activity.FieldDeletedAt)
	}
	if m.FieldCleared(activity.FieldCreator) {
		fields = append(fields, activity.FieldCreator)
	}
	if m.FieldCleared(activity.FieldLastModifier) {
		fields = append(fields, activity.FieldLastModifier)
	}
	if m.FieldCleared(activity.FieldRemark) {
		fields = append(fields, activity.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ActivityMutation) ClearField(name string) error {
	switch name {
	case activity.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case activity.FieldCreator:
		m.ClearCreator()
		return nil
	case activity.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case activity.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Activity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ActivityMutation) ResetField(name string) error {
	switch name {
	case activity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case activity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case activity.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case activity.FieldCreator:
		m.ResetCreator()
		return nil
	case activity.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case activity.FieldRemark:
		m.ResetRemark()
		return nil
	case activity.FieldName:
		m.ResetName()
		return nil
	case activity.FieldImage:
		m.ResetImage()
		return nil
	case activity.FieldLink:
		m.ResetLink()
		return nil
	case activity.FieldSort:
		m.ResetSort()
		return nil
	}
	return fmt.Errorf("unknown Activity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ActivityMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ActivityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ActivityMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ActivityMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Activity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ActivityMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Activity edge %s", name)
}

// AgentMutation represents an operation that mutates the Agent nodes in the graph.
type AgentMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	name              *string
	phone             *string
	super             *bool
	clearedFields     map[string]struct{}
	enterprise        *uint64
	clearedenterprise bool
	stations          map[uint64]struct{}
	removedstations   map[uint64]struct{}
	clearedstations   bool
	done              bool
	oldValue          func(context.Context) (*Agent, error)
	predicates        []predicate.Agent
}

var _ ent.Mutation = (*AgentMutation)(nil)

// agentOption allows management of the mutation configuration using functional options.
type agentOption func(*AgentMutation)

// newAgentMutation creates new mutation for the Agent entity.
func newAgentMutation(c config, op Op, opts ...agentOption) *AgentMutation {
	m := &AgentMutation{
		config:        c,
		op:            op,
		typ:           TypeAgent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentID sets the ID field of the mutation.
func withAgentID(id uint64) agentOption {
	return func(m *AgentMutation) {
		var (
			err   error
			once  sync.Once
			value *Agent
		)
		m.oldValue = func(ctx context.Context) (*Agent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Agent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgent sets the old Agent of the mutation.
func withAgent(node *Agent) agentOption {
	return func(m *AgentMutation) {
		m.oldValue = func(context.Context) (*Agent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AgentMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AgentMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Agent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AgentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AgentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AgentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AgentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AgentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AgentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AgentMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AgentMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AgentMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[agent.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AgentMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[agent.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AgentMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, agent.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *AgentMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *AgentMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *AgentMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[agent.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *AgentMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[agent.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *AgentMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, agent.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *AgentMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *AgentMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *AgentMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[agent.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *AgentMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[agent.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *AgentMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, agent.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *AgentMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *AgentMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *AgentMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[agent.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *AgentMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[agent.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *AgentMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, agent.FieldRemark)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *AgentMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *AgentMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldEnterpriseID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *AgentMutation) ResetEnterpriseID() {
	m.enterprise = nil
}

// SetName sets the "name" field.
func (m *AgentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AgentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AgentMutation) ResetName() {
	m.name = nil
}

// SetPhone sets the "phone" field.
func (m *AgentMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *AgentMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *AgentMutation) ResetPhone() {
	m.phone = nil
}

// SetSuper sets the "super" field.
func (m *AgentMutation) SetSuper(b bool) {
	m.super = &b
}

// Super returns the value of the "super" field in the mutation.
func (m *AgentMutation) Super() (r bool, exists bool) {
	v := m.super
	if v == nil {
		return
	}
	return *v, true
}

// OldSuper returns the old "super" field's value of the Agent entity.
// If the Agent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentMutation) OldSuper(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuper: %w", err)
	}
	return oldValue.Super, nil
}

// ResetSuper resets all changes to the "super" field.
func (m *AgentMutation) ResetSuper() {
	m.super = nil
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *AgentMutation) ClearEnterprise() {
	m.clearedenterprise = true
	m.clearedFields[agent.FieldEnterpriseID] = struct{}{}
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *AgentMutation) EnterpriseCleared() bool {
	return m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *AgentMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *AgentMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// AddStationIDs adds the "stations" edge to the EnterpriseStation entity by ids.
func (m *AgentMutation) AddStationIDs(ids ...uint64) {
	if m.stations == nil {
		m.stations = make(map[uint64]struct{})
	}
	for i := range ids {
		m.stations[ids[i]] = struct{}{}
	}
}

// ClearStations clears the "stations" edge to the EnterpriseStation entity.
func (m *AgentMutation) ClearStations() {
	m.clearedstations = true
}

// StationsCleared reports if the "stations" edge to the EnterpriseStation entity was cleared.
func (m *AgentMutation) StationsCleared() bool {
	return m.clearedstations
}

// RemoveStationIDs removes the "stations" edge to the EnterpriseStation entity by IDs.
func (m *AgentMutation) RemoveStationIDs(ids ...uint64) {
	if m.removedstations == nil {
		m.removedstations = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.stations, ids[i])
		m.removedstations[ids[i]] = struct{}{}
	}
}

// RemovedStations returns the removed IDs of the "stations" edge to the EnterpriseStation entity.
func (m *AgentMutation) RemovedStationsIDs() (ids []uint64) {
	for id := range m.removedstations {
		ids = append(ids, id)
	}
	return
}

// StationsIDs returns the "stations" edge IDs in the mutation.
func (m *AgentMutation) StationsIDs() (ids []uint64) {
	for id := range m.stations {
		ids = append(ids, id)
	}
	return
}

// ResetStations resets all changes to the "stations" edge.
func (m *AgentMutation) ResetStations() {
	m.stations = nil
	m.clearedstations = false
	m.removedstations = nil
}

// Where appends a list predicates to the AgentMutation builder.
func (m *AgentMutation) Where(ps ...predicate.Agent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AgentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AgentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Agent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AgentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AgentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Agent).
func (m *AgentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, agent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, agent.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, agent.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, agent.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, agent.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, agent.FieldRemark)
	}
	if m.enterprise != nil {
		fields = append(fields, agent.FieldEnterpriseID)
	}
	if m.name != nil {
		fields = append(fields, agent.FieldName)
	}
	if m.phone != nil {
		fields = append(fields, agent.FieldPhone)
	}
	if m.super != nil {
		fields = append(fields, agent.FieldSuper)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agent.FieldCreatedAt:
		return m.CreatedAt()
	case agent.FieldUpdatedAt:
		return m.UpdatedAt()
	case agent.FieldDeletedAt:
		return m.DeletedAt()
	case agent.FieldCreator:
		return m.Creator()
	case agent.FieldLastModifier:
		return m.LastModifier()
	case agent.FieldRemark:
		return m.Remark()
	case agent.FieldEnterpriseID:
		return m.EnterpriseID()
	case agent.FieldName:
		return m.Name()
	case agent.FieldPhone:
		return m.Phone()
	case agent.FieldSuper:
		return m.Super()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case agent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case agent.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case agent.FieldCreator:
		return m.OldCreator(ctx)
	case agent.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case agent.FieldRemark:
		return m.OldRemark(ctx)
	case agent.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case agent.FieldName:
		return m.OldName(ctx)
	case agent.FieldPhone:
		return m.OldPhone(ctx)
	case agent.FieldSuper:
		return m.OldSuper(ctx)
	}
	return nil, fmt.Errorf("unknown Agent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case agent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case agent.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case agent.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case agent.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case agent.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case agent.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case agent.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case agent.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case agent.FieldSuper:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuper(v)
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Agent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(agent.FieldDeletedAt) {
		fields = append(fields, agent.FieldDeletedAt)
	}
	if m.FieldCleared(agent.FieldCreator) {
		fields = append(fields, agent.FieldCreator)
	}
	if m.FieldCleared(agent.FieldLastModifier) {
		fields = append(fields, agent.FieldLastModifier)
	}
	if m.FieldCleared(agent.FieldRemark) {
		fields = append(fields, agent.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentMutation) ClearField(name string) error {
	switch name {
	case agent.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case agent.FieldCreator:
		m.ClearCreator()
		return nil
	case agent.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case agent.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Agent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentMutation) ResetField(name string) error {
	switch name {
	case agent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case agent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case agent.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case agent.FieldCreator:
		m.ResetCreator()
		return nil
	case agent.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case agent.FieldRemark:
		m.ResetRemark()
		return nil
	case agent.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case agent.FieldName:
		m.ResetName()
		return nil
	case agent.FieldPhone:
		m.ResetPhone()
		return nil
	case agent.FieldSuper:
		m.ResetSuper()
		return nil
	}
	return fmt.Errorf("unknown Agent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.enterprise != nil {
		edges = append(edges, agent.EdgeEnterprise)
	}
	if m.stations != nil {
		edges = append(edges, agent.EdgeStations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case agent.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	case agent.EdgeStations:
		ids := make([]ent.Value, 0, len(m.stations))
		for id := range m.stations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedstations != nil {
		edges = append(edges, agent.EdgeStations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case agent.EdgeStations:
		ids := make([]ent.Value, 0, len(m.removedstations))
		for id := range m.removedstations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedenterprise {
		edges = append(edges, agent.EdgeEnterprise)
	}
	if m.clearedstations {
		edges = append(edges, agent.EdgeStations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentMutation) EdgeCleared(name string) bool {
	switch name {
	case agent.EdgeEnterprise:
		return m.clearedenterprise
	case agent.EdgeStations:
		return m.clearedstations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentMutation) ClearEdge(name string) error {
	switch name {
	case agent.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	}
	return fmt.Errorf("unknown Agent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentMutation) ResetEdge(name string) error {
	switch name {
	case agent.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	case agent.EdgeStations:
		m.ResetStations()
		return nil
	}
	return fmt.Errorf("unknown Agent edge %s", name)
}

// AllocateMutation represents an operation that mutates the Allocate nodes in the graph.
type AllocateMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	created_at       *time.Time
	updated_at       *time.Time
	creator          **model.Modifier
	last_modifier    **model.Modifier
	remark           *string
	_type            *allocate.Type
	status           *uint8
	addstatus        *int8
	time             *time.Time
	model            *string
	clearedFields    map[string]struct{}
	rider            *uint64
	clearedrider     bool
	subscribe        *uint64
	clearedsubscribe bool
	employee         *uint64
	clearedemployee  bool
	cabinet          *uint64
	clearedcabinet   bool
	store            *uint64
	clearedstore     bool
	brand            *uint64
	clearedbrand     bool
	battery          *uint64
	clearedbattery   bool
	station          *uint64
	clearedstation   bool
	agent            *uint64
	clearedagent     bool
	contract         *uint64
	clearedcontract  bool
	ebike            *uint64
	clearedebike     bool
	done             bool
	oldValue         func(context.Context) (*Allocate, error)
	predicates       []predicate.Allocate
}

var _ ent.Mutation = (*AllocateMutation)(nil)

// allocateOption allows management of the mutation configuration using functional options.
type allocateOption func(*AllocateMutation)

// newAllocateMutation creates new mutation for the Allocate entity.
func newAllocateMutation(c config, op Op, opts ...allocateOption) *AllocateMutation {
	m := &AllocateMutation{
		config:        c,
		op:            op,
		typ:           TypeAllocate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAllocateID sets the ID field of the mutation.
func withAllocateID(id uint64) allocateOption {
	return func(m *AllocateMutation) {
		var (
			err   error
			once  sync.Once
			value *Allocate
		)
		m.oldValue = func(ctx context.Context) (*Allocate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Allocate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAllocate sets the old Allocate of the mutation.
func withAllocate(node *Allocate) allocateOption {
	return func(m *AllocateMutation) {
		m.oldValue = func(context.Context) (*Allocate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AllocateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AllocateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AllocateMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AllocateMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Allocate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AllocateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AllocateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Allocate entity.
// If the Allocate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocateMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AllocateMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[allocate.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AllocateMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[allocate.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AllocateMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, allocate.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AllocateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AllocateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Allocate entity.
// If the Allocate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocateMutation) OldUpdatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AllocateMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[allocate.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AllocateMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[allocate.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AllocateMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, allocate.FieldUpdatedAt)
}

// SetRiderID sets the "rider_id" field.
func (m *AllocateMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *AllocateMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the Allocate entity.
// If the Allocate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocateMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *AllocateMutation) ResetRiderID() {
	m.rider = nil
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *AllocateMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *AllocateMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the Allocate entity.
// If the Allocate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocateMutation) OldSubscribeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *AllocateMutation) ResetSubscribeID() {
	m.subscribe = nil
}

// SetCreator sets the "creator" field.
func (m *AllocateMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *AllocateMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Allocate entity.
// If the Allocate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocateMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *AllocateMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[allocate.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *AllocateMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[allocate.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *AllocateMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, allocate.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *AllocateMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *AllocateMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Allocate entity.
// If the Allocate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocateMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *AllocateMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[allocate.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *AllocateMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[allocate.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *AllocateMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, allocate.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *AllocateMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *AllocateMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Allocate entity.
// If the Allocate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocateMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *AllocateMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[allocate.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *AllocateMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[allocate.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *AllocateMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, allocate.FieldRemark)
}

// SetEmployeeID sets the "employee_id" field.
func (m *AllocateMutation) SetEmployeeID(u uint64) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *AllocateMutation) EmployeeID() (r uint64, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Allocate entity.
// If the Allocate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocateMutation) OldEmployeeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *AllocateMutation) ClearEmployeeID() {
	m.employee = nil
	m.clearedFields[allocate.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *AllocateMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[allocate.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *AllocateMutation) ResetEmployeeID() {
	m.employee = nil
	delete(m.clearedFields, allocate.FieldEmployeeID)
}

// SetCabinetID sets the "cabinet_id" field.
func (m *AllocateMutation) SetCabinetID(u uint64) {
	m.cabinet = &u
}

// CabinetID returns the value of the "cabinet_id" field in the mutation.
func (m *AllocateMutation) CabinetID() (r uint64, exists bool) {
	v := m.cabinet
	if v == nil {
		return
	}
	return *v, true
}

// OldCabinetID returns the old "cabinet_id" field's value of the Allocate entity.
// If the Allocate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocateMutation) OldCabinetID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCabinetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCabinetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCabinetID: %w", err)
	}
	return oldValue.CabinetID, nil
}

// ClearCabinetID clears the value of the "cabinet_id" field.
func (m *AllocateMutation) ClearCabinetID() {
	m.cabinet = nil
	m.clearedFields[allocate.FieldCabinetID] = struct{}{}
}

// CabinetIDCleared returns if the "cabinet_id" field was cleared in this mutation.
func (m *AllocateMutation) CabinetIDCleared() bool {
	_, ok := m.clearedFields[allocate.FieldCabinetID]
	return ok
}

// ResetCabinetID resets all changes to the "cabinet_id" field.
func (m *AllocateMutation) ResetCabinetID() {
	m.cabinet = nil
	delete(m.clearedFields, allocate.FieldCabinetID)
}

// SetStoreID sets the "store_id" field.
func (m *AllocateMutation) SetStoreID(u uint64) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *AllocateMutation) StoreID() (r uint64, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Allocate entity.
// If the Allocate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocateMutation) OldStoreID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *AllocateMutation) ClearStoreID() {
	m.store = nil
	m.clearedFields[allocate.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *AllocateMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[allocate.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *AllocateMutation) ResetStoreID() {
	m.store = nil
	delete(m.clearedFields, allocate.FieldStoreID)
}

// SetBrandID sets the "brand_id" field.
func (m *AllocateMutation) SetBrandID(u uint64) {
	m.brand = &u
}

// BrandID returns the value of the "brand_id" field in the mutation.
func (m *AllocateMutation) BrandID() (r uint64, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrandID returns the old "brand_id" field's value of the Allocate entity.
// If the Allocate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocateMutation) OldBrandID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrandID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrandID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrandID: %w", err)
	}
	return oldValue.BrandID, nil
}

// ClearBrandID clears the value of the "brand_id" field.
func (m *AllocateMutation) ClearBrandID() {
	m.brand = nil
	m.clearedFields[allocate.FieldBrandID] = struct{}{}
}

// BrandIDCleared returns if the "brand_id" field was cleared in this mutation.
func (m *AllocateMutation) BrandIDCleared() bool {
	_, ok := m.clearedFields[allocate.FieldBrandID]
	return ok
}

// ResetBrandID resets all changes to the "brand_id" field.
func (m *AllocateMutation) ResetBrandID() {
	m.brand = nil
	delete(m.clearedFields, allocate.FieldBrandID)
}

// SetBatteryID sets the "battery_id" field.
func (m *AllocateMutation) SetBatteryID(u uint64) {
	m.battery = &u
}

// BatteryID returns the value of the "battery_id" field in the mutation.
func (m *AllocateMutation) BatteryID() (r uint64, exists bool) {
	v := m.battery
	if v == nil {
		return
	}
	return *v, true
}

// OldBatteryID returns the old "battery_id" field's value of the Allocate entity.
// If the Allocate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocateMutation) OldBatteryID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatteryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatteryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatteryID: %w", err)
	}
	return oldValue.BatteryID, nil
}

// ClearBatteryID clears the value of the "battery_id" field.
func (m *AllocateMutation) ClearBatteryID() {
	m.battery = nil
	m.clearedFields[allocate.FieldBatteryID] = struct{}{}
}

// BatteryIDCleared returns if the "battery_id" field was cleared in this mutation.
func (m *AllocateMutation) BatteryIDCleared() bool {
	_, ok := m.clearedFields[allocate.FieldBatteryID]
	return ok
}

// ResetBatteryID resets all changes to the "battery_id" field.
func (m *AllocateMutation) ResetBatteryID() {
	m.battery = nil
	delete(m.clearedFields, allocate.FieldBatteryID)
}

// SetStationID sets the "station_id" field.
func (m *AllocateMutation) SetStationID(u uint64) {
	m.station = &u
}

// StationID returns the value of the "station_id" field in the mutation.
func (m *AllocateMutation) StationID() (r uint64, exists bool) {
	v := m.station
	if v == nil {
		return
	}
	return *v, true
}

// OldStationID returns the old "station_id" field's value of the Allocate entity.
// If the Allocate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocateMutation) OldStationID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStationID: %w", err)
	}
	return oldValue.StationID, nil
}

// ClearStationID clears the value of the "station_id" field.
func (m *AllocateMutation) ClearStationID() {
	m.station = nil
	m.clearedFields[allocate.FieldStationID] = struct{}{}
}

// StationIDCleared returns if the "station_id" field was cleared in this mutation.
func (m *AllocateMutation) StationIDCleared() bool {
	_, ok := m.clearedFields[allocate.FieldStationID]
	return ok
}

// ResetStationID resets all changes to the "station_id" field.
func (m *AllocateMutation) ResetStationID() {
	m.station = nil
	delete(m.clearedFields, allocate.FieldStationID)
}

// SetAgentID sets the "agent_id" field.
func (m *AllocateMutation) SetAgentID(u uint64) {
	m.agent = &u
}

// AgentID returns the value of the "agent_id" field in the mutation.
func (m *AllocateMutation) AgentID() (r uint64, exists bool) {
	v := m.agent
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentID returns the old "agent_id" field's value of the Allocate entity.
// If the Allocate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocateMutation) OldAgentID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentID: %w", err)
	}
	return oldValue.AgentID, nil
}

// ClearAgentID clears the value of the "agent_id" field.
func (m *AllocateMutation) ClearAgentID() {
	m.agent = nil
	m.clearedFields[allocate.FieldAgentID] = struct{}{}
}

// AgentIDCleared returns if the "agent_id" field was cleared in this mutation.
func (m *AllocateMutation) AgentIDCleared() bool {
	_, ok := m.clearedFields[allocate.FieldAgentID]
	return ok
}

// ResetAgentID resets all changes to the "agent_id" field.
func (m *AllocateMutation) ResetAgentID() {
	m.agent = nil
	delete(m.clearedFields, allocate.FieldAgentID)
}

// SetType sets the "type" field.
func (m *AllocateMutation) SetType(a allocate.Type) {
	m._type = &a
}

// GetType returns the value of the "type" field in the mutation.
func (m *AllocateMutation) GetType() (r allocate.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Allocate entity.
// If the Allocate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocateMutation) OldType(ctx context.Context) (v allocate.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AllocateMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *AllocateMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AllocateMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Allocate entity.
// If the Allocate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocateMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *AllocateMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AllocateMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *AllocateMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetTime sets the "time" field.
func (m *AllocateMutation) SetTime(t time.Time) {
	m.time = &t
}

// Time returns the value of the "time" field in the mutation.
func (m *AllocateMutation) Time() (r time.Time, exists bool) {
	v := m.time
	if v == nil {
		return
	}
	return *v, true
}

// OldTime returns the old "time" field's value of the Allocate entity.
// If the Allocate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocateMutation) OldTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTime: %w", err)
	}
	return oldValue.Time, nil
}

// ResetTime resets all changes to the "time" field.
func (m *AllocateMutation) ResetTime() {
	m.time = nil
}

// SetModel sets the "model" field.
func (m *AllocateMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *AllocateMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Allocate entity.
// If the Allocate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocateMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *AllocateMutation) ResetModel() {
	m.model = nil
}

// SetEbikeID sets the "ebike_id" field.
func (m *AllocateMutation) SetEbikeID(u uint64) {
	m.ebike = &u
}

// EbikeID returns the value of the "ebike_id" field in the mutation.
func (m *AllocateMutation) EbikeID() (r uint64, exists bool) {
	v := m.ebike
	if v == nil {
		return
	}
	return *v, true
}

// OldEbikeID returns the old "ebike_id" field's value of the Allocate entity.
// If the Allocate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AllocateMutation) OldEbikeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEbikeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEbikeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEbikeID: %w", err)
	}
	return oldValue.EbikeID, nil
}

// ClearEbikeID clears the value of the "ebike_id" field.
func (m *AllocateMutation) ClearEbikeID() {
	m.ebike = nil
	m.clearedFields[allocate.FieldEbikeID] = struct{}{}
}

// EbikeIDCleared returns if the "ebike_id" field was cleared in this mutation.
func (m *AllocateMutation) EbikeIDCleared() bool {
	_, ok := m.clearedFields[allocate.FieldEbikeID]
	return ok
}

// ResetEbikeID resets all changes to the "ebike_id" field.
func (m *AllocateMutation) ResetEbikeID() {
	m.ebike = nil
	delete(m.clearedFields, allocate.FieldEbikeID)
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *AllocateMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[allocate.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *AllocateMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *AllocateMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *AllocateMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *AllocateMutation) ClearSubscribe() {
	m.clearedsubscribe = true
	m.clearedFields[allocate.FieldSubscribeID] = struct{}{}
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *AllocateMutation) SubscribeCleared() bool {
	return m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *AllocateMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *AllocateMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *AllocateMutation) ClearEmployee() {
	m.clearedemployee = true
	m.clearedFields[allocate.FieldEmployeeID] = struct{}{}
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *AllocateMutation) EmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *AllocateMutation) EmployeeIDs() (ids []uint64) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *AllocateMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// ClearCabinet clears the "cabinet" edge to the Cabinet entity.
func (m *AllocateMutation) ClearCabinet() {
	m.clearedcabinet = true
	m.clearedFields[allocate.FieldCabinetID] = struct{}{}
}

// CabinetCleared reports if the "cabinet" edge to the Cabinet entity was cleared.
func (m *AllocateMutation) CabinetCleared() bool {
	return m.CabinetIDCleared() || m.clearedcabinet
}

// CabinetIDs returns the "cabinet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CabinetID instead. It exists only for internal usage by the builders.
func (m *AllocateMutation) CabinetIDs() (ids []uint64) {
	if id := m.cabinet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCabinet resets all changes to the "cabinet" edge.
func (m *AllocateMutation) ResetCabinet() {
	m.cabinet = nil
	m.clearedcabinet = false
}

// ClearStore clears the "store" edge to the Store entity.
func (m *AllocateMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[allocate.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *AllocateMutation) StoreCleared() bool {
	return m.StoreIDCleared() || m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *AllocateMutation) StoreIDs() (ids []uint64) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *AllocateMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// ClearBrand clears the "brand" edge to the EbikeBrand entity.
func (m *AllocateMutation) ClearBrand() {
	m.clearedbrand = true
	m.clearedFields[allocate.FieldBrandID] = struct{}{}
}

// BrandCleared reports if the "brand" edge to the EbikeBrand entity was cleared.
func (m *AllocateMutation) BrandCleared() bool {
	return m.BrandIDCleared() || m.clearedbrand
}

// BrandIDs returns the "brand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BrandID instead. It exists only for internal usage by the builders.
func (m *AllocateMutation) BrandIDs() (ids []uint64) {
	if id := m.brand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBrand resets all changes to the "brand" edge.
func (m *AllocateMutation) ResetBrand() {
	m.brand = nil
	m.clearedbrand = false
}

// ClearBattery clears the "battery" edge to the Battery entity.
func (m *AllocateMutation) ClearBattery() {
	m.clearedbattery = true
	m.clearedFields[allocate.FieldBatteryID] = struct{}{}
}

// BatteryCleared reports if the "battery" edge to the Battery entity was cleared.
func (m *AllocateMutation) BatteryCleared() bool {
	return m.BatteryIDCleared() || m.clearedbattery
}

// BatteryIDs returns the "battery" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BatteryID instead. It exists only for internal usage by the builders.
func (m *AllocateMutation) BatteryIDs() (ids []uint64) {
	if id := m.battery; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBattery resets all changes to the "battery" edge.
func (m *AllocateMutation) ResetBattery() {
	m.battery = nil
	m.clearedbattery = false
}

// ClearStation clears the "station" edge to the EnterpriseStation entity.
func (m *AllocateMutation) ClearStation() {
	m.clearedstation = true
	m.clearedFields[allocate.FieldStationID] = struct{}{}
}

// StationCleared reports if the "station" edge to the EnterpriseStation entity was cleared.
func (m *AllocateMutation) StationCleared() bool {
	return m.StationIDCleared() || m.clearedstation
}

// StationIDs returns the "station" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StationID instead. It exists only for internal usage by the builders.
func (m *AllocateMutation) StationIDs() (ids []uint64) {
	if id := m.station; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStation resets all changes to the "station" edge.
func (m *AllocateMutation) ResetStation() {
	m.station = nil
	m.clearedstation = false
}

// ClearAgent clears the "agent" edge to the Agent entity.
func (m *AllocateMutation) ClearAgent() {
	m.clearedagent = true
	m.clearedFields[allocate.FieldAgentID] = struct{}{}
}

// AgentCleared reports if the "agent" edge to the Agent entity was cleared.
func (m *AllocateMutation) AgentCleared() bool {
	return m.AgentIDCleared() || m.clearedagent
}

// AgentIDs returns the "agent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentID instead. It exists only for internal usage by the builders.
func (m *AllocateMutation) AgentIDs() (ids []uint64) {
	if id := m.agent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgent resets all changes to the "agent" edge.
func (m *AllocateMutation) ResetAgent() {
	m.agent = nil
	m.clearedagent = false
}

// SetContractID sets the "contract" edge to the Contract entity by id.
func (m *AllocateMutation) SetContractID(id uint64) {
	m.contract = &id
}

// ClearContract clears the "contract" edge to the Contract entity.
func (m *AllocateMutation) ClearContract() {
	m.clearedcontract = true
}

// ContractCleared reports if the "contract" edge to the Contract entity was cleared.
func (m *AllocateMutation) ContractCleared() bool {
	return m.clearedcontract
}

// ContractID returns the "contract" edge ID in the mutation.
func (m *AllocateMutation) ContractID() (id uint64, exists bool) {
	if m.contract != nil {
		return *m.contract, true
	}
	return
}

// ContractIDs returns the "contract" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ContractID instead. It exists only for internal usage by the builders.
func (m *AllocateMutation) ContractIDs() (ids []uint64) {
	if id := m.contract; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetContract resets all changes to the "contract" edge.
func (m *AllocateMutation) ResetContract() {
	m.contract = nil
	m.clearedcontract = false
}

// ClearEbike clears the "ebike" edge to the Ebike entity.
func (m *AllocateMutation) ClearEbike() {
	m.clearedebike = true
	m.clearedFields[allocate.FieldEbikeID] = struct{}{}
}

// EbikeCleared reports if the "ebike" edge to the Ebike entity was cleared.
func (m *AllocateMutation) EbikeCleared() bool {
	return m.EbikeIDCleared() || m.clearedebike
}

// EbikeIDs returns the "ebike" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EbikeID instead. It exists only for internal usage by the builders.
func (m *AllocateMutation) EbikeIDs() (ids []uint64) {
	if id := m.ebike; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEbike resets all changes to the "ebike" edge.
func (m *AllocateMutation) ResetEbike() {
	m.ebike = nil
	m.clearedebike = false
}

// Where appends a list predicates to the AllocateMutation builder.
func (m *AllocateMutation) Where(ps ...predicate.Allocate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AllocateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AllocateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Allocate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AllocateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AllocateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Allocate).
func (m *AllocateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AllocateMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, allocate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, allocate.FieldUpdatedAt)
	}
	if m.rider != nil {
		fields = append(fields, allocate.FieldRiderID)
	}
	if m.subscribe != nil {
		fields = append(fields, allocate.FieldSubscribeID)
	}
	if m.creator != nil {
		fields = append(fields, allocate.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, allocate.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, allocate.FieldRemark)
	}
	if m.employee != nil {
		fields = append(fields, allocate.FieldEmployeeID)
	}
	if m.cabinet != nil {
		fields = append(fields, allocate.FieldCabinetID)
	}
	if m.store != nil {
		fields = append(fields, allocate.FieldStoreID)
	}
	if m.brand != nil {
		fields = append(fields, allocate.FieldBrandID)
	}
	if m.battery != nil {
		fields = append(fields, allocate.FieldBatteryID)
	}
	if m.station != nil {
		fields = append(fields, allocate.FieldStationID)
	}
	if m.agent != nil {
		fields = append(fields, allocate.FieldAgentID)
	}
	if m._type != nil {
		fields = append(fields, allocate.FieldType)
	}
	if m.status != nil {
		fields = append(fields, allocate.FieldStatus)
	}
	if m.time != nil {
		fields = append(fields, allocate.FieldTime)
	}
	if m.model != nil {
		fields = append(fields, allocate.FieldModel)
	}
	if m.ebike != nil {
		fields = append(fields, allocate.FieldEbikeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AllocateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case allocate.FieldCreatedAt:
		return m.CreatedAt()
	case allocate.FieldUpdatedAt:
		return m.UpdatedAt()
	case allocate.FieldRiderID:
		return m.RiderID()
	case allocate.FieldSubscribeID:
		return m.SubscribeID()
	case allocate.FieldCreator:
		return m.Creator()
	case allocate.FieldLastModifier:
		return m.LastModifier()
	case allocate.FieldRemark:
		return m.Remark()
	case allocate.FieldEmployeeID:
		return m.EmployeeID()
	case allocate.FieldCabinetID:
		return m.CabinetID()
	case allocate.FieldStoreID:
		return m.StoreID()
	case allocate.FieldBrandID:
		return m.BrandID()
	case allocate.FieldBatteryID:
		return m.BatteryID()
	case allocate.FieldStationID:
		return m.StationID()
	case allocate.FieldAgentID:
		return m.AgentID()
	case allocate.FieldType:
		return m.GetType()
	case allocate.FieldStatus:
		return m.Status()
	case allocate.FieldTime:
		return m.Time()
	case allocate.FieldModel:
		return m.Model()
	case allocate.FieldEbikeID:
		return m.EbikeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AllocateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case allocate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case allocate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case allocate.FieldRiderID:
		return m.OldRiderID(ctx)
	case allocate.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case allocate.FieldCreator:
		return m.OldCreator(ctx)
	case allocate.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case allocate.FieldRemark:
		return m.OldRemark(ctx)
	case allocate.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case allocate.FieldCabinetID:
		return m.OldCabinetID(ctx)
	case allocate.FieldStoreID:
		return m.OldStoreID(ctx)
	case allocate.FieldBrandID:
		return m.OldBrandID(ctx)
	case allocate.FieldBatteryID:
		return m.OldBatteryID(ctx)
	case allocate.FieldStationID:
		return m.OldStationID(ctx)
	case allocate.FieldAgentID:
		return m.OldAgentID(ctx)
	case allocate.FieldType:
		return m.OldType(ctx)
	case allocate.FieldStatus:
		return m.OldStatus(ctx)
	case allocate.FieldTime:
		return m.OldTime(ctx)
	case allocate.FieldModel:
		return m.OldModel(ctx)
	case allocate.FieldEbikeID:
		return m.OldEbikeID(ctx)
	}
	return nil, fmt.Errorf("unknown Allocate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AllocateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case allocate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case allocate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case allocate.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case allocate.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case allocate.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case allocate.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case allocate.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case allocate.FieldEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case allocate.FieldCabinetID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCabinetID(v)
		return nil
	case allocate.FieldStoreID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case allocate.FieldBrandID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrandID(v)
		return nil
	case allocate.FieldBatteryID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatteryID(v)
		return nil
	case allocate.FieldStationID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStationID(v)
		return nil
	case allocate.FieldAgentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentID(v)
		return nil
	case allocate.FieldType:
		v, ok := value.(allocate.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case allocate.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case allocate.FieldTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTime(v)
		return nil
	case allocate.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case allocate.FieldEbikeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEbikeID(v)
		return nil
	}
	return fmt.Errorf("unknown Allocate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AllocateMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, allocate.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AllocateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case allocate.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AllocateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case allocate.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Allocate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AllocateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(allocate.FieldCreatedAt) {
		fields = append(fields, allocate.FieldCreatedAt)
	}
	if m.FieldCleared(allocate.FieldUpdatedAt) {
		fields = append(fields, allocate.FieldUpdatedAt)
	}
	if m.FieldCleared(allocate.FieldCreator) {
		fields = append(fields, allocate.FieldCreator)
	}
	if m.FieldCleared(allocate.FieldLastModifier) {
		fields = append(fields, allocate.FieldLastModifier)
	}
	if m.FieldCleared(allocate.FieldRemark) {
		fields = append(fields, allocate.FieldRemark)
	}
	if m.FieldCleared(allocate.FieldEmployeeID) {
		fields = append(fields, allocate.FieldEmployeeID)
	}
	if m.FieldCleared(allocate.FieldCabinetID) {
		fields = append(fields, allocate.FieldCabinetID)
	}
	if m.FieldCleared(allocate.FieldStoreID) {
		fields = append(fields, allocate.FieldStoreID)
	}
	if m.FieldCleared(allocate.FieldBrandID) {
		fields = append(fields, allocate.FieldBrandID)
	}
	if m.FieldCleared(allocate.FieldBatteryID) {
		fields = append(fields, allocate.FieldBatteryID)
	}
	if m.FieldCleared(allocate.FieldStationID) {
		fields = append(fields, allocate.FieldStationID)
	}
	if m.FieldCleared(allocate.FieldAgentID) {
		fields = append(fields, allocate.FieldAgentID)
	}
	if m.FieldCleared(allocate.FieldEbikeID) {
		fields = append(fields, allocate.FieldEbikeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AllocateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AllocateMutation) ClearField(name string) error {
	switch name {
	case allocate.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case allocate.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case allocate.FieldCreator:
		m.ClearCreator()
		return nil
	case allocate.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case allocate.FieldRemark:
		m.ClearRemark()
		return nil
	case allocate.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case allocate.FieldCabinetID:
		m.ClearCabinetID()
		return nil
	case allocate.FieldStoreID:
		m.ClearStoreID()
		return nil
	case allocate.FieldBrandID:
		m.ClearBrandID()
		return nil
	case allocate.FieldBatteryID:
		m.ClearBatteryID()
		return nil
	case allocate.FieldStationID:
		m.ClearStationID()
		return nil
	case allocate.FieldAgentID:
		m.ClearAgentID()
		return nil
	case allocate.FieldEbikeID:
		m.ClearEbikeID()
		return nil
	}
	return fmt.Errorf("unknown Allocate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AllocateMutation) ResetField(name string) error {
	switch name {
	case allocate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case allocate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case allocate.FieldRiderID:
		m.ResetRiderID()
		return nil
	case allocate.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case allocate.FieldCreator:
		m.ResetCreator()
		return nil
	case allocate.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case allocate.FieldRemark:
		m.ResetRemark()
		return nil
	case allocate.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case allocate.FieldCabinetID:
		m.ResetCabinetID()
		return nil
	case allocate.FieldStoreID:
		m.ResetStoreID()
		return nil
	case allocate.FieldBrandID:
		m.ResetBrandID()
		return nil
	case allocate.FieldBatteryID:
		m.ResetBatteryID()
		return nil
	case allocate.FieldStationID:
		m.ResetStationID()
		return nil
	case allocate.FieldAgentID:
		m.ResetAgentID()
		return nil
	case allocate.FieldType:
		m.ResetType()
		return nil
	case allocate.FieldStatus:
		m.ResetStatus()
		return nil
	case allocate.FieldTime:
		m.ResetTime()
		return nil
	case allocate.FieldModel:
		m.ResetModel()
		return nil
	case allocate.FieldEbikeID:
		m.ResetEbikeID()
		return nil
	}
	return fmt.Errorf("unknown Allocate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AllocateMutation) AddedEdges() []string {
	edges := make([]string, 0, 11)
	if m.rider != nil {
		edges = append(edges, allocate.EdgeRider)
	}
	if m.subscribe != nil {
		edges = append(edges, allocate.EdgeSubscribe)
	}
	if m.employee != nil {
		edges = append(edges, allocate.EdgeEmployee)
	}
	if m.cabinet != nil {
		edges = append(edges, allocate.EdgeCabinet)
	}
	if m.store != nil {
		edges = append(edges, allocate.EdgeStore)
	}
	if m.brand != nil {
		edges = append(edges, allocate.EdgeBrand)
	}
	if m.battery != nil {
		edges = append(edges, allocate.EdgeBattery)
	}
	if m.station != nil {
		edges = append(edges, allocate.EdgeStation)
	}
	if m.agent != nil {
		edges = append(edges, allocate.EdgeAgent)
	}
	if m.contract != nil {
		edges = append(edges, allocate.EdgeContract)
	}
	if m.ebike != nil {
		edges = append(edges, allocate.EdgeEbike)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AllocateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case allocate.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case allocate.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	case allocate.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case allocate.EdgeCabinet:
		if id := m.cabinet; id != nil {
			return []ent.Value{*id}
		}
	case allocate.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	case allocate.EdgeBrand:
		if id := m.brand; id != nil {
			return []ent.Value{*id}
		}
	case allocate.EdgeBattery:
		if id := m.battery; id != nil {
			return []ent.Value{*id}
		}
	case allocate.EdgeStation:
		if id := m.station; id != nil {
			return []ent.Value{*id}
		}
	case allocate.EdgeAgent:
		if id := m.agent; id != nil {
			return []ent.Value{*id}
		}
	case allocate.EdgeContract:
		if id := m.contract; id != nil {
			return []ent.Value{*id}
		}
	case allocate.EdgeEbike:
		if id := m.ebike; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AllocateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 11)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AllocateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AllocateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 11)
	if m.clearedrider {
		edges = append(edges, allocate.EdgeRider)
	}
	if m.clearedsubscribe {
		edges = append(edges, allocate.EdgeSubscribe)
	}
	if m.clearedemployee {
		edges = append(edges, allocate.EdgeEmployee)
	}
	if m.clearedcabinet {
		edges = append(edges, allocate.EdgeCabinet)
	}
	if m.clearedstore {
		edges = append(edges, allocate.EdgeStore)
	}
	if m.clearedbrand {
		edges = append(edges, allocate.EdgeBrand)
	}
	if m.clearedbattery {
		edges = append(edges, allocate.EdgeBattery)
	}
	if m.clearedstation {
		edges = append(edges, allocate.EdgeStation)
	}
	if m.clearedagent {
		edges = append(edges, allocate.EdgeAgent)
	}
	if m.clearedcontract {
		edges = append(edges, allocate.EdgeContract)
	}
	if m.clearedebike {
		edges = append(edges, allocate.EdgeEbike)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AllocateMutation) EdgeCleared(name string) bool {
	switch name {
	case allocate.EdgeRider:
		return m.clearedrider
	case allocate.EdgeSubscribe:
		return m.clearedsubscribe
	case allocate.EdgeEmployee:
		return m.clearedemployee
	case allocate.EdgeCabinet:
		return m.clearedcabinet
	case allocate.EdgeStore:
		return m.clearedstore
	case allocate.EdgeBrand:
		return m.clearedbrand
	case allocate.EdgeBattery:
		return m.clearedbattery
	case allocate.EdgeStation:
		return m.clearedstation
	case allocate.EdgeAgent:
		return m.clearedagent
	case allocate.EdgeContract:
		return m.clearedcontract
	case allocate.EdgeEbike:
		return m.clearedebike
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AllocateMutation) ClearEdge(name string) error {
	switch name {
	case allocate.EdgeRider:
		m.ClearRider()
		return nil
	case allocate.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	case allocate.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case allocate.EdgeCabinet:
		m.ClearCabinet()
		return nil
	case allocate.EdgeStore:
		m.ClearStore()
		return nil
	case allocate.EdgeBrand:
		m.ClearBrand()
		return nil
	case allocate.EdgeBattery:
		m.ClearBattery()
		return nil
	case allocate.EdgeStation:
		m.ClearStation()
		return nil
	case allocate.EdgeAgent:
		m.ClearAgent()
		return nil
	case allocate.EdgeContract:
		m.ClearContract()
		return nil
	case allocate.EdgeEbike:
		m.ClearEbike()
		return nil
	}
	return fmt.Errorf("unknown Allocate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AllocateMutation) ResetEdge(name string) error {
	switch name {
	case allocate.EdgeRider:
		m.ResetRider()
		return nil
	case allocate.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	case allocate.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case allocate.EdgeCabinet:
		m.ResetCabinet()
		return nil
	case allocate.EdgeStore:
		m.ResetStore()
		return nil
	case allocate.EdgeBrand:
		m.ResetBrand()
		return nil
	case allocate.EdgeBattery:
		m.ResetBattery()
		return nil
	case allocate.EdgeStation:
		m.ResetStation()
		return nil
	case allocate.EdgeAgent:
		m.ResetAgent()
		return nil
	case allocate.EdgeContract:
		m.ResetContract()
		return nil
	case allocate.EdgeEbike:
		m.ResetEbike()
		return nil
	}
	return fmt.Errorf("unknown Allocate edge %s", name)
}

// AssistanceMutation represents an operation that mutates the Assistance nodes in the graph.
type AssistanceMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uint64
	created_at             *time.Time
	updated_at             *time.Time
	deleted_at             *time.Time
	creator                **model.Modifier
	last_modifier          **model.Modifier
	remark                 *string
	status                 *uint8
	addstatus              *int8
	lng                    *float64
	addlng                 *float64
	lat                    *float64
	addlat                 *float64
	address                *string
	breakdown              *string
	breakdown_desc         *string
	breakdown_photos       *[]string
	appendbreakdown_photos []string
	cancel_reason          *string
	cancel_reason_desc     *string
	distance               *float64
	adddistance            *float64
	reason                 *string
	detect_photo           *string
	joint_photo            *string
	cost                   *float64
	addcost                *float64
	refused_desc           *string
	pay_at                 *time.Time
	allocate_at            *time.Time
	wait                   *int
	addwait                *int
	free_reason            *string
	fail_reason            *string
	process_at             *time.Time
	price                  *float64
	addprice               *float64
	navi_duration          *int
	addnavi_duration       *int
	navi_polylines         *[]string
	appendnavi_polylines   []string
	clearedFields          map[string]struct{}
	store                  *uint64
	clearedstore           bool
	rider                  *uint64
	clearedrider           bool
	subscribe              *uint64
	clearedsubscribe       bool
	city                   *uint64
	clearedcity            bool
	_order                 *uint64
	cleared_order          bool
	employee               *uint64
	clearedemployee        bool
	done                   bool
	oldValue               func(context.Context) (*Assistance, error)
	predicates             []predicate.Assistance
}

var _ ent.Mutation = (*AssistanceMutation)(nil)

// assistanceOption allows management of the mutation configuration using functional options.
type assistanceOption func(*AssistanceMutation)

// newAssistanceMutation creates new mutation for the Assistance entity.
func newAssistanceMutation(c config, op Op, opts ...assistanceOption) *AssistanceMutation {
	m := &AssistanceMutation{
		config:        c,
		op:            op,
		typ:           TypeAssistance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAssistanceID sets the ID field of the mutation.
func withAssistanceID(id uint64) assistanceOption {
	return func(m *AssistanceMutation) {
		var (
			err   error
			once  sync.Once
			value *Assistance
		)
		m.oldValue = func(ctx context.Context) (*Assistance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Assistance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAssistance sets the old Assistance of the mutation.
func withAssistance(node *Assistance) assistanceOption {
	return func(m *AssistanceMutation) {
		m.oldValue = func(context.Context) (*Assistance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AssistanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AssistanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AssistanceMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AssistanceMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Assistance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AssistanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AssistanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AssistanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AssistanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AssistanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AssistanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AssistanceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AssistanceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AssistanceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[assistance.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AssistanceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[assistance.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AssistanceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, assistance.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *AssistanceMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *AssistanceMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *AssistanceMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[assistance.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *AssistanceMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[assistance.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *AssistanceMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, assistance.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *AssistanceMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *AssistanceMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *AssistanceMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[assistance.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *AssistanceMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[assistance.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *AssistanceMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, assistance.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *AssistanceMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *AssistanceMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *AssistanceMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[assistance.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *AssistanceMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[assistance.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *AssistanceMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, assistance.FieldRemark)
}

// SetStoreID sets the "store_id" field.
func (m *AssistanceMutation) SetStoreID(u uint64) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *AssistanceMutation) StoreID() (r uint64, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldStoreID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *AssistanceMutation) ClearStoreID() {
	m.store = nil
	m.clearedFields[assistance.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *AssistanceMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[assistance.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *AssistanceMutation) ResetStoreID() {
	m.store = nil
	delete(m.clearedFields, assistance.FieldStoreID)
}

// SetRiderID sets the "rider_id" field.
func (m *AssistanceMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *AssistanceMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *AssistanceMutation) ResetRiderID() {
	m.rider = nil
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *AssistanceMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *AssistanceMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldSubscribeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *AssistanceMutation) ResetSubscribeID() {
	m.subscribe = nil
}

// SetCityID sets the "city_id" field.
func (m *AssistanceMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *AssistanceMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *AssistanceMutation) ResetCityID() {
	m.city = nil
}

// SetEmployeeID sets the "employee_id" field.
func (m *AssistanceMutation) SetEmployeeID(u uint64) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *AssistanceMutation) EmployeeID() (r uint64, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldEmployeeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *AssistanceMutation) ClearEmployeeID() {
	m.employee = nil
	m.clearedFields[assistance.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *AssistanceMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[assistance.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *AssistanceMutation) ResetEmployeeID() {
	m.employee = nil
	delete(m.clearedFields, assistance.FieldEmployeeID)
}

// SetOrderID sets the "order_id" field.
func (m *AssistanceMutation) SetOrderID(u uint64) {
	m._order = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *AssistanceMutation) OrderID() (r uint64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldOrderID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *AssistanceMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[assistance.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *AssistanceMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[assistance.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *AssistanceMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, assistance.FieldOrderID)
}

// SetStatus sets the "status" field.
func (m *AssistanceMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *AssistanceMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *AssistanceMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *AssistanceMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *AssistanceMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetLng sets the "lng" field.
func (m *AssistanceMutation) SetLng(f float64) {
	m.lng = &f
	m.addlng = nil
}

// Lng returns the value of the "lng" field in the mutation.
func (m *AssistanceMutation) Lng() (r float64, exists bool) {
	v := m.lng
	if v == nil {
		return
	}
	return *v, true
}

// OldLng returns the old "lng" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldLng(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLng is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLng requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLng: %w", err)
	}
	return oldValue.Lng, nil
}

// AddLng adds f to the "lng" field.
func (m *AssistanceMutation) AddLng(f float64) {
	if m.addlng != nil {
		*m.addlng += f
	} else {
		m.addlng = &f
	}
}

// AddedLng returns the value that was added to the "lng" field in this mutation.
func (m *AssistanceMutation) AddedLng() (r float64, exists bool) {
	v := m.addlng
	if v == nil {
		return
	}
	return *v, true
}

// ResetLng resets all changes to the "lng" field.
func (m *AssistanceMutation) ResetLng() {
	m.lng = nil
	m.addlng = nil
}

// SetLat sets the "lat" field.
func (m *AssistanceMutation) SetLat(f float64) {
	m.lat = &f
	m.addlat = nil
}

// Lat returns the value of the "lat" field in the mutation.
func (m *AssistanceMutation) Lat() (r float64, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "lat" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// AddLat adds f to the "lat" field.
func (m *AssistanceMutation) AddLat(f float64) {
	if m.addlat != nil {
		*m.addlat += f
	} else {
		m.addlat = &f
	}
}

// AddedLat returns the value that was added to the "lat" field in this mutation.
func (m *AssistanceMutation) AddedLat() (r float64, exists bool) {
	v := m.addlat
	if v == nil {
		return
	}
	return *v, true
}

// ResetLat resets all changes to the "lat" field.
func (m *AssistanceMutation) ResetLat() {
	m.lat = nil
	m.addlat = nil
}

// SetAddress sets the "address" field.
func (m *AssistanceMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *AssistanceMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *AssistanceMutation) ResetAddress() {
	m.address = nil
}

// SetBreakdown sets the "breakdown" field.
func (m *AssistanceMutation) SetBreakdown(s string) {
	m.breakdown = &s
}

// Breakdown returns the value of the "breakdown" field in the mutation.
func (m *AssistanceMutation) Breakdown() (r string, exists bool) {
	v := m.breakdown
	if v == nil {
		return
	}
	return *v, true
}

// OldBreakdown returns the old "breakdown" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldBreakdown(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBreakdown is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBreakdown requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreakdown: %w", err)
	}
	return oldValue.Breakdown, nil
}

// ResetBreakdown resets all changes to the "breakdown" field.
func (m *AssistanceMutation) ResetBreakdown() {
	m.breakdown = nil
}

// SetBreakdownDesc sets the "breakdown_desc" field.
func (m *AssistanceMutation) SetBreakdownDesc(s string) {
	m.breakdown_desc = &s
}

// BreakdownDesc returns the value of the "breakdown_desc" field in the mutation.
func (m *AssistanceMutation) BreakdownDesc() (r string, exists bool) {
	v := m.breakdown_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldBreakdownDesc returns the old "breakdown_desc" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldBreakdownDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBreakdownDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBreakdownDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreakdownDesc: %w", err)
	}
	return oldValue.BreakdownDesc, nil
}

// ClearBreakdownDesc clears the value of the "breakdown_desc" field.
func (m *AssistanceMutation) ClearBreakdownDesc() {
	m.breakdown_desc = nil
	m.clearedFields[assistance.FieldBreakdownDesc] = struct{}{}
}

// BreakdownDescCleared returns if the "breakdown_desc" field was cleared in this mutation.
func (m *AssistanceMutation) BreakdownDescCleared() bool {
	_, ok := m.clearedFields[assistance.FieldBreakdownDesc]
	return ok
}

// ResetBreakdownDesc resets all changes to the "breakdown_desc" field.
func (m *AssistanceMutation) ResetBreakdownDesc() {
	m.breakdown_desc = nil
	delete(m.clearedFields, assistance.FieldBreakdownDesc)
}

// SetBreakdownPhotos sets the "breakdown_photos" field.
func (m *AssistanceMutation) SetBreakdownPhotos(s []string) {
	m.breakdown_photos = &s
	m.appendbreakdown_photos = nil
}

// BreakdownPhotos returns the value of the "breakdown_photos" field in the mutation.
func (m *AssistanceMutation) BreakdownPhotos() (r []string, exists bool) {
	v := m.breakdown_photos
	if v == nil {
		return
	}
	return *v, true
}

// OldBreakdownPhotos returns the old "breakdown_photos" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldBreakdownPhotos(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBreakdownPhotos is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBreakdownPhotos requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBreakdownPhotos: %w", err)
	}
	return oldValue.BreakdownPhotos, nil
}

// AppendBreakdownPhotos adds s to the "breakdown_photos" field.
func (m *AssistanceMutation) AppendBreakdownPhotos(s []string) {
	m.appendbreakdown_photos = append(m.appendbreakdown_photos, s...)
}

// AppendedBreakdownPhotos returns the list of values that were appended to the "breakdown_photos" field in this mutation.
func (m *AssistanceMutation) AppendedBreakdownPhotos() ([]string, bool) {
	if len(m.appendbreakdown_photos) == 0 {
		return nil, false
	}
	return m.appendbreakdown_photos, true
}

// ResetBreakdownPhotos resets all changes to the "breakdown_photos" field.
func (m *AssistanceMutation) ResetBreakdownPhotos() {
	m.breakdown_photos = nil
	m.appendbreakdown_photos = nil
}

// SetCancelReason sets the "cancel_reason" field.
func (m *AssistanceMutation) SetCancelReason(s string) {
	m.cancel_reason = &s
}

// CancelReason returns the value of the "cancel_reason" field in the mutation.
func (m *AssistanceMutation) CancelReason() (r string, exists bool) {
	v := m.cancel_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelReason returns the old "cancel_reason" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldCancelReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelReason: %w", err)
	}
	return oldValue.CancelReason, nil
}

// ClearCancelReason clears the value of the "cancel_reason" field.
func (m *AssistanceMutation) ClearCancelReason() {
	m.cancel_reason = nil
	m.clearedFields[assistance.FieldCancelReason] = struct{}{}
}

// CancelReasonCleared returns if the "cancel_reason" field was cleared in this mutation.
func (m *AssistanceMutation) CancelReasonCleared() bool {
	_, ok := m.clearedFields[assistance.FieldCancelReason]
	return ok
}

// ResetCancelReason resets all changes to the "cancel_reason" field.
func (m *AssistanceMutation) ResetCancelReason() {
	m.cancel_reason = nil
	delete(m.clearedFields, assistance.FieldCancelReason)
}

// SetCancelReasonDesc sets the "cancel_reason_desc" field.
func (m *AssistanceMutation) SetCancelReasonDesc(s string) {
	m.cancel_reason_desc = &s
}

// CancelReasonDesc returns the value of the "cancel_reason_desc" field in the mutation.
func (m *AssistanceMutation) CancelReasonDesc() (r string, exists bool) {
	v := m.cancel_reason_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelReasonDesc returns the old "cancel_reason_desc" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldCancelReasonDesc(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelReasonDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelReasonDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelReasonDesc: %w", err)
	}
	return oldValue.CancelReasonDesc, nil
}

// ClearCancelReasonDesc clears the value of the "cancel_reason_desc" field.
func (m *AssistanceMutation) ClearCancelReasonDesc() {
	m.cancel_reason_desc = nil
	m.clearedFields[assistance.FieldCancelReasonDesc] = struct{}{}
}

// CancelReasonDescCleared returns if the "cancel_reason_desc" field was cleared in this mutation.
func (m *AssistanceMutation) CancelReasonDescCleared() bool {
	_, ok := m.clearedFields[assistance.FieldCancelReasonDesc]
	return ok
}

// ResetCancelReasonDesc resets all changes to the "cancel_reason_desc" field.
func (m *AssistanceMutation) ResetCancelReasonDesc() {
	m.cancel_reason_desc = nil
	delete(m.clearedFields, assistance.FieldCancelReasonDesc)
}

// SetDistance sets the "distance" field.
func (m *AssistanceMutation) SetDistance(f float64) {
	m.distance = &f
	m.adddistance = nil
}

// Distance returns the value of the "distance" field in the mutation.
func (m *AssistanceMutation) Distance() (r float64, exists bool) {
	v := m.distance
	if v == nil {
		return
	}
	return *v, true
}

// OldDistance returns the old "distance" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldDistance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistance: %w", err)
	}
	return oldValue.Distance, nil
}

// AddDistance adds f to the "distance" field.
func (m *AssistanceMutation) AddDistance(f float64) {
	if m.adddistance != nil {
		*m.adddistance += f
	} else {
		m.adddistance = &f
	}
}

// AddedDistance returns the value that was added to the "distance" field in this mutation.
func (m *AssistanceMutation) AddedDistance() (r float64, exists bool) {
	v := m.adddistance
	if v == nil {
		return
	}
	return *v, true
}

// ClearDistance clears the value of the "distance" field.
func (m *AssistanceMutation) ClearDistance() {
	m.distance = nil
	m.adddistance = nil
	m.clearedFields[assistance.FieldDistance] = struct{}{}
}

// DistanceCleared returns if the "distance" field was cleared in this mutation.
func (m *AssistanceMutation) DistanceCleared() bool {
	_, ok := m.clearedFields[assistance.FieldDistance]
	return ok
}

// ResetDistance resets all changes to the "distance" field.
func (m *AssistanceMutation) ResetDistance() {
	m.distance = nil
	m.adddistance = nil
	delete(m.clearedFields, assistance.FieldDistance)
}

// SetReason sets the "reason" field.
func (m *AssistanceMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *AssistanceMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *AssistanceMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[assistance.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *AssistanceMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[assistance.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *AssistanceMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, assistance.FieldReason)
}

// SetDetectPhoto sets the "detect_photo" field.
func (m *AssistanceMutation) SetDetectPhoto(s string) {
	m.detect_photo = &s
}

// DetectPhoto returns the value of the "detect_photo" field in the mutation.
func (m *AssistanceMutation) DetectPhoto() (r string, exists bool) {
	v := m.detect_photo
	if v == nil {
		return
	}
	return *v, true
}

// OldDetectPhoto returns the old "detect_photo" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldDetectPhoto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetectPhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetectPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetectPhoto: %w", err)
	}
	return oldValue.DetectPhoto, nil
}

// ClearDetectPhoto clears the value of the "detect_photo" field.
func (m *AssistanceMutation) ClearDetectPhoto() {
	m.detect_photo = nil
	m.clearedFields[assistance.FieldDetectPhoto] = struct{}{}
}

// DetectPhotoCleared returns if the "detect_photo" field was cleared in this mutation.
func (m *AssistanceMutation) DetectPhotoCleared() bool {
	_, ok := m.clearedFields[assistance.FieldDetectPhoto]
	return ok
}

// ResetDetectPhoto resets all changes to the "detect_photo" field.
func (m *AssistanceMutation) ResetDetectPhoto() {
	m.detect_photo = nil
	delete(m.clearedFields, assistance.FieldDetectPhoto)
}

// SetJointPhoto sets the "joint_photo" field.
func (m *AssistanceMutation) SetJointPhoto(s string) {
	m.joint_photo = &s
}

// JointPhoto returns the value of the "joint_photo" field in the mutation.
func (m *AssistanceMutation) JointPhoto() (r string, exists bool) {
	v := m.joint_photo
	if v == nil {
		return
	}
	return *v, true
}

// OldJointPhoto returns the old "joint_photo" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldJointPhoto(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJointPhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJointPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJointPhoto: %w", err)
	}
	return oldValue.JointPhoto, nil
}

// ClearJointPhoto clears the value of the "joint_photo" field.
func (m *AssistanceMutation) ClearJointPhoto() {
	m.joint_photo = nil
	m.clearedFields[assistance.FieldJointPhoto] = struct{}{}
}

// JointPhotoCleared returns if the "joint_photo" field was cleared in this mutation.
func (m *AssistanceMutation) JointPhotoCleared() bool {
	_, ok := m.clearedFields[assistance.FieldJointPhoto]
	return ok
}

// ResetJointPhoto resets all changes to the "joint_photo" field.
func (m *AssistanceMutation) ResetJointPhoto() {
	m.joint_photo = nil
	delete(m.clearedFields, assistance.FieldJointPhoto)
}

// SetCost sets the "cost" field.
func (m *AssistanceMutation) SetCost(f float64) {
	m.cost = &f
	m.addcost = nil
}

// Cost returns the value of the "cost" field in the mutation.
func (m *AssistanceMutation) Cost() (r float64, exists bool) {
	v := m.cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCost returns the old "cost" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCost: %w", err)
	}
	return oldValue.Cost, nil
}

// AddCost adds f to the "cost" field.
func (m *AssistanceMutation) AddCost(f float64) {
	if m.addcost != nil {
		*m.addcost += f
	} else {
		m.addcost = &f
	}
}

// AddedCost returns the value that was added to the "cost" field in this mutation.
func (m *AssistanceMutation) AddedCost() (r float64, exists bool) {
	v := m.addcost
	if v == nil {
		return
	}
	return *v, true
}

// ClearCost clears the value of the "cost" field.
func (m *AssistanceMutation) ClearCost() {
	m.cost = nil
	m.addcost = nil
	m.clearedFields[assistance.FieldCost] = struct{}{}
}

// CostCleared returns if the "cost" field was cleared in this mutation.
func (m *AssistanceMutation) CostCleared() bool {
	_, ok := m.clearedFields[assistance.FieldCost]
	return ok
}

// ResetCost resets all changes to the "cost" field.
func (m *AssistanceMutation) ResetCost() {
	m.cost = nil
	m.addcost = nil
	delete(m.clearedFields, assistance.FieldCost)
}

// SetRefusedDesc sets the "refused_desc" field.
func (m *AssistanceMutation) SetRefusedDesc(s string) {
	m.refused_desc = &s
}

// RefusedDesc returns the value of the "refused_desc" field in the mutation.
func (m *AssistanceMutation) RefusedDesc() (r string, exists bool) {
	v := m.refused_desc
	if v == nil {
		return
	}
	return *v, true
}

// OldRefusedDesc returns the old "refused_desc" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldRefusedDesc(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefusedDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefusedDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefusedDesc: %w", err)
	}
	return oldValue.RefusedDesc, nil
}

// ClearRefusedDesc clears the value of the "refused_desc" field.
func (m *AssistanceMutation) ClearRefusedDesc() {
	m.refused_desc = nil
	m.clearedFields[assistance.FieldRefusedDesc] = struct{}{}
}

// RefusedDescCleared returns if the "refused_desc" field was cleared in this mutation.
func (m *AssistanceMutation) RefusedDescCleared() bool {
	_, ok := m.clearedFields[assistance.FieldRefusedDesc]
	return ok
}

// ResetRefusedDesc resets all changes to the "refused_desc" field.
func (m *AssistanceMutation) ResetRefusedDesc() {
	m.refused_desc = nil
	delete(m.clearedFields, assistance.FieldRefusedDesc)
}

// SetPayAt sets the "pay_at" field.
func (m *AssistanceMutation) SetPayAt(t time.Time) {
	m.pay_at = &t
}

// PayAt returns the value of the "pay_at" field in the mutation.
func (m *AssistanceMutation) PayAt() (r time.Time, exists bool) {
	v := m.pay_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPayAt returns the old "pay_at" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldPayAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayAt: %w", err)
	}
	return oldValue.PayAt, nil
}

// ClearPayAt clears the value of the "pay_at" field.
func (m *AssistanceMutation) ClearPayAt() {
	m.pay_at = nil
	m.clearedFields[assistance.FieldPayAt] = struct{}{}
}

// PayAtCleared returns if the "pay_at" field was cleared in this mutation.
func (m *AssistanceMutation) PayAtCleared() bool {
	_, ok := m.clearedFields[assistance.FieldPayAt]
	return ok
}

// ResetPayAt resets all changes to the "pay_at" field.
func (m *AssistanceMutation) ResetPayAt() {
	m.pay_at = nil
	delete(m.clearedFields, assistance.FieldPayAt)
}

// SetAllocateAt sets the "allocate_at" field.
func (m *AssistanceMutation) SetAllocateAt(t time.Time) {
	m.allocate_at = &t
}

// AllocateAt returns the value of the "allocate_at" field in the mutation.
func (m *AssistanceMutation) AllocateAt() (r time.Time, exists bool) {
	v := m.allocate_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAllocateAt returns the old "allocate_at" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldAllocateAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllocateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllocateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllocateAt: %w", err)
	}
	return oldValue.AllocateAt, nil
}

// ClearAllocateAt clears the value of the "allocate_at" field.
func (m *AssistanceMutation) ClearAllocateAt() {
	m.allocate_at = nil
	m.clearedFields[assistance.FieldAllocateAt] = struct{}{}
}

// AllocateAtCleared returns if the "allocate_at" field was cleared in this mutation.
func (m *AssistanceMutation) AllocateAtCleared() bool {
	_, ok := m.clearedFields[assistance.FieldAllocateAt]
	return ok
}

// ResetAllocateAt resets all changes to the "allocate_at" field.
func (m *AssistanceMutation) ResetAllocateAt() {
	m.allocate_at = nil
	delete(m.clearedFields, assistance.FieldAllocateAt)
}

// SetWait sets the "wait" field.
func (m *AssistanceMutation) SetWait(i int) {
	m.wait = &i
	m.addwait = nil
}

// Wait returns the value of the "wait" field in the mutation.
func (m *AssistanceMutation) Wait() (r int, exists bool) {
	v := m.wait
	if v == nil {
		return
	}
	return *v, true
}

// OldWait returns the old "wait" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldWait(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWait is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWait requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWait: %w", err)
	}
	return oldValue.Wait, nil
}

// AddWait adds i to the "wait" field.
func (m *AssistanceMutation) AddWait(i int) {
	if m.addwait != nil {
		*m.addwait += i
	} else {
		m.addwait = &i
	}
}

// AddedWait returns the value that was added to the "wait" field in this mutation.
func (m *AssistanceMutation) AddedWait() (r int, exists bool) {
	v := m.addwait
	if v == nil {
		return
	}
	return *v, true
}

// ResetWait resets all changes to the "wait" field.
func (m *AssistanceMutation) ResetWait() {
	m.wait = nil
	m.addwait = nil
}

// SetFreeReason sets the "free_reason" field.
func (m *AssistanceMutation) SetFreeReason(s string) {
	m.free_reason = &s
}

// FreeReason returns the value of the "free_reason" field in the mutation.
func (m *AssistanceMutation) FreeReason() (r string, exists bool) {
	v := m.free_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFreeReason returns the old "free_reason" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldFreeReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFreeReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFreeReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFreeReason: %w", err)
	}
	return oldValue.FreeReason, nil
}

// ClearFreeReason clears the value of the "free_reason" field.
func (m *AssistanceMutation) ClearFreeReason() {
	m.free_reason = nil
	m.clearedFields[assistance.FieldFreeReason] = struct{}{}
}

// FreeReasonCleared returns if the "free_reason" field was cleared in this mutation.
func (m *AssistanceMutation) FreeReasonCleared() bool {
	_, ok := m.clearedFields[assistance.FieldFreeReason]
	return ok
}

// ResetFreeReason resets all changes to the "free_reason" field.
func (m *AssistanceMutation) ResetFreeReason() {
	m.free_reason = nil
	delete(m.clearedFields, assistance.FieldFreeReason)
}

// SetFailReason sets the "fail_reason" field.
func (m *AssistanceMutation) SetFailReason(s string) {
	m.fail_reason = &s
}

// FailReason returns the value of the "fail_reason" field in the mutation.
func (m *AssistanceMutation) FailReason() (r string, exists bool) {
	v := m.fail_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailReason returns the old "fail_reason" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldFailReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailReason: %w", err)
	}
	return oldValue.FailReason, nil
}

// ClearFailReason clears the value of the "fail_reason" field.
func (m *AssistanceMutation) ClearFailReason() {
	m.fail_reason = nil
	m.clearedFields[assistance.FieldFailReason] = struct{}{}
}

// FailReasonCleared returns if the "fail_reason" field was cleared in this mutation.
func (m *AssistanceMutation) FailReasonCleared() bool {
	_, ok := m.clearedFields[assistance.FieldFailReason]
	return ok
}

// ResetFailReason resets all changes to the "fail_reason" field.
func (m *AssistanceMutation) ResetFailReason() {
	m.fail_reason = nil
	delete(m.clearedFields, assistance.FieldFailReason)
}

// SetProcessAt sets the "process_at" field.
func (m *AssistanceMutation) SetProcessAt(t time.Time) {
	m.process_at = &t
}

// ProcessAt returns the value of the "process_at" field in the mutation.
func (m *AssistanceMutation) ProcessAt() (r time.Time, exists bool) {
	v := m.process_at
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessAt returns the old "process_at" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldProcessAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessAt: %w", err)
	}
	return oldValue.ProcessAt, nil
}

// ClearProcessAt clears the value of the "process_at" field.
func (m *AssistanceMutation) ClearProcessAt() {
	m.process_at = nil
	m.clearedFields[assistance.FieldProcessAt] = struct{}{}
}

// ProcessAtCleared returns if the "process_at" field was cleared in this mutation.
func (m *AssistanceMutation) ProcessAtCleared() bool {
	_, ok := m.clearedFields[assistance.FieldProcessAt]
	return ok
}

// ResetProcessAt resets all changes to the "process_at" field.
func (m *AssistanceMutation) ResetProcessAt() {
	m.process_at = nil
	delete(m.clearedFields, assistance.FieldProcessAt)
}

// SetPrice sets the "price" field.
func (m *AssistanceMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *AssistanceMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *AssistanceMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *AssistanceMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ClearPrice clears the value of the "price" field.
func (m *AssistanceMutation) ClearPrice() {
	m.price = nil
	m.addprice = nil
	m.clearedFields[assistance.FieldPrice] = struct{}{}
}

// PriceCleared returns if the "price" field was cleared in this mutation.
func (m *AssistanceMutation) PriceCleared() bool {
	_, ok := m.clearedFields[assistance.FieldPrice]
	return ok
}

// ResetPrice resets all changes to the "price" field.
func (m *AssistanceMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
	delete(m.clearedFields, assistance.FieldPrice)
}

// SetNaviDuration sets the "navi_duration" field.
func (m *AssistanceMutation) SetNaviDuration(i int) {
	m.navi_duration = &i
	m.addnavi_duration = nil
}

// NaviDuration returns the value of the "navi_duration" field in the mutation.
func (m *AssistanceMutation) NaviDuration() (r int, exists bool) {
	v := m.navi_duration
	if v == nil {
		return
	}
	return *v, true
}

// OldNaviDuration returns the old "navi_duration" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldNaviDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNaviDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNaviDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNaviDuration: %w", err)
	}
	return oldValue.NaviDuration, nil
}

// AddNaviDuration adds i to the "navi_duration" field.
func (m *AssistanceMutation) AddNaviDuration(i int) {
	if m.addnavi_duration != nil {
		*m.addnavi_duration += i
	} else {
		m.addnavi_duration = &i
	}
}

// AddedNaviDuration returns the value that was added to the "navi_duration" field in this mutation.
func (m *AssistanceMutation) AddedNaviDuration() (r int, exists bool) {
	v := m.addnavi_duration
	if v == nil {
		return
	}
	return *v, true
}

// ClearNaviDuration clears the value of the "navi_duration" field.
func (m *AssistanceMutation) ClearNaviDuration() {
	m.navi_duration = nil
	m.addnavi_duration = nil
	m.clearedFields[assistance.FieldNaviDuration] = struct{}{}
}

// NaviDurationCleared returns if the "navi_duration" field was cleared in this mutation.
func (m *AssistanceMutation) NaviDurationCleared() bool {
	_, ok := m.clearedFields[assistance.FieldNaviDuration]
	return ok
}

// ResetNaviDuration resets all changes to the "navi_duration" field.
func (m *AssistanceMutation) ResetNaviDuration() {
	m.navi_duration = nil
	m.addnavi_duration = nil
	delete(m.clearedFields, assistance.FieldNaviDuration)
}

// SetNaviPolylines sets the "navi_polylines" field.
func (m *AssistanceMutation) SetNaviPolylines(s []string) {
	m.navi_polylines = &s
	m.appendnavi_polylines = nil
}

// NaviPolylines returns the value of the "navi_polylines" field in the mutation.
func (m *AssistanceMutation) NaviPolylines() (r []string, exists bool) {
	v := m.navi_polylines
	if v == nil {
		return
	}
	return *v, true
}

// OldNaviPolylines returns the old "navi_polylines" field's value of the Assistance entity.
// If the Assistance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AssistanceMutation) OldNaviPolylines(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNaviPolylines is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNaviPolylines requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNaviPolylines: %w", err)
	}
	return oldValue.NaviPolylines, nil
}

// AppendNaviPolylines adds s to the "navi_polylines" field.
func (m *AssistanceMutation) AppendNaviPolylines(s []string) {
	m.appendnavi_polylines = append(m.appendnavi_polylines, s...)
}

// AppendedNaviPolylines returns the list of values that were appended to the "navi_polylines" field in this mutation.
func (m *AssistanceMutation) AppendedNaviPolylines() ([]string, bool) {
	if len(m.appendnavi_polylines) == 0 {
		return nil, false
	}
	return m.appendnavi_polylines, true
}

// ClearNaviPolylines clears the value of the "navi_polylines" field.
func (m *AssistanceMutation) ClearNaviPolylines() {
	m.navi_polylines = nil
	m.appendnavi_polylines = nil
	m.clearedFields[assistance.FieldNaviPolylines] = struct{}{}
}

// NaviPolylinesCleared returns if the "navi_polylines" field was cleared in this mutation.
func (m *AssistanceMutation) NaviPolylinesCleared() bool {
	_, ok := m.clearedFields[assistance.FieldNaviPolylines]
	return ok
}

// ResetNaviPolylines resets all changes to the "navi_polylines" field.
func (m *AssistanceMutation) ResetNaviPolylines() {
	m.navi_polylines = nil
	m.appendnavi_polylines = nil
	delete(m.clearedFields, assistance.FieldNaviPolylines)
}

// ClearStore clears the "store" edge to the Store entity.
func (m *AssistanceMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[assistance.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *AssistanceMutation) StoreCleared() bool {
	return m.StoreIDCleared() || m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *AssistanceMutation) StoreIDs() (ids []uint64) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *AssistanceMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *AssistanceMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[assistance.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *AssistanceMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *AssistanceMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *AssistanceMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *AssistanceMutation) ClearSubscribe() {
	m.clearedsubscribe = true
	m.clearedFields[assistance.FieldSubscribeID] = struct{}{}
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *AssistanceMutation) SubscribeCleared() bool {
	return m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *AssistanceMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *AssistanceMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *AssistanceMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[assistance.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *AssistanceMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *AssistanceMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *AssistanceMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *AssistanceMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[assistance.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *AssistanceMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *AssistanceMutation) OrderIDs() (ids []uint64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *AssistanceMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *AssistanceMutation) ClearEmployee() {
	m.clearedemployee = true
	m.clearedFields[assistance.FieldEmployeeID] = struct{}{}
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *AssistanceMutation) EmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *AssistanceMutation) EmployeeIDs() (ids []uint64) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *AssistanceMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// Where appends a list predicates to the AssistanceMutation builder.
func (m *AssistanceMutation) Where(ps ...predicate.Assistance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AssistanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AssistanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Assistance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AssistanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AssistanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Assistance).
func (m *AssistanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AssistanceMutation) Fields() []string {
	fields := make([]string, 0, 36)
	if m.created_at != nil {
		fields = append(fields, assistance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, assistance.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, assistance.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, assistance.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, assistance.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, assistance.FieldRemark)
	}
	if m.store != nil {
		fields = append(fields, assistance.FieldStoreID)
	}
	if m.rider != nil {
		fields = append(fields, assistance.FieldRiderID)
	}
	if m.subscribe != nil {
		fields = append(fields, assistance.FieldSubscribeID)
	}
	if m.city != nil {
		fields = append(fields, assistance.FieldCityID)
	}
	if m.employee != nil {
		fields = append(fields, assistance.FieldEmployeeID)
	}
	if m._order != nil {
		fields = append(fields, assistance.FieldOrderID)
	}
	if m.status != nil {
		fields = append(fields, assistance.FieldStatus)
	}
	if m.lng != nil {
		fields = append(fields, assistance.FieldLng)
	}
	if m.lat != nil {
		fields = append(fields, assistance.FieldLat)
	}
	if m.address != nil {
		fields = append(fields, assistance.FieldAddress)
	}
	if m.breakdown != nil {
		fields = append(fields, assistance.FieldBreakdown)
	}
	if m.breakdown_desc != nil {
		fields = append(fields, assistance.FieldBreakdownDesc)
	}
	if m.breakdown_photos != nil {
		fields = append(fields, assistance.FieldBreakdownPhotos)
	}
	if m.cancel_reason != nil {
		fields = append(fields, assistance.FieldCancelReason)
	}
	if m.cancel_reason_desc != nil {
		fields = append(fields, assistance.FieldCancelReasonDesc)
	}
	if m.distance != nil {
		fields = append(fields, assistance.FieldDistance)
	}
	if m.reason != nil {
		fields = append(fields, assistance.FieldReason)
	}
	if m.detect_photo != nil {
		fields = append(fields, assistance.FieldDetectPhoto)
	}
	if m.joint_photo != nil {
		fields = append(fields, assistance.FieldJointPhoto)
	}
	if m.cost != nil {
		fields = append(fields, assistance.FieldCost)
	}
	if m.refused_desc != nil {
		fields = append(fields, assistance.FieldRefusedDesc)
	}
	if m.pay_at != nil {
		fields = append(fields, assistance.FieldPayAt)
	}
	if m.allocate_at != nil {
		fields = append(fields, assistance.FieldAllocateAt)
	}
	if m.wait != nil {
		fields = append(fields, assistance.FieldWait)
	}
	if m.free_reason != nil {
		fields = append(fields, assistance.FieldFreeReason)
	}
	if m.fail_reason != nil {
		fields = append(fields, assistance.FieldFailReason)
	}
	if m.process_at != nil {
		fields = append(fields, assistance.FieldProcessAt)
	}
	if m.price != nil {
		fields = append(fields, assistance.FieldPrice)
	}
	if m.navi_duration != nil {
		fields = append(fields, assistance.FieldNaviDuration)
	}
	if m.navi_polylines != nil {
		fields = append(fields, assistance.FieldNaviPolylines)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AssistanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case assistance.FieldCreatedAt:
		return m.CreatedAt()
	case assistance.FieldUpdatedAt:
		return m.UpdatedAt()
	case assistance.FieldDeletedAt:
		return m.DeletedAt()
	case assistance.FieldCreator:
		return m.Creator()
	case assistance.FieldLastModifier:
		return m.LastModifier()
	case assistance.FieldRemark:
		return m.Remark()
	case assistance.FieldStoreID:
		return m.StoreID()
	case assistance.FieldRiderID:
		return m.RiderID()
	case assistance.FieldSubscribeID:
		return m.SubscribeID()
	case assistance.FieldCityID:
		return m.CityID()
	case assistance.FieldEmployeeID:
		return m.EmployeeID()
	case assistance.FieldOrderID:
		return m.OrderID()
	case assistance.FieldStatus:
		return m.Status()
	case assistance.FieldLng:
		return m.Lng()
	case assistance.FieldLat:
		return m.Lat()
	case assistance.FieldAddress:
		return m.Address()
	case assistance.FieldBreakdown:
		return m.Breakdown()
	case assistance.FieldBreakdownDesc:
		return m.BreakdownDesc()
	case assistance.FieldBreakdownPhotos:
		return m.BreakdownPhotos()
	case assistance.FieldCancelReason:
		return m.CancelReason()
	case assistance.FieldCancelReasonDesc:
		return m.CancelReasonDesc()
	case assistance.FieldDistance:
		return m.Distance()
	case assistance.FieldReason:
		return m.Reason()
	case assistance.FieldDetectPhoto:
		return m.DetectPhoto()
	case assistance.FieldJointPhoto:
		return m.JointPhoto()
	case assistance.FieldCost:
		return m.Cost()
	case assistance.FieldRefusedDesc:
		return m.RefusedDesc()
	case assistance.FieldPayAt:
		return m.PayAt()
	case assistance.FieldAllocateAt:
		return m.AllocateAt()
	case assistance.FieldWait:
		return m.Wait()
	case assistance.FieldFreeReason:
		return m.FreeReason()
	case assistance.FieldFailReason:
		return m.FailReason()
	case assistance.FieldProcessAt:
		return m.ProcessAt()
	case assistance.FieldPrice:
		return m.Price()
	case assistance.FieldNaviDuration:
		return m.NaviDuration()
	case assistance.FieldNaviPolylines:
		return m.NaviPolylines()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AssistanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case assistance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case assistance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case assistance.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case assistance.FieldCreator:
		return m.OldCreator(ctx)
	case assistance.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case assistance.FieldRemark:
		return m.OldRemark(ctx)
	case assistance.FieldStoreID:
		return m.OldStoreID(ctx)
	case assistance.FieldRiderID:
		return m.OldRiderID(ctx)
	case assistance.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case assistance.FieldCityID:
		return m.OldCityID(ctx)
	case assistance.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case assistance.FieldOrderID:
		return m.OldOrderID(ctx)
	case assistance.FieldStatus:
		return m.OldStatus(ctx)
	case assistance.FieldLng:
		return m.OldLng(ctx)
	case assistance.FieldLat:
		return m.OldLat(ctx)
	case assistance.FieldAddress:
		return m.OldAddress(ctx)
	case assistance.FieldBreakdown:
		return m.OldBreakdown(ctx)
	case assistance.FieldBreakdownDesc:
		return m.OldBreakdownDesc(ctx)
	case assistance.FieldBreakdownPhotos:
		return m.OldBreakdownPhotos(ctx)
	case assistance.FieldCancelReason:
		return m.OldCancelReason(ctx)
	case assistance.FieldCancelReasonDesc:
		return m.OldCancelReasonDesc(ctx)
	case assistance.FieldDistance:
		return m.OldDistance(ctx)
	case assistance.FieldReason:
		return m.OldReason(ctx)
	case assistance.FieldDetectPhoto:
		return m.OldDetectPhoto(ctx)
	case assistance.FieldJointPhoto:
		return m.OldJointPhoto(ctx)
	case assistance.FieldCost:
		return m.OldCost(ctx)
	case assistance.FieldRefusedDesc:
		return m.OldRefusedDesc(ctx)
	case assistance.FieldPayAt:
		return m.OldPayAt(ctx)
	case assistance.FieldAllocateAt:
		return m.OldAllocateAt(ctx)
	case assistance.FieldWait:
		return m.OldWait(ctx)
	case assistance.FieldFreeReason:
		return m.OldFreeReason(ctx)
	case assistance.FieldFailReason:
		return m.OldFailReason(ctx)
	case assistance.FieldProcessAt:
		return m.OldProcessAt(ctx)
	case assistance.FieldPrice:
		return m.OldPrice(ctx)
	case assistance.FieldNaviDuration:
		return m.OldNaviDuration(ctx)
	case assistance.FieldNaviPolylines:
		return m.OldNaviPolylines(ctx)
	}
	return nil, fmt.Errorf("unknown Assistance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssistanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case assistance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case assistance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case assistance.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case assistance.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case assistance.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case assistance.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case assistance.FieldStoreID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case assistance.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case assistance.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case assistance.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case assistance.FieldEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case assistance.FieldOrderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case assistance.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case assistance.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLng(v)
		return nil
	case assistance.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	case assistance.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case assistance.FieldBreakdown:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreakdown(v)
		return nil
	case assistance.FieldBreakdownDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreakdownDesc(v)
		return nil
	case assistance.FieldBreakdownPhotos:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBreakdownPhotos(v)
		return nil
	case assistance.FieldCancelReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelReason(v)
		return nil
	case assistance.FieldCancelReasonDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelReasonDesc(v)
		return nil
	case assistance.FieldDistance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistance(v)
		return nil
	case assistance.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case assistance.FieldDetectPhoto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetectPhoto(v)
		return nil
	case assistance.FieldJointPhoto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJointPhoto(v)
		return nil
	case assistance.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCost(v)
		return nil
	case assistance.FieldRefusedDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefusedDesc(v)
		return nil
	case assistance.FieldPayAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayAt(v)
		return nil
	case assistance.FieldAllocateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllocateAt(v)
		return nil
	case assistance.FieldWait:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWait(v)
		return nil
	case assistance.FieldFreeReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFreeReason(v)
		return nil
	case assistance.FieldFailReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailReason(v)
		return nil
	case assistance.FieldProcessAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessAt(v)
		return nil
	case assistance.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case assistance.FieldNaviDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNaviDuration(v)
		return nil
	case assistance.FieldNaviPolylines:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNaviPolylines(v)
		return nil
	}
	return fmt.Errorf("unknown Assistance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AssistanceMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, assistance.FieldStatus)
	}
	if m.addlng != nil {
		fields = append(fields, assistance.FieldLng)
	}
	if m.addlat != nil {
		fields = append(fields, assistance.FieldLat)
	}
	if m.adddistance != nil {
		fields = append(fields, assistance.FieldDistance)
	}
	if m.addcost != nil {
		fields = append(fields, assistance.FieldCost)
	}
	if m.addwait != nil {
		fields = append(fields, assistance.FieldWait)
	}
	if m.addprice != nil {
		fields = append(fields, assistance.FieldPrice)
	}
	if m.addnavi_duration != nil {
		fields = append(fields, assistance.FieldNaviDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AssistanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case assistance.FieldStatus:
		return m.AddedStatus()
	case assistance.FieldLng:
		return m.AddedLng()
	case assistance.FieldLat:
		return m.AddedLat()
	case assistance.FieldDistance:
		return m.AddedDistance()
	case assistance.FieldCost:
		return m.AddedCost()
	case assistance.FieldWait:
		return m.AddedWait()
	case assistance.FieldPrice:
		return m.AddedPrice()
	case assistance.FieldNaviDuration:
		return m.AddedNaviDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AssistanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case assistance.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case assistance.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLng(v)
		return nil
	case assistance.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLat(v)
		return nil
	case assistance.FieldDistance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDistance(v)
		return nil
	case assistance.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCost(v)
		return nil
	case assistance.FieldWait:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWait(v)
		return nil
	case assistance.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case assistance.FieldNaviDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNaviDuration(v)
		return nil
	}
	return fmt.Errorf("unknown Assistance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AssistanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(assistance.FieldDeletedAt) {
		fields = append(fields, assistance.FieldDeletedAt)
	}
	if m.FieldCleared(assistance.FieldCreator) {
		fields = append(fields, assistance.FieldCreator)
	}
	if m.FieldCleared(assistance.FieldLastModifier) {
		fields = append(fields, assistance.FieldLastModifier)
	}
	if m.FieldCleared(assistance.FieldRemark) {
		fields = append(fields, assistance.FieldRemark)
	}
	if m.FieldCleared(assistance.FieldStoreID) {
		fields = append(fields, assistance.FieldStoreID)
	}
	if m.FieldCleared(assistance.FieldEmployeeID) {
		fields = append(fields, assistance.FieldEmployeeID)
	}
	if m.FieldCleared(assistance.FieldOrderID) {
		fields = append(fields, assistance.FieldOrderID)
	}
	if m.FieldCleared(assistance.FieldBreakdownDesc) {
		fields = append(fields, assistance.FieldBreakdownDesc)
	}
	if m.FieldCleared(assistance.FieldCancelReason) {
		fields = append(fields, assistance.FieldCancelReason)
	}
	if m.FieldCleared(assistance.FieldCancelReasonDesc) {
		fields = append(fields, assistance.FieldCancelReasonDesc)
	}
	if m.FieldCleared(assistance.FieldDistance) {
		fields = append(fields, assistance.FieldDistance)
	}
	if m.FieldCleared(assistance.FieldReason) {
		fields = append(fields, assistance.FieldReason)
	}
	if m.FieldCleared(assistance.FieldDetectPhoto) {
		fields = append(fields, assistance.FieldDetectPhoto)
	}
	if m.FieldCleared(assistance.FieldJointPhoto) {
		fields = append(fields, assistance.FieldJointPhoto)
	}
	if m.FieldCleared(assistance.FieldCost) {
		fields = append(fields, assistance.FieldCost)
	}
	if m.FieldCleared(assistance.FieldRefusedDesc) {
		fields = append(fields, assistance.FieldRefusedDesc)
	}
	if m.FieldCleared(assistance.FieldPayAt) {
		fields = append(fields, assistance.FieldPayAt)
	}
	if m.FieldCleared(assistance.FieldAllocateAt) {
		fields = append(fields, assistance.FieldAllocateAt)
	}
	if m.FieldCleared(assistance.FieldFreeReason) {
		fields = append(fields, assistance.FieldFreeReason)
	}
	if m.FieldCleared(assistance.FieldFailReason) {
		fields = append(fields, assistance.FieldFailReason)
	}
	if m.FieldCleared(assistance.FieldProcessAt) {
		fields = append(fields, assistance.FieldProcessAt)
	}
	if m.FieldCleared(assistance.FieldPrice) {
		fields = append(fields, assistance.FieldPrice)
	}
	if m.FieldCleared(assistance.FieldNaviDuration) {
		fields = append(fields, assistance.FieldNaviDuration)
	}
	if m.FieldCleared(assistance.FieldNaviPolylines) {
		fields = append(fields, assistance.FieldNaviPolylines)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AssistanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AssistanceMutation) ClearField(name string) error {
	switch name {
	case assistance.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case assistance.FieldCreator:
		m.ClearCreator()
		return nil
	case assistance.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case assistance.FieldRemark:
		m.ClearRemark()
		return nil
	case assistance.FieldStoreID:
		m.ClearStoreID()
		return nil
	case assistance.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case assistance.FieldOrderID:
		m.ClearOrderID()
		return nil
	case assistance.FieldBreakdownDesc:
		m.ClearBreakdownDesc()
		return nil
	case assistance.FieldCancelReason:
		m.ClearCancelReason()
		return nil
	case assistance.FieldCancelReasonDesc:
		m.ClearCancelReasonDesc()
		return nil
	case assistance.FieldDistance:
		m.ClearDistance()
		return nil
	case assistance.FieldReason:
		m.ClearReason()
		return nil
	case assistance.FieldDetectPhoto:
		m.ClearDetectPhoto()
		return nil
	case assistance.FieldJointPhoto:
		m.ClearJointPhoto()
		return nil
	case assistance.FieldCost:
		m.ClearCost()
		return nil
	case assistance.FieldRefusedDesc:
		m.ClearRefusedDesc()
		return nil
	case assistance.FieldPayAt:
		m.ClearPayAt()
		return nil
	case assistance.FieldAllocateAt:
		m.ClearAllocateAt()
		return nil
	case assistance.FieldFreeReason:
		m.ClearFreeReason()
		return nil
	case assistance.FieldFailReason:
		m.ClearFailReason()
		return nil
	case assistance.FieldProcessAt:
		m.ClearProcessAt()
		return nil
	case assistance.FieldPrice:
		m.ClearPrice()
		return nil
	case assistance.FieldNaviDuration:
		m.ClearNaviDuration()
		return nil
	case assistance.FieldNaviPolylines:
		m.ClearNaviPolylines()
		return nil
	}
	return fmt.Errorf("unknown Assistance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AssistanceMutation) ResetField(name string) error {
	switch name {
	case assistance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case assistance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case assistance.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case assistance.FieldCreator:
		m.ResetCreator()
		return nil
	case assistance.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case assistance.FieldRemark:
		m.ResetRemark()
		return nil
	case assistance.FieldStoreID:
		m.ResetStoreID()
		return nil
	case assistance.FieldRiderID:
		m.ResetRiderID()
		return nil
	case assistance.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case assistance.FieldCityID:
		m.ResetCityID()
		return nil
	case assistance.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case assistance.FieldOrderID:
		m.ResetOrderID()
		return nil
	case assistance.FieldStatus:
		m.ResetStatus()
		return nil
	case assistance.FieldLng:
		m.ResetLng()
		return nil
	case assistance.FieldLat:
		m.ResetLat()
		return nil
	case assistance.FieldAddress:
		m.ResetAddress()
		return nil
	case assistance.FieldBreakdown:
		m.ResetBreakdown()
		return nil
	case assistance.FieldBreakdownDesc:
		m.ResetBreakdownDesc()
		return nil
	case assistance.FieldBreakdownPhotos:
		m.ResetBreakdownPhotos()
		return nil
	case assistance.FieldCancelReason:
		m.ResetCancelReason()
		return nil
	case assistance.FieldCancelReasonDesc:
		m.ResetCancelReasonDesc()
		return nil
	case assistance.FieldDistance:
		m.ResetDistance()
		return nil
	case assistance.FieldReason:
		m.ResetReason()
		return nil
	case assistance.FieldDetectPhoto:
		m.ResetDetectPhoto()
		return nil
	case assistance.FieldJointPhoto:
		m.ResetJointPhoto()
		return nil
	case assistance.FieldCost:
		m.ResetCost()
		return nil
	case assistance.FieldRefusedDesc:
		m.ResetRefusedDesc()
		return nil
	case assistance.FieldPayAt:
		m.ResetPayAt()
		return nil
	case assistance.FieldAllocateAt:
		m.ResetAllocateAt()
		return nil
	case assistance.FieldWait:
		m.ResetWait()
		return nil
	case assistance.FieldFreeReason:
		m.ResetFreeReason()
		return nil
	case assistance.FieldFailReason:
		m.ResetFailReason()
		return nil
	case assistance.FieldProcessAt:
		m.ResetProcessAt()
		return nil
	case assistance.FieldPrice:
		m.ResetPrice()
		return nil
	case assistance.FieldNaviDuration:
		m.ResetNaviDuration()
		return nil
	case assistance.FieldNaviPolylines:
		m.ResetNaviPolylines()
		return nil
	}
	return fmt.Errorf("unknown Assistance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AssistanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.store != nil {
		edges = append(edges, assistance.EdgeStore)
	}
	if m.rider != nil {
		edges = append(edges, assistance.EdgeRider)
	}
	if m.subscribe != nil {
		edges = append(edges, assistance.EdgeSubscribe)
	}
	if m.city != nil {
		edges = append(edges, assistance.EdgeCity)
	}
	if m._order != nil {
		edges = append(edges, assistance.EdgeOrder)
	}
	if m.employee != nil {
		edges = append(edges, assistance.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AssistanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case assistance.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	case assistance.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case assistance.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	case assistance.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case assistance.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	case assistance.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AssistanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AssistanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AssistanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedstore {
		edges = append(edges, assistance.EdgeStore)
	}
	if m.clearedrider {
		edges = append(edges, assistance.EdgeRider)
	}
	if m.clearedsubscribe {
		edges = append(edges, assistance.EdgeSubscribe)
	}
	if m.clearedcity {
		edges = append(edges, assistance.EdgeCity)
	}
	if m.cleared_order {
		edges = append(edges, assistance.EdgeOrder)
	}
	if m.clearedemployee {
		edges = append(edges, assistance.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AssistanceMutation) EdgeCleared(name string) bool {
	switch name {
	case assistance.EdgeStore:
		return m.clearedstore
	case assistance.EdgeRider:
		return m.clearedrider
	case assistance.EdgeSubscribe:
		return m.clearedsubscribe
	case assistance.EdgeCity:
		return m.clearedcity
	case assistance.EdgeOrder:
		return m.cleared_order
	case assistance.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AssistanceMutation) ClearEdge(name string) error {
	switch name {
	case assistance.EdgeStore:
		m.ClearStore()
		return nil
	case assistance.EdgeRider:
		m.ClearRider()
		return nil
	case assistance.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	case assistance.EdgeCity:
		m.ClearCity()
		return nil
	case assistance.EdgeOrder:
		m.ClearOrder()
		return nil
	case assistance.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown Assistance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AssistanceMutation) ResetEdge(name string) error {
	switch name {
	case assistance.EdgeStore:
		m.ResetStore()
		return nil
	case assistance.EdgeRider:
		m.ResetRider()
		return nil
	case assistance.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	case assistance.EdgeCity:
		m.ResetCity()
		return nil
	case assistance.EdgeOrder:
		m.ResetOrder()
		return nil
	case assistance.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Assistance edge %s", name)
}

// AttendanceMutation represents an operation that mutates the Attendance nodes in the graph.
type AttendanceMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	creator         **model.Modifier
	last_modifier   **model.Modifier
	remark          *string
	inventory       *[]model.AttendanceInventory
	appendinventory []model.AttendanceInventory
	photo           *string
	duty            *bool
	date            *time.Time
	lng             *float64
	addlng          *float64
	lat             *float64
	addlat          *float64
	address         *string
	distance        *float64
	adddistance     *float64
	clearedFields   map[string]struct{}
	store           *uint64
	clearedstore    bool
	employee        *uint64
	clearedemployee bool
	done            bool
	oldValue        func(context.Context) (*Attendance, error)
	predicates      []predicate.Attendance
}

var _ ent.Mutation = (*AttendanceMutation)(nil)

// attendanceOption allows management of the mutation configuration using functional options.
type attendanceOption func(*AttendanceMutation)

// newAttendanceMutation creates new mutation for the Attendance entity.
func newAttendanceMutation(c config, op Op, opts ...attendanceOption) *AttendanceMutation {
	m := &AttendanceMutation{
		config:        c,
		op:            op,
		typ:           TypeAttendance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttendanceID sets the ID field of the mutation.
func withAttendanceID(id uint64) attendanceOption {
	return func(m *AttendanceMutation) {
		var (
			err   error
			once  sync.Once
			value *Attendance
		)
		m.oldValue = func(ctx context.Context) (*Attendance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Attendance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttendance sets the old Attendance of the mutation.
func withAttendance(node *Attendance) attendanceOption {
	return func(m *AttendanceMutation) {
		m.oldValue = func(context.Context) (*Attendance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttendanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttendanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttendanceMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttendanceMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Attendance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AttendanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AttendanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AttendanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AttendanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AttendanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AttendanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AttendanceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AttendanceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AttendanceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[attendance.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AttendanceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[attendance.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AttendanceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, attendance.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *AttendanceMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *AttendanceMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *AttendanceMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[attendance.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *AttendanceMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[attendance.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *AttendanceMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, attendance.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *AttendanceMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *AttendanceMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *AttendanceMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[attendance.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *AttendanceMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[attendance.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *AttendanceMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, attendance.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *AttendanceMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *AttendanceMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *AttendanceMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[attendance.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *AttendanceMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[attendance.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *AttendanceMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, attendance.FieldRemark)
}

// SetStoreID sets the "store_id" field.
func (m *AttendanceMutation) SetStoreID(u uint64) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *AttendanceMutation) StoreID() (r uint64, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldStoreID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *AttendanceMutation) ResetStoreID() {
	m.store = nil
}

// SetEmployeeID sets the "employee_id" field.
func (m *AttendanceMutation) SetEmployeeID(u uint64) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *AttendanceMutation) EmployeeID() (r uint64, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldEmployeeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *AttendanceMutation) ResetEmployeeID() {
	m.employee = nil
}

// SetInventory sets the "inventory" field.
func (m *AttendanceMutation) SetInventory(mi []model.AttendanceInventory) {
	m.inventory = &mi
	m.appendinventory = nil
}

// Inventory returns the value of the "inventory" field in the mutation.
func (m *AttendanceMutation) Inventory() (r []model.AttendanceInventory, exists bool) {
	v := m.inventory
	if v == nil {
		return
	}
	return *v, true
}

// OldInventory returns the old "inventory" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldInventory(ctx context.Context) (v []model.AttendanceInventory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInventory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInventory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInventory: %w", err)
	}
	return oldValue.Inventory, nil
}

// AppendInventory adds mi to the "inventory" field.
func (m *AttendanceMutation) AppendInventory(mi []model.AttendanceInventory) {
	m.appendinventory = append(m.appendinventory, mi...)
}

// AppendedInventory returns the list of values that were appended to the "inventory" field in this mutation.
func (m *AttendanceMutation) AppendedInventory() ([]model.AttendanceInventory, bool) {
	if len(m.appendinventory) == 0 {
		return nil, false
	}
	return m.appendinventory, true
}

// ClearInventory clears the value of the "inventory" field.
func (m *AttendanceMutation) ClearInventory() {
	m.inventory = nil
	m.appendinventory = nil
	m.clearedFields[attendance.FieldInventory] = struct{}{}
}

// InventoryCleared returns if the "inventory" field was cleared in this mutation.
func (m *AttendanceMutation) InventoryCleared() bool {
	_, ok := m.clearedFields[attendance.FieldInventory]
	return ok
}

// ResetInventory resets all changes to the "inventory" field.
func (m *AttendanceMutation) ResetInventory() {
	m.inventory = nil
	m.appendinventory = nil
	delete(m.clearedFields, attendance.FieldInventory)
}

// SetPhoto sets the "photo" field.
func (m *AttendanceMutation) SetPhoto(s string) {
	m.photo = &s
}

// Photo returns the value of the "photo" field in the mutation.
func (m *AttendanceMutation) Photo() (r string, exists bool) {
	v := m.photo
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoto returns the old "photo" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldPhoto(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoto is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoto requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoto: %w", err)
	}
	return oldValue.Photo, nil
}

// ClearPhoto clears the value of the "photo" field.
func (m *AttendanceMutation) ClearPhoto() {
	m.photo = nil
	m.clearedFields[attendance.FieldPhoto] = struct{}{}
}

// PhotoCleared returns if the "photo" field was cleared in this mutation.
func (m *AttendanceMutation) PhotoCleared() bool {
	_, ok := m.clearedFields[attendance.FieldPhoto]
	return ok
}

// ResetPhoto resets all changes to the "photo" field.
func (m *AttendanceMutation) ResetPhoto() {
	m.photo = nil
	delete(m.clearedFields, attendance.FieldPhoto)
}

// SetDuty sets the "duty" field.
func (m *AttendanceMutation) SetDuty(b bool) {
	m.duty = &b
}

// Duty returns the value of the "duty" field in the mutation.
func (m *AttendanceMutation) Duty() (r bool, exists bool) {
	v := m.duty
	if v == nil {
		return
	}
	return *v, true
}

// OldDuty returns the old "duty" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldDuty(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuty: %w", err)
	}
	return oldValue.Duty, nil
}

// ResetDuty resets all changes to the "duty" field.
func (m *AttendanceMutation) ResetDuty() {
	m.duty = nil
}

// SetDate sets the "date" field.
func (m *AttendanceMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *AttendanceMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *AttendanceMutation) ResetDate() {
	m.date = nil
}

// SetLng sets the "lng" field.
func (m *AttendanceMutation) SetLng(f float64) {
	m.lng = &f
	m.addlng = nil
}

// Lng returns the value of the "lng" field in the mutation.
func (m *AttendanceMutation) Lng() (r float64, exists bool) {
	v := m.lng
	if v == nil {
		return
	}
	return *v, true
}

// OldLng returns the old "lng" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldLng(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLng is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLng requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLng: %w", err)
	}
	return oldValue.Lng, nil
}

// AddLng adds f to the "lng" field.
func (m *AttendanceMutation) AddLng(f float64) {
	if m.addlng != nil {
		*m.addlng += f
	} else {
		m.addlng = &f
	}
}

// AddedLng returns the value that was added to the "lng" field in this mutation.
func (m *AttendanceMutation) AddedLng() (r float64, exists bool) {
	v := m.addlng
	if v == nil {
		return
	}
	return *v, true
}

// ClearLng clears the value of the "lng" field.
func (m *AttendanceMutation) ClearLng() {
	m.lng = nil
	m.addlng = nil
	m.clearedFields[attendance.FieldLng] = struct{}{}
}

// LngCleared returns if the "lng" field was cleared in this mutation.
func (m *AttendanceMutation) LngCleared() bool {
	_, ok := m.clearedFields[attendance.FieldLng]
	return ok
}

// ResetLng resets all changes to the "lng" field.
func (m *AttendanceMutation) ResetLng() {
	m.lng = nil
	m.addlng = nil
	delete(m.clearedFields, attendance.FieldLng)
}

// SetLat sets the "lat" field.
func (m *AttendanceMutation) SetLat(f float64) {
	m.lat = &f
	m.addlat = nil
}

// Lat returns the value of the "lat" field in the mutation.
func (m *AttendanceMutation) Lat() (r float64, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "lat" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldLat(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// AddLat adds f to the "lat" field.
func (m *AttendanceMutation) AddLat(f float64) {
	if m.addlat != nil {
		*m.addlat += f
	} else {
		m.addlat = &f
	}
}

// AddedLat returns the value that was added to the "lat" field in this mutation.
func (m *AttendanceMutation) AddedLat() (r float64, exists bool) {
	v := m.addlat
	if v == nil {
		return
	}
	return *v, true
}

// ClearLat clears the value of the "lat" field.
func (m *AttendanceMutation) ClearLat() {
	m.lat = nil
	m.addlat = nil
	m.clearedFields[attendance.FieldLat] = struct{}{}
}

// LatCleared returns if the "lat" field was cleared in this mutation.
func (m *AttendanceMutation) LatCleared() bool {
	_, ok := m.clearedFields[attendance.FieldLat]
	return ok
}

// ResetLat resets all changes to the "lat" field.
func (m *AttendanceMutation) ResetLat() {
	m.lat = nil
	m.addlat = nil
	delete(m.clearedFields, attendance.FieldLat)
}

// SetAddress sets the "address" field.
func (m *AttendanceMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *AttendanceMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *AttendanceMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[attendance.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *AttendanceMutation) AddressCleared() bool {
	_, ok := m.clearedFields[attendance.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *AttendanceMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, attendance.FieldAddress)
}

// SetDistance sets the "distance" field.
func (m *AttendanceMutation) SetDistance(f float64) {
	m.distance = &f
	m.adddistance = nil
}

// Distance returns the value of the "distance" field in the mutation.
func (m *AttendanceMutation) Distance() (r float64, exists bool) {
	v := m.distance
	if v == nil {
		return
	}
	return *v, true
}

// OldDistance returns the old "distance" field's value of the Attendance entity.
// If the Attendance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttendanceMutation) OldDistance(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistance: %w", err)
	}
	return oldValue.Distance, nil
}

// AddDistance adds f to the "distance" field.
func (m *AttendanceMutation) AddDistance(f float64) {
	if m.adddistance != nil {
		*m.adddistance += f
	} else {
		m.adddistance = &f
	}
}

// AddedDistance returns the value that was added to the "distance" field in this mutation.
func (m *AttendanceMutation) AddedDistance() (r float64, exists bool) {
	v := m.adddistance
	if v == nil {
		return
	}
	return *v, true
}

// ClearDistance clears the value of the "distance" field.
func (m *AttendanceMutation) ClearDistance() {
	m.distance = nil
	m.adddistance = nil
	m.clearedFields[attendance.FieldDistance] = struct{}{}
}

// DistanceCleared returns if the "distance" field was cleared in this mutation.
func (m *AttendanceMutation) DistanceCleared() bool {
	_, ok := m.clearedFields[attendance.FieldDistance]
	return ok
}

// ResetDistance resets all changes to the "distance" field.
func (m *AttendanceMutation) ResetDistance() {
	m.distance = nil
	m.adddistance = nil
	delete(m.clearedFields, attendance.FieldDistance)
}

// ClearStore clears the "store" edge to the Store entity.
func (m *AttendanceMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[attendance.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *AttendanceMutation) StoreCleared() bool {
	return m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *AttendanceMutation) StoreIDs() (ids []uint64) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *AttendanceMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *AttendanceMutation) ClearEmployee() {
	m.clearedemployee = true
	m.clearedFields[attendance.FieldEmployeeID] = struct{}{}
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *AttendanceMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *AttendanceMutation) EmployeeIDs() (ids []uint64) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *AttendanceMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// Where appends a list predicates to the AttendanceMutation builder.
func (m *AttendanceMutation) Where(ps ...predicate.Attendance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AttendanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AttendanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Attendance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AttendanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AttendanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Attendance).
func (m *AttendanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttendanceMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, attendance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, attendance.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, attendance.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, attendance.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, attendance.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, attendance.FieldRemark)
	}
	if m.store != nil {
		fields = append(fields, attendance.FieldStoreID)
	}
	if m.employee != nil {
		fields = append(fields, attendance.FieldEmployeeID)
	}
	if m.inventory != nil {
		fields = append(fields, attendance.FieldInventory)
	}
	if m.photo != nil {
		fields = append(fields, attendance.FieldPhoto)
	}
	if m.duty != nil {
		fields = append(fields, attendance.FieldDuty)
	}
	if m.date != nil {
		fields = append(fields, attendance.FieldDate)
	}
	if m.lng != nil {
		fields = append(fields, attendance.FieldLng)
	}
	if m.lat != nil {
		fields = append(fields, attendance.FieldLat)
	}
	if m.address != nil {
		fields = append(fields, attendance.FieldAddress)
	}
	if m.distance != nil {
		fields = append(fields, attendance.FieldDistance)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttendanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attendance.FieldCreatedAt:
		return m.CreatedAt()
	case attendance.FieldUpdatedAt:
		return m.UpdatedAt()
	case attendance.FieldDeletedAt:
		return m.DeletedAt()
	case attendance.FieldCreator:
		return m.Creator()
	case attendance.FieldLastModifier:
		return m.LastModifier()
	case attendance.FieldRemark:
		return m.Remark()
	case attendance.FieldStoreID:
		return m.StoreID()
	case attendance.FieldEmployeeID:
		return m.EmployeeID()
	case attendance.FieldInventory:
		return m.Inventory()
	case attendance.FieldPhoto:
		return m.Photo()
	case attendance.FieldDuty:
		return m.Duty()
	case attendance.FieldDate:
		return m.Date()
	case attendance.FieldLng:
		return m.Lng()
	case attendance.FieldLat:
		return m.Lat()
	case attendance.FieldAddress:
		return m.Address()
	case attendance.FieldDistance:
		return m.Distance()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttendanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attendance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case attendance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case attendance.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case attendance.FieldCreator:
		return m.OldCreator(ctx)
	case attendance.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case attendance.FieldRemark:
		return m.OldRemark(ctx)
	case attendance.FieldStoreID:
		return m.OldStoreID(ctx)
	case attendance.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case attendance.FieldInventory:
		return m.OldInventory(ctx)
	case attendance.FieldPhoto:
		return m.OldPhoto(ctx)
	case attendance.FieldDuty:
		return m.OldDuty(ctx)
	case attendance.FieldDate:
		return m.OldDate(ctx)
	case attendance.FieldLng:
		return m.OldLng(ctx)
	case attendance.FieldLat:
		return m.OldLat(ctx)
	case attendance.FieldAddress:
		return m.OldAddress(ctx)
	case attendance.FieldDistance:
		return m.OldDistance(ctx)
	}
	return nil, fmt.Errorf("unknown Attendance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttendanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attendance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case attendance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case attendance.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case attendance.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case attendance.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case attendance.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case attendance.FieldStoreID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case attendance.FieldEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case attendance.FieldInventory:
		v, ok := value.([]model.AttendanceInventory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInventory(v)
		return nil
	case attendance.FieldPhoto:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoto(v)
		return nil
	case attendance.FieldDuty:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuty(v)
		return nil
	case attendance.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case attendance.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLng(v)
		return nil
	case attendance.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	case attendance.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case attendance.FieldDistance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistance(v)
		return nil
	}
	return fmt.Errorf("unknown Attendance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttendanceMutation) AddedFields() []string {
	var fields []string
	if m.addlng != nil {
		fields = append(fields, attendance.FieldLng)
	}
	if m.addlat != nil {
		fields = append(fields, attendance.FieldLat)
	}
	if m.adddistance != nil {
		fields = append(fields, attendance.FieldDistance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttendanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case attendance.FieldLng:
		return m.AddedLng()
	case attendance.FieldLat:
		return m.AddedLat()
	case attendance.FieldDistance:
		return m.AddedDistance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttendanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case attendance.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLng(v)
		return nil
	case attendance.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLat(v)
		return nil
	case attendance.FieldDistance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDistance(v)
		return nil
	}
	return fmt.Errorf("unknown Attendance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttendanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(attendance.FieldDeletedAt) {
		fields = append(fields, attendance.FieldDeletedAt)
	}
	if m.FieldCleared(attendance.FieldCreator) {
		fields = append(fields, attendance.FieldCreator)
	}
	if m.FieldCleared(attendance.FieldLastModifier) {
		fields = append(fields, attendance.FieldLastModifier)
	}
	if m.FieldCleared(attendance.FieldRemark) {
		fields = append(fields, attendance.FieldRemark)
	}
	if m.FieldCleared(attendance.FieldInventory) {
		fields = append(fields, attendance.FieldInventory)
	}
	if m.FieldCleared(attendance.FieldPhoto) {
		fields = append(fields, attendance.FieldPhoto)
	}
	if m.FieldCleared(attendance.FieldLng) {
		fields = append(fields, attendance.FieldLng)
	}
	if m.FieldCleared(attendance.FieldLat) {
		fields = append(fields, attendance.FieldLat)
	}
	if m.FieldCleared(attendance.FieldAddress) {
		fields = append(fields, attendance.FieldAddress)
	}
	if m.FieldCleared(attendance.FieldDistance) {
		fields = append(fields, attendance.FieldDistance)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttendanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttendanceMutation) ClearField(name string) error {
	switch name {
	case attendance.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case attendance.FieldCreator:
		m.ClearCreator()
		return nil
	case attendance.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case attendance.FieldRemark:
		m.ClearRemark()
		return nil
	case attendance.FieldInventory:
		m.ClearInventory()
		return nil
	case attendance.FieldPhoto:
		m.ClearPhoto()
		return nil
	case attendance.FieldLng:
		m.ClearLng()
		return nil
	case attendance.FieldLat:
		m.ClearLat()
		return nil
	case attendance.FieldAddress:
		m.ClearAddress()
		return nil
	case attendance.FieldDistance:
		m.ClearDistance()
		return nil
	}
	return fmt.Errorf("unknown Attendance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttendanceMutation) ResetField(name string) error {
	switch name {
	case attendance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case attendance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case attendance.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case attendance.FieldCreator:
		m.ResetCreator()
		return nil
	case attendance.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case attendance.FieldRemark:
		m.ResetRemark()
		return nil
	case attendance.FieldStoreID:
		m.ResetStoreID()
		return nil
	case attendance.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case attendance.FieldInventory:
		m.ResetInventory()
		return nil
	case attendance.FieldPhoto:
		m.ResetPhoto()
		return nil
	case attendance.FieldDuty:
		m.ResetDuty()
		return nil
	case attendance.FieldDate:
		m.ResetDate()
		return nil
	case attendance.FieldLng:
		m.ResetLng()
		return nil
	case attendance.FieldLat:
		m.ResetLat()
		return nil
	case attendance.FieldAddress:
		m.ResetAddress()
		return nil
	case attendance.FieldDistance:
		m.ResetDistance()
		return nil
	}
	return fmt.Errorf("unknown Attendance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttendanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.store != nil {
		edges = append(edges, attendance.EdgeStore)
	}
	if m.employee != nil {
		edges = append(edges, attendance.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttendanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attendance.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	case attendance.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttendanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttendanceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttendanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstore {
		edges = append(edges, attendance.EdgeStore)
	}
	if m.clearedemployee {
		edges = append(edges, attendance.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttendanceMutation) EdgeCleared(name string) bool {
	switch name {
	case attendance.EdgeStore:
		return m.clearedstore
	case attendance.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttendanceMutation) ClearEdge(name string) error {
	switch name {
	case attendance.EdgeStore:
		m.ClearStore()
		return nil
	case attendance.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown Attendance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttendanceMutation) ResetEdge(name string) error {
	switch name {
	case attendance.EdgeStore:
		m.ResetStore()
		return nil
	case attendance.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Attendance edge %s", name)
}

// BatteryMutation represents an operation that mutates the Battery nodes in the graph.
type BatteryMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	sn                *string
	brand             *adapter.BatteryBrand
	enable            *bool
	model             *string
	ordinal           *int
	addordinal        *int
	clearedFields     map[string]struct{}
	city              *uint64
	clearedcity       bool
	rider             *uint64
	clearedrider      bool
	cabinet           *uint64
	clearedcabinet    bool
	subscribe         *uint64
	clearedsubscribe  bool
	enterprise        *uint64
	clearedenterprise bool
	flows             map[uint64]struct{}
	removedflows      map[uint64]struct{}
	clearedflows      bool
	station           *uint64
	clearedstation    bool
	done              bool
	oldValue          func(context.Context) (*Battery, error)
	predicates        []predicate.Battery
}

var _ ent.Mutation = (*BatteryMutation)(nil)

// batteryOption allows management of the mutation configuration using functional options.
type batteryOption func(*BatteryMutation)

// newBatteryMutation creates new mutation for the Battery entity.
func newBatteryMutation(c config, op Op, opts ...batteryOption) *BatteryMutation {
	m := &BatteryMutation{
		config:        c,
		op:            op,
		typ:           TypeBattery,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBatteryID sets the ID field of the mutation.
func withBatteryID(id uint64) batteryOption {
	return func(m *BatteryMutation) {
		var (
			err   error
			once  sync.Once
			value *Battery
		)
		m.oldValue = func(ctx context.Context) (*Battery, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Battery.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBattery sets the old Battery of the mutation.
func withBattery(node *Battery) batteryOption {
	return func(m *BatteryMutation) {
		m.oldValue = func(context.Context) (*Battery, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BatteryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BatteryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BatteryMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BatteryMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Battery.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BatteryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BatteryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BatteryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BatteryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BatteryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BatteryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BatteryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BatteryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BatteryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[battery.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BatteryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[battery.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BatteryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, battery.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *BatteryMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *BatteryMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *BatteryMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[battery.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *BatteryMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[battery.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *BatteryMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, battery.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *BatteryMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *BatteryMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *BatteryMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[battery.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *BatteryMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[battery.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *BatteryMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, battery.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *BatteryMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *BatteryMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *BatteryMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[battery.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *BatteryMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[battery.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *BatteryMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, battery.FieldRemark)
}

// SetCityID sets the "city_id" field.
func (m *BatteryMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *BatteryMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldCityID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ClearCityID clears the value of the "city_id" field.
func (m *BatteryMutation) ClearCityID() {
	m.city = nil
	m.clearedFields[battery.FieldCityID] = struct{}{}
}

// CityIDCleared returns if the "city_id" field was cleared in this mutation.
func (m *BatteryMutation) CityIDCleared() bool {
	_, ok := m.clearedFields[battery.FieldCityID]
	return ok
}

// ResetCityID resets all changes to the "city_id" field.
func (m *BatteryMutation) ResetCityID() {
	m.city = nil
	delete(m.clearedFields, battery.FieldCityID)
}

// SetRiderID sets the "rider_id" field.
func (m *BatteryMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *BatteryMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldRiderID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ClearRiderID clears the value of the "rider_id" field.
func (m *BatteryMutation) ClearRiderID() {
	m.rider = nil
	m.clearedFields[battery.FieldRiderID] = struct{}{}
}

// RiderIDCleared returns if the "rider_id" field was cleared in this mutation.
func (m *BatteryMutation) RiderIDCleared() bool {
	_, ok := m.clearedFields[battery.FieldRiderID]
	return ok
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *BatteryMutation) ResetRiderID() {
	m.rider = nil
	delete(m.clearedFields, battery.FieldRiderID)
}

// SetCabinetID sets the "cabinet_id" field.
func (m *BatteryMutation) SetCabinetID(u uint64) {
	m.cabinet = &u
}

// CabinetID returns the value of the "cabinet_id" field in the mutation.
func (m *BatteryMutation) CabinetID() (r uint64, exists bool) {
	v := m.cabinet
	if v == nil {
		return
	}
	return *v, true
}

// OldCabinetID returns the old "cabinet_id" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldCabinetID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCabinetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCabinetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCabinetID: %w", err)
	}
	return oldValue.CabinetID, nil
}

// ClearCabinetID clears the value of the "cabinet_id" field.
func (m *BatteryMutation) ClearCabinetID() {
	m.cabinet = nil
	m.clearedFields[battery.FieldCabinetID] = struct{}{}
}

// CabinetIDCleared returns if the "cabinet_id" field was cleared in this mutation.
func (m *BatteryMutation) CabinetIDCleared() bool {
	_, ok := m.clearedFields[battery.FieldCabinetID]
	return ok
}

// ResetCabinetID resets all changes to the "cabinet_id" field.
func (m *BatteryMutation) ResetCabinetID() {
	m.cabinet = nil
	delete(m.clearedFields, battery.FieldCabinetID)
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *BatteryMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *BatteryMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldSubscribeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ClearSubscribeID clears the value of the "subscribe_id" field.
func (m *BatteryMutation) ClearSubscribeID() {
	m.subscribe = nil
	m.clearedFields[battery.FieldSubscribeID] = struct{}{}
}

// SubscribeIDCleared returns if the "subscribe_id" field was cleared in this mutation.
func (m *BatteryMutation) SubscribeIDCleared() bool {
	_, ok := m.clearedFields[battery.FieldSubscribeID]
	return ok
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *BatteryMutation) ResetSubscribeID() {
	m.subscribe = nil
	delete(m.clearedFields, battery.FieldSubscribeID)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *BatteryMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *BatteryMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldEnterpriseID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ClearEnterpriseID clears the value of the "enterprise_id" field.
func (m *BatteryMutation) ClearEnterpriseID() {
	m.enterprise = nil
	m.clearedFields[battery.FieldEnterpriseID] = struct{}{}
}

// EnterpriseIDCleared returns if the "enterprise_id" field was cleared in this mutation.
func (m *BatteryMutation) EnterpriseIDCleared() bool {
	_, ok := m.clearedFields[battery.FieldEnterpriseID]
	return ok
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *BatteryMutation) ResetEnterpriseID() {
	m.enterprise = nil
	delete(m.clearedFields, battery.FieldEnterpriseID)
}

// SetStationID sets the "station_id" field.
func (m *BatteryMutation) SetStationID(u uint64) {
	m.station = &u
}

// StationID returns the value of the "station_id" field in the mutation.
func (m *BatteryMutation) StationID() (r uint64, exists bool) {
	v := m.station
	if v == nil {
		return
	}
	return *v, true
}

// OldStationID returns the old "station_id" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldStationID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStationID: %w", err)
	}
	return oldValue.StationID, nil
}

// ClearStationID clears the value of the "station_id" field.
func (m *BatteryMutation) ClearStationID() {
	m.station = nil
	m.clearedFields[battery.FieldStationID] = struct{}{}
}

// StationIDCleared returns if the "station_id" field was cleared in this mutation.
func (m *BatteryMutation) StationIDCleared() bool {
	_, ok := m.clearedFields[battery.FieldStationID]
	return ok
}

// ResetStationID resets all changes to the "station_id" field.
func (m *BatteryMutation) ResetStationID() {
	m.station = nil
	delete(m.clearedFields, battery.FieldStationID)
}

// SetSn sets the "sn" field.
func (m *BatteryMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *BatteryMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *BatteryMutation) ResetSn() {
	m.sn = nil
}

// SetBrand sets the "brand" field.
func (m *BatteryMutation) SetBrand(ab adapter.BatteryBrand) {
	m.brand = &ab
}

// Brand returns the value of the "brand" field in the mutation.
func (m *BatteryMutation) Brand() (r adapter.BatteryBrand, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrand returns the old "brand" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldBrand(ctx context.Context) (v adapter.BatteryBrand, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrand: %w", err)
	}
	return oldValue.Brand, nil
}

// ResetBrand resets all changes to the "brand" field.
func (m *BatteryMutation) ResetBrand() {
	m.brand = nil
}

// SetEnable sets the "enable" field.
func (m *BatteryMutation) SetEnable(b bool) {
	m.enable = &b
}

// Enable returns the value of the "enable" field in the mutation.
func (m *BatteryMutation) Enable() (r bool, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// ResetEnable resets all changes to the "enable" field.
func (m *BatteryMutation) ResetEnable() {
	m.enable = nil
}

// SetModel sets the "model" field.
func (m *BatteryMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *BatteryMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *BatteryMutation) ResetModel() {
	m.model = nil
}

// SetOrdinal sets the "ordinal" field.
func (m *BatteryMutation) SetOrdinal(i int) {
	m.ordinal = &i
	m.addordinal = nil
}

// Ordinal returns the value of the "ordinal" field in the mutation.
func (m *BatteryMutation) Ordinal() (r int, exists bool) {
	v := m.ordinal
	if v == nil {
		return
	}
	return *v, true
}

// OldOrdinal returns the old "ordinal" field's value of the Battery entity.
// If the Battery object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryMutation) OldOrdinal(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrdinal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrdinal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrdinal: %w", err)
	}
	return oldValue.Ordinal, nil
}

// AddOrdinal adds i to the "ordinal" field.
func (m *BatteryMutation) AddOrdinal(i int) {
	if m.addordinal != nil {
		*m.addordinal += i
	} else {
		m.addordinal = &i
	}
}

// AddedOrdinal returns the value that was added to the "ordinal" field in this mutation.
func (m *BatteryMutation) AddedOrdinal() (r int, exists bool) {
	v := m.addordinal
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrdinal clears the value of the "ordinal" field.
func (m *BatteryMutation) ClearOrdinal() {
	m.ordinal = nil
	m.addordinal = nil
	m.clearedFields[battery.FieldOrdinal] = struct{}{}
}

// OrdinalCleared returns if the "ordinal" field was cleared in this mutation.
func (m *BatteryMutation) OrdinalCleared() bool {
	_, ok := m.clearedFields[battery.FieldOrdinal]
	return ok
}

// ResetOrdinal resets all changes to the "ordinal" field.
func (m *BatteryMutation) ResetOrdinal() {
	m.ordinal = nil
	m.addordinal = nil
	delete(m.clearedFields, battery.FieldOrdinal)
}

// ClearCity clears the "city" edge to the City entity.
func (m *BatteryMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[battery.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *BatteryMutation) CityCleared() bool {
	return m.CityIDCleared() || m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *BatteryMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *BatteryMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *BatteryMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[battery.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *BatteryMutation) RiderCleared() bool {
	return m.RiderIDCleared() || m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *BatteryMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *BatteryMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearCabinet clears the "cabinet" edge to the Cabinet entity.
func (m *BatteryMutation) ClearCabinet() {
	m.clearedcabinet = true
	m.clearedFields[battery.FieldCabinetID] = struct{}{}
}

// CabinetCleared reports if the "cabinet" edge to the Cabinet entity was cleared.
func (m *BatteryMutation) CabinetCleared() bool {
	return m.CabinetIDCleared() || m.clearedcabinet
}

// CabinetIDs returns the "cabinet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CabinetID instead. It exists only for internal usage by the builders.
func (m *BatteryMutation) CabinetIDs() (ids []uint64) {
	if id := m.cabinet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCabinet resets all changes to the "cabinet" edge.
func (m *BatteryMutation) ResetCabinet() {
	m.cabinet = nil
	m.clearedcabinet = false
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *BatteryMutation) ClearSubscribe() {
	m.clearedsubscribe = true
	m.clearedFields[battery.FieldSubscribeID] = struct{}{}
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *BatteryMutation) SubscribeCleared() bool {
	return m.SubscribeIDCleared() || m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *BatteryMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *BatteryMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *BatteryMutation) ClearEnterprise() {
	m.clearedenterprise = true
	m.clearedFields[battery.FieldEnterpriseID] = struct{}{}
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *BatteryMutation) EnterpriseCleared() bool {
	return m.EnterpriseIDCleared() || m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *BatteryMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *BatteryMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// AddFlowIDs adds the "flows" edge to the BatteryFlow entity by ids.
func (m *BatteryMutation) AddFlowIDs(ids ...uint64) {
	if m.flows == nil {
		m.flows = make(map[uint64]struct{})
	}
	for i := range ids {
		m.flows[ids[i]] = struct{}{}
	}
}

// ClearFlows clears the "flows" edge to the BatteryFlow entity.
func (m *BatteryMutation) ClearFlows() {
	m.clearedflows = true
}

// FlowsCleared reports if the "flows" edge to the BatteryFlow entity was cleared.
func (m *BatteryMutation) FlowsCleared() bool {
	return m.clearedflows
}

// RemoveFlowIDs removes the "flows" edge to the BatteryFlow entity by IDs.
func (m *BatteryMutation) RemoveFlowIDs(ids ...uint64) {
	if m.removedflows == nil {
		m.removedflows = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.flows, ids[i])
		m.removedflows[ids[i]] = struct{}{}
	}
}

// RemovedFlows returns the removed IDs of the "flows" edge to the BatteryFlow entity.
func (m *BatteryMutation) RemovedFlowsIDs() (ids []uint64) {
	for id := range m.removedflows {
		ids = append(ids, id)
	}
	return
}

// FlowsIDs returns the "flows" edge IDs in the mutation.
func (m *BatteryMutation) FlowsIDs() (ids []uint64) {
	for id := range m.flows {
		ids = append(ids, id)
	}
	return
}

// ResetFlows resets all changes to the "flows" edge.
func (m *BatteryMutation) ResetFlows() {
	m.flows = nil
	m.clearedflows = false
	m.removedflows = nil
}

// ClearStation clears the "station" edge to the EnterpriseStation entity.
func (m *BatteryMutation) ClearStation() {
	m.clearedstation = true
	m.clearedFields[battery.FieldStationID] = struct{}{}
}

// StationCleared reports if the "station" edge to the EnterpriseStation entity was cleared.
func (m *BatteryMutation) StationCleared() bool {
	return m.StationIDCleared() || m.clearedstation
}

// StationIDs returns the "station" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StationID instead. It exists only for internal usage by the builders.
func (m *BatteryMutation) StationIDs() (ids []uint64) {
	if id := m.station; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStation resets all changes to the "station" edge.
func (m *BatteryMutation) ResetStation() {
	m.station = nil
	m.clearedstation = false
}

// Where appends a list predicates to the BatteryMutation builder.
func (m *BatteryMutation) Where(ps ...predicate.Battery) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BatteryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BatteryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Battery, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BatteryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BatteryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Battery).
func (m *BatteryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BatteryMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, battery.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, battery.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, battery.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, battery.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, battery.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, battery.FieldRemark)
	}
	if m.city != nil {
		fields = append(fields, battery.FieldCityID)
	}
	if m.rider != nil {
		fields = append(fields, battery.FieldRiderID)
	}
	if m.cabinet != nil {
		fields = append(fields, battery.FieldCabinetID)
	}
	if m.subscribe != nil {
		fields = append(fields, battery.FieldSubscribeID)
	}
	if m.enterprise != nil {
		fields = append(fields, battery.FieldEnterpriseID)
	}
	if m.station != nil {
		fields = append(fields, battery.FieldStationID)
	}
	if m.sn != nil {
		fields = append(fields, battery.FieldSn)
	}
	if m.brand != nil {
		fields = append(fields, battery.FieldBrand)
	}
	if m.enable != nil {
		fields = append(fields, battery.FieldEnable)
	}
	if m.model != nil {
		fields = append(fields, battery.FieldModel)
	}
	if m.ordinal != nil {
		fields = append(fields, battery.FieldOrdinal)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BatteryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case battery.FieldCreatedAt:
		return m.CreatedAt()
	case battery.FieldUpdatedAt:
		return m.UpdatedAt()
	case battery.FieldDeletedAt:
		return m.DeletedAt()
	case battery.FieldCreator:
		return m.Creator()
	case battery.FieldLastModifier:
		return m.LastModifier()
	case battery.FieldRemark:
		return m.Remark()
	case battery.FieldCityID:
		return m.CityID()
	case battery.FieldRiderID:
		return m.RiderID()
	case battery.FieldCabinetID:
		return m.CabinetID()
	case battery.FieldSubscribeID:
		return m.SubscribeID()
	case battery.FieldEnterpriseID:
		return m.EnterpriseID()
	case battery.FieldStationID:
		return m.StationID()
	case battery.FieldSn:
		return m.Sn()
	case battery.FieldBrand:
		return m.Brand()
	case battery.FieldEnable:
		return m.Enable()
	case battery.FieldModel:
		return m.Model()
	case battery.FieldOrdinal:
		return m.Ordinal()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BatteryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case battery.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case battery.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case battery.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case battery.FieldCreator:
		return m.OldCreator(ctx)
	case battery.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case battery.FieldRemark:
		return m.OldRemark(ctx)
	case battery.FieldCityID:
		return m.OldCityID(ctx)
	case battery.FieldRiderID:
		return m.OldRiderID(ctx)
	case battery.FieldCabinetID:
		return m.OldCabinetID(ctx)
	case battery.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case battery.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case battery.FieldStationID:
		return m.OldStationID(ctx)
	case battery.FieldSn:
		return m.OldSn(ctx)
	case battery.FieldBrand:
		return m.OldBrand(ctx)
	case battery.FieldEnable:
		return m.OldEnable(ctx)
	case battery.FieldModel:
		return m.OldModel(ctx)
	case battery.FieldOrdinal:
		return m.OldOrdinal(ctx)
	}
	return nil, fmt.Errorf("unknown Battery field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BatteryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case battery.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case battery.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case battery.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case battery.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case battery.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case battery.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case battery.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case battery.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case battery.FieldCabinetID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCabinetID(v)
		return nil
	case battery.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case battery.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case battery.FieldStationID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStationID(v)
		return nil
	case battery.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case battery.FieldBrand:
		v, ok := value.(adapter.BatteryBrand)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrand(v)
		return nil
	case battery.FieldEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case battery.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case battery.FieldOrdinal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrdinal(v)
		return nil
	}
	return fmt.Errorf("unknown Battery field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BatteryMutation) AddedFields() []string {
	var fields []string
	if m.addordinal != nil {
		fields = append(fields, battery.FieldOrdinal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BatteryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case battery.FieldOrdinal:
		return m.AddedOrdinal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BatteryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case battery.FieldOrdinal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrdinal(v)
		return nil
	}
	return fmt.Errorf("unknown Battery numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BatteryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(battery.FieldDeletedAt) {
		fields = append(fields, battery.FieldDeletedAt)
	}
	if m.FieldCleared(battery.FieldCreator) {
		fields = append(fields, battery.FieldCreator)
	}
	if m.FieldCleared(battery.FieldLastModifier) {
		fields = append(fields, battery.FieldLastModifier)
	}
	if m.FieldCleared(battery.FieldRemark) {
		fields = append(fields, battery.FieldRemark)
	}
	if m.FieldCleared(battery.FieldCityID) {
		fields = append(fields, battery.FieldCityID)
	}
	if m.FieldCleared(battery.FieldRiderID) {
		fields = append(fields, battery.FieldRiderID)
	}
	if m.FieldCleared(battery.FieldCabinetID) {
		fields = append(fields, battery.FieldCabinetID)
	}
	if m.FieldCleared(battery.FieldSubscribeID) {
		fields = append(fields, battery.FieldSubscribeID)
	}
	if m.FieldCleared(battery.FieldEnterpriseID) {
		fields = append(fields, battery.FieldEnterpriseID)
	}
	if m.FieldCleared(battery.FieldStationID) {
		fields = append(fields, battery.FieldStationID)
	}
	if m.FieldCleared(battery.FieldOrdinal) {
		fields = append(fields, battery.FieldOrdinal)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BatteryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BatteryMutation) ClearField(name string) error {
	switch name {
	case battery.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case battery.FieldCreator:
		m.ClearCreator()
		return nil
	case battery.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case battery.FieldRemark:
		m.ClearRemark()
		return nil
	case battery.FieldCityID:
		m.ClearCityID()
		return nil
	case battery.FieldRiderID:
		m.ClearRiderID()
		return nil
	case battery.FieldCabinetID:
		m.ClearCabinetID()
		return nil
	case battery.FieldSubscribeID:
		m.ClearSubscribeID()
		return nil
	case battery.FieldEnterpriseID:
		m.ClearEnterpriseID()
		return nil
	case battery.FieldStationID:
		m.ClearStationID()
		return nil
	case battery.FieldOrdinal:
		m.ClearOrdinal()
		return nil
	}
	return fmt.Errorf("unknown Battery nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BatteryMutation) ResetField(name string) error {
	switch name {
	case battery.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case battery.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case battery.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case battery.FieldCreator:
		m.ResetCreator()
		return nil
	case battery.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case battery.FieldRemark:
		m.ResetRemark()
		return nil
	case battery.FieldCityID:
		m.ResetCityID()
		return nil
	case battery.FieldRiderID:
		m.ResetRiderID()
		return nil
	case battery.FieldCabinetID:
		m.ResetCabinetID()
		return nil
	case battery.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case battery.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case battery.FieldStationID:
		m.ResetStationID()
		return nil
	case battery.FieldSn:
		m.ResetSn()
		return nil
	case battery.FieldBrand:
		m.ResetBrand()
		return nil
	case battery.FieldEnable:
		m.ResetEnable()
		return nil
	case battery.FieldModel:
		m.ResetModel()
		return nil
	case battery.FieldOrdinal:
		m.ResetOrdinal()
		return nil
	}
	return fmt.Errorf("unknown Battery field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BatteryMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.city != nil {
		edges = append(edges, battery.EdgeCity)
	}
	if m.rider != nil {
		edges = append(edges, battery.EdgeRider)
	}
	if m.cabinet != nil {
		edges = append(edges, battery.EdgeCabinet)
	}
	if m.subscribe != nil {
		edges = append(edges, battery.EdgeSubscribe)
	}
	if m.enterprise != nil {
		edges = append(edges, battery.EdgeEnterprise)
	}
	if m.flows != nil {
		edges = append(edges, battery.EdgeFlows)
	}
	if m.station != nil {
		edges = append(edges, battery.EdgeStation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BatteryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case battery.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case battery.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case battery.EdgeCabinet:
		if id := m.cabinet; id != nil {
			return []ent.Value{*id}
		}
	case battery.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	case battery.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	case battery.EdgeFlows:
		ids := make([]ent.Value, 0, len(m.flows))
		for id := range m.flows {
			ids = append(ids, id)
		}
		return ids
	case battery.EdgeStation:
		if id := m.station; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BatteryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedflows != nil {
		edges = append(edges, battery.EdgeFlows)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BatteryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case battery.EdgeFlows:
		ids := make([]ent.Value, 0, len(m.removedflows))
		for id := range m.removedflows {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BatteryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedcity {
		edges = append(edges, battery.EdgeCity)
	}
	if m.clearedrider {
		edges = append(edges, battery.EdgeRider)
	}
	if m.clearedcabinet {
		edges = append(edges, battery.EdgeCabinet)
	}
	if m.clearedsubscribe {
		edges = append(edges, battery.EdgeSubscribe)
	}
	if m.clearedenterprise {
		edges = append(edges, battery.EdgeEnterprise)
	}
	if m.clearedflows {
		edges = append(edges, battery.EdgeFlows)
	}
	if m.clearedstation {
		edges = append(edges, battery.EdgeStation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BatteryMutation) EdgeCleared(name string) bool {
	switch name {
	case battery.EdgeCity:
		return m.clearedcity
	case battery.EdgeRider:
		return m.clearedrider
	case battery.EdgeCabinet:
		return m.clearedcabinet
	case battery.EdgeSubscribe:
		return m.clearedsubscribe
	case battery.EdgeEnterprise:
		return m.clearedenterprise
	case battery.EdgeFlows:
		return m.clearedflows
	case battery.EdgeStation:
		return m.clearedstation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BatteryMutation) ClearEdge(name string) error {
	switch name {
	case battery.EdgeCity:
		m.ClearCity()
		return nil
	case battery.EdgeRider:
		m.ClearRider()
		return nil
	case battery.EdgeCabinet:
		m.ClearCabinet()
		return nil
	case battery.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	case battery.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	case battery.EdgeStation:
		m.ClearStation()
		return nil
	}
	return fmt.Errorf("unknown Battery unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BatteryMutation) ResetEdge(name string) error {
	switch name {
	case battery.EdgeCity:
		m.ResetCity()
		return nil
	case battery.EdgeRider:
		m.ResetRider()
		return nil
	case battery.EdgeCabinet:
		m.ResetCabinet()
		return nil
	case battery.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	case battery.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	case battery.EdgeFlows:
		m.ResetFlows()
		return nil
	case battery.EdgeStation:
		m.ResetStation()
		return nil
	}
	return fmt.Errorf("unknown Battery edge %s", name)
}

// BatteryFlowMutation represents an operation that mutates the BatteryFlow nodes in the graph.
type BatteryFlowMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	created_at       *time.Time
	updated_at       *time.Time
	sn               *string
	soc              *float64
	addsoc           *float64
	serial           *string
	ordinal          *int
	addordinal       *int
	geom             **adapter.Geometry
	remark           *string
	clearedFields    map[string]struct{}
	subscribe        *uint64
	clearedsubscribe bool
	battery          *uint64
	clearedbattery   bool
	cabinet          *uint64
	clearedcabinet   bool
	rider            *uint64
	clearedrider     bool
	done             bool
	oldValue         func(context.Context) (*BatteryFlow, error)
	predicates       []predicate.BatteryFlow
}

var _ ent.Mutation = (*BatteryFlowMutation)(nil)

// batteryflowOption allows management of the mutation configuration using functional options.
type batteryflowOption func(*BatteryFlowMutation)

// newBatteryFlowMutation creates new mutation for the BatteryFlow entity.
func newBatteryFlowMutation(c config, op Op, opts ...batteryflowOption) *BatteryFlowMutation {
	m := &BatteryFlowMutation{
		config:        c,
		op:            op,
		typ:           TypeBatteryFlow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBatteryFlowID sets the ID field of the mutation.
func withBatteryFlowID(id uint64) batteryflowOption {
	return func(m *BatteryFlowMutation) {
		var (
			err   error
			once  sync.Once
			value *BatteryFlow
		)
		m.oldValue = func(ctx context.Context) (*BatteryFlow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BatteryFlow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBatteryFlow sets the old BatteryFlow of the mutation.
func withBatteryFlow(node *BatteryFlow) batteryflowOption {
	return func(m *BatteryFlowMutation) {
		m.oldValue = func(context.Context) (*BatteryFlow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BatteryFlowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BatteryFlowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BatteryFlowMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BatteryFlowMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BatteryFlow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BatteryFlowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BatteryFlowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BatteryFlow entity.
// If the BatteryFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryFlowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BatteryFlowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BatteryFlowMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BatteryFlowMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BatteryFlow entity.
// If the BatteryFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryFlowMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BatteryFlowMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *BatteryFlowMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *BatteryFlowMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the BatteryFlow entity.
// If the BatteryFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryFlowMutation) OldSubscribeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ClearSubscribeID clears the value of the "subscribe_id" field.
func (m *BatteryFlowMutation) ClearSubscribeID() {
	m.subscribe = nil
	m.clearedFields[batteryflow.FieldSubscribeID] = struct{}{}
}

// SubscribeIDCleared returns if the "subscribe_id" field was cleared in this mutation.
func (m *BatteryFlowMutation) SubscribeIDCleared() bool {
	_, ok := m.clearedFields[batteryflow.FieldSubscribeID]
	return ok
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *BatteryFlowMutation) ResetSubscribeID() {
	m.subscribe = nil
	delete(m.clearedFields, batteryflow.FieldSubscribeID)
}

// SetBatteryID sets the "battery_id" field.
func (m *BatteryFlowMutation) SetBatteryID(u uint64) {
	m.battery = &u
}

// BatteryID returns the value of the "battery_id" field in the mutation.
func (m *BatteryFlowMutation) BatteryID() (r uint64, exists bool) {
	v := m.battery
	if v == nil {
		return
	}
	return *v, true
}

// OldBatteryID returns the old "battery_id" field's value of the BatteryFlow entity.
// If the BatteryFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryFlowMutation) OldBatteryID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatteryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatteryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatteryID: %w", err)
	}
	return oldValue.BatteryID, nil
}

// ResetBatteryID resets all changes to the "battery_id" field.
func (m *BatteryFlowMutation) ResetBatteryID() {
	m.battery = nil
}

// SetSn sets the "sn" field.
func (m *BatteryFlowMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *BatteryFlowMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the BatteryFlow entity.
// If the BatteryFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryFlowMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *BatteryFlowMutation) ResetSn() {
	m.sn = nil
}

// SetSoc sets the "soc" field.
func (m *BatteryFlowMutation) SetSoc(f float64) {
	m.soc = &f
	m.addsoc = nil
}

// Soc returns the value of the "soc" field in the mutation.
func (m *BatteryFlowMutation) Soc() (r float64, exists bool) {
	v := m.soc
	if v == nil {
		return
	}
	return *v, true
}

// OldSoc returns the old "soc" field's value of the BatteryFlow entity.
// If the BatteryFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryFlowMutation) OldSoc(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoc: %w", err)
	}
	return oldValue.Soc, nil
}

// AddSoc adds f to the "soc" field.
func (m *BatteryFlowMutation) AddSoc(f float64) {
	if m.addsoc != nil {
		*m.addsoc += f
	} else {
		m.addsoc = &f
	}
}

// AddedSoc returns the value that was added to the "soc" field in this mutation.
func (m *BatteryFlowMutation) AddedSoc() (r float64, exists bool) {
	v := m.addsoc
	if v == nil {
		return
	}
	return *v, true
}

// ResetSoc resets all changes to the "soc" field.
func (m *BatteryFlowMutation) ResetSoc() {
	m.soc = nil
	m.addsoc = nil
}

// SetRiderID sets the "rider_id" field.
func (m *BatteryFlowMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *BatteryFlowMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the BatteryFlow entity.
// If the BatteryFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryFlowMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ClearRiderID clears the value of the "rider_id" field.
func (m *BatteryFlowMutation) ClearRiderID() {
	m.rider = nil
	m.clearedFields[batteryflow.FieldRiderID] = struct{}{}
}

// RiderIDCleared returns if the "rider_id" field was cleared in this mutation.
func (m *BatteryFlowMutation) RiderIDCleared() bool {
	_, ok := m.clearedFields[batteryflow.FieldRiderID]
	return ok
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *BatteryFlowMutation) ResetRiderID() {
	m.rider = nil
	delete(m.clearedFields, batteryflow.FieldRiderID)
}

// SetCabinetID sets the "cabinet_id" field.
func (m *BatteryFlowMutation) SetCabinetID(u uint64) {
	m.cabinet = &u
}

// CabinetID returns the value of the "cabinet_id" field in the mutation.
func (m *BatteryFlowMutation) CabinetID() (r uint64, exists bool) {
	v := m.cabinet
	if v == nil {
		return
	}
	return *v, true
}

// OldCabinetID returns the old "cabinet_id" field's value of the BatteryFlow entity.
// If the BatteryFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryFlowMutation) OldCabinetID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCabinetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCabinetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCabinetID: %w", err)
	}
	return oldValue.CabinetID, nil
}

// ClearCabinetID clears the value of the "cabinet_id" field.
func (m *BatteryFlowMutation) ClearCabinetID() {
	m.cabinet = nil
	m.clearedFields[batteryflow.FieldCabinetID] = struct{}{}
}

// CabinetIDCleared returns if the "cabinet_id" field was cleared in this mutation.
func (m *BatteryFlowMutation) CabinetIDCleared() bool {
	_, ok := m.clearedFields[batteryflow.FieldCabinetID]
	return ok
}

// ResetCabinetID resets all changes to the "cabinet_id" field.
func (m *BatteryFlowMutation) ResetCabinetID() {
	m.cabinet = nil
	delete(m.clearedFields, batteryflow.FieldCabinetID)
}

// SetSerial sets the "serial" field.
func (m *BatteryFlowMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *BatteryFlowMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the BatteryFlow entity.
// If the BatteryFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryFlowMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ClearSerial clears the value of the "serial" field.
func (m *BatteryFlowMutation) ClearSerial() {
	m.serial = nil
	m.clearedFields[batteryflow.FieldSerial] = struct{}{}
}

// SerialCleared returns if the "serial" field was cleared in this mutation.
func (m *BatteryFlowMutation) SerialCleared() bool {
	_, ok := m.clearedFields[batteryflow.FieldSerial]
	return ok
}

// ResetSerial resets all changes to the "serial" field.
func (m *BatteryFlowMutation) ResetSerial() {
	m.serial = nil
	delete(m.clearedFields, batteryflow.FieldSerial)
}

// SetOrdinal sets the "ordinal" field.
func (m *BatteryFlowMutation) SetOrdinal(i int) {
	m.ordinal = &i
	m.addordinal = nil
}

// Ordinal returns the value of the "ordinal" field in the mutation.
func (m *BatteryFlowMutation) Ordinal() (r int, exists bool) {
	v := m.ordinal
	if v == nil {
		return
	}
	return *v, true
}

// OldOrdinal returns the old "ordinal" field's value of the BatteryFlow entity.
// If the BatteryFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryFlowMutation) OldOrdinal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrdinal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrdinal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrdinal: %w", err)
	}
	return oldValue.Ordinal, nil
}

// AddOrdinal adds i to the "ordinal" field.
func (m *BatteryFlowMutation) AddOrdinal(i int) {
	if m.addordinal != nil {
		*m.addordinal += i
	} else {
		m.addordinal = &i
	}
}

// AddedOrdinal returns the value that was added to the "ordinal" field in this mutation.
func (m *BatteryFlowMutation) AddedOrdinal() (r int, exists bool) {
	v := m.addordinal
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrdinal clears the value of the "ordinal" field.
func (m *BatteryFlowMutation) ClearOrdinal() {
	m.ordinal = nil
	m.addordinal = nil
	m.clearedFields[batteryflow.FieldOrdinal] = struct{}{}
}

// OrdinalCleared returns if the "ordinal" field was cleared in this mutation.
func (m *BatteryFlowMutation) OrdinalCleared() bool {
	_, ok := m.clearedFields[batteryflow.FieldOrdinal]
	return ok
}

// ResetOrdinal resets all changes to the "ordinal" field.
func (m *BatteryFlowMutation) ResetOrdinal() {
	m.ordinal = nil
	m.addordinal = nil
	delete(m.clearedFields, batteryflow.FieldOrdinal)
}

// SetGeom sets the "geom" field.
func (m *BatteryFlowMutation) SetGeom(a *adapter.Geometry) {
	m.geom = &a
}

// Geom returns the value of the "geom" field in the mutation.
func (m *BatteryFlowMutation) Geom() (r *adapter.Geometry, exists bool) {
	v := m.geom
	if v == nil {
		return
	}
	return *v, true
}

// OldGeom returns the old "geom" field's value of the BatteryFlow entity.
// If the BatteryFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryFlowMutation) OldGeom(ctx context.Context) (v *adapter.Geometry, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeom: %w", err)
	}
	return oldValue.Geom, nil
}

// ClearGeom clears the value of the "geom" field.
func (m *BatteryFlowMutation) ClearGeom() {
	m.geom = nil
	m.clearedFields[batteryflow.FieldGeom] = struct{}{}
}

// GeomCleared returns if the "geom" field was cleared in this mutation.
func (m *BatteryFlowMutation) GeomCleared() bool {
	_, ok := m.clearedFields[batteryflow.FieldGeom]
	return ok
}

// ResetGeom resets all changes to the "geom" field.
func (m *BatteryFlowMutation) ResetGeom() {
	m.geom = nil
	delete(m.clearedFields, batteryflow.FieldGeom)
}

// SetRemark sets the "remark" field.
func (m *BatteryFlowMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *BatteryFlowMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the BatteryFlow entity.
// If the BatteryFlow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryFlowMutation) OldRemark(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *BatteryFlowMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[batteryflow.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *BatteryFlowMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[batteryflow.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *BatteryFlowMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, batteryflow.FieldRemark)
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *BatteryFlowMutation) ClearSubscribe() {
	m.clearedsubscribe = true
	m.clearedFields[batteryflow.FieldSubscribeID] = struct{}{}
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *BatteryFlowMutation) SubscribeCleared() bool {
	return m.SubscribeIDCleared() || m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *BatteryFlowMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *BatteryFlowMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// ClearBattery clears the "battery" edge to the Battery entity.
func (m *BatteryFlowMutation) ClearBattery() {
	m.clearedbattery = true
	m.clearedFields[batteryflow.FieldBatteryID] = struct{}{}
}

// BatteryCleared reports if the "battery" edge to the Battery entity was cleared.
func (m *BatteryFlowMutation) BatteryCleared() bool {
	return m.clearedbattery
}

// BatteryIDs returns the "battery" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BatteryID instead. It exists only for internal usage by the builders.
func (m *BatteryFlowMutation) BatteryIDs() (ids []uint64) {
	if id := m.battery; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBattery resets all changes to the "battery" edge.
func (m *BatteryFlowMutation) ResetBattery() {
	m.battery = nil
	m.clearedbattery = false
}

// ClearCabinet clears the "cabinet" edge to the Cabinet entity.
func (m *BatteryFlowMutation) ClearCabinet() {
	m.clearedcabinet = true
	m.clearedFields[batteryflow.FieldCabinetID] = struct{}{}
}

// CabinetCleared reports if the "cabinet" edge to the Cabinet entity was cleared.
func (m *BatteryFlowMutation) CabinetCleared() bool {
	return m.CabinetIDCleared() || m.clearedcabinet
}

// CabinetIDs returns the "cabinet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CabinetID instead. It exists only for internal usage by the builders.
func (m *BatteryFlowMutation) CabinetIDs() (ids []uint64) {
	if id := m.cabinet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCabinet resets all changes to the "cabinet" edge.
func (m *BatteryFlowMutation) ResetCabinet() {
	m.cabinet = nil
	m.clearedcabinet = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *BatteryFlowMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[batteryflow.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *BatteryFlowMutation) RiderCleared() bool {
	return m.RiderIDCleared() || m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *BatteryFlowMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *BatteryFlowMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// Where appends a list predicates to the BatteryFlowMutation builder.
func (m *BatteryFlowMutation) Where(ps ...predicate.BatteryFlow) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BatteryFlowMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BatteryFlowMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BatteryFlow, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BatteryFlowMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BatteryFlowMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BatteryFlow).
func (m *BatteryFlowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BatteryFlowMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, batteryflow.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, batteryflow.FieldUpdatedAt)
	}
	if m.subscribe != nil {
		fields = append(fields, batteryflow.FieldSubscribeID)
	}
	if m.battery != nil {
		fields = append(fields, batteryflow.FieldBatteryID)
	}
	if m.sn != nil {
		fields = append(fields, batteryflow.FieldSn)
	}
	if m.soc != nil {
		fields = append(fields, batteryflow.FieldSoc)
	}
	if m.rider != nil {
		fields = append(fields, batteryflow.FieldRiderID)
	}
	if m.cabinet != nil {
		fields = append(fields, batteryflow.FieldCabinetID)
	}
	if m.serial != nil {
		fields = append(fields, batteryflow.FieldSerial)
	}
	if m.ordinal != nil {
		fields = append(fields, batteryflow.FieldOrdinal)
	}
	if m.geom != nil {
		fields = append(fields, batteryflow.FieldGeom)
	}
	if m.remark != nil {
		fields = append(fields, batteryflow.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BatteryFlowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case batteryflow.FieldCreatedAt:
		return m.CreatedAt()
	case batteryflow.FieldUpdatedAt:
		return m.UpdatedAt()
	case batteryflow.FieldSubscribeID:
		return m.SubscribeID()
	case batteryflow.FieldBatteryID:
		return m.BatteryID()
	case batteryflow.FieldSn:
		return m.Sn()
	case batteryflow.FieldSoc:
		return m.Soc()
	case batteryflow.FieldRiderID:
		return m.RiderID()
	case batteryflow.FieldCabinetID:
		return m.CabinetID()
	case batteryflow.FieldSerial:
		return m.Serial()
	case batteryflow.FieldOrdinal:
		return m.Ordinal()
	case batteryflow.FieldGeom:
		return m.Geom()
	case batteryflow.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BatteryFlowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case batteryflow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case batteryflow.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case batteryflow.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case batteryflow.FieldBatteryID:
		return m.OldBatteryID(ctx)
	case batteryflow.FieldSn:
		return m.OldSn(ctx)
	case batteryflow.FieldSoc:
		return m.OldSoc(ctx)
	case batteryflow.FieldRiderID:
		return m.OldRiderID(ctx)
	case batteryflow.FieldCabinetID:
		return m.OldCabinetID(ctx)
	case batteryflow.FieldSerial:
		return m.OldSerial(ctx)
	case batteryflow.FieldOrdinal:
		return m.OldOrdinal(ctx)
	case batteryflow.FieldGeom:
		return m.OldGeom(ctx)
	case batteryflow.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown BatteryFlow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BatteryFlowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case batteryflow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case batteryflow.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case batteryflow.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case batteryflow.FieldBatteryID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatteryID(v)
		return nil
	case batteryflow.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case batteryflow.FieldSoc:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoc(v)
		return nil
	case batteryflow.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case batteryflow.FieldCabinetID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCabinetID(v)
		return nil
	case batteryflow.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case batteryflow.FieldOrdinal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrdinal(v)
		return nil
	case batteryflow.FieldGeom:
		v, ok := value.(*adapter.Geometry)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeom(v)
		return nil
	case batteryflow.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown BatteryFlow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BatteryFlowMutation) AddedFields() []string {
	var fields []string
	if m.addsoc != nil {
		fields = append(fields, batteryflow.FieldSoc)
	}
	if m.addordinal != nil {
		fields = append(fields, batteryflow.FieldOrdinal)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BatteryFlowMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case batteryflow.FieldSoc:
		return m.AddedSoc()
	case batteryflow.FieldOrdinal:
		return m.AddedOrdinal()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BatteryFlowMutation) AddField(name string, value ent.Value) error {
	switch name {
	case batteryflow.FieldSoc:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSoc(v)
		return nil
	case batteryflow.FieldOrdinal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrdinal(v)
		return nil
	}
	return fmt.Errorf("unknown BatteryFlow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BatteryFlowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(batteryflow.FieldSubscribeID) {
		fields = append(fields, batteryflow.FieldSubscribeID)
	}
	if m.FieldCleared(batteryflow.FieldRiderID) {
		fields = append(fields, batteryflow.FieldRiderID)
	}
	if m.FieldCleared(batteryflow.FieldCabinetID) {
		fields = append(fields, batteryflow.FieldCabinetID)
	}
	if m.FieldCleared(batteryflow.FieldSerial) {
		fields = append(fields, batteryflow.FieldSerial)
	}
	if m.FieldCleared(batteryflow.FieldOrdinal) {
		fields = append(fields, batteryflow.FieldOrdinal)
	}
	if m.FieldCleared(batteryflow.FieldGeom) {
		fields = append(fields, batteryflow.FieldGeom)
	}
	if m.FieldCleared(batteryflow.FieldRemark) {
		fields = append(fields, batteryflow.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BatteryFlowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BatteryFlowMutation) ClearField(name string) error {
	switch name {
	case batteryflow.FieldSubscribeID:
		m.ClearSubscribeID()
		return nil
	case batteryflow.FieldRiderID:
		m.ClearRiderID()
		return nil
	case batteryflow.FieldCabinetID:
		m.ClearCabinetID()
		return nil
	case batteryflow.FieldSerial:
		m.ClearSerial()
		return nil
	case batteryflow.FieldOrdinal:
		m.ClearOrdinal()
		return nil
	case batteryflow.FieldGeom:
		m.ClearGeom()
		return nil
	case batteryflow.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown BatteryFlow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BatteryFlowMutation) ResetField(name string) error {
	switch name {
	case batteryflow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case batteryflow.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case batteryflow.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case batteryflow.FieldBatteryID:
		m.ResetBatteryID()
		return nil
	case batteryflow.FieldSn:
		m.ResetSn()
		return nil
	case batteryflow.FieldSoc:
		m.ResetSoc()
		return nil
	case batteryflow.FieldRiderID:
		m.ResetRiderID()
		return nil
	case batteryflow.FieldCabinetID:
		m.ResetCabinetID()
		return nil
	case batteryflow.FieldSerial:
		m.ResetSerial()
		return nil
	case batteryflow.FieldOrdinal:
		m.ResetOrdinal()
		return nil
	case batteryflow.FieldGeom:
		m.ResetGeom()
		return nil
	case batteryflow.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown BatteryFlow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BatteryFlowMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.subscribe != nil {
		edges = append(edges, batteryflow.EdgeSubscribe)
	}
	if m.battery != nil {
		edges = append(edges, batteryflow.EdgeBattery)
	}
	if m.cabinet != nil {
		edges = append(edges, batteryflow.EdgeCabinet)
	}
	if m.rider != nil {
		edges = append(edges, batteryflow.EdgeRider)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BatteryFlowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case batteryflow.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	case batteryflow.EdgeBattery:
		if id := m.battery; id != nil {
			return []ent.Value{*id}
		}
	case batteryflow.EdgeCabinet:
		if id := m.cabinet; id != nil {
			return []ent.Value{*id}
		}
	case batteryflow.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BatteryFlowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BatteryFlowMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BatteryFlowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedsubscribe {
		edges = append(edges, batteryflow.EdgeSubscribe)
	}
	if m.clearedbattery {
		edges = append(edges, batteryflow.EdgeBattery)
	}
	if m.clearedcabinet {
		edges = append(edges, batteryflow.EdgeCabinet)
	}
	if m.clearedrider {
		edges = append(edges, batteryflow.EdgeRider)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BatteryFlowMutation) EdgeCleared(name string) bool {
	switch name {
	case batteryflow.EdgeSubscribe:
		return m.clearedsubscribe
	case batteryflow.EdgeBattery:
		return m.clearedbattery
	case batteryflow.EdgeCabinet:
		return m.clearedcabinet
	case batteryflow.EdgeRider:
		return m.clearedrider
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BatteryFlowMutation) ClearEdge(name string) error {
	switch name {
	case batteryflow.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	case batteryflow.EdgeBattery:
		m.ClearBattery()
		return nil
	case batteryflow.EdgeCabinet:
		m.ClearCabinet()
		return nil
	case batteryflow.EdgeRider:
		m.ClearRider()
		return nil
	}
	return fmt.Errorf("unknown BatteryFlow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BatteryFlowMutation) ResetEdge(name string) error {
	switch name {
	case batteryflow.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	case batteryflow.EdgeBattery:
		m.ResetBattery()
		return nil
	case batteryflow.EdgeCabinet:
		m.ResetCabinet()
		return nil
	case batteryflow.EdgeRider:
		m.ResetRider()
		return nil
	}
	return fmt.Errorf("unknown BatteryFlow edge %s", name)
}

// BatteryModelMutation represents an operation that mutates the BatteryModel nodes in the graph.
type BatteryModelMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	model           *string
	created_at      *time.Time
	clearedFields   map[string]struct{}
	cabinets        map[uint64]struct{}
	removedcabinets map[uint64]struct{}
	clearedcabinets bool
	done            bool
	oldValue        func(context.Context) (*BatteryModel, error)
	predicates      []predicate.BatteryModel
}

var _ ent.Mutation = (*BatteryModelMutation)(nil)

// batterymodelOption allows management of the mutation configuration using functional options.
type batterymodelOption func(*BatteryModelMutation)

// newBatteryModelMutation creates new mutation for the BatteryModel entity.
func newBatteryModelMutation(c config, op Op, opts ...batterymodelOption) *BatteryModelMutation {
	m := &BatteryModelMutation{
		config:        c,
		op:            op,
		typ:           TypeBatteryModel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBatteryModelID sets the ID field of the mutation.
func withBatteryModelID(id uint64) batterymodelOption {
	return func(m *BatteryModelMutation) {
		var (
			err   error
			once  sync.Once
			value *BatteryModel
		)
		m.oldValue = func(ctx context.Context) (*BatteryModel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BatteryModel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBatteryModel sets the old BatteryModel of the mutation.
func withBatteryModel(node *BatteryModel) batterymodelOption {
	return func(m *BatteryModelMutation) {
		m.oldValue = func(context.Context) (*BatteryModel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BatteryModelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BatteryModelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BatteryModelMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BatteryModelMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BatteryModel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetModel sets the "model" field.
func (m *BatteryModelMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *BatteryModelMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the BatteryModel entity.
// If the BatteryModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryModelMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *BatteryModelMutation) ResetModel() {
	m.model = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *BatteryModelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BatteryModelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BatteryModel entity.
// If the BatteryModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryModelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BatteryModelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddCabinetIDs adds the "cabinets" edge to the Cabinet entity by ids.
func (m *BatteryModelMutation) AddCabinetIDs(ids ...uint64) {
	if m.cabinets == nil {
		m.cabinets = make(map[uint64]struct{})
	}
	for i := range ids {
		m.cabinets[ids[i]] = struct{}{}
	}
}

// ClearCabinets clears the "cabinets" edge to the Cabinet entity.
func (m *BatteryModelMutation) ClearCabinets() {
	m.clearedcabinets = true
}

// CabinetsCleared reports if the "cabinets" edge to the Cabinet entity was cleared.
func (m *BatteryModelMutation) CabinetsCleared() bool {
	return m.clearedcabinets
}

// RemoveCabinetIDs removes the "cabinets" edge to the Cabinet entity by IDs.
func (m *BatteryModelMutation) RemoveCabinetIDs(ids ...uint64) {
	if m.removedcabinets == nil {
		m.removedcabinets = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.cabinets, ids[i])
		m.removedcabinets[ids[i]] = struct{}{}
	}
}

// RemovedCabinets returns the removed IDs of the "cabinets" edge to the Cabinet entity.
func (m *BatteryModelMutation) RemovedCabinetsIDs() (ids []uint64) {
	for id := range m.removedcabinets {
		ids = append(ids, id)
	}
	return
}

// CabinetsIDs returns the "cabinets" edge IDs in the mutation.
func (m *BatteryModelMutation) CabinetsIDs() (ids []uint64) {
	for id := range m.cabinets {
		ids = append(ids, id)
	}
	return
}

// ResetCabinets resets all changes to the "cabinets" edge.
func (m *BatteryModelMutation) ResetCabinets() {
	m.cabinets = nil
	m.clearedcabinets = false
	m.removedcabinets = nil
}

// Where appends a list predicates to the BatteryModelMutation builder.
func (m *BatteryModelMutation) Where(ps ...predicate.BatteryModel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BatteryModelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BatteryModelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BatteryModel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BatteryModelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BatteryModelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BatteryModel).
func (m *BatteryModelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BatteryModelMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.model != nil {
		fields = append(fields, batterymodel.FieldModel)
	}
	if m.created_at != nil {
		fields = append(fields, batterymodel.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BatteryModelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case batterymodel.FieldModel:
		return m.Model()
	case batterymodel.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BatteryModelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case batterymodel.FieldModel:
		return m.OldModel(ctx)
	case batterymodel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown BatteryModel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BatteryModelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case batterymodel.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case batterymodel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown BatteryModel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BatteryModelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BatteryModelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BatteryModelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BatteryModel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BatteryModelMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BatteryModelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BatteryModelMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BatteryModel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BatteryModelMutation) ResetField(name string) error {
	switch name {
	case batterymodel.FieldModel:
		m.ResetModel()
		return nil
	case batterymodel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown BatteryModel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BatteryModelMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cabinets != nil {
		edges = append(edges, batterymodel.EdgeCabinets)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BatteryModelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case batterymodel.EdgeCabinets:
		ids := make([]ent.Value, 0, len(m.cabinets))
		for id := range m.cabinets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BatteryModelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcabinets != nil {
		edges = append(edges, batterymodel.EdgeCabinets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BatteryModelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case batterymodel.EdgeCabinets:
		ids := make([]ent.Value, 0, len(m.removedcabinets))
		for id := range m.removedcabinets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BatteryModelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcabinets {
		edges = append(edges, batterymodel.EdgeCabinets)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BatteryModelMutation) EdgeCleared(name string) bool {
	switch name {
	case batterymodel.EdgeCabinets:
		return m.clearedcabinets
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BatteryModelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BatteryModel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BatteryModelMutation) ResetEdge(name string) error {
	switch name {
	case batterymodel.EdgeCabinets:
		m.ResetCabinets()
		return nil
	}
	return fmt.Errorf("unknown BatteryModel edge %s", name)
}

// BranchMutation represents an operation that mutates the Branch nodes in the graph.
type BranchMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	creator          **model.Modifier
	last_modifier    **model.Modifier
	remark           *string
	name             *string
	lng              *float64
	addlng           *float64
	lat              *float64
	addlat           *float64
	address          *string
	photos           *[]string
	appendphotos     []string
	geom             **model.Geometry
	clearedFields    map[string]struct{}
	city             *uint64
	clearedcity      bool
	contracts        map[uint64]struct{}
	removedcontracts map[uint64]struct{}
	clearedcontracts bool
	cabinets         map[uint64]struct{}
	removedcabinets  map[uint64]struct{}
	clearedcabinets  bool
	faults           map[uint64]struct{}
	removedfaults    map[uint64]struct{}
	clearedfaults    bool
	stores           map[uint64]struct{}
	removedstores    map[uint64]struct{}
	clearedstores    bool
	done             bool
	oldValue         func(context.Context) (*Branch, error)
	predicates       []predicate.Branch
}

var _ ent.Mutation = (*BranchMutation)(nil)

// branchOption allows management of the mutation configuration using functional options.
type branchOption func(*BranchMutation)

// newBranchMutation creates new mutation for the Branch entity.
func newBranchMutation(c config, op Op, opts ...branchOption) *BranchMutation {
	m := &BranchMutation{
		config:        c,
		op:            op,
		typ:           TypeBranch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBranchID sets the ID field of the mutation.
func withBranchID(id uint64) branchOption {
	return func(m *BranchMutation) {
		var (
			err   error
			once  sync.Once
			value *Branch
		)
		m.oldValue = func(ctx context.Context) (*Branch, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Branch.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBranch sets the old Branch of the mutation.
func withBranch(node *Branch) branchOption {
	return func(m *BranchMutation) {
		m.oldValue = func(context.Context) (*Branch, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BranchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BranchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BranchMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BranchMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Branch.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BranchMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BranchMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BranchMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BranchMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BranchMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BranchMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BranchMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BranchMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BranchMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[branch.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BranchMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[branch.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BranchMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, branch.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *BranchMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *BranchMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *BranchMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[branch.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *BranchMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[branch.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *BranchMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, branch.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *BranchMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *BranchMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *BranchMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[branch.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *BranchMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[branch.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *BranchMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, branch.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *BranchMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *BranchMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *BranchMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[branch.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *BranchMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[branch.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *BranchMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, branch.FieldRemark)
}

// SetCityID sets the "city_id" field.
func (m *BranchMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *BranchMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *BranchMutation) ResetCityID() {
	m.city = nil
}

// SetName sets the "name" field.
func (m *BranchMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BranchMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BranchMutation) ResetName() {
	m.name = nil
}

// SetLng sets the "lng" field.
func (m *BranchMutation) SetLng(f float64) {
	m.lng = &f
	m.addlng = nil
}

// Lng returns the value of the "lng" field in the mutation.
func (m *BranchMutation) Lng() (r float64, exists bool) {
	v := m.lng
	if v == nil {
		return
	}
	return *v, true
}

// OldLng returns the old "lng" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldLng(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLng is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLng requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLng: %w", err)
	}
	return oldValue.Lng, nil
}

// AddLng adds f to the "lng" field.
func (m *BranchMutation) AddLng(f float64) {
	if m.addlng != nil {
		*m.addlng += f
	} else {
		m.addlng = &f
	}
}

// AddedLng returns the value that was added to the "lng" field in this mutation.
func (m *BranchMutation) AddedLng() (r float64, exists bool) {
	v := m.addlng
	if v == nil {
		return
	}
	return *v, true
}

// ResetLng resets all changes to the "lng" field.
func (m *BranchMutation) ResetLng() {
	m.lng = nil
	m.addlng = nil
}

// SetLat sets the "lat" field.
func (m *BranchMutation) SetLat(f float64) {
	m.lat = &f
	m.addlat = nil
}

// Lat returns the value of the "lat" field in the mutation.
func (m *BranchMutation) Lat() (r float64, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "lat" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// AddLat adds f to the "lat" field.
func (m *BranchMutation) AddLat(f float64) {
	if m.addlat != nil {
		*m.addlat += f
	} else {
		m.addlat = &f
	}
}

// AddedLat returns the value that was added to the "lat" field in this mutation.
func (m *BranchMutation) AddedLat() (r float64, exists bool) {
	v := m.addlat
	if v == nil {
		return
	}
	return *v, true
}

// ResetLat resets all changes to the "lat" field.
func (m *BranchMutation) ResetLat() {
	m.lat = nil
	m.addlat = nil
}

// SetAddress sets the "address" field.
func (m *BranchMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *BranchMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *BranchMutation) ResetAddress() {
	m.address = nil
}

// SetPhotos sets the "photos" field.
func (m *BranchMutation) SetPhotos(s []string) {
	m.photos = &s
	m.appendphotos = nil
}

// Photos returns the value of the "photos" field in the mutation.
func (m *BranchMutation) Photos() (r []string, exists bool) {
	v := m.photos
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotos returns the old "photos" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldPhotos(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotos is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotos requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotos: %w", err)
	}
	return oldValue.Photos, nil
}

// AppendPhotos adds s to the "photos" field.
func (m *BranchMutation) AppendPhotos(s []string) {
	m.appendphotos = append(m.appendphotos, s...)
}

// AppendedPhotos returns the list of values that were appended to the "photos" field in this mutation.
func (m *BranchMutation) AppendedPhotos() ([]string, bool) {
	if len(m.appendphotos) == 0 {
		return nil, false
	}
	return m.appendphotos, true
}

// ResetPhotos resets all changes to the "photos" field.
func (m *BranchMutation) ResetPhotos() {
	m.photos = nil
	m.appendphotos = nil
}

// SetGeom sets the "geom" field.
func (m *BranchMutation) SetGeom(value *model.Geometry) {
	m.geom = &value
}

// Geom returns the value of the "geom" field in the mutation.
func (m *BranchMutation) Geom() (r *model.Geometry, exists bool) {
	v := m.geom
	if v == nil {
		return
	}
	return *v, true
}

// OldGeom returns the old "geom" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldGeom(ctx context.Context) (v *model.Geometry, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeom: %w", err)
	}
	return oldValue.Geom, nil
}

// ResetGeom resets all changes to the "geom" field.
func (m *BranchMutation) ResetGeom() {
	m.geom = nil
}

// ClearCity clears the "city" edge to the City entity.
func (m *BranchMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[branch.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *BranchMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *BranchMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *BranchMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// AddContractIDs adds the "contracts" edge to the BranchContract entity by ids.
func (m *BranchMutation) AddContractIDs(ids ...uint64) {
	if m.contracts == nil {
		m.contracts = make(map[uint64]struct{})
	}
	for i := range ids {
		m.contracts[ids[i]] = struct{}{}
	}
}

// ClearContracts clears the "contracts" edge to the BranchContract entity.
func (m *BranchMutation) ClearContracts() {
	m.clearedcontracts = true
}

// ContractsCleared reports if the "contracts" edge to the BranchContract entity was cleared.
func (m *BranchMutation) ContractsCleared() bool {
	return m.clearedcontracts
}

// RemoveContractIDs removes the "contracts" edge to the BranchContract entity by IDs.
func (m *BranchMutation) RemoveContractIDs(ids ...uint64) {
	if m.removedcontracts == nil {
		m.removedcontracts = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.contracts, ids[i])
		m.removedcontracts[ids[i]] = struct{}{}
	}
}

// RemovedContracts returns the removed IDs of the "contracts" edge to the BranchContract entity.
func (m *BranchMutation) RemovedContractsIDs() (ids []uint64) {
	for id := range m.removedcontracts {
		ids = append(ids, id)
	}
	return
}

// ContractsIDs returns the "contracts" edge IDs in the mutation.
func (m *BranchMutation) ContractsIDs() (ids []uint64) {
	for id := range m.contracts {
		ids = append(ids, id)
	}
	return
}

// ResetContracts resets all changes to the "contracts" edge.
func (m *BranchMutation) ResetContracts() {
	m.contracts = nil
	m.clearedcontracts = false
	m.removedcontracts = nil
}

// AddCabinetIDs adds the "cabinets" edge to the Cabinet entity by ids.
func (m *BranchMutation) AddCabinetIDs(ids ...uint64) {
	if m.cabinets == nil {
		m.cabinets = make(map[uint64]struct{})
	}
	for i := range ids {
		m.cabinets[ids[i]] = struct{}{}
	}
}

// ClearCabinets clears the "cabinets" edge to the Cabinet entity.
func (m *BranchMutation) ClearCabinets() {
	m.clearedcabinets = true
}

// CabinetsCleared reports if the "cabinets" edge to the Cabinet entity was cleared.
func (m *BranchMutation) CabinetsCleared() bool {
	return m.clearedcabinets
}

// RemoveCabinetIDs removes the "cabinets" edge to the Cabinet entity by IDs.
func (m *BranchMutation) RemoveCabinetIDs(ids ...uint64) {
	if m.removedcabinets == nil {
		m.removedcabinets = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.cabinets, ids[i])
		m.removedcabinets[ids[i]] = struct{}{}
	}
}

// RemovedCabinets returns the removed IDs of the "cabinets" edge to the Cabinet entity.
func (m *BranchMutation) RemovedCabinetsIDs() (ids []uint64) {
	for id := range m.removedcabinets {
		ids = append(ids, id)
	}
	return
}

// CabinetsIDs returns the "cabinets" edge IDs in the mutation.
func (m *BranchMutation) CabinetsIDs() (ids []uint64) {
	for id := range m.cabinets {
		ids = append(ids, id)
	}
	return
}

// ResetCabinets resets all changes to the "cabinets" edge.
func (m *BranchMutation) ResetCabinets() {
	m.cabinets = nil
	m.clearedcabinets = false
	m.removedcabinets = nil
}

// AddFaultIDs adds the "faults" edge to the CabinetFault entity by ids.
func (m *BranchMutation) AddFaultIDs(ids ...uint64) {
	if m.faults == nil {
		m.faults = make(map[uint64]struct{})
	}
	for i := range ids {
		m.faults[ids[i]] = struct{}{}
	}
}

// ClearFaults clears the "faults" edge to the CabinetFault entity.
func (m *BranchMutation) ClearFaults() {
	m.clearedfaults = true
}

// FaultsCleared reports if the "faults" edge to the CabinetFault entity was cleared.
func (m *BranchMutation) FaultsCleared() bool {
	return m.clearedfaults
}

// RemoveFaultIDs removes the "faults" edge to the CabinetFault entity by IDs.
func (m *BranchMutation) RemoveFaultIDs(ids ...uint64) {
	if m.removedfaults == nil {
		m.removedfaults = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.faults, ids[i])
		m.removedfaults[ids[i]] = struct{}{}
	}
}

// RemovedFaults returns the removed IDs of the "faults" edge to the CabinetFault entity.
func (m *BranchMutation) RemovedFaultsIDs() (ids []uint64) {
	for id := range m.removedfaults {
		ids = append(ids, id)
	}
	return
}

// FaultsIDs returns the "faults" edge IDs in the mutation.
func (m *BranchMutation) FaultsIDs() (ids []uint64) {
	for id := range m.faults {
		ids = append(ids, id)
	}
	return
}

// ResetFaults resets all changes to the "faults" edge.
func (m *BranchMutation) ResetFaults() {
	m.faults = nil
	m.clearedfaults = false
	m.removedfaults = nil
}

// AddStoreIDs adds the "stores" edge to the Store entity by ids.
func (m *BranchMutation) AddStoreIDs(ids ...uint64) {
	if m.stores == nil {
		m.stores = make(map[uint64]struct{})
	}
	for i := range ids {
		m.stores[ids[i]] = struct{}{}
	}
}

// ClearStores clears the "stores" edge to the Store entity.
func (m *BranchMutation) ClearStores() {
	m.clearedstores = true
}

// StoresCleared reports if the "stores" edge to the Store entity was cleared.
func (m *BranchMutation) StoresCleared() bool {
	return m.clearedstores
}

// RemoveStoreIDs removes the "stores" edge to the Store entity by IDs.
func (m *BranchMutation) RemoveStoreIDs(ids ...uint64) {
	if m.removedstores == nil {
		m.removedstores = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.stores, ids[i])
		m.removedstores[ids[i]] = struct{}{}
	}
}

// RemovedStores returns the removed IDs of the "stores" edge to the Store entity.
func (m *BranchMutation) RemovedStoresIDs() (ids []uint64) {
	for id := range m.removedstores {
		ids = append(ids, id)
	}
	return
}

// StoresIDs returns the "stores" edge IDs in the mutation.
func (m *BranchMutation) StoresIDs() (ids []uint64) {
	for id := range m.stores {
		ids = append(ids, id)
	}
	return
}

// ResetStores resets all changes to the "stores" edge.
func (m *BranchMutation) ResetStores() {
	m.stores = nil
	m.clearedstores = false
	m.removedstores = nil
}

// Where appends a list predicates to the BranchMutation builder.
func (m *BranchMutation) Where(ps ...predicate.Branch) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BranchMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BranchMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Branch, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BranchMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BranchMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Branch).
func (m *BranchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BranchMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, branch.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, branch.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, branch.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, branch.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, branch.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, branch.FieldRemark)
	}
	if m.city != nil {
		fields = append(fields, branch.FieldCityID)
	}
	if m.name != nil {
		fields = append(fields, branch.FieldName)
	}
	if m.lng != nil {
		fields = append(fields, branch.FieldLng)
	}
	if m.lat != nil {
		fields = append(fields, branch.FieldLat)
	}
	if m.address != nil {
		fields = append(fields, branch.FieldAddress)
	}
	if m.photos != nil {
		fields = append(fields, branch.FieldPhotos)
	}
	if m.geom != nil {
		fields = append(fields, branch.FieldGeom)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BranchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case branch.FieldCreatedAt:
		return m.CreatedAt()
	case branch.FieldUpdatedAt:
		return m.UpdatedAt()
	case branch.FieldDeletedAt:
		return m.DeletedAt()
	case branch.FieldCreator:
		return m.Creator()
	case branch.FieldLastModifier:
		return m.LastModifier()
	case branch.FieldRemark:
		return m.Remark()
	case branch.FieldCityID:
		return m.CityID()
	case branch.FieldName:
		return m.Name()
	case branch.FieldLng:
		return m.Lng()
	case branch.FieldLat:
		return m.Lat()
	case branch.FieldAddress:
		return m.Address()
	case branch.FieldPhotos:
		return m.Photos()
	case branch.FieldGeom:
		return m.Geom()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BranchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case branch.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case branch.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case branch.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case branch.FieldCreator:
		return m.OldCreator(ctx)
	case branch.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case branch.FieldRemark:
		return m.OldRemark(ctx)
	case branch.FieldCityID:
		return m.OldCityID(ctx)
	case branch.FieldName:
		return m.OldName(ctx)
	case branch.FieldLng:
		return m.OldLng(ctx)
	case branch.FieldLat:
		return m.OldLat(ctx)
	case branch.FieldAddress:
		return m.OldAddress(ctx)
	case branch.FieldPhotos:
		return m.OldPhotos(ctx)
	case branch.FieldGeom:
		return m.OldGeom(ctx)
	}
	return nil, fmt.Errorf("unknown Branch field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BranchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case branch.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case branch.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case branch.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case branch.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case branch.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case branch.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case branch.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case branch.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case branch.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLng(v)
		return nil
	case branch.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	case branch.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case branch.FieldPhotos:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotos(v)
		return nil
	case branch.FieldGeom:
		v, ok := value.(*model.Geometry)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeom(v)
		return nil
	}
	return fmt.Errorf("unknown Branch field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BranchMutation) AddedFields() []string {
	var fields []string
	if m.addlng != nil {
		fields = append(fields, branch.FieldLng)
	}
	if m.addlat != nil {
		fields = append(fields, branch.FieldLat)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BranchMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case branch.FieldLng:
		return m.AddedLng()
	case branch.FieldLat:
		return m.AddedLat()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BranchMutation) AddField(name string, value ent.Value) error {
	switch name {
	case branch.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLng(v)
		return nil
	case branch.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLat(v)
		return nil
	}
	return fmt.Errorf("unknown Branch numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BranchMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(branch.FieldDeletedAt) {
		fields = append(fields, branch.FieldDeletedAt)
	}
	if m.FieldCleared(branch.FieldCreator) {
		fields = append(fields, branch.FieldCreator)
	}
	if m.FieldCleared(branch.FieldLastModifier) {
		fields = append(fields, branch.FieldLastModifier)
	}
	if m.FieldCleared(branch.FieldRemark) {
		fields = append(fields, branch.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BranchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BranchMutation) ClearField(name string) error {
	switch name {
	case branch.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case branch.FieldCreator:
		m.ClearCreator()
		return nil
	case branch.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case branch.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Branch nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BranchMutation) ResetField(name string) error {
	switch name {
	case branch.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case branch.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case branch.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case branch.FieldCreator:
		m.ResetCreator()
		return nil
	case branch.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case branch.FieldRemark:
		m.ResetRemark()
		return nil
	case branch.FieldCityID:
		m.ResetCityID()
		return nil
	case branch.FieldName:
		m.ResetName()
		return nil
	case branch.FieldLng:
		m.ResetLng()
		return nil
	case branch.FieldLat:
		m.ResetLat()
		return nil
	case branch.FieldAddress:
		m.ResetAddress()
		return nil
	case branch.FieldPhotos:
		m.ResetPhotos()
		return nil
	case branch.FieldGeom:
		m.ResetGeom()
		return nil
	}
	return fmt.Errorf("unknown Branch field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BranchMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.city != nil {
		edges = append(edges, branch.EdgeCity)
	}
	if m.contracts != nil {
		edges = append(edges, branch.EdgeContracts)
	}
	if m.cabinets != nil {
		edges = append(edges, branch.EdgeCabinets)
	}
	if m.faults != nil {
		edges = append(edges, branch.EdgeFaults)
	}
	if m.stores != nil {
		edges = append(edges, branch.EdgeStores)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BranchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case branch.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case branch.EdgeContracts:
		ids := make([]ent.Value, 0, len(m.contracts))
		for id := range m.contracts {
			ids = append(ids, id)
		}
		return ids
	case branch.EdgeCabinets:
		ids := make([]ent.Value, 0, len(m.cabinets))
		for id := range m.cabinets {
			ids = append(ids, id)
		}
		return ids
	case branch.EdgeFaults:
		ids := make([]ent.Value, 0, len(m.faults))
		for id := range m.faults {
			ids = append(ids, id)
		}
		return ids
	case branch.EdgeStores:
		ids := make([]ent.Value, 0, len(m.stores))
		for id := range m.stores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BranchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcontracts != nil {
		edges = append(edges, branch.EdgeContracts)
	}
	if m.removedcabinets != nil {
		edges = append(edges, branch.EdgeCabinets)
	}
	if m.removedfaults != nil {
		edges = append(edges, branch.EdgeFaults)
	}
	if m.removedstores != nil {
		edges = append(edges, branch.EdgeStores)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BranchMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case branch.EdgeContracts:
		ids := make([]ent.Value, 0, len(m.removedcontracts))
		for id := range m.removedcontracts {
			ids = append(ids, id)
		}
		return ids
	case branch.EdgeCabinets:
		ids := make([]ent.Value, 0, len(m.removedcabinets))
		for id := range m.removedcabinets {
			ids = append(ids, id)
		}
		return ids
	case branch.EdgeFaults:
		ids := make([]ent.Value, 0, len(m.removedfaults))
		for id := range m.removedfaults {
			ids = append(ids, id)
		}
		return ids
	case branch.EdgeStores:
		ids := make([]ent.Value, 0, len(m.removedstores))
		for id := range m.removedstores {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BranchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcity {
		edges = append(edges, branch.EdgeCity)
	}
	if m.clearedcontracts {
		edges = append(edges, branch.EdgeContracts)
	}
	if m.clearedcabinets {
		edges = append(edges, branch.EdgeCabinets)
	}
	if m.clearedfaults {
		edges = append(edges, branch.EdgeFaults)
	}
	if m.clearedstores {
		edges = append(edges, branch.EdgeStores)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BranchMutation) EdgeCleared(name string) bool {
	switch name {
	case branch.EdgeCity:
		return m.clearedcity
	case branch.EdgeContracts:
		return m.clearedcontracts
	case branch.EdgeCabinets:
		return m.clearedcabinets
	case branch.EdgeFaults:
		return m.clearedfaults
	case branch.EdgeStores:
		return m.clearedstores
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BranchMutation) ClearEdge(name string) error {
	switch name {
	case branch.EdgeCity:
		m.ClearCity()
		return nil
	}
	return fmt.Errorf("unknown Branch unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BranchMutation) ResetEdge(name string) error {
	switch name {
	case branch.EdgeCity:
		m.ResetCity()
		return nil
	case branch.EdgeContracts:
		m.ResetContracts()
		return nil
	case branch.EdgeCabinets:
		m.ResetCabinets()
		return nil
	case branch.EdgeFaults:
		m.ResetFaults()
		return nil
	case branch.EdgeStores:
		m.ResetStores()
		return nil
	}
	return fmt.Errorf("unknown Branch edge %s", name)
}

// BranchContractMutation represents an operation that mutates the BranchContract nodes in the graph.
type BranchContractMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	creator               **model.Modifier
	last_modifier         **model.Modifier
	remark                *string
	landlord_name         *string
	id_card_number        *string
	phone                 *string
	bank_number           *string
	pledge                *float64
	addpledge             *float64
	rent                  *float64
	addrent               *float64
	lease                 *uint
	addlease              *int
	electricity_pledge    *float64
	addelectricity_pledge *float64
	electricity           *string
	area                  *float64
	addarea               *float64
	start_time            *time.Time
	end_time              *time.Time
	file                  *string
	sheets                *[]string
	appendsheets          []string
	clearedFields         map[string]struct{}
	branch                *uint64
	clearedbranch         bool
	done                  bool
	oldValue              func(context.Context) (*BranchContract, error)
	predicates            []predicate.BranchContract
}

var _ ent.Mutation = (*BranchContractMutation)(nil)

// branchcontractOption allows management of the mutation configuration using functional options.
type branchcontractOption func(*BranchContractMutation)

// newBranchContractMutation creates new mutation for the BranchContract entity.
func newBranchContractMutation(c config, op Op, opts ...branchcontractOption) *BranchContractMutation {
	m := &BranchContractMutation{
		config:        c,
		op:            op,
		typ:           TypeBranchContract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBranchContractID sets the ID field of the mutation.
func withBranchContractID(id uint64) branchcontractOption {
	return func(m *BranchContractMutation) {
		var (
			err   error
			once  sync.Once
			value *BranchContract
		)
		m.oldValue = func(ctx context.Context) (*BranchContract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BranchContract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBranchContract sets the old BranchContract of the mutation.
func withBranchContract(node *BranchContract) branchcontractOption {
	return func(m *BranchContractMutation) {
		m.oldValue = func(context.Context) (*BranchContract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BranchContractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BranchContractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BranchContractMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BranchContractMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BranchContract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BranchContractMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BranchContractMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BranchContractMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BranchContractMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BranchContractMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BranchContractMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BranchContractMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BranchContractMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BranchContractMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[branchcontract.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BranchContractMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[branchcontract.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BranchContractMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, branchcontract.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *BranchContractMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *BranchContractMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *BranchContractMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[branchcontract.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *BranchContractMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[branchcontract.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *BranchContractMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, branchcontract.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *BranchContractMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *BranchContractMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *BranchContractMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[branchcontract.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *BranchContractMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[branchcontract.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *BranchContractMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, branchcontract.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *BranchContractMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *BranchContractMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *BranchContractMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[branchcontract.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *BranchContractMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[branchcontract.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *BranchContractMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, branchcontract.FieldRemark)
}

// SetBranchID sets the "branch_id" field.
func (m *BranchContractMutation) SetBranchID(u uint64) {
	m.branch = &u
}

// BranchID returns the value of the "branch_id" field in the mutation.
func (m *BranchContractMutation) BranchID() (r uint64, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranchID returns the old "branch_id" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldBranchID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBranchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBranchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranchID: %w", err)
	}
	return oldValue.BranchID, nil
}

// ResetBranchID resets all changes to the "branch_id" field.
func (m *BranchContractMutation) ResetBranchID() {
	m.branch = nil
}

// SetLandlordName sets the "landlord_name" field.
func (m *BranchContractMutation) SetLandlordName(s string) {
	m.landlord_name = &s
}

// LandlordName returns the value of the "landlord_name" field in the mutation.
func (m *BranchContractMutation) LandlordName() (r string, exists bool) {
	v := m.landlord_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLandlordName returns the old "landlord_name" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldLandlordName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLandlordName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLandlordName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLandlordName: %w", err)
	}
	return oldValue.LandlordName, nil
}

// ResetLandlordName resets all changes to the "landlord_name" field.
func (m *BranchContractMutation) ResetLandlordName() {
	m.landlord_name = nil
}

// SetIDCardNumber sets the "id_card_number" field.
func (m *BranchContractMutation) SetIDCardNumber(s string) {
	m.id_card_number = &s
}

// IDCardNumber returns the value of the "id_card_number" field in the mutation.
func (m *BranchContractMutation) IDCardNumber() (r string, exists bool) {
	v := m.id_card_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCardNumber returns the old "id_card_number" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldIDCardNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCardNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCardNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCardNumber: %w", err)
	}
	return oldValue.IDCardNumber, nil
}

// ResetIDCardNumber resets all changes to the "id_card_number" field.
func (m *BranchContractMutation) ResetIDCardNumber() {
	m.id_card_number = nil
}

// SetPhone sets the "phone" field.
func (m *BranchContractMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *BranchContractMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *BranchContractMutation) ResetPhone() {
	m.phone = nil
}

// SetBankNumber sets the "bank_number" field.
func (m *BranchContractMutation) SetBankNumber(s string) {
	m.bank_number = &s
}

// BankNumber returns the value of the "bank_number" field in the mutation.
func (m *BranchContractMutation) BankNumber() (r string, exists bool) {
	v := m.bank_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBankNumber returns the old "bank_number" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldBankNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankNumber: %w", err)
	}
	return oldValue.BankNumber, nil
}

// ResetBankNumber resets all changes to the "bank_number" field.
func (m *BranchContractMutation) ResetBankNumber() {
	m.bank_number = nil
}

// SetPledge sets the "pledge" field.
func (m *BranchContractMutation) SetPledge(f float64) {
	m.pledge = &f
	m.addpledge = nil
}

// Pledge returns the value of the "pledge" field in the mutation.
func (m *BranchContractMutation) Pledge() (r float64, exists bool) {
	v := m.pledge
	if v == nil {
		return
	}
	return *v, true
}

// OldPledge returns the old "pledge" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldPledge(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPledge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPledge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPledge: %w", err)
	}
	return oldValue.Pledge, nil
}

// AddPledge adds f to the "pledge" field.
func (m *BranchContractMutation) AddPledge(f float64) {
	if m.addpledge != nil {
		*m.addpledge += f
	} else {
		m.addpledge = &f
	}
}

// AddedPledge returns the value that was added to the "pledge" field in this mutation.
func (m *BranchContractMutation) AddedPledge() (r float64, exists bool) {
	v := m.addpledge
	if v == nil {
		return
	}
	return *v, true
}

// ResetPledge resets all changes to the "pledge" field.
func (m *BranchContractMutation) ResetPledge() {
	m.pledge = nil
	m.addpledge = nil
}

// SetRent sets the "rent" field.
func (m *BranchContractMutation) SetRent(f float64) {
	m.rent = &f
	m.addrent = nil
}

// Rent returns the value of the "rent" field in the mutation.
func (m *BranchContractMutation) Rent() (r float64, exists bool) {
	v := m.rent
	if v == nil {
		return
	}
	return *v, true
}

// OldRent returns the old "rent" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldRent(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRent: %w", err)
	}
	return oldValue.Rent, nil
}

// AddRent adds f to the "rent" field.
func (m *BranchContractMutation) AddRent(f float64) {
	if m.addrent != nil {
		*m.addrent += f
	} else {
		m.addrent = &f
	}
}

// AddedRent returns the value that was added to the "rent" field in this mutation.
func (m *BranchContractMutation) AddedRent() (r float64, exists bool) {
	v := m.addrent
	if v == nil {
		return
	}
	return *v, true
}

// ResetRent resets all changes to the "rent" field.
func (m *BranchContractMutation) ResetRent() {
	m.rent = nil
	m.addrent = nil
}

// SetLease sets the "lease" field.
func (m *BranchContractMutation) SetLease(u uint) {
	m.lease = &u
	m.addlease = nil
}

// Lease returns the value of the "lease" field in the mutation.
func (m *BranchContractMutation) Lease() (r uint, exists bool) {
	v := m.lease
	if v == nil {
		return
	}
	return *v, true
}

// OldLease returns the old "lease" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldLease(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLease is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLease requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLease: %w", err)
	}
	return oldValue.Lease, nil
}

// AddLease adds u to the "lease" field.
func (m *BranchContractMutation) AddLease(u int) {
	if m.addlease != nil {
		*m.addlease += u
	} else {
		m.addlease = &u
	}
}

// AddedLease returns the value that was added to the "lease" field in this mutation.
func (m *BranchContractMutation) AddedLease() (r int, exists bool) {
	v := m.addlease
	if v == nil {
		return
	}
	return *v, true
}

// ResetLease resets all changes to the "lease" field.
func (m *BranchContractMutation) ResetLease() {
	m.lease = nil
	m.addlease = nil
}

// SetElectricityPledge sets the "electricity_pledge" field.
func (m *BranchContractMutation) SetElectricityPledge(f float64) {
	m.electricity_pledge = &f
	m.addelectricity_pledge = nil
}

// ElectricityPledge returns the value of the "electricity_pledge" field in the mutation.
func (m *BranchContractMutation) ElectricityPledge() (r float64, exists bool) {
	v := m.electricity_pledge
	if v == nil {
		return
	}
	return *v, true
}

// OldElectricityPledge returns the old "electricity_pledge" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldElectricityPledge(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElectricityPledge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElectricityPledge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElectricityPledge: %w", err)
	}
	return oldValue.ElectricityPledge, nil
}

// AddElectricityPledge adds f to the "electricity_pledge" field.
func (m *BranchContractMutation) AddElectricityPledge(f float64) {
	if m.addelectricity_pledge != nil {
		*m.addelectricity_pledge += f
	} else {
		m.addelectricity_pledge = &f
	}
}

// AddedElectricityPledge returns the value that was added to the "electricity_pledge" field in this mutation.
func (m *BranchContractMutation) AddedElectricityPledge() (r float64, exists bool) {
	v := m.addelectricity_pledge
	if v == nil {
		return
	}
	return *v, true
}

// ResetElectricityPledge resets all changes to the "electricity_pledge" field.
func (m *BranchContractMutation) ResetElectricityPledge() {
	m.electricity_pledge = nil
	m.addelectricity_pledge = nil
}

// SetElectricity sets the "electricity" field.
func (m *BranchContractMutation) SetElectricity(s string) {
	m.electricity = &s
}

// Electricity returns the value of the "electricity" field in the mutation.
func (m *BranchContractMutation) Electricity() (r string, exists bool) {
	v := m.electricity
	if v == nil {
		return
	}
	return *v, true
}

// OldElectricity returns the old "electricity" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldElectricity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElectricity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElectricity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElectricity: %w", err)
	}
	return oldValue.Electricity, nil
}

// ResetElectricity resets all changes to the "electricity" field.
func (m *BranchContractMutation) ResetElectricity() {
	m.electricity = nil
}

// SetArea sets the "area" field.
func (m *BranchContractMutation) SetArea(f float64) {
	m.area = &f
	m.addarea = nil
}

// Area returns the value of the "area" field in the mutation.
func (m *BranchContractMutation) Area() (r float64, exists bool) {
	v := m.area
	if v == nil {
		return
	}
	return *v, true
}

// OldArea returns the old "area" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldArea(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArea: %w", err)
	}
	return oldValue.Area, nil
}

// AddArea adds f to the "area" field.
func (m *BranchContractMutation) AddArea(f float64) {
	if m.addarea != nil {
		*m.addarea += f
	} else {
		m.addarea = &f
	}
}

// AddedArea returns the value that was added to the "area" field in this mutation.
func (m *BranchContractMutation) AddedArea() (r float64, exists bool) {
	v := m.addarea
	if v == nil {
		return
	}
	return *v, true
}

// ResetArea resets all changes to the "area" field.
func (m *BranchContractMutation) ResetArea() {
	m.area = nil
	m.addarea = nil
}

// SetStartTime sets the "start_time" field.
func (m *BranchContractMutation) SetStartTime(t time.Time) {
	m.start_time = &t
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *BranchContractMutation) StartTime() (r time.Time, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *BranchContractMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *BranchContractMutation) SetEndTime(t time.Time) {
	m.end_time = &t
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *BranchContractMutation) EndTime() (r time.Time, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *BranchContractMutation) ResetEndTime() {
	m.end_time = nil
}

// SetFile sets the "file" field.
func (m *BranchContractMutation) SetFile(s string) {
	m.file = &s
}

// File returns the value of the "file" field in the mutation.
func (m *BranchContractMutation) File() (r string, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldFile returns the old "file" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldFile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFile: %w", err)
	}
	return oldValue.File, nil
}

// ResetFile resets all changes to the "file" field.
func (m *BranchContractMutation) ResetFile() {
	m.file = nil
}

// SetSheets sets the "sheets" field.
func (m *BranchContractMutation) SetSheets(s []string) {
	m.sheets = &s
	m.appendsheets = nil
}

// Sheets returns the value of the "sheets" field in the mutation.
func (m *BranchContractMutation) Sheets() (r []string, exists bool) {
	v := m.sheets
	if v == nil {
		return
	}
	return *v, true
}

// OldSheets returns the old "sheets" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldSheets(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSheets is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSheets requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSheets: %w", err)
	}
	return oldValue.Sheets, nil
}

// AppendSheets adds s to the "sheets" field.
func (m *BranchContractMutation) AppendSheets(s []string) {
	m.appendsheets = append(m.appendsheets, s...)
}

// AppendedSheets returns the list of values that were appended to the "sheets" field in this mutation.
func (m *BranchContractMutation) AppendedSheets() ([]string, bool) {
	if len(m.appendsheets) == 0 {
		return nil, false
	}
	return m.appendsheets, true
}

// ResetSheets resets all changes to the "sheets" field.
func (m *BranchContractMutation) ResetSheets() {
	m.sheets = nil
	m.appendsheets = nil
}

// ClearBranch clears the "branch" edge to the Branch entity.
func (m *BranchContractMutation) ClearBranch() {
	m.clearedbranch = true
	m.clearedFields[branchcontract.FieldBranchID] = struct{}{}
}

// BranchCleared reports if the "branch" edge to the Branch entity was cleared.
func (m *BranchContractMutation) BranchCleared() bool {
	return m.clearedbranch
}

// BranchIDs returns the "branch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BranchID instead. It exists only for internal usage by the builders.
func (m *BranchContractMutation) BranchIDs() (ids []uint64) {
	if id := m.branch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBranch resets all changes to the "branch" edge.
func (m *BranchContractMutation) ResetBranch() {
	m.branch = nil
	m.clearedbranch = false
}

// Where appends a list predicates to the BranchContractMutation builder.
func (m *BranchContractMutation) Where(ps ...predicate.BranchContract) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BranchContractMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BranchContractMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BranchContract, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BranchContractMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BranchContractMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BranchContract).
func (m *BranchContractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BranchContractMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.created_at != nil {
		fields = append(fields, branchcontract.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, branchcontract.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, branchcontract.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, branchcontract.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, branchcontract.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, branchcontract.FieldRemark)
	}
	if m.branch != nil {
		fields = append(fields, branchcontract.FieldBranchID)
	}
	if m.landlord_name != nil {
		fields = append(fields, branchcontract.FieldLandlordName)
	}
	if m.id_card_number != nil {
		fields = append(fields, branchcontract.FieldIDCardNumber)
	}
	if m.phone != nil {
		fields = append(fields, branchcontract.FieldPhone)
	}
	if m.bank_number != nil {
		fields = append(fields, branchcontract.FieldBankNumber)
	}
	if m.pledge != nil {
		fields = append(fields, branchcontract.FieldPledge)
	}
	if m.rent != nil {
		fields = append(fields, branchcontract.FieldRent)
	}
	if m.lease != nil {
		fields = append(fields, branchcontract.FieldLease)
	}
	if m.electricity_pledge != nil {
		fields = append(fields, branchcontract.FieldElectricityPledge)
	}
	if m.electricity != nil {
		fields = append(fields, branchcontract.FieldElectricity)
	}
	if m.area != nil {
		fields = append(fields, branchcontract.FieldArea)
	}
	if m.start_time != nil {
		fields = append(fields, branchcontract.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, branchcontract.FieldEndTime)
	}
	if m.file != nil {
		fields = append(fields, branchcontract.FieldFile)
	}
	if m.sheets != nil {
		fields = append(fields, branchcontract.FieldSheets)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BranchContractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case branchcontract.FieldCreatedAt:
		return m.CreatedAt()
	case branchcontract.FieldUpdatedAt:
		return m.UpdatedAt()
	case branchcontract.FieldDeletedAt:
		return m.DeletedAt()
	case branchcontract.FieldCreator:
		return m.Creator()
	case branchcontract.FieldLastModifier:
		return m.LastModifier()
	case branchcontract.FieldRemark:
		return m.Remark()
	case branchcontract.FieldBranchID:
		return m.BranchID()
	case branchcontract.FieldLandlordName:
		return m.LandlordName()
	case branchcontract.FieldIDCardNumber:
		return m.IDCardNumber()
	case branchcontract.FieldPhone:
		return m.Phone()
	case branchcontract.FieldBankNumber:
		return m.BankNumber()
	case branchcontract.FieldPledge:
		return m.Pledge()
	case branchcontract.FieldRent:
		return m.Rent()
	case branchcontract.FieldLease:
		return m.Lease()
	case branchcontract.FieldElectricityPledge:
		return m.ElectricityPledge()
	case branchcontract.FieldElectricity:
		return m.Electricity()
	case branchcontract.FieldArea:
		return m.Area()
	case branchcontract.FieldStartTime:
		return m.StartTime()
	case branchcontract.FieldEndTime:
		return m.EndTime()
	case branchcontract.FieldFile:
		return m.File()
	case branchcontract.FieldSheets:
		return m.Sheets()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BranchContractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case branchcontract.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case branchcontract.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case branchcontract.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case branchcontract.FieldCreator:
		return m.OldCreator(ctx)
	case branchcontract.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case branchcontract.FieldRemark:
		return m.OldRemark(ctx)
	case branchcontract.FieldBranchID:
		return m.OldBranchID(ctx)
	case branchcontract.FieldLandlordName:
		return m.OldLandlordName(ctx)
	case branchcontract.FieldIDCardNumber:
		return m.OldIDCardNumber(ctx)
	case branchcontract.FieldPhone:
		return m.OldPhone(ctx)
	case branchcontract.FieldBankNumber:
		return m.OldBankNumber(ctx)
	case branchcontract.FieldPledge:
		return m.OldPledge(ctx)
	case branchcontract.FieldRent:
		return m.OldRent(ctx)
	case branchcontract.FieldLease:
		return m.OldLease(ctx)
	case branchcontract.FieldElectricityPledge:
		return m.OldElectricityPledge(ctx)
	case branchcontract.FieldElectricity:
		return m.OldElectricity(ctx)
	case branchcontract.FieldArea:
		return m.OldArea(ctx)
	case branchcontract.FieldStartTime:
		return m.OldStartTime(ctx)
	case branchcontract.FieldEndTime:
		return m.OldEndTime(ctx)
	case branchcontract.FieldFile:
		return m.OldFile(ctx)
	case branchcontract.FieldSheets:
		return m.OldSheets(ctx)
	}
	return nil, fmt.Errorf("unknown BranchContract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BranchContractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case branchcontract.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case branchcontract.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case branchcontract.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case branchcontract.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case branchcontract.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case branchcontract.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case branchcontract.FieldBranchID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranchID(v)
		return nil
	case branchcontract.FieldLandlordName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLandlordName(v)
		return nil
	case branchcontract.FieldIDCardNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCardNumber(v)
		return nil
	case branchcontract.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case branchcontract.FieldBankNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankNumber(v)
		return nil
	case branchcontract.FieldPledge:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPledge(v)
		return nil
	case branchcontract.FieldRent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRent(v)
		return nil
	case branchcontract.FieldLease:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLease(v)
		return nil
	case branchcontract.FieldElectricityPledge:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElectricityPledge(v)
		return nil
	case branchcontract.FieldElectricity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElectricity(v)
		return nil
	case branchcontract.FieldArea:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArea(v)
		return nil
	case branchcontract.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case branchcontract.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case branchcontract.FieldFile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFile(v)
		return nil
	case branchcontract.FieldSheets:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSheets(v)
		return nil
	}
	return fmt.Errorf("unknown BranchContract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BranchContractMutation) AddedFields() []string {
	var fields []string
	if m.addpledge != nil {
		fields = append(fields, branchcontract.FieldPledge)
	}
	if m.addrent != nil {
		fields = append(fields, branchcontract.FieldRent)
	}
	if m.addlease != nil {
		fields = append(fields, branchcontract.FieldLease)
	}
	if m.addelectricity_pledge != nil {
		fields = append(fields, branchcontract.FieldElectricityPledge)
	}
	if m.addarea != nil {
		fields = append(fields, branchcontract.FieldArea)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BranchContractMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case branchcontract.FieldPledge:
		return m.AddedPledge()
	case branchcontract.FieldRent:
		return m.AddedRent()
	case branchcontract.FieldLease:
		return m.AddedLease()
	case branchcontract.FieldElectricityPledge:
		return m.AddedElectricityPledge()
	case branchcontract.FieldArea:
		return m.AddedArea()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BranchContractMutation) AddField(name string, value ent.Value) error {
	switch name {
	case branchcontract.FieldPledge:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPledge(v)
		return nil
	case branchcontract.FieldRent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRent(v)
		return nil
	case branchcontract.FieldLease:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLease(v)
		return nil
	case branchcontract.FieldElectricityPledge:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddElectricityPledge(v)
		return nil
	case branchcontract.FieldArea:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddArea(v)
		return nil
	}
	return fmt.Errorf("unknown BranchContract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BranchContractMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(branchcontract.FieldDeletedAt) {
		fields = append(fields, branchcontract.FieldDeletedAt)
	}
	if m.FieldCleared(branchcontract.FieldCreator) {
		fields = append(fields, branchcontract.FieldCreator)
	}
	if m.FieldCleared(branchcontract.FieldLastModifier) {
		fields = append(fields, branchcontract.FieldLastModifier)
	}
	if m.FieldCleared(branchcontract.FieldRemark) {
		fields = append(fields, branchcontract.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BranchContractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BranchContractMutation) ClearField(name string) error {
	switch name {
	case branchcontract.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case branchcontract.FieldCreator:
		m.ClearCreator()
		return nil
	case branchcontract.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case branchcontract.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown BranchContract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BranchContractMutation) ResetField(name string) error {
	switch name {
	case branchcontract.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case branchcontract.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case branchcontract.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case branchcontract.FieldCreator:
		m.ResetCreator()
		return nil
	case branchcontract.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case branchcontract.FieldRemark:
		m.ResetRemark()
		return nil
	case branchcontract.FieldBranchID:
		m.ResetBranchID()
		return nil
	case branchcontract.FieldLandlordName:
		m.ResetLandlordName()
		return nil
	case branchcontract.FieldIDCardNumber:
		m.ResetIDCardNumber()
		return nil
	case branchcontract.FieldPhone:
		m.ResetPhone()
		return nil
	case branchcontract.FieldBankNumber:
		m.ResetBankNumber()
		return nil
	case branchcontract.FieldPledge:
		m.ResetPledge()
		return nil
	case branchcontract.FieldRent:
		m.ResetRent()
		return nil
	case branchcontract.FieldLease:
		m.ResetLease()
		return nil
	case branchcontract.FieldElectricityPledge:
		m.ResetElectricityPledge()
		return nil
	case branchcontract.FieldElectricity:
		m.ResetElectricity()
		return nil
	case branchcontract.FieldArea:
		m.ResetArea()
		return nil
	case branchcontract.FieldStartTime:
		m.ResetStartTime()
		return nil
	case branchcontract.FieldEndTime:
		m.ResetEndTime()
		return nil
	case branchcontract.FieldFile:
		m.ResetFile()
		return nil
	case branchcontract.FieldSheets:
		m.ResetSheets()
		return nil
	}
	return fmt.Errorf("unknown BranchContract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BranchContractMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.branch != nil {
		edges = append(edges, branchcontract.EdgeBranch)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BranchContractMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case branchcontract.EdgeBranch:
		if id := m.branch; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BranchContractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BranchContractMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BranchContractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbranch {
		edges = append(edges, branchcontract.EdgeBranch)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BranchContractMutation) EdgeCleared(name string) bool {
	switch name {
	case branchcontract.EdgeBranch:
		return m.clearedbranch
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BranchContractMutation) ClearEdge(name string) error {
	switch name {
	case branchcontract.EdgeBranch:
		m.ClearBranch()
		return nil
	}
	return fmt.Errorf("unknown BranchContract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BranchContractMutation) ResetEdge(name string) error {
	switch name {
	case branchcontract.EdgeBranch:
		m.ResetBranch()
		return nil
	}
	return fmt.Errorf("unknown BranchContract edge %s", name)
}

// BusinessMutation represents an operation that mutates the Business nodes in the graph.
type BusinessMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	_type             *business.Type
	bin_info          **model.BinInfo
	stock_sn          *string
	clearedFields     map[string]struct{}
	rider             *uint64
	clearedrider      bool
	city              *uint64
	clearedcity       bool
	subscribe         *uint64
	clearedsubscribe  bool
	employee          *uint64
	clearedemployee   bool
	store             *uint64
	clearedstore      bool
	plan              *uint64
	clearedplan       bool
	enterprise        *uint64
	clearedenterprise bool
	station           *uint64
	clearedstation    bool
	cabinet           *uint64
	clearedcabinet    bool
	battery           *uint64
	clearedbattery    bool
	agent             *uint64
	clearedagent      bool
	done              bool
	oldValue          func(context.Context) (*Business, error)
	predicates        []predicate.Business
}

var _ ent.Mutation = (*BusinessMutation)(nil)

// businessOption allows management of the mutation configuration using functional options.
type businessOption func(*BusinessMutation)

// newBusinessMutation creates new mutation for the Business entity.
func newBusinessMutation(c config, op Op, opts ...businessOption) *BusinessMutation {
	m := &BusinessMutation{
		config:        c,
		op:            op,
		typ:           TypeBusiness,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBusinessID sets the ID field of the mutation.
func withBusinessID(id uint64) businessOption {
	return func(m *BusinessMutation) {
		var (
			err   error
			once  sync.Once
			value *Business
		)
		m.oldValue = func(ctx context.Context) (*Business, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Business.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBusiness sets the old Business of the mutation.
func withBusiness(node *Business) businessOption {
	return func(m *BusinessMutation) {
		m.oldValue = func(context.Context) (*Business, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BusinessMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BusinessMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BusinessMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BusinessMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Business.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BusinessMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BusinessMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BusinessMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BusinessMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BusinessMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BusinessMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BusinessMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BusinessMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BusinessMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[business.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BusinessMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[business.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BusinessMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, business.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *BusinessMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *BusinessMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *BusinessMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[business.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *BusinessMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[business.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *BusinessMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, business.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *BusinessMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *BusinessMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *BusinessMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[business.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *BusinessMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[business.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *BusinessMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, business.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *BusinessMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *BusinessMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *BusinessMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[business.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *BusinessMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[business.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *BusinessMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, business.FieldRemark)
}

// SetRiderID sets the "rider_id" field.
func (m *BusinessMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *BusinessMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *BusinessMutation) ResetRiderID() {
	m.rider = nil
}

// SetCityID sets the "city_id" field.
func (m *BusinessMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *BusinessMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *BusinessMutation) ResetCityID() {
	m.city = nil
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *BusinessMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *BusinessMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldSubscribeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *BusinessMutation) ResetSubscribeID() {
	m.subscribe = nil
}

// SetEmployeeID sets the "employee_id" field.
func (m *BusinessMutation) SetEmployeeID(u uint64) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *BusinessMutation) EmployeeID() (r uint64, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldEmployeeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *BusinessMutation) ClearEmployeeID() {
	m.employee = nil
	m.clearedFields[business.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *BusinessMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[business.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *BusinessMutation) ResetEmployeeID() {
	m.employee = nil
	delete(m.clearedFields, business.FieldEmployeeID)
}

// SetStoreID sets the "store_id" field.
func (m *BusinessMutation) SetStoreID(u uint64) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *BusinessMutation) StoreID() (r uint64, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldStoreID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *BusinessMutation) ClearStoreID() {
	m.store = nil
	m.clearedFields[business.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *BusinessMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[business.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *BusinessMutation) ResetStoreID() {
	m.store = nil
	delete(m.clearedFields, business.FieldStoreID)
}

// SetPlanID sets the "plan_id" field.
func (m *BusinessMutation) SetPlanID(u uint64) {
	m.plan = &u
}

// PlanID returns the value of the "plan_id" field in the mutation.
func (m *BusinessMutation) PlanID() (r uint64, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanID returns the old "plan_id" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldPlanID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanID: %w", err)
	}
	return oldValue.PlanID, nil
}

// ClearPlanID clears the value of the "plan_id" field.
func (m *BusinessMutation) ClearPlanID() {
	m.plan = nil
	m.clearedFields[business.FieldPlanID] = struct{}{}
}

// PlanIDCleared returns if the "plan_id" field was cleared in this mutation.
func (m *BusinessMutation) PlanIDCleared() bool {
	_, ok := m.clearedFields[business.FieldPlanID]
	return ok
}

// ResetPlanID resets all changes to the "plan_id" field.
func (m *BusinessMutation) ResetPlanID() {
	m.plan = nil
	delete(m.clearedFields, business.FieldPlanID)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *BusinessMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *BusinessMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldEnterpriseID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ClearEnterpriseID clears the value of the "enterprise_id" field.
func (m *BusinessMutation) ClearEnterpriseID() {
	m.enterprise = nil
	m.clearedFields[business.FieldEnterpriseID] = struct{}{}
}

// EnterpriseIDCleared returns if the "enterprise_id" field was cleared in this mutation.
func (m *BusinessMutation) EnterpriseIDCleared() bool {
	_, ok := m.clearedFields[business.FieldEnterpriseID]
	return ok
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *BusinessMutation) ResetEnterpriseID() {
	m.enterprise = nil
	delete(m.clearedFields, business.FieldEnterpriseID)
}

// SetStationID sets the "station_id" field.
func (m *BusinessMutation) SetStationID(u uint64) {
	m.station = &u
}

// StationID returns the value of the "station_id" field in the mutation.
func (m *BusinessMutation) StationID() (r uint64, exists bool) {
	v := m.station
	if v == nil {
		return
	}
	return *v, true
}

// OldStationID returns the old "station_id" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldStationID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStationID: %w", err)
	}
	return oldValue.StationID, nil
}

// ClearStationID clears the value of the "station_id" field.
func (m *BusinessMutation) ClearStationID() {
	m.station = nil
	m.clearedFields[business.FieldStationID] = struct{}{}
}

// StationIDCleared returns if the "station_id" field was cleared in this mutation.
func (m *BusinessMutation) StationIDCleared() bool {
	_, ok := m.clearedFields[business.FieldStationID]
	return ok
}

// ResetStationID resets all changes to the "station_id" field.
func (m *BusinessMutation) ResetStationID() {
	m.station = nil
	delete(m.clearedFields, business.FieldStationID)
}

// SetCabinetID sets the "cabinet_id" field.
func (m *BusinessMutation) SetCabinetID(u uint64) {
	m.cabinet = &u
}

// CabinetID returns the value of the "cabinet_id" field in the mutation.
func (m *BusinessMutation) CabinetID() (r uint64, exists bool) {
	v := m.cabinet
	if v == nil {
		return
	}
	return *v, true
}

// OldCabinetID returns the old "cabinet_id" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldCabinetID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCabinetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCabinetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCabinetID: %w", err)
	}
	return oldValue.CabinetID, nil
}

// ClearCabinetID clears the value of the "cabinet_id" field.
func (m *BusinessMutation) ClearCabinetID() {
	m.cabinet = nil
	m.clearedFields[business.FieldCabinetID] = struct{}{}
}

// CabinetIDCleared returns if the "cabinet_id" field was cleared in this mutation.
func (m *BusinessMutation) CabinetIDCleared() bool {
	_, ok := m.clearedFields[business.FieldCabinetID]
	return ok
}

// ResetCabinetID resets all changes to the "cabinet_id" field.
func (m *BusinessMutation) ResetCabinetID() {
	m.cabinet = nil
	delete(m.clearedFields, business.FieldCabinetID)
}

// SetBatteryID sets the "battery_id" field.
func (m *BusinessMutation) SetBatteryID(u uint64) {
	m.battery = &u
}

// BatteryID returns the value of the "battery_id" field in the mutation.
func (m *BusinessMutation) BatteryID() (r uint64, exists bool) {
	v := m.battery
	if v == nil {
		return
	}
	return *v, true
}

// OldBatteryID returns the old "battery_id" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldBatteryID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatteryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatteryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatteryID: %w", err)
	}
	return oldValue.BatteryID, nil
}

// ClearBatteryID clears the value of the "battery_id" field.
func (m *BusinessMutation) ClearBatteryID() {
	m.battery = nil
	m.clearedFields[business.FieldBatteryID] = struct{}{}
}

// BatteryIDCleared returns if the "battery_id" field was cleared in this mutation.
func (m *BusinessMutation) BatteryIDCleared() bool {
	_, ok := m.clearedFields[business.FieldBatteryID]
	return ok
}

// ResetBatteryID resets all changes to the "battery_id" field.
func (m *BusinessMutation) ResetBatteryID() {
	m.battery = nil
	delete(m.clearedFields, business.FieldBatteryID)
}

// SetAgentID sets the "agent_id" field.
func (m *BusinessMutation) SetAgentID(u uint64) {
	m.agent = &u
}

// AgentID returns the value of the "agent_id" field in the mutation.
func (m *BusinessMutation) AgentID() (r uint64, exists bool) {
	v := m.agent
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentID returns the old "agent_id" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldAgentID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentID: %w", err)
	}
	return oldValue.AgentID, nil
}

// ClearAgentID clears the value of the "agent_id" field.
func (m *BusinessMutation) ClearAgentID() {
	m.agent = nil
	m.clearedFields[business.FieldAgentID] = struct{}{}
}

// AgentIDCleared returns if the "agent_id" field was cleared in this mutation.
func (m *BusinessMutation) AgentIDCleared() bool {
	_, ok := m.clearedFields[business.FieldAgentID]
	return ok
}

// ResetAgentID resets all changes to the "agent_id" field.
func (m *BusinessMutation) ResetAgentID() {
	m.agent = nil
	delete(m.clearedFields, business.FieldAgentID)
}

// SetType sets the "type" field.
func (m *BusinessMutation) SetType(b business.Type) {
	m._type = &b
}

// GetType returns the value of the "type" field in the mutation.
func (m *BusinessMutation) GetType() (r business.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldType(ctx context.Context) (v business.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BusinessMutation) ResetType() {
	m._type = nil
}

// SetBinInfo sets the "bin_info" field.
func (m *BusinessMutation) SetBinInfo(mi *model.BinInfo) {
	m.bin_info = &mi
}

// BinInfo returns the value of the "bin_info" field in the mutation.
func (m *BusinessMutation) BinInfo() (r *model.BinInfo, exists bool) {
	v := m.bin_info
	if v == nil {
		return
	}
	return *v, true
}

// OldBinInfo returns the old "bin_info" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldBinInfo(ctx context.Context) (v *model.BinInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBinInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBinInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBinInfo: %w", err)
	}
	return oldValue.BinInfo, nil
}

// ClearBinInfo clears the value of the "bin_info" field.
func (m *BusinessMutation) ClearBinInfo() {
	m.bin_info = nil
	m.clearedFields[business.FieldBinInfo] = struct{}{}
}

// BinInfoCleared returns if the "bin_info" field was cleared in this mutation.
func (m *BusinessMutation) BinInfoCleared() bool {
	_, ok := m.clearedFields[business.FieldBinInfo]
	return ok
}

// ResetBinInfo resets all changes to the "bin_info" field.
func (m *BusinessMutation) ResetBinInfo() {
	m.bin_info = nil
	delete(m.clearedFields, business.FieldBinInfo)
}

// SetStockSn sets the "stock_sn" field.
func (m *BusinessMutation) SetStockSn(s string) {
	m.stock_sn = &s
}

// StockSn returns the value of the "stock_sn" field in the mutation.
func (m *BusinessMutation) StockSn() (r string, exists bool) {
	v := m.stock_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldStockSn returns the old "stock_sn" field's value of the Business entity.
// If the Business object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessMutation) OldStockSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStockSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStockSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStockSn: %w", err)
	}
	return oldValue.StockSn, nil
}

// ClearStockSn clears the value of the "stock_sn" field.
func (m *BusinessMutation) ClearStockSn() {
	m.stock_sn = nil
	m.clearedFields[business.FieldStockSn] = struct{}{}
}

// StockSnCleared returns if the "stock_sn" field was cleared in this mutation.
func (m *BusinessMutation) StockSnCleared() bool {
	_, ok := m.clearedFields[business.FieldStockSn]
	return ok
}

// ResetStockSn resets all changes to the "stock_sn" field.
func (m *BusinessMutation) ResetStockSn() {
	m.stock_sn = nil
	delete(m.clearedFields, business.FieldStockSn)
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *BusinessMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[business.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *BusinessMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *BusinessMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *BusinessMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[business.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *BusinessMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *BusinessMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *BusinessMutation) ClearSubscribe() {
	m.clearedsubscribe = true
	m.clearedFields[business.FieldSubscribeID] = struct{}{}
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *BusinessMutation) SubscribeCleared() bool {
	return m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *BusinessMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *BusinessMutation) ClearEmployee() {
	m.clearedemployee = true
	m.clearedFields[business.FieldEmployeeID] = struct{}{}
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *BusinessMutation) EmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) EmployeeIDs() (ids []uint64) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *BusinessMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// ClearStore clears the "store" edge to the Store entity.
func (m *BusinessMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[business.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *BusinessMutation) StoreCleared() bool {
	return m.StoreIDCleared() || m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) StoreIDs() (ids []uint64) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *BusinessMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// ClearPlan clears the "plan" edge to the Plan entity.
func (m *BusinessMutation) ClearPlan() {
	m.clearedplan = true
	m.clearedFields[business.FieldPlanID] = struct{}{}
}

// PlanCleared reports if the "plan" edge to the Plan entity was cleared.
func (m *BusinessMutation) PlanCleared() bool {
	return m.PlanIDCleared() || m.clearedplan
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) PlanIDs() (ids []uint64) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *BusinessMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *BusinessMutation) ClearEnterprise() {
	m.clearedenterprise = true
	m.clearedFields[business.FieldEnterpriseID] = struct{}{}
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *BusinessMutation) EnterpriseCleared() bool {
	return m.EnterpriseIDCleared() || m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *BusinessMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// ClearStation clears the "station" edge to the EnterpriseStation entity.
func (m *BusinessMutation) ClearStation() {
	m.clearedstation = true
	m.clearedFields[business.FieldStationID] = struct{}{}
}

// StationCleared reports if the "station" edge to the EnterpriseStation entity was cleared.
func (m *BusinessMutation) StationCleared() bool {
	return m.StationIDCleared() || m.clearedstation
}

// StationIDs returns the "station" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StationID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) StationIDs() (ids []uint64) {
	if id := m.station; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStation resets all changes to the "station" edge.
func (m *BusinessMutation) ResetStation() {
	m.station = nil
	m.clearedstation = false
}

// ClearCabinet clears the "cabinet" edge to the Cabinet entity.
func (m *BusinessMutation) ClearCabinet() {
	m.clearedcabinet = true
	m.clearedFields[business.FieldCabinetID] = struct{}{}
}

// CabinetCleared reports if the "cabinet" edge to the Cabinet entity was cleared.
func (m *BusinessMutation) CabinetCleared() bool {
	return m.CabinetIDCleared() || m.clearedcabinet
}

// CabinetIDs returns the "cabinet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CabinetID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) CabinetIDs() (ids []uint64) {
	if id := m.cabinet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCabinet resets all changes to the "cabinet" edge.
func (m *BusinessMutation) ResetCabinet() {
	m.cabinet = nil
	m.clearedcabinet = false
}

// ClearBattery clears the "battery" edge to the Battery entity.
func (m *BusinessMutation) ClearBattery() {
	m.clearedbattery = true
	m.clearedFields[business.FieldBatteryID] = struct{}{}
}

// BatteryCleared reports if the "battery" edge to the Battery entity was cleared.
func (m *BusinessMutation) BatteryCleared() bool {
	return m.BatteryIDCleared() || m.clearedbattery
}

// BatteryIDs returns the "battery" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BatteryID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) BatteryIDs() (ids []uint64) {
	if id := m.battery; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBattery resets all changes to the "battery" edge.
func (m *BusinessMutation) ResetBattery() {
	m.battery = nil
	m.clearedbattery = false
}

// ClearAgent clears the "agent" edge to the Agent entity.
func (m *BusinessMutation) ClearAgent() {
	m.clearedagent = true
	m.clearedFields[business.FieldAgentID] = struct{}{}
}

// AgentCleared reports if the "agent" edge to the Agent entity was cleared.
func (m *BusinessMutation) AgentCleared() bool {
	return m.AgentIDCleared() || m.clearedagent
}

// AgentIDs returns the "agent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentID instead. It exists only for internal usage by the builders.
func (m *BusinessMutation) AgentIDs() (ids []uint64) {
	if id := m.agent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgent resets all changes to the "agent" edge.
func (m *BusinessMutation) ResetAgent() {
	m.agent = nil
	m.clearedagent = false
}

// Where appends a list predicates to the BusinessMutation builder.
func (m *BusinessMutation) Where(ps ...predicate.Business) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BusinessMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BusinessMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Business, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BusinessMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BusinessMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Business).
func (m *BusinessMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BusinessMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, business.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, business.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, business.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, business.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, business.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, business.FieldRemark)
	}
	if m.rider != nil {
		fields = append(fields, business.FieldRiderID)
	}
	if m.city != nil {
		fields = append(fields, business.FieldCityID)
	}
	if m.subscribe != nil {
		fields = append(fields, business.FieldSubscribeID)
	}
	if m.employee != nil {
		fields = append(fields, business.FieldEmployeeID)
	}
	if m.store != nil {
		fields = append(fields, business.FieldStoreID)
	}
	if m.plan != nil {
		fields = append(fields, business.FieldPlanID)
	}
	if m.enterprise != nil {
		fields = append(fields, business.FieldEnterpriseID)
	}
	if m.station != nil {
		fields = append(fields, business.FieldStationID)
	}
	if m.cabinet != nil {
		fields = append(fields, business.FieldCabinetID)
	}
	if m.battery != nil {
		fields = append(fields, business.FieldBatteryID)
	}
	if m.agent != nil {
		fields = append(fields, business.FieldAgentID)
	}
	if m._type != nil {
		fields = append(fields, business.FieldType)
	}
	if m.bin_info != nil {
		fields = append(fields, business.FieldBinInfo)
	}
	if m.stock_sn != nil {
		fields = append(fields, business.FieldStockSn)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BusinessMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case business.FieldCreatedAt:
		return m.CreatedAt()
	case business.FieldUpdatedAt:
		return m.UpdatedAt()
	case business.FieldDeletedAt:
		return m.DeletedAt()
	case business.FieldCreator:
		return m.Creator()
	case business.FieldLastModifier:
		return m.LastModifier()
	case business.FieldRemark:
		return m.Remark()
	case business.FieldRiderID:
		return m.RiderID()
	case business.FieldCityID:
		return m.CityID()
	case business.FieldSubscribeID:
		return m.SubscribeID()
	case business.FieldEmployeeID:
		return m.EmployeeID()
	case business.FieldStoreID:
		return m.StoreID()
	case business.FieldPlanID:
		return m.PlanID()
	case business.FieldEnterpriseID:
		return m.EnterpriseID()
	case business.FieldStationID:
		return m.StationID()
	case business.FieldCabinetID:
		return m.CabinetID()
	case business.FieldBatteryID:
		return m.BatteryID()
	case business.FieldAgentID:
		return m.AgentID()
	case business.FieldType:
		return m.GetType()
	case business.FieldBinInfo:
		return m.BinInfo()
	case business.FieldStockSn:
		return m.StockSn()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BusinessMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case business.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case business.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case business.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case business.FieldCreator:
		return m.OldCreator(ctx)
	case business.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case business.FieldRemark:
		return m.OldRemark(ctx)
	case business.FieldRiderID:
		return m.OldRiderID(ctx)
	case business.FieldCityID:
		return m.OldCityID(ctx)
	case business.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case business.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case business.FieldStoreID:
		return m.OldStoreID(ctx)
	case business.FieldPlanID:
		return m.OldPlanID(ctx)
	case business.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case business.FieldStationID:
		return m.OldStationID(ctx)
	case business.FieldCabinetID:
		return m.OldCabinetID(ctx)
	case business.FieldBatteryID:
		return m.OldBatteryID(ctx)
	case business.FieldAgentID:
		return m.OldAgentID(ctx)
	case business.FieldType:
		return m.OldType(ctx)
	case business.FieldBinInfo:
		return m.OldBinInfo(ctx)
	case business.FieldStockSn:
		return m.OldStockSn(ctx)
	}
	return nil, fmt.Errorf("unknown Business field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessMutation) SetField(name string, value ent.Value) error {
	switch name {
	case business.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case business.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case business.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case business.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case business.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case business.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case business.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case business.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case business.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case business.FieldEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case business.FieldStoreID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case business.FieldPlanID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanID(v)
		return nil
	case business.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case business.FieldStationID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStationID(v)
		return nil
	case business.FieldCabinetID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCabinetID(v)
		return nil
	case business.FieldBatteryID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatteryID(v)
		return nil
	case business.FieldAgentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentID(v)
		return nil
	case business.FieldType:
		v, ok := value.(business.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case business.FieldBinInfo:
		v, ok := value.(*model.BinInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBinInfo(v)
		return nil
	case business.FieldStockSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStockSn(v)
		return nil
	}
	return fmt.Errorf("unknown Business field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BusinessMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BusinessMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Business numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BusinessMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(business.FieldDeletedAt) {
		fields = append(fields, business.FieldDeletedAt)
	}
	if m.FieldCleared(business.FieldCreator) {
		fields = append(fields, business.FieldCreator)
	}
	if m.FieldCleared(business.FieldLastModifier) {
		fields = append(fields, business.FieldLastModifier)
	}
	if m.FieldCleared(business.FieldRemark) {
		fields = append(fields, business.FieldRemark)
	}
	if m.FieldCleared(business.FieldEmployeeID) {
		fields = append(fields, business.FieldEmployeeID)
	}
	if m.FieldCleared(business.FieldStoreID) {
		fields = append(fields, business.FieldStoreID)
	}
	if m.FieldCleared(business.FieldPlanID) {
		fields = append(fields, business.FieldPlanID)
	}
	if m.FieldCleared(business.FieldEnterpriseID) {
		fields = append(fields, business.FieldEnterpriseID)
	}
	if m.FieldCleared(business.FieldStationID) {
		fields = append(fields, business.FieldStationID)
	}
	if m.FieldCleared(business.FieldCabinetID) {
		fields = append(fields, business.FieldCabinetID)
	}
	if m.FieldCleared(business.FieldBatteryID) {
		fields = append(fields, business.FieldBatteryID)
	}
	if m.FieldCleared(business.FieldAgentID) {
		fields = append(fields, business.FieldAgentID)
	}
	if m.FieldCleared(business.FieldBinInfo) {
		fields = append(fields, business.FieldBinInfo)
	}
	if m.FieldCleared(business.FieldStockSn) {
		fields = append(fields, business.FieldStockSn)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BusinessMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BusinessMutation) ClearField(name string) error {
	switch name {
	case business.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case business.FieldCreator:
		m.ClearCreator()
		return nil
	case business.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case business.FieldRemark:
		m.ClearRemark()
		return nil
	case business.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case business.FieldStoreID:
		m.ClearStoreID()
		return nil
	case business.FieldPlanID:
		m.ClearPlanID()
		return nil
	case business.FieldEnterpriseID:
		m.ClearEnterpriseID()
		return nil
	case business.FieldStationID:
		m.ClearStationID()
		return nil
	case business.FieldCabinetID:
		m.ClearCabinetID()
		return nil
	case business.FieldBatteryID:
		m.ClearBatteryID()
		return nil
	case business.FieldAgentID:
		m.ClearAgentID()
		return nil
	case business.FieldBinInfo:
		m.ClearBinInfo()
		return nil
	case business.FieldStockSn:
		m.ClearStockSn()
		return nil
	}
	return fmt.Errorf("unknown Business nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BusinessMutation) ResetField(name string) error {
	switch name {
	case business.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case business.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case business.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case business.FieldCreator:
		m.ResetCreator()
		return nil
	case business.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case business.FieldRemark:
		m.ResetRemark()
		return nil
	case business.FieldRiderID:
		m.ResetRiderID()
		return nil
	case business.FieldCityID:
		m.ResetCityID()
		return nil
	case business.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case business.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case business.FieldStoreID:
		m.ResetStoreID()
		return nil
	case business.FieldPlanID:
		m.ResetPlanID()
		return nil
	case business.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case business.FieldStationID:
		m.ResetStationID()
		return nil
	case business.FieldCabinetID:
		m.ResetCabinetID()
		return nil
	case business.FieldBatteryID:
		m.ResetBatteryID()
		return nil
	case business.FieldAgentID:
		m.ResetAgentID()
		return nil
	case business.FieldType:
		m.ResetType()
		return nil
	case business.FieldBinInfo:
		m.ResetBinInfo()
		return nil
	case business.FieldStockSn:
		m.ResetStockSn()
		return nil
	}
	return fmt.Errorf("unknown Business field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BusinessMutation) AddedEdges() []string {
	edges := make([]string, 0, 11)
	if m.rider != nil {
		edges = append(edges, business.EdgeRider)
	}
	if m.city != nil {
		edges = append(edges, business.EdgeCity)
	}
	if m.subscribe != nil {
		edges = append(edges, business.EdgeSubscribe)
	}
	if m.employee != nil {
		edges = append(edges, business.EdgeEmployee)
	}
	if m.store != nil {
		edges = append(edges, business.EdgeStore)
	}
	if m.plan != nil {
		edges = append(edges, business.EdgePlan)
	}
	if m.enterprise != nil {
		edges = append(edges, business.EdgeEnterprise)
	}
	if m.station != nil {
		edges = append(edges, business.EdgeStation)
	}
	if m.cabinet != nil {
		edges = append(edges, business.EdgeCabinet)
	}
	if m.battery != nil {
		edges = append(edges, business.EdgeBattery)
	}
	if m.agent != nil {
		edges = append(edges, business.EdgeAgent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BusinessMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case business.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case business.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case business.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	case business.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case business.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	case business.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	case business.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	case business.EdgeStation:
		if id := m.station; id != nil {
			return []ent.Value{*id}
		}
	case business.EdgeCabinet:
		if id := m.cabinet; id != nil {
			return []ent.Value{*id}
		}
	case business.EdgeBattery:
		if id := m.battery; id != nil {
			return []ent.Value{*id}
		}
	case business.EdgeAgent:
		if id := m.agent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BusinessMutation) RemovedEdges() []string {
	edges := make([]string, 0, 11)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BusinessMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BusinessMutation) ClearedEdges() []string {
	edges := make([]string, 0, 11)
	if m.clearedrider {
		edges = append(edges, business.EdgeRider)
	}
	if m.clearedcity {
		edges = append(edges, business.EdgeCity)
	}
	if m.clearedsubscribe {
		edges = append(edges, business.EdgeSubscribe)
	}
	if m.clearedemployee {
		edges = append(edges, business.EdgeEmployee)
	}
	if m.clearedstore {
		edges = append(edges, business.EdgeStore)
	}
	if m.clearedplan {
		edges = append(edges, business.EdgePlan)
	}
	if m.clearedenterprise {
		edges = append(edges, business.EdgeEnterprise)
	}
	if m.clearedstation {
		edges = append(edges, business.EdgeStation)
	}
	if m.clearedcabinet {
		edges = append(edges, business.EdgeCabinet)
	}
	if m.clearedbattery {
		edges = append(edges, business.EdgeBattery)
	}
	if m.clearedagent {
		edges = append(edges, business.EdgeAgent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BusinessMutation) EdgeCleared(name string) bool {
	switch name {
	case business.EdgeRider:
		return m.clearedrider
	case business.EdgeCity:
		return m.clearedcity
	case business.EdgeSubscribe:
		return m.clearedsubscribe
	case business.EdgeEmployee:
		return m.clearedemployee
	case business.EdgeStore:
		return m.clearedstore
	case business.EdgePlan:
		return m.clearedplan
	case business.EdgeEnterprise:
		return m.clearedenterprise
	case business.EdgeStation:
		return m.clearedstation
	case business.EdgeCabinet:
		return m.clearedcabinet
	case business.EdgeBattery:
		return m.clearedbattery
	case business.EdgeAgent:
		return m.clearedagent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BusinessMutation) ClearEdge(name string) error {
	switch name {
	case business.EdgeRider:
		m.ClearRider()
		return nil
	case business.EdgeCity:
		m.ClearCity()
		return nil
	case business.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	case business.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case business.EdgeStore:
		m.ClearStore()
		return nil
	case business.EdgePlan:
		m.ClearPlan()
		return nil
	case business.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	case business.EdgeStation:
		m.ClearStation()
		return nil
	case business.EdgeCabinet:
		m.ClearCabinet()
		return nil
	case business.EdgeBattery:
		m.ClearBattery()
		return nil
	case business.EdgeAgent:
		m.ClearAgent()
		return nil
	}
	return fmt.Errorf("unknown Business unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BusinessMutation) ResetEdge(name string) error {
	switch name {
	case business.EdgeRider:
		m.ResetRider()
		return nil
	case business.EdgeCity:
		m.ResetCity()
		return nil
	case business.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	case business.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case business.EdgeStore:
		m.ResetStore()
		return nil
	case business.EdgePlan:
		m.ResetPlan()
		return nil
	case business.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	case business.EdgeStation:
		m.ResetStation()
		return nil
	case business.EdgeCabinet:
		m.ResetCabinet()
		return nil
	case business.EdgeBattery:
		m.ResetBattery()
		return nil
	case business.EdgeAgent:
		m.ResetAgent()
		return nil
	}
	return fmt.Errorf("unknown Business edge %s", name)
}

// CabinetMutation represents an operation that mutates the Cabinet nodes in the graph.
type CabinetMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uint64
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *time.Time
	creator                 **model.Modifier
	last_modifier           **model.Modifier
	remark                  *string
	sn                      *string
	brand                   *adapter.CabinetBrand
	serial                  *string
	name                    *string
	doors                   *int
	adddoors                *int
	status                  *uint8
	addstatus               *int8
	lng                     *float64
	addlng                  *float64
	lat                     *float64
	addlat                  *float64
	geom                    **model.Geometry
	address                 *string
	sim_sn                  *string
	sim_date                *time.Time
	transferred             *bool
	intelligent             *bool
	health                  *uint8
	addhealth               *int8
	bin                     *model.CabinetBins
	appendbin               model.CabinetBins
	battery_num             *int
	addbattery_num          *int
	battery_full_num        *int
	addbattery_full_num     *int
	battery_charging_num    *int
	addbattery_charging_num *int
	empty_bin_num           *int
	addempty_bin_num        *int
	locked_bin_num          *int
	addlocked_bin_num       *int
	clearedFields           map[string]struct{}
	city                    *uint64
	clearedcity             bool
	branch                  *uint64
	clearedbranch           bool
	models                  map[uint64]struct{}
	removedmodels           map[uint64]struct{}
	clearedmodels           bool
	faults                  map[uint64]struct{}
	removedfaults           map[uint64]struct{}
	clearedfaults           bool
	exchanges               map[uint64]struct{}
	removedexchanges        map[uint64]struct{}
	clearedexchanges        bool
	stocks                  map[uint64]struct{}
	removedstocks           map[uint64]struct{}
	clearedstocks           bool
	batteries               map[uint64]struct{}
	removedbatteries        map[uint64]struct{}
	clearedbatteries        bool
	battery_flows           map[uint64]struct{}
	removedbattery_flows    map[uint64]struct{}
	clearedbattery_flows    bool
	station                 *uint64
	clearedstation          bool
	enterprise              *uint64
	clearedenterprise       bool
	done                    bool
	oldValue                func(context.Context) (*Cabinet, error)
	predicates              []predicate.Cabinet
}

var _ ent.Mutation = (*CabinetMutation)(nil)

// cabinetOption allows management of the mutation configuration using functional options.
type cabinetOption func(*CabinetMutation)

// newCabinetMutation creates new mutation for the Cabinet entity.
func newCabinetMutation(c config, op Op, opts ...cabinetOption) *CabinetMutation {
	m := &CabinetMutation{
		config:        c,
		op:            op,
		typ:           TypeCabinet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCabinetID sets the ID field of the mutation.
func withCabinetID(id uint64) cabinetOption {
	return func(m *CabinetMutation) {
		var (
			err   error
			once  sync.Once
			value *Cabinet
		)
		m.oldValue = func(ctx context.Context) (*Cabinet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cabinet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCabinet sets the old Cabinet of the mutation.
func withCabinet(node *Cabinet) cabinetOption {
	return func(m *CabinetMutation) {
		m.oldValue = func(context.Context) (*Cabinet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CabinetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CabinetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CabinetMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CabinetMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cabinet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CabinetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CabinetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CabinetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CabinetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CabinetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CabinetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CabinetMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CabinetMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CabinetMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[cabinet.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CabinetMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CabinetMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, cabinet.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *CabinetMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *CabinetMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *CabinetMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[cabinet.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *CabinetMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *CabinetMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, cabinet.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *CabinetMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *CabinetMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *CabinetMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[cabinet.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *CabinetMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *CabinetMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, cabinet.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *CabinetMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CabinetMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *CabinetMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[cabinet.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *CabinetMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *CabinetMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, cabinet.FieldRemark)
}

// SetCityID sets the "city_id" field.
func (m *CabinetMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *CabinetMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldCityID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ClearCityID clears the value of the "city_id" field.
func (m *CabinetMutation) ClearCityID() {
	m.city = nil
	m.clearedFields[cabinet.FieldCityID] = struct{}{}
}

// CityIDCleared returns if the "city_id" field was cleared in this mutation.
func (m *CabinetMutation) CityIDCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldCityID]
	return ok
}

// ResetCityID resets all changes to the "city_id" field.
func (m *CabinetMutation) ResetCityID() {
	m.city = nil
	delete(m.clearedFields, cabinet.FieldCityID)
}

// SetBranchID sets the "branch_id" field.
func (m *CabinetMutation) SetBranchID(u uint64) {
	m.branch = &u
}

// BranchID returns the value of the "branch_id" field in the mutation.
func (m *CabinetMutation) BranchID() (r uint64, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranchID returns the old "branch_id" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldBranchID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBranchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBranchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranchID: %w", err)
	}
	return oldValue.BranchID, nil
}

// ClearBranchID clears the value of the "branch_id" field.
func (m *CabinetMutation) ClearBranchID() {
	m.branch = nil
	m.clearedFields[cabinet.FieldBranchID] = struct{}{}
}

// BranchIDCleared returns if the "branch_id" field was cleared in this mutation.
func (m *CabinetMutation) BranchIDCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldBranchID]
	return ok
}

// ResetBranchID resets all changes to the "branch_id" field.
func (m *CabinetMutation) ResetBranchID() {
	m.branch = nil
	delete(m.clearedFields, cabinet.FieldBranchID)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *CabinetMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *CabinetMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldEnterpriseID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ClearEnterpriseID clears the value of the "enterprise_id" field.
func (m *CabinetMutation) ClearEnterpriseID() {
	m.enterprise = nil
	m.clearedFields[cabinet.FieldEnterpriseID] = struct{}{}
}

// EnterpriseIDCleared returns if the "enterprise_id" field was cleared in this mutation.
func (m *CabinetMutation) EnterpriseIDCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldEnterpriseID]
	return ok
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *CabinetMutation) ResetEnterpriseID() {
	m.enterprise = nil
	delete(m.clearedFields, cabinet.FieldEnterpriseID)
}

// SetStationID sets the "station_id" field.
func (m *CabinetMutation) SetStationID(u uint64) {
	m.station = &u
}

// StationID returns the value of the "station_id" field in the mutation.
func (m *CabinetMutation) StationID() (r uint64, exists bool) {
	v := m.station
	if v == nil {
		return
	}
	return *v, true
}

// OldStationID returns the old "station_id" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldStationID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStationID: %w", err)
	}
	return oldValue.StationID, nil
}

// ClearStationID clears the value of the "station_id" field.
func (m *CabinetMutation) ClearStationID() {
	m.station = nil
	m.clearedFields[cabinet.FieldStationID] = struct{}{}
}

// StationIDCleared returns if the "station_id" field was cleared in this mutation.
func (m *CabinetMutation) StationIDCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldStationID]
	return ok
}

// ResetStationID resets all changes to the "station_id" field.
func (m *CabinetMutation) ResetStationID() {
	m.station = nil
	delete(m.clearedFields, cabinet.FieldStationID)
}

// SetSn sets the "sn" field.
func (m *CabinetMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *CabinetMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *CabinetMutation) ResetSn() {
	m.sn = nil
}

// SetBrand sets the "brand" field.
func (m *CabinetMutation) SetBrand(ab adapter.CabinetBrand) {
	m.brand = &ab
}

// Brand returns the value of the "brand" field in the mutation.
func (m *CabinetMutation) Brand() (r adapter.CabinetBrand, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrand returns the old "brand" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldBrand(ctx context.Context) (v adapter.CabinetBrand, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrand: %w", err)
	}
	return oldValue.Brand, nil
}

// ResetBrand resets all changes to the "brand" field.
func (m *CabinetMutation) ResetBrand() {
	m.brand = nil
}

// SetSerial sets the "serial" field.
func (m *CabinetMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *CabinetMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ResetSerial resets all changes to the "serial" field.
func (m *CabinetMutation) ResetSerial() {
	m.serial = nil
}

// SetName sets the "name" field.
func (m *CabinetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CabinetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CabinetMutation) ResetName() {
	m.name = nil
}

// SetDoors sets the "doors" field.
func (m *CabinetMutation) SetDoors(i int) {
	m.doors = &i
	m.adddoors = nil
}

// Doors returns the value of the "doors" field in the mutation.
func (m *CabinetMutation) Doors() (r int, exists bool) {
	v := m.doors
	if v == nil {
		return
	}
	return *v, true
}

// OldDoors returns the old "doors" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldDoors(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDoors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDoors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoors: %w", err)
	}
	return oldValue.Doors, nil
}

// AddDoors adds i to the "doors" field.
func (m *CabinetMutation) AddDoors(i int) {
	if m.adddoors != nil {
		*m.adddoors += i
	} else {
		m.adddoors = &i
	}
}

// AddedDoors returns the value that was added to the "doors" field in this mutation.
func (m *CabinetMutation) AddedDoors() (r int, exists bool) {
	v := m.adddoors
	if v == nil {
		return
	}
	return *v, true
}

// ResetDoors resets all changes to the "doors" field.
func (m *CabinetMutation) ResetDoors() {
	m.doors = nil
	m.adddoors = nil
}

// SetStatus sets the "status" field.
func (m *CabinetMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CabinetMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *CabinetMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CabinetMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CabinetMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetLng sets the "lng" field.
func (m *CabinetMutation) SetLng(f float64) {
	m.lng = &f
	m.addlng = nil
}

// Lng returns the value of the "lng" field in the mutation.
func (m *CabinetMutation) Lng() (r float64, exists bool) {
	v := m.lng
	if v == nil {
		return
	}
	return *v, true
}

// OldLng returns the old "lng" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldLng(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLng is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLng requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLng: %w", err)
	}
	return oldValue.Lng, nil
}

// AddLng adds f to the "lng" field.
func (m *CabinetMutation) AddLng(f float64) {
	if m.addlng != nil {
		*m.addlng += f
	} else {
		m.addlng = &f
	}
}

// AddedLng returns the value that was added to the "lng" field in this mutation.
func (m *CabinetMutation) AddedLng() (r float64, exists bool) {
	v := m.addlng
	if v == nil {
		return
	}
	return *v, true
}

// ClearLng clears the value of the "lng" field.
func (m *CabinetMutation) ClearLng() {
	m.lng = nil
	m.addlng = nil
	m.clearedFields[cabinet.FieldLng] = struct{}{}
}

// LngCleared returns if the "lng" field was cleared in this mutation.
func (m *CabinetMutation) LngCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldLng]
	return ok
}

// ResetLng resets all changes to the "lng" field.
func (m *CabinetMutation) ResetLng() {
	m.lng = nil
	m.addlng = nil
	delete(m.clearedFields, cabinet.FieldLng)
}

// SetLat sets the "lat" field.
func (m *CabinetMutation) SetLat(f float64) {
	m.lat = &f
	m.addlat = nil
}

// Lat returns the value of the "lat" field in the mutation.
func (m *CabinetMutation) Lat() (r float64, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "lat" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// AddLat adds f to the "lat" field.
func (m *CabinetMutation) AddLat(f float64) {
	if m.addlat != nil {
		*m.addlat += f
	} else {
		m.addlat = &f
	}
}

// AddedLat returns the value that was added to the "lat" field in this mutation.
func (m *CabinetMutation) AddedLat() (r float64, exists bool) {
	v := m.addlat
	if v == nil {
		return
	}
	return *v, true
}

// ClearLat clears the value of the "lat" field.
func (m *CabinetMutation) ClearLat() {
	m.lat = nil
	m.addlat = nil
	m.clearedFields[cabinet.FieldLat] = struct{}{}
}

// LatCleared returns if the "lat" field was cleared in this mutation.
func (m *CabinetMutation) LatCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldLat]
	return ok
}

// ResetLat resets all changes to the "lat" field.
func (m *CabinetMutation) ResetLat() {
	m.lat = nil
	m.addlat = nil
	delete(m.clearedFields, cabinet.FieldLat)
}

// SetGeom sets the "geom" field.
func (m *CabinetMutation) SetGeom(value *model.Geometry) {
	m.geom = &value
}

// Geom returns the value of the "geom" field in the mutation.
func (m *CabinetMutation) Geom() (r *model.Geometry, exists bool) {
	v := m.geom
	if v == nil {
		return
	}
	return *v, true
}

// OldGeom returns the old "geom" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldGeom(ctx context.Context) (v *model.Geometry, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGeom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGeom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGeom: %w", err)
	}
	return oldValue.Geom, nil
}

// ClearGeom clears the value of the "geom" field.
func (m *CabinetMutation) ClearGeom() {
	m.geom = nil
	m.clearedFields[cabinet.FieldGeom] = struct{}{}
}

// GeomCleared returns if the "geom" field was cleared in this mutation.
func (m *CabinetMutation) GeomCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldGeom]
	return ok
}

// ResetGeom resets all changes to the "geom" field.
func (m *CabinetMutation) ResetGeom() {
	m.geom = nil
	delete(m.clearedFields, cabinet.FieldGeom)
}

// SetAddress sets the "address" field.
func (m *CabinetMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *CabinetMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *CabinetMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[cabinet.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *CabinetMutation) AddressCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *CabinetMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, cabinet.FieldAddress)
}

// SetSimSn sets the "sim_sn" field.
func (m *CabinetMutation) SetSimSn(s string) {
	m.sim_sn = &s
}

// SimSn returns the value of the "sim_sn" field in the mutation.
func (m *CabinetMutation) SimSn() (r string, exists bool) {
	v := m.sim_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSimSn returns the old "sim_sn" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldSimSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSimSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSimSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSimSn: %w", err)
	}
	return oldValue.SimSn, nil
}

// ClearSimSn clears the value of the "sim_sn" field.
func (m *CabinetMutation) ClearSimSn() {
	m.sim_sn = nil
	m.clearedFields[cabinet.FieldSimSn] = struct{}{}
}

// SimSnCleared returns if the "sim_sn" field was cleared in this mutation.
func (m *CabinetMutation) SimSnCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldSimSn]
	return ok
}

// ResetSimSn resets all changes to the "sim_sn" field.
func (m *CabinetMutation) ResetSimSn() {
	m.sim_sn = nil
	delete(m.clearedFields, cabinet.FieldSimSn)
}

// SetSimDate sets the "sim_date" field.
func (m *CabinetMutation) SetSimDate(t time.Time) {
	m.sim_date = &t
}

// SimDate returns the value of the "sim_date" field in the mutation.
func (m *CabinetMutation) SimDate() (r time.Time, exists bool) {
	v := m.sim_date
	if v == nil {
		return
	}
	return *v, true
}

// OldSimDate returns the old "sim_date" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldSimDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSimDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSimDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSimDate: %w", err)
	}
	return oldValue.SimDate, nil
}

// ClearSimDate clears the value of the "sim_date" field.
func (m *CabinetMutation) ClearSimDate() {
	m.sim_date = nil
	m.clearedFields[cabinet.FieldSimDate] = struct{}{}
}

// SimDateCleared returns if the "sim_date" field was cleared in this mutation.
func (m *CabinetMutation) SimDateCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldSimDate]
	return ok
}

// ResetSimDate resets all changes to the "sim_date" field.
func (m *CabinetMutation) ResetSimDate() {
	m.sim_date = nil
	delete(m.clearedFields, cabinet.FieldSimDate)
}

// SetTransferred sets the "transferred" field.
func (m *CabinetMutation) SetTransferred(b bool) {
	m.transferred = &b
}

// Transferred returns the value of the "transferred" field in the mutation.
func (m *CabinetMutation) Transferred() (r bool, exists bool) {
	v := m.transferred
	if v == nil {
		return
	}
	return *v, true
}

// OldTransferred returns the old "transferred" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldTransferred(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransferred is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransferred requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransferred: %w", err)
	}
	return oldValue.Transferred, nil
}

// ResetTransferred resets all changes to the "transferred" field.
func (m *CabinetMutation) ResetTransferred() {
	m.transferred = nil
}

// SetIntelligent sets the "intelligent" field.
func (m *CabinetMutation) SetIntelligent(b bool) {
	m.intelligent = &b
}

// Intelligent returns the value of the "intelligent" field in the mutation.
func (m *CabinetMutation) Intelligent() (r bool, exists bool) {
	v := m.intelligent
	if v == nil {
		return
	}
	return *v, true
}

// OldIntelligent returns the old "intelligent" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldIntelligent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntelligent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntelligent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntelligent: %w", err)
	}
	return oldValue.Intelligent, nil
}

// ResetIntelligent resets all changes to the "intelligent" field.
func (m *CabinetMutation) ResetIntelligent() {
	m.intelligent = nil
}

// SetHealth sets the "health" field.
func (m *CabinetMutation) SetHealth(u uint8) {
	m.health = &u
	m.addhealth = nil
}

// Health returns the value of the "health" field in the mutation.
func (m *CabinetMutation) Health() (r uint8, exists bool) {
	v := m.health
	if v == nil {
		return
	}
	return *v, true
}

// OldHealth returns the old "health" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldHealth(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHealth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHealth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealth: %w", err)
	}
	return oldValue.Health, nil
}

// AddHealth adds u to the "health" field.
func (m *CabinetMutation) AddHealth(u int8) {
	if m.addhealth != nil {
		*m.addhealth += u
	} else {
		m.addhealth = &u
	}
}

// AddedHealth returns the value that was added to the "health" field in this mutation.
func (m *CabinetMutation) AddedHealth() (r int8, exists bool) {
	v := m.addhealth
	if v == nil {
		return
	}
	return *v, true
}

// ResetHealth resets all changes to the "health" field.
func (m *CabinetMutation) ResetHealth() {
	m.health = nil
	m.addhealth = nil
}

// SetBin sets the "bin" field.
func (m *CabinetMutation) SetBin(mb model.CabinetBins) {
	m.bin = &mb
	m.appendbin = nil
}

// Bin returns the value of the "bin" field in the mutation.
func (m *CabinetMutation) Bin() (r model.CabinetBins, exists bool) {
	v := m.bin
	if v == nil {
		return
	}
	return *v, true
}

// OldBin returns the old "bin" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldBin(ctx context.Context) (v model.CabinetBins, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBin: %w", err)
	}
	return oldValue.Bin, nil
}

// AppendBin adds mb to the "bin" field.
func (m *CabinetMutation) AppendBin(mb model.CabinetBins) {
	m.appendbin = append(m.appendbin, mb...)
}

// AppendedBin returns the list of values that were appended to the "bin" field in this mutation.
func (m *CabinetMutation) AppendedBin() (model.CabinetBins, bool) {
	if len(m.appendbin) == 0 {
		return nil, false
	}
	return m.appendbin, true
}

// ClearBin clears the value of the "bin" field.
func (m *CabinetMutation) ClearBin() {
	m.bin = nil
	m.appendbin = nil
	m.clearedFields[cabinet.FieldBin] = struct{}{}
}

// BinCleared returns if the "bin" field was cleared in this mutation.
func (m *CabinetMutation) BinCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldBin]
	return ok
}

// ResetBin resets all changes to the "bin" field.
func (m *CabinetMutation) ResetBin() {
	m.bin = nil
	m.appendbin = nil
	delete(m.clearedFields, cabinet.FieldBin)
}

// SetBatteryNum sets the "battery_num" field.
func (m *CabinetMutation) SetBatteryNum(i int) {
	m.battery_num = &i
	m.addbattery_num = nil
}

// BatteryNum returns the value of the "battery_num" field in the mutation.
func (m *CabinetMutation) BatteryNum() (r int, exists bool) {
	v := m.battery_num
	if v == nil {
		return
	}
	return *v, true
}

// OldBatteryNum returns the old "battery_num" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldBatteryNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatteryNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatteryNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatteryNum: %w", err)
	}
	return oldValue.BatteryNum, nil
}

// AddBatteryNum adds i to the "battery_num" field.
func (m *CabinetMutation) AddBatteryNum(i int) {
	if m.addbattery_num != nil {
		*m.addbattery_num += i
	} else {
		m.addbattery_num = &i
	}
}

// AddedBatteryNum returns the value that was added to the "battery_num" field in this mutation.
func (m *CabinetMutation) AddedBatteryNum() (r int, exists bool) {
	v := m.addbattery_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetBatteryNum resets all changes to the "battery_num" field.
func (m *CabinetMutation) ResetBatteryNum() {
	m.battery_num = nil
	m.addbattery_num = nil
}

// SetBatteryFullNum sets the "battery_full_num" field.
func (m *CabinetMutation) SetBatteryFullNum(i int) {
	m.battery_full_num = &i
	m.addbattery_full_num = nil
}

// BatteryFullNum returns the value of the "battery_full_num" field in the mutation.
func (m *CabinetMutation) BatteryFullNum() (r int, exists bool) {
	v := m.battery_full_num
	if v == nil {
		return
	}
	return *v, true
}

// OldBatteryFullNum returns the old "battery_full_num" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldBatteryFullNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatteryFullNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatteryFullNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatteryFullNum: %w", err)
	}
	return oldValue.BatteryFullNum, nil
}

// AddBatteryFullNum adds i to the "battery_full_num" field.
func (m *CabinetMutation) AddBatteryFullNum(i int) {
	if m.addbattery_full_num != nil {
		*m.addbattery_full_num += i
	} else {
		m.addbattery_full_num = &i
	}
}

// AddedBatteryFullNum returns the value that was added to the "battery_full_num" field in this mutation.
func (m *CabinetMutation) AddedBatteryFullNum() (r int, exists bool) {
	v := m.addbattery_full_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetBatteryFullNum resets all changes to the "battery_full_num" field.
func (m *CabinetMutation) ResetBatteryFullNum() {
	m.battery_full_num = nil
	m.addbattery_full_num = nil
}

// SetBatteryChargingNum sets the "battery_charging_num" field.
func (m *CabinetMutation) SetBatteryChargingNum(i int) {
	m.battery_charging_num = &i
	m.addbattery_charging_num = nil
}

// BatteryChargingNum returns the value of the "battery_charging_num" field in the mutation.
func (m *CabinetMutation) BatteryChargingNum() (r int, exists bool) {
	v := m.battery_charging_num
	if v == nil {
		return
	}
	return *v, true
}

// OldBatteryChargingNum returns the old "battery_charging_num" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldBatteryChargingNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatteryChargingNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatteryChargingNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatteryChargingNum: %w", err)
	}
	return oldValue.BatteryChargingNum, nil
}

// AddBatteryChargingNum adds i to the "battery_charging_num" field.
func (m *CabinetMutation) AddBatteryChargingNum(i int) {
	if m.addbattery_charging_num != nil {
		*m.addbattery_charging_num += i
	} else {
		m.addbattery_charging_num = &i
	}
}

// AddedBatteryChargingNum returns the value that was added to the "battery_charging_num" field in this mutation.
func (m *CabinetMutation) AddedBatteryChargingNum() (r int, exists bool) {
	v := m.addbattery_charging_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetBatteryChargingNum resets all changes to the "battery_charging_num" field.
func (m *CabinetMutation) ResetBatteryChargingNum() {
	m.battery_charging_num = nil
	m.addbattery_charging_num = nil
}

// SetEmptyBinNum sets the "empty_bin_num" field.
func (m *CabinetMutation) SetEmptyBinNum(i int) {
	m.empty_bin_num = &i
	m.addempty_bin_num = nil
}

// EmptyBinNum returns the value of the "empty_bin_num" field in the mutation.
func (m *CabinetMutation) EmptyBinNum() (r int, exists bool) {
	v := m.empty_bin_num
	if v == nil {
		return
	}
	return *v, true
}

// OldEmptyBinNum returns the old "empty_bin_num" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldEmptyBinNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmptyBinNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmptyBinNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmptyBinNum: %w", err)
	}
	return oldValue.EmptyBinNum, nil
}

// AddEmptyBinNum adds i to the "empty_bin_num" field.
func (m *CabinetMutation) AddEmptyBinNum(i int) {
	if m.addempty_bin_num != nil {
		*m.addempty_bin_num += i
	} else {
		m.addempty_bin_num = &i
	}
}

// AddedEmptyBinNum returns the value that was added to the "empty_bin_num" field in this mutation.
func (m *CabinetMutation) AddedEmptyBinNum() (r int, exists bool) {
	v := m.addempty_bin_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetEmptyBinNum resets all changes to the "empty_bin_num" field.
func (m *CabinetMutation) ResetEmptyBinNum() {
	m.empty_bin_num = nil
	m.addempty_bin_num = nil
}

// SetLockedBinNum sets the "locked_bin_num" field.
func (m *CabinetMutation) SetLockedBinNum(i int) {
	m.locked_bin_num = &i
	m.addlocked_bin_num = nil
}

// LockedBinNum returns the value of the "locked_bin_num" field in the mutation.
func (m *CabinetMutation) LockedBinNum() (r int, exists bool) {
	v := m.locked_bin_num
	if v == nil {
		return
	}
	return *v, true
}

// OldLockedBinNum returns the old "locked_bin_num" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldLockedBinNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockedBinNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockedBinNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockedBinNum: %w", err)
	}
	return oldValue.LockedBinNum, nil
}

// AddLockedBinNum adds i to the "locked_bin_num" field.
func (m *CabinetMutation) AddLockedBinNum(i int) {
	if m.addlocked_bin_num != nil {
		*m.addlocked_bin_num += i
	} else {
		m.addlocked_bin_num = &i
	}
}

// AddedLockedBinNum returns the value that was added to the "locked_bin_num" field in this mutation.
func (m *CabinetMutation) AddedLockedBinNum() (r int, exists bool) {
	v := m.addlocked_bin_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetLockedBinNum resets all changes to the "locked_bin_num" field.
func (m *CabinetMutation) ResetLockedBinNum() {
	m.locked_bin_num = nil
	m.addlocked_bin_num = nil
}

// ClearCity clears the "city" edge to the City entity.
func (m *CabinetMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[cabinet.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *CabinetMutation) CityCleared() bool {
	return m.CityIDCleared() || m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *CabinetMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *CabinetMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearBranch clears the "branch" edge to the Branch entity.
func (m *CabinetMutation) ClearBranch() {
	m.clearedbranch = true
	m.clearedFields[cabinet.FieldBranchID] = struct{}{}
}

// BranchCleared reports if the "branch" edge to the Branch entity was cleared.
func (m *CabinetMutation) BranchCleared() bool {
	return m.BranchIDCleared() || m.clearedbranch
}

// BranchIDs returns the "branch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BranchID instead. It exists only for internal usage by the builders.
func (m *CabinetMutation) BranchIDs() (ids []uint64) {
	if id := m.branch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBranch resets all changes to the "branch" edge.
func (m *CabinetMutation) ResetBranch() {
	m.branch = nil
	m.clearedbranch = false
}

// AddModelIDs adds the "models" edge to the BatteryModel entity by ids.
func (m *CabinetMutation) AddModelIDs(ids ...uint64) {
	if m.models == nil {
		m.models = make(map[uint64]struct{})
	}
	for i := range ids {
		m.models[ids[i]] = struct{}{}
	}
}

// ClearModels clears the "models" edge to the BatteryModel entity.
func (m *CabinetMutation) ClearModels() {
	m.clearedmodels = true
}

// ModelsCleared reports if the "models" edge to the BatteryModel entity was cleared.
func (m *CabinetMutation) ModelsCleared() bool {
	return m.clearedmodels
}

// RemoveModelIDs removes the "models" edge to the BatteryModel entity by IDs.
func (m *CabinetMutation) RemoveModelIDs(ids ...uint64) {
	if m.removedmodels == nil {
		m.removedmodels = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.models, ids[i])
		m.removedmodels[ids[i]] = struct{}{}
	}
}

// RemovedModels returns the removed IDs of the "models" edge to the BatteryModel entity.
func (m *CabinetMutation) RemovedModelsIDs() (ids []uint64) {
	for id := range m.removedmodels {
		ids = append(ids, id)
	}
	return
}

// ModelsIDs returns the "models" edge IDs in the mutation.
func (m *CabinetMutation) ModelsIDs() (ids []uint64) {
	for id := range m.models {
		ids = append(ids, id)
	}
	return
}

// ResetModels resets all changes to the "models" edge.
func (m *CabinetMutation) ResetModels() {
	m.models = nil
	m.clearedmodels = false
	m.removedmodels = nil
}

// AddFaultIDs adds the "faults" edge to the CabinetFault entity by ids.
func (m *CabinetMutation) AddFaultIDs(ids ...uint64) {
	if m.faults == nil {
		m.faults = make(map[uint64]struct{})
	}
	for i := range ids {
		m.faults[ids[i]] = struct{}{}
	}
}

// ClearFaults clears the "faults" edge to the CabinetFault entity.
func (m *CabinetMutation) ClearFaults() {
	m.clearedfaults = true
}

// FaultsCleared reports if the "faults" edge to the CabinetFault entity was cleared.
func (m *CabinetMutation) FaultsCleared() bool {
	return m.clearedfaults
}

// RemoveFaultIDs removes the "faults" edge to the CabinetFault entity by IDs.
func (m *CabinetMutation) RemoveFaultIDs(ids ...uint64) {
	if m.removedfaults == nil {
		m.removedfaults = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.faults, ids[i])
		m.removedfaults[ids[i]] = struct{}{}
	}
}

// RemovedFaults returns the removed IDs of the "faults" edge to the CabinetFault entity.
func (m *CabinetMutation) RemovedFaultsIDs() (ids []uint64) {
	for id := range m.removedfaults {
		ids = append(ids, id)
	}
	return
}

// FaultsIDs returns the "faults" edge IDs in the mutation.
func (m *CabinetMutation) FaultsIDs() (ids []uint64) {
	for id := range m.faults {
		ids = append(ids, id)
	}
	return
}

// ResetFaults resets all changes to the "faults" edge.
func (m *CabinetMutation) ResetFaults() {
	m.faults = nil
	m.clearedfaults = false
	m.removedfaults = nil
}

// AddExchangeIDs adds the "exchanges" edge to the Exchange entity by ids.
func (m *CabinetMutation) AddExchangeIDs(ids ...uint64) {
	if m.exchanges == nil {
		m.exchanges = make(map[uint64]struct{})
	}
	for i := range ids {
		m.exchanges[ids[i]] = struct{}{}
	}
}

// ClearExchanges clears the "exchanges" edge to the Exchange entity.
func (m *CabinetMutation) ClearExchanges() {
	m.clearedexchanges = true
}

// ExchangesCleared reports if the "exchanges" edge to the Exchange entity was cleared.
func (m *CabinetMutation) ExchangesCleared() bool {
	return m.clearedexchanges
}

// RemoveExchangeIDs removes the "exchanges" edge to the Exchange entity by IDs.
func (m *CabinetMutation) RemoveExchangeIDs(ids ...uint64) {
	if m.removedexchanges == nil {
		m.removedexchanges = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.exchanges, ids[i])
		m.removedexchanges[ids[i]] = struct{}{}
	}
}

// RemovedExchanges returns the removed IDs of the "exchanges" edge to the Exchange entity.
func (m *CabinetMutation) RemovedExchangesIDs() (ids []uint64) {
	for id := range m.removedexchanges {
		ids = append(ids, id)
	}
	return
}

// ExchangesIDs returns the "exchanges" edge IDs in the mutation.
func (m *CabinetMutation) ExchangesIDs() (ids []uint64) {
	for id := range m.exchanges {
		ids = append(ids, id)
	}
	return
}

// ResetExchanges resets all changes to the "exchanges" edge.
func (m *CabinetMutation) ResetExchanges() {
	m.exchanges = nil
	m.clearedexchanges = false
	m.removedexchanges = nil
}

// AddStockIDs adds the "stocks" edge to the Stock entity by ids.
func (m *CabinetMutation) AddStockIDs(ids ...uint64) {
	if m.stocks == nil {
		m.stocks = make(map[uint64]struct{})
	}
	for i := range ids {
		m.stocks[ids[i]] = struct{}{}
	}
}

// ClearStocks clears the "stocks" edge to the Stock entity.
func (m *CabinetMutation) ClearStocks() {
	m.clearedstocks = true
}

// StocksCleared reports if the "stocks" edge to the Stock entity was cleared.
func (m *CabinetMutation) StocksCleared() bool {
	return m.clearedstocks
}

// RemoveStockIDs removes the "stocks" edge to the Stock entity by IDs.
func (m *CabinetMutation) RemoveStockIDs(ids ...uint64) {
	if m.removedstocks == nil {
		m.removedstocks = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.stocks, ids[i])
		m.removedstocks[ids[i]] = struct{}{}
	}
}

// RemovedStocks returns the removed IDs of the "stocks" edge to the Stock entity.
func (m *CabinetMutation) RemovedStocksIDs() (ids []uint64) {
	for id := range m.removedstocks {
		ids = append(ids, id)
	}
	return
}

// StocksIDs returns the "stocks" edge IDs in the mutation.
func (m *CabinetMutation) StocksIDs() (ids []uint64) {
	for id := range m.stocks {
		ids = append(ids, id)
	}
	return
}

// ResetStocks resets all changes to the "stocks" edge.
func (m *CabinetMutation) ResetStocks() {
	m.stocks = nil
	m.clearedstocks = false
	m.removedstocks = nil
}

// AddBatteryIDs adds the "batteries" edge to the Battery entity by ids.
func (m *CabinetMutation) AddBatteryIDs(ids ...uint64) {
	if m.batteries == nil {
		m.batteries = make(map[uint64]struct{})
	}
	for i := range ids {
		m.batteries[ids[i]] = struct{}{}
	}
}

// ClearBatteries clears the "batteries" edge to the Battery entity.
func (m *CabinetMutation) ClearBatteries() {
	m.clearedbatteries = true
}

// BatteriesCleared reports if the "batteries" edge to the Battery entity was cleared.
func (m *CabinetMutation) BatteriesCleared() bool {
	return m.clearedbatteries
}

// RemoveBatteryIDs removes the "batteries" edge to the Battery entity by IDs.
func (m *CabinetMutation) RemoveBatteryIDs(ids ...uint64) {
	if m.removedbatteries == nil {
		m.removedbatteries = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.batteries, ids[i])
		m.removedbatteries[ids[i]] = struct{}{}
	}
}

// RemovedBatteries returns the removed IDs of the "batteries" edge to the Battery entity.
func (m *CabinetMutation) RemovedBatteriesIDs() (ids []uint64) {
	for id := range m.removedbatteries {
		ids = append(ids, id)
	}
	return
}

// BatteriesIDs returns the "batteries" edge IDs in the mutation.
func (m *CabinetMutation) BatteriesIDs() (ids []uint64) {
	for id := range m.batteries {
		ids = append(ids, id)
	}
	return
}

// ResetBatteries resets all changes to the "batteries" edge.
func (m *CabinetMutation) ResetBatteries() {
	m.batteries = nil
	m.clearedbatteries = false
	m.removedbatteries = nil
}

// AddBatteryFlowIDs adds the "battery_flows" edge to the BatteryFlow entity by ids.
func (m *CabinetMutation) AddBatteryFlowIDs(ids ...uint64) {
	if m.battery_flows == nil {
		m.battery_flows = make(map[uint64]struct{})
	}
	for i := range ids {
		m.battery_flows[ids[i]] = struct{}{}
	}
}

// ClearBatteryFlows clears the "battery_flows" edge to the BatteryFlow entity.
func (m *CabinetMutation) ClearBatteryFlows() {
	m.clearedbattery_flows = true
}

// BatteryFlowsCleared reports if the "battery_flows" edge to the BatteryFlow entity was cleared.
func (m *CabinetMutation) BatteryFlowsCleared() bool {
	return m.clearedbattery_flows
}

// RemoveBatteryFlowIDs removes the "battery_flows" edge to the BatteryFlow entity by IDs.
func (m *CabinetMutation) RemoveBatteryFlowIDs(ids ...uint64) {
	if m.removedbattery_flows == nil {
		m.removedbattery_flows = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.battery_flows, ids[i])
		m.removedbattery_flows[ids[i]] = struct{}{}
	}
}

// RemovedBatteryFlows returns the removed IDs of the "battery_flows" edge to the BatteryFlow entity.
func (m *CabinetMutation) RemovedBatteryFlowsIDs() (ids []uint64) {
	for id := range m.removedbattery_flows {
		ids = append(ids, id)
	}
	return
}

// BatteryFlowsIDs returns the "battery_flows" edge IDs in the mutation.
func (m *CabinetMutation) BatteryFlowsIDs() (ids []uint64) {
	for id := range m.battery_flows {
		ids = append(ids, id)
	}
	return
}

// ResetBatteryFlows resets all changes to the "battery_flows" edge.
func (m *CabinetMutation) ResetBatteryFlows() {
	m.battery_flows = nil
	m.clearedbattery_flows = false
	m.removedbattery_flows = nil
}

// ClearStation clears the "station" edge to the EnterpriseStation entity.
func (m *CabinetMutation) ClearStation() {
	m.clearedstation = true
	m.clearedFields[cabinet.FieldStationID] = struct{}{}
}

// StationCleared reports if the "station" edge to the EnterpriseStation entity was cleared.
func (m *CabinetMutation) StationCleared() bool {
	return m.StationIDCleared() || m.clearedstation
}

// StationIDs returns the "station" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StationID instead. It exists only for internal usage by the builders.
func (m *CabinetMutation) StationIDs() (ids []uint64) {
	if id := m.station; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStation resets all changes to the "station" edge.
func (m *CabinetMutation) ResetStation() {
	m.station = nil
	m.clearedstation = false
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *CabinetMutation) ClearEnterprise() {
	m.clearedenterprise = true
	m.clearedFields[cabinet.FieldEnterpriseID] = struct{}{}
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *CabinetMutation) EnterpriseCleared() bool {
	return m.EnterpriseIDCleared() || m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *CabinetMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *CabinetMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// Where appends a list predicates to the CabinetMutation builder.
func (m *CabinetMutation) Where(ps ...predicate.Cabinet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CabinetMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CabinetMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Cabinet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CabinetMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CabinetMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Cabinet).
func (m *CabinetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CabinetMutation) Fields() []string {
	fields := make([]string, 0, 31)
	if m.created_at != nil {
		fields = append(fields, cabinet.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cabinet.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, cabinet.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, cabinet.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, cabinet.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, cabinet.FieldRemark)
	}
	if m.city != nil {
		fields = append(fields, cabinet.FieldCityID)
	}
	if m.branch != nil {
		fields = append(fields, cabinet.FieldBranchID)
	}
	if m.enterprise != nil {
		fields = append(fields, cabinet.FieldEnterpriseID)
	}
	if m.station != nil {
		fields = append(fields, cabinet.FieldStationID)
	}
	if m.sn != nil {
		fields = append(fields, cabinet.FieldSn)
	}
	if m.brand != nil {
		fields = append(fields, cabinet.FieldBrand)
	}
	if m.serial != nil {
		fields = append(fields, cabinet.FieldSerial)
	}
	if m.name != nil {
		fields = append(fields, cabinet.FieldName)
	}
	if m.doors != nil {
		fields = append(fields, cabinet.FieldDoors)
	}
	if m.status != nil {
		fields = append(fields, cabinet.FieldStatus)
	}
	if m.lng != nil {
		fields = append(fields, cabinet.FieldLng)
	}
	if m.lat != nil {
		fields = append(fields, cabinet.FieldLat)
	}
	if m.geom != nil {
		fields = append(fields, cabinet.FieldGeom)
	}
	if m.address != nil {
		fields = append(fields, cabinet.FieldAddress)
	}
	if m.sim_sn != nil {
		fields = append(fields, cabinet.FieldSimSn)
	}
	if m.sim_date != nil {
		fields = append(fields, cabinet.FieldSimDate)
	}
	if m.transferred != nil {
		fields = append(fields, cabinet.FieldTransferred)
	}
	if m.intelligent != nil {
		fields = append(fields, cabinet.FieldIntelligent)
	}
	if m.health != nil {
		fields = append(fields, cabinet.FieldHealth)
	}
	if m.bin != nil {
		fields = append(fields, cabinet.FieldBin)
	}
	if m.battery_num != nil {
		fields = append(fields, cabinet.FieldBatteryNum)
	}
	if m.battery_full_num != nil {
		fields = append(fields, cabinet.FieldBatteryFullNum)
	}
	if m.battery_charging_num != nil {
		fields = append(fields, cabinet.FieldBatteryChargingNum)
	}
	if m.empty_bin_num != nil {
		fields = append(fields, cabinet.FieldEmptyBinNum)
	}
	if m.locked_bin_num != nil {
		fields = append(fields, cabinet.FieldLockedBinNum)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CabinetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cabinet.FieldCreatedAt:
		return m.CreatedAt()
	case cabinet.FieldUpdatedAt:
		return m.UpdatedAt()
	case cabinet.FieldDeletedAt:
		return m.DeletedAt()
	case cabinet.FieldCreator:
		return m.Creator()
	case cabinet.FieldLastModifier:
		return m.LastModifier()
	case cabinet.FieldRemark:
		return m.Remark()
	case cabinet.FieldCityID:
		return m.CityID()
	case cabinet.FieldBranchID:
		return m.BranchID()
	case cabinet.FieldEnterpriseID:
		return m.EnterpriseID()
	case cabinet.FieldStationID:
		return m.StationID()
	case cabinet.FieldSn:
		return m.Sn()
	case cabinet.FieldBrand:
		return m.Brand()
	case cabinet.FieldSerial:
		return m.Serial()
	case cabinet.FieldName:
		return m.Name()
	case cabinet.FieldDoors:
		return m.Doors()
	case cabinet.FieldStatus:
		return m.Status()
	case cabinet.FieldLng:
		return m.Lng()
	case cabinet.FieldLat:
		return m.Lat()
	case cabinet.FieldGeom:
		return m.Geom()
	case cabinet.FieldAddress:
		return m.Address()
	case cabinet.FieldSimSn:
		return m.SimSn()
	case cabinet.FieldSimDate:
		return m.SimDate()
	case cabinet.FieldTransferred:
		return m.Transferred()
	case cabinet.FieldIntelligent:
		return m.Intelligent()
	case cabinet.FieldHealth:
		return m.Health()
	case cabinet.FieldBin:
		return m.Bin()
	case cabinet.FieldBatteryNum:
		return m.BatteryNum()
	case cabinet.FieldBatteryFullNum:
		return m.BatteryFullNum()
	case cabinet.FieldBatteryChargingNum:
		return m.BatteryChargingNum()
	case cabinet.FieldEmptyBinNum:
		return m.EmptyBinNum()
	case cabinet.FieldLockedBinNum:
		return m.LockedBinNum()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CabinetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cabinet.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cabinet.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cabinet.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case cabinet.FieldCreator:
		return m.OldCreator(ctx)
	case cabinet.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case cabinet.FieldRemark:
		return m.OldRemark(ctx)
	case cabinet.FieldCityID:
		return m.OldCityID(ctx)
	case cabinet.FieldBranchID:
		return m.OldBranchID(ctx)
	case cabinet.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case cabinet.FieldStationID:
		return m.OldStationID(ctx)
	case cabinet.FieldSn:
		return m.OldSn(ctx)
	case cabinet.FieldBrand:
		return m.OldBrand(ctx)
	case cabinet.FieldSerial:
		return m.OldSerial(ctx)
	case cabinet.FieldName:
		return m.OldName(ctx)
	case cabinet.FieldDoors:
		return m.OldDoors(ctx)
	case cabinet.FieldStatus:
		return m.OldStatus(ctx)
	case cabinet.FieldLng:
		return m.OldLng(ctx)
	case cabinet.FieldLat:
		return m.OldLat(ctx)
	case cabinet.FieldGeom:
		return m.OldGeom(ctx)
	case cabinet.FieldAddress:
		return m.OldAddress(ctx)
	case cabinet.FieldSimSn:
		return m.OldSimSn(ctx)
	case cabinet.FieldSimDate:
		return m.OldSimDate(ctx)
	case cabinet.FieldTransferred:
		return m.OldTransferred(ctx)
	case cabinet.FieldIntelligent:
		return m.OldIntelligent(ctx)
	case cabinet.FieldHealth:
		return m.OldHealth(ctx)
	case cabinet.FieldBin:
		return m.OldBin(ctx)
	case cabinet.FieldBatteryNum:
		return m.OldBatteryNum(ctx)
	case cabinet.FieldBatteryFullNum:
		return m.OldBatteryFullNum(ctx)
	case cabinet.FieldBatteryChargingNum:
		return m.OldBatteryChargingNum(ctx)
	case cabinet.FieldEmptyBinNum:
		return m.OldEmptyBinNum(ctx)
	case cabinet.FieldLockedBinNum:
		return m.OldLockedBinNum(ctx)
	}
	return nil, fmt.Errorf("unknown Cabinet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CabinetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cabinet.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cabinet.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cabinet.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case cabinet.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case cabinet.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case cabinet.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case cabinet.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case cabinet.FieldBranchID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranchID(v)
		return nil
	case cabinet.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case cabinet.FieldStationID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStationID(v)
		return nil
	case cabinet.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case cabinet.FieldBrand:
		v, ok := value.(adapter.CabinetBrand)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrand(v)
		return nil
	case cabinet.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case cabinet.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cabinet.FieldDoors:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoors(v)
		return nil
	case cabinet.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case cabinet.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLng(v)
		return nil
	case cabinet.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	case cabinet.FieldGeom:
		v, ok := value.(*model.Geometry)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGeom(v)
		return nil
	case cabinet.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case cabinet.FieldSimSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSimSn(v)
		return nil
	case cabinet.FieldSimDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSimDate(v)
		return nil
	case cabinet.FieldTransferred:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransferred(v)
		return nil
	case cabinet.FieldIntelligent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntelligent(v)
		return nil
	case cabinet.FieldHealth:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealth(v)
		return nil
	case cabinet.FieldBin:
		v, ok := value.(model.CabinetBins)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBin(v)
		return nil
	case cabinet.FieldBatteryNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatteryNum(v)
		return nil
	case cabinet.FieldBatteryFullNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatteryFullNum(v)
		return nil
	case cabinet.FieldBatteryChargingNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatteryChargingNum(v)
		return nil
	case cabinet.FieldEmptyBinNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmptyBinNum(v)
		return nil
	case cabinet.FieldLockedBinNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockedBinNum(v)
		return nil
	}
	return fmt.Errorf("unknown Cabinet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CabinetMutation) AddedFields() []string {
	var fields []string
	if m.adddoors != nil {
		fields = append(fields, cabinet.FieldDoors)
	}
	if m.addstatus != nil {
		fields = append(fields, cabinet.FieldStatus)
	}
	if m.addlng != nil {
		fields = append(fields, cabinet.FieldLng)
	}
	if m.addlat != nil {
		fields = append(fields, cabinet.FieldLat)
	}
	if m.addhealth != nil {
		fields = append(fields, cabinet.FieldHealth)
	}
	if m.addbattery_num != nil {
		fields = append(fields, cabinet.FieldBatteryNum)
	}
	if m.addbattery_full_num != nil {
		fields = append(fields, cabinet.FieldBatteryFullNum)
	}
	if m.addbattery_charging_num != nil {
		fields = append(fields, cabinet.FieldBatteryChargingNum)
	}
	if m.addempty_bin_num != nil {
		fields = append(fields, cabinet.FieldEmptyBinNum)
	}
	if m.addlocked_bin_num != nil {
		fields = append(fields, cabinet.FieldLockedBinNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CabinetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cabinet.FieldDoors:
		return m.AddedDoors()
	case cabinet.FieldStatus:
		return m.AddedStatus()
	case cabinet.FieldLng:
		return m.AddedLng()
	case cabinet.FieldLat:
		return m.AddedLat()
	case cabinet.FieldHealth:
		return m.AddedHealth()
	case cabinet.FieldBatteryNum:
		return m.AddedBatteryNum()
	case cabinet.FieldBatteryFullNum:
		return m.AddedBatteryFullNum()
	case cabinet.FieldBatteryChargingNum:
		return m.AddedBatteryChargingNum()
	case cabinet.FieldEmptyBinNum:
		return m.AddedEmptyBinNum()
	case cabinet.FieldLockedBinNum:
		return m.AddedLockedBinNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CabinetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cabinet.FieldDoors:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDoors(v)
		return nil
	case cabinet.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case cabinet.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLng(v)
		return nil
	case cabinet.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLat(v)
		return nil
	case cabinet.FieldHealth:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHealth(v)
		return nil
	case cabinet.FieldBatteryNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBatteryNum(v)
		return nil
	case cabinet.FieldBatteryFullNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBatteryFullNum(v)
		return nil
	case cabinet.FieldBatteryChargingNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBatteryChargingNum(v)
		return nil
	case cabinet.FieldEmptyBinNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEmptyBinNum(v)
		return nil
	case cabinet.FieldLockedBinNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLockedBinNum(v)
		return nil
	}
	return fmt.Errorf("unknown Cabinet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CabinetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cabinet.FieldDeletedAt) {
		fields = append(fields, cabinet.FieldDeletedAt)
	}
	if m.FieldCleared(cabinet.FieldCreator) {
		fields = append(fields, cabinet.FieldCreator)
	}
	if m.FieldCleared(cabinet.FieldLastModifier) {
		fields = append(fields, cabinet.FieldLastModifier)
	}
	if m.FieldCleared(cabinet.FieldRemark) {
		fields = append(fields, cabinet.FieldRemark)
	}
	if m.FieldCleared(cabinet.FieldCityID) {
		fields = append(fields, cabinet.FieldCityID)
	}
	if m.FieldCleared(cabinet.FieldBranchID) {
		fields = append(fields, cabinet.FieldBranchID)
	}
	if m.FieldCleared(cabinet.FieldEnterpriseID) {
		fields = append(fields, cabinet.FieldEnterpriseID)
	}
	if m.FieldCleared(cabinet.FieldStationID) {
		fields = append(fields, cabinet.FieldStationID)
	}
	if m.FieldCleared(cabinet.FieldLng) {
		fields = append(fields, cabinet.FieldLng)
	}
	if m.FieldCleared(cabinet.FieldLat) {
		fields = append(fields, cabinet.FieldLat)
	}
	if m.FieldCleared(cabinet.FieldGeom) {
		fields = append(fields, cabinet.FieldGeom)
	}
	if m.FieldCleared(cabinet.FieldAddress) {
		fields = append(fields, cabinet.FieldAddress)
	}
	if m.FieldCleared(cabinet.FieldSimSn) {
		fields = append(fields, cabinet.FieldSimSn)
	}
	if m.FieldCleared(cabinet.FieldSimDate) {
		fields = append(fields, cabinet.FieldSimDate)
	}
	if m.FieldCleared(cabinet.FieldBin) {
		fields = append(fields, cabinet.FieldBin)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CabinetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CabinetMutation) ClearField(name string) error {
	switch name {
	case cabinet.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case cabinet.FieldCreator:
		m.ClearCreator()
		return nil
	case cabinet.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case cabinet.FieldRemark:
		m.ClearRemark()
		return nil
	case cabinet.FieldCityID:
		m.ClearCityID()
		return nil
	case cabinet.FieldBranchID:
		m.ClearBranchID()
		return nil
	case cabinet.FieldEnterpriseID:
		m.ClearEnterpriseID()
		return nil
	case cabinet.FieldStationID:
		m.ClearStationID()
		return nil
	case cabinet.FieldLng:
		m.ClearLng()
		return nil
	case cabinet.FieldLat:
		m.ClearLat()
		return nil
	case cabinet.FieldGeom:
		m.ClearGeom()
		return nil
	case cabinet.FieldAddress:
		m.ClearAddress()
		return nil
	case cabinet.FieldSimSn:
		m.ClearSimSn()
		return nil
	case cabinet.FieldSimDate:
		m.ClearSimDate()
		return nil
	case cabinet.FieldBin:
		m.ClearBin()
		return nil
	}
	return fmt.Errorf("unknown Cabinet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CabinetMutation) ResetField(name string) error {
	switch name {
	case cabinet.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cabinet.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cabinet.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case cabinet.FieldCreator:
		m.ResetCreator()
		return nil
	case cabinet.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case cabinet.FieldRemark:
		m.ResetRemark()
		return nil
	case cabinet.FieldCityID:
		m.ResetCityID()
		return nil
	case cabinet.FieldBranchID:
		m.ResetBranchID()
		return nil
	case cabinet.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case cabinet.FieldStationID:
		m.ResetStationID()
		return nil
	case cabinet.FieldSn:
		m.ResetSn()
		return nil
	case cabinet.FieldBrand:
		m.ResetBrand()
		return nil
	case cabinet.FieldSerial:
		m.ResetSerial()
		return nil
	case cabinet.FieldName:
		m.ResetName()
		return nil
	case cabinet.FieldDoors:
		m.ResetDoors()
		return nil
	case cabinet.FieldStatus:
		m.ResetStatus()
		return nil
	case cabinet.FieldLng:
		m.ResetLng()
		return nil
	case cabinet.FieldLat:
		m.ResetLat()
		return nil
	case cabinet.FieldGeom:
		m.ResetGeom()
		return nil
	case cabinet.FieldAddress:
		m.ResetAddress()
		return nil
	case cabinet.FieldSimSn:
		m.ResetSimSn()
		return nil
	case cabinet.FieldSimDate:
		m.ResetSimDate()
		return nil
	case cabinet.FieldTransferred:
		m.ResetTransferred()
		return nil
	case cabinet.FieldIntelligent:
		m.ResetIntelligent()
		return nil
	case cabinet.FieldHealth:
		m.ResetHealth()
		return nil
	case cabinet.FieldBin:
		m.ResetBin()
		return nil
	case cabinet.FieldBatteryNum:
		m.ResetBatteryNum()
		return nil
	case cabinet.FieldBatteryFullNum:
		m.ResetBatteryFullNum()
		return nil
	case cabinet.FieldBatteryChargingNum:
		m.ResetBatteryChargingNum()
		return nil
	case cabinet.FieldEmptyBinNum:
		m.ResetEmptyBinNum()
		return nil
	case cabinet.FieldLockedBinNum:
		m.ResetLockedBinNum()
		return nil
	}
	return fmt.Errorf("unknown Cabinet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CabinetMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.city != nil {
		edges = append(edges, cabinet.EdgeCity)
	}
	if m.branch != nil {
		edges = append(edges, cabinet.EdgeBranch)
	}
	if m.models != nil {
		edges = append(edges, cabinet.EdgeModels)
	}
	if m.faults != nil {
		edges = append(edges, cabinet.EdgeFaults)
	}
	if m.exchanges != nil {
		edges = append(edges, cabinet.EdgeExchanges)
	}
	if m.stocks != nil {
		edges = append(edges, cabinet.EdgeStocks)
	}
	if m.batteries != nil {
		edges = append(edges, cabinet.EdgeBatteries)
	}
	if m.battery_flows != nil {
		edges = append(edges, cabinet.EdgeBatteryFlows)
	}
	if m.station != nil {
		edges = append(edges, cabinet.EdgeStation)
	}
	if m.enterprise != nil {
		edges = append(edges, cabinet.EdgeEnterprise)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CabinetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cabinet.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case cabinet.EdgeBranch:
		if id := m.branch; id != nil {
			return []ent.Value{*id}
		}
	case cabinet.EdgeModels:
		ids := make([]ent.Value, 0, len(m.models))
		for id := range m.models {
			ids = append(ids, id)
		}
		return ids
	case cabinet.EdgeFaults:
		ids := make([]ent.Value, 0, len(m.faults))
		for id := range m.faults {
			ids = append(ids, id)
		}
		return ids
	case cabinet.EdgeExchanges:
		ids := make([]ent.Value, 0, len(m.exchanges))
		for id := range m.exchanges {
			ids = append(ids, id)
		}
		return ids
	case cabinet.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.stocks))
		for id := range m.stocks {
			ids = append(ids, id)
		}
		return ids
	case cabinet.EdgeBatteries:
		ids := make([]ent.Value, 0, len(m.batteries))
		for id := range m.batteries {
			ids = append(ids, id)
		}
		return ids
	case cabinet.EdgeBatteryFlows:
		ids := make([]ent.Value, 0, len(m.battery_flows))
		for id := range m.battery_flows {
			ids = append(ids, id)
		}
		return ids
	case cabinet.EdgeStation:
		if id := m.station; id != nil {
			return []ent.Value{*id}
		}
	case cabinet.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CabinetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedmodels != nil {
		edges = append(edges, cabinet.EdgeModels)
	}
	if m.removedfaults != nil {
		edges = append(edges, cabinet.EdgeFaults)
	}
	if m.removedexchanges != nil {
		edges = append(edges, cabinet.EdgeExchanges)
	}
	if m.removedstocks != nil {
		edges = append(edges, cabinet.EdgeStocks)
	}
	if m.removedbatteries != nil {
		edges = append(edges, cabinet.EdgeBatteries)
	}
	if m.removedbattery_flows != nil {
		edges = append(edges, cabinet.EdgeBatteryFlows)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CabinetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cabinet.EdgeModels:
		ids := make([]ent.Value, 0, len(m.removedmodels))
		for id := range m.removedmodels {
			ids = append(ids, id)
		}
		return ids
	case cabinet.EdgeFaults:
		ids := make([]ent.Value, 0, len(m.removedfaults))
		for id := range m.removedfaults {
			ids = append(ids, id)
		}
		return ids
	case cabinet.EdgeExchanges:
		ids := make([]ent.Value, 0, len(m.removedexchanges))
		for id := range m.removedexchanges {
			ids = append(ids, id)
		}
		return ids
	case cabinet.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.removedstocks))
		for id := range m.removedstocks {
			ids = append(ids, id)
		}
		return ids
	case cabinet.EdgeBatteries:
		ids := make([]ent.Value, 0, len(m.removedbatteries))
		for id := range m.removedbatteries {
			ids = append(ids, id)
		}
		return ids
	case cabinet.EdgeBatteryFlows:
		ids := make([]ent.Value, 0, len(m.removedbattery_flows))
		for id := range m.removedbattery_flows {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CabinetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedcity {
		edges = append(edges, cabinet.EdgeCity)
	}
	if m.clearedbranch {
		edges = append(edges, cabinet.EdgeBranch)
	}
	if m.clearedmodels {
		edges = append(edges, cabinet.EdgeModels)
	}
	if m.clearedfaults {
		edges = append(edges, cabinet.EdgeFaults)
	}
	if m.clearedexchanges {
		edges = append(edges, cabinet.EdgeExchanges)
	}
	if m.clearedstocks {
		edges = append(edges, cabinet.EdgeStocks)
	}
	if m.clearedbatteries {
		edges = append(edges, cabinet.EdgeBatteries)
	}
	if m.clearedbattery_flows {
		edges = append(edges, cabinet.EdgeBatteryFlows)
	}
	if m.clearedstation {
		edges = append(edges, cabinet.EdgeStation)
	}
	if m.clearedenterprise {
		edges = append(edges, cabinet.EdgeEnterprise)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CabinetMutation) EdgeCleared(name string) bool {
	switch name {
	case cabinet.EdgeCity:
		return m.clearedcity
	case cabinet.EdgeBranch:
		return m.clearedbranch
	case cabinet.EdgeModels:
		return m.clearedmodels
	case cabinet.EdgeFaults:
		return m.clearedfaults
	case cabinet.EdgeExchanges:
		return m.clearedexchanges
	case cabinet.EdgeStocks:
		return m.clearedstocks
	case cabinet.EdgeBatteries:
		return m.clearedbatteries
	case cabinet.EdgeBatteryFlows:
		return m.clearedbattery_flows
	case cabinet.EdgeStation:
		return m.clearedstation
	case cabinet.EdgeEnterprise:
		return m.clearedenterprise
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CabinetMutation) ClearEdge(name string) error {
	switch name {
	case cabinet.EdgeCity:
		m.ClearCity()
		return nil
	case cabinet.EdgeBranch:
		m.ClearBranch()
		return nil
	case cabinet.EdgeStation:
		m.ClearStation()
		return nil
	case cabinet.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	}
	return fmt.Errorf("unknown Cabinet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CabinetMutation) ResetEdge(name string) error {
	switch name {
	case cabinet.EdgeCity:
		m.ResetCity()
		return nil
	case cabinet.EdgeBranch:
		m.ResetBranch()
		return nil
	case cabinet.EdgeModels:
		m.ResetModels()
		return nil
	case cabinet.EdgeFaults:
		m.ResetFaults()
		return nil
	case cabinet.EdgeExchanges:
		m.ResetExchanges()
		return nil
	case cabinet.EdgeStocks:
		m.ResetStocks()
		return nil
	case cabinet.EdgeBatteries:
		m.ResetBatteries()
		return nil
	case cabinet.EdgeBatteryFlows:
		m.ResetBatteryFlows()
		return nil
	case cabinet.EdgeStation:
		m.ResetStation()
		return nil
	case cabinet.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	}
	return fmt.Errorf("unknown Cabinet edge %s", name)
}

// CabinetFaultMutation represents an operation that mutates the CabinetFault nodes in the graph.
type CabinetFaultMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	status            *uint8
	addstatus         *int8
	fault             *string
	attachments       *[]string
	appendattachments []string
	description       *string
	clearedFields     map[string]struct{}
	city              *uint64
	clearedcity       bool
	branch            *uint64
	clearedbranch     bool
	cabinet           *uint64
	clearedcabinet    bool
	rider             *uint64
	clearedrider      bool
	done              bool
	oldValue          func(context.Context) (*CabinetFault, error)
	predicates        []predicate.CabinetFault
}

var _ ent.Mutation = (*CabinetFaultMutation)(nil)

// cabinetfaultOption allows management of the mutation configuration using functional options.
type cabinetfaultOption func(*CabinetFaultMutation)

// newCabinetFaultMutation creates new mutation for the CabinetFault entity.
func newCabinetFaultMutation(c config, op Op, opts ...cabinetfaultOption) *CabinetFaultMutation {
	m := &CabinetFaultMutation{
		config:        c,
		op:            op,
		typ:           TypeCabinetFault,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCabinetFaultID sets the ID field of the mutation.
func withCabinetFaultID(id uint64) cabinetfaultOption {
	return func(m *CabinetFaultMutation) {
		var (
			err   error
			once  sync.Once
			value *CabinetFault
		)
		m.oldValue = func(ctx context.Context) (*CabinetFault, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CabinetFault.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCabinetFault sets the old CabinetFault of the mutation.
func withCabinetFault(node *CabinetFault) cabinetfaultOption {
	return func(m *CabinetFaultMutation) {
		m.oldValue = func(context.Context) (*CabinetFault, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CabinetFaultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CabinetFaultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CabinetFaultMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CabinetFaultMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CabinetFault.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CabinetFaultMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CabinetFaultMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CabinetFaultMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CabinetFaultMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CabinetFaultMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CabinetFaultMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CabinetFaultMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CabinetFaultMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CabinetFaultMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[cabinetfault.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CabinetFaultMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[cabinetfault.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CabinetFaultMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, cabinetfault.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *CabinetFaultMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *CabinetFaultMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *CabinetFaultMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[cabinetfault.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *CabinetFaultMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[cabinetfault.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *CabinetFaultMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, cabinetfault.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *CabinetFaultMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *CabinetFaultMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *CabinetFaultMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[cabinetfault.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *CabinetFaultMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[cabinetfault.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *CabinetFaultMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, cabinetfault.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *CabinetFaultMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CabinetFaultMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *CabinetFaultMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[cabinetfault.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *CabinetFaultMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[cabinetfault.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *CabinetFaultMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, cabinetfault.FieldRemark)
}

// SetCityID sets the "city_id" field.
func (m *CabinetFaultMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *CabinetFaultMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *CabinetFaultMutation) ResetCityID() {
	m.city = nil
}

// SetStatus sets the "status" field.
func (m *CabinetFaultMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CabinetFaultMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *CabinetFaultMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CabinetFaultMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CabinetFaultMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetBranchID sets the "branch_id" field.
func (m *CabinetFaultMutation) SetBranchID(u uint64) {
	m.branch = &u
}

// BranchID returns the value of the "branch_id" field in the mutation.
func (m *CabinetFaultMutation) BranchID() (r uint64, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranchID returns the old "branch_id" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldBranchID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBranchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBranchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranchID: %w", err)
	}
	return oldValue.BranchID, nil
}

// ResetBranchID resets all changes to the "branch_id" field.
func (m *CabinetFaultMutation) ResetBranchID() {
	m.branch = nil
}

// SetCabinetID sets the "cabinet_id" field.
func (m *CabinetFaultMutation) SetCabinetID(u uint64) {
	m.cabinet = &u
}

// CabinetID returns the value of the "cabinet_id" field in the mutation.
func (m *CabinetFaultMutation) CabinetID() (r uint64, exists bool) {
	v := m.cabinet
	if v == nil {
		return
	}
	return *v, true
}

// OldCabinetID returns the old "cabinet_id" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldCabinetID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCabinetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCabinetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCabinetID: %w", err)
	}
	return oldValue.CabinetID, nil
}

// ResetCabinetID resets all changes to the "cabinet_id" field.
func (m *CabinetFaultMutation) ResetCabinetID() {
	m.cabinet = nil
}

// SetRiderID sets the "rider_id" field.
func (m *CabinetFaultMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *CabinetFaultMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *CabinetFaultMutation) ResetRiderID() {
	m.rider = nil
}

// SetFault sets the "fault" field.
func (m *CabinetFaultMutation) SetFault(s string) {
	m.fault = &s
}

// Fault returns the value of the "fault" field in the mutation.
func (m *CabinetFaultMutation) Fault() (r string, exists bool) {
	v := m.fault
	if v == nil {
		return
	}
	return *v, true
}

// OldFault returns the old "fault" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldFault(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFault: %w", err)
	}
	return oldValue.Fault, nil
}

// ClearFault clears the value of the "fault" field.
func (m *CabinetFaultMutation) ClearFault() {
	m.fault = nil
	m.clearedFields[cabinetfault.FieldFault] = struct{}{}
}

// FaultCleared returns if the "fault" field was cleared in this mutation.
func (m *CabinetFaultMutation) FaultCleared() bool {
	_, ok := m.clearedFields[cabinetfault.FieldFault]
	return ok
}

// ResetFault resets all changes to the "fault" field.
func (m *CabinetFaultMutation) ResetFault() {
	m.fault = nil
	delete(m.clearedFields, cabinetfault.FieldFault)
}

// SetAttachments sets the "attachments" field.
func (m *CabinetFaultMutation) SetAttachments(s []string) {
	m.attachments = &s
	m.appendattachments = nil
}

// Attachments returns the value of the "attachments" field in the mutation.
func (m *CabinetFaultMutation) Attachments() (r []string, exists bool) {
	v := m.attachments
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachments returns the old "attachments" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldAttachments(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttachments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttachments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachments: %w", err)
	}
	return oldValue.Attachments, nil
}

// AppendAttachments adds s to the "attachments" field.
func (m *CabinetFaultMutation) AppendAttachments(s []string) {
	m.appendattachments = append(m.appendattachments, s...)
}

// AppendedAttachments returns the list of values that were appended to the "attachments" field in this mutation.
func (m *CabinetFaultMutation) AppendedAttachments() ([]string, bool) {
	if len(m.appendattachments) == 0 {
		return nil, false
	}
	return m.appendattachments, true
}

// ClearAttachments clears the value of the "attachments" field.
func (m *CabinetFaultMutation) ClearAttachments() {
	m.attachments = nil
	m.appendattachments = nil
	m.clearedFields[cabinetfault.FieldAttachments] = struct{}{}
}

// AttachmentsCleared returns if the "attachments" field was cleared in this mutation.
func (m *CabinetFaultMutation) AttachmentsCleared() bool {
	_, ok := m.clearedFields[cabinetfault.FieldAttachments]
	return ok
}

// ResetAttachments resets all changes to the "attachments" field.
func (m *CabinetFaultMutation) ResetAttachments() {
	m.attachments = nil
	m.appendattachments = nil
	delete(m.clearedFields, cabinetfault.FieldAttachments)
}

// SetDescription sets the "description" field.
func (m *CabinetFaultMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CabinetFaultMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CabinetFaultMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[cabinetfault.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CabinetFaultMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[cabinetfault.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CabinetFaultMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, cabinetfault.FieldDescription)
}

// ClearCity clears the "city" edge to the City entity.
func (m *CabinetFaultMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[cabinetfault.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *CabinetFaultMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *CabinetFaultMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *CabinetFaultMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearBranch clears the "branch" edge to the Branch entity.
func (m *CabinetFaultMutation) ClearBranch() {
	m.clearedbranch = true
	m.clearedFields[cabinetfault.FieldBranchID] = struct{}{}
}

// BranchCleared reports if the "branch" edge to the Branch entity was cleared.
func (m *CabinetFaultMutation) BranchCleared() bool {
	return m.clearedbranch
}

// BranchIDs returns the "branch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BranchID instead. It exists only for internal usage by the builders.
func (m *CabinetFaultMutation) BranchIDs() (ids []uint64) {
	if id := m.branch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBranch resets all changes to the "branch" edge.
func (m *CabinetFaultMutation) ResetBranch() {
	m.branch = nil
	m.clearedbranch = false
}

// ClearCabinet clears the "cabinet" edge to the Cabinet entity.
func (m *CabinetFaultMutation) ClearCabinet() {
	m.clearedcabinet = true
	m.clearedFields[cabinetfault.FieldCabinetID] = struct{}{}
}

// CabinetCleared reports if the "cabinet" edge to the Cabinet entity was cleared.
func (m *CabinetFaultMutation) CabinetCleared() bool {
	return m.clearedcabinet
}

// CabinetIDs returns the "cabinet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CabinetID instead. It exists only for internal usage by the builders.
func (m *CabinetFaultMutation) CabinetIDs() (ids []uint64) {
	if id := m.cabinet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCabinet resets all changes to the "cabinet" edge.
func (m *CabinetFaultMutation) ResetCabinet() {
	m.cabinet = nil
	m.clearedcabinet = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *CabinetFaultMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[cabinetfault.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *CabinetFaultMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *CabinetFaultMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *CabinetFaultMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// Where appends a list predicates to the CabinetFaultMutation builder.
func (m *CabinetFaultMutation) Where(ps ...predicate.CabinetFault) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CabinetFaultMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CabinetFaultMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CabinetFault, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CabinetFaultMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CabinetFaultMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CabinetFault).
func (m *CabinetFaultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CabinetFaultMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, cabinetfault.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cabinetfault.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, cabinetfault.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, cabinetfault.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, cabinetfault.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, cabinetfault.FieldRemark)
	}
	if m.city != nil {
		fields = append(fields, cabinetfault.FieldCityID)
	}
	if m.status != nil {
		fields = append(fields, cabinetfault.FieldStatus)
	}
	if m.branch != nil {
		fields = append(fields, cabinetfault.FieldBranchID)
	}
	if m.cabinet != nil {
		fields = append(fields, cabinetfault.FieldCabinetID)
	}
	if m.rider != nil {
		fields = append(fields, cabinetfault.FieldRiderID)
	}
	if m.fault != nil {
		fields = append(fields, cabinetfault.FieldFault)
	}
	if m.attachments != nil {
		fields = append(fields, cabinetfault.FieldAttachments)
	}
	if m.description != nil {
		fields = append(fields, cabinetfault.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CabinetFaultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cabinetfault.FieldCreatedAt:
		return m.CreatedAt()
	case cabinetfault.FieldUpdatedAt:
		return m.UpdatedAt()
	case cabinetfault.FieldDeletedAt:
		return m.DeletedAt()
	case cabinetfault.FieldCreator:
		return m.Creator()
	case cabinetfault.FieldLastModifier:
		return m.LastModifier()
	case cabinetfault.FieldRemark:
		return m.Remark()
	case cabinetfault.FieldCityID:
		return m.CityID()
	case cabinetfault.FieldStatus:
		return m.Status()
	case cabinetfault.FieldBranchID:
		return m.BranchID()
	case cabinetfault.FieldCabinetID:
		return m.CabinetID()
	case cabinetfault.FieldRiderID:
		return m.RiderID()
	case cabinetfault.FieldFault:
		return m.Fault()
	case cabinetfault.FieldAttachments:
		return m.Attachments()
	case cabinetfault.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CabinetFaultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cabinetfault.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cabinetfault.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cabinetfault.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case cabinetfault.FieldCreator:
		return m.OldCreator(ctx)
	case cabinetfault.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case cabinetfault.FieldRemark:
		return m.OldRemark(ctx)
	case cabinetfault.FieldCityID:
		return m.OldCityID(ctx)
	case cabinetfault.FieldStatus:
		return m.OldStatus(ctx)
	case cabinetfault.FieldBranchID:
		return m.OldBranchID(ctx)
	case cabinetfault.FieldCabinetID:
		return m.OldCabinetID(ctx)
	case cabinetfault.FieldRiderID:
		return m.OldRiderID(ctx)
	case cabinetfault.FieldFault:
		return m.OldFault(ctx)
	case cabinetfault.FieldAttachments:
		return m.OldAttachments(ctx)
	case cabinetfault.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown CabinetFault field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CabinetFaultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cabinetfault.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cabinetfault.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cabinetfault.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case cabinetfault.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case cabinetfault.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case cabinetfault.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case cabinetfault.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case cabinetfault.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case cabinetfault.FieldBranchID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranchID(v)
		return nil
	case cabinetfault.FieldCabinetID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCabinetID(v)
		return nil
	case cabinetfault.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case cabinetfault.FieldFault:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFault(v)
		return nil
	case cabinetfault.FieldAttachments:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachments(v)
		return nil
	case cabinetfault.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown CabinetFault field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CabinetFaultMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, cabinetfault.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CabinetFaultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cabinetfault.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CabinetFaultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cabinetfault.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown CabinetFault numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CabinetFaultMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cabinetfault.FieldDeletedAt) {
		fields = append(fields, cabinetfault.FieldDeletedAt)
	}
	if m.FieldCleared(cabinetfault.FieldCreator) {
		fields = append(fields, cabinetfault.FieldCreator)
	}
	if m.FieldCleared(cabinetfault.FieldLastModifier) {
		fields = append(fields, cabinetfault.FieldLastModifier)
	}
	if m.FieldCleared(cabinetfault.FieldRemark) {
		fields = append(fields, cabinetfault.FieldRemark)
	}
	if m.FieldCleared(cabinetfault.FieldFault) {
		fields = append(fields, cabinetfault.FieldFault)
	}
	if m.FieldCleared(cabinetfault.FieldAttachments) {
		fields = append(fields, cabinetfault.FieldAttachments)
	}
	if m.FieldCleared(cabinetfault.FieldDescription) {
		fields = append(fields, cabinetfault.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CabinetFaultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CabinetFaultMutation) ClearField(name string) error {
	switch name {
	case cabinetfault.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case cabinetfault.FieldCreator:
		m.ClearCreator()
		return nil
	case cabinetfault.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case cabinetfault.FieldRemark:
		m.ClearRemark()
		return nil
	case cabinetfault.FieldFault:
		m.ClearFault()
		return nil
	case cabinetfault.FieldAttachments:
		m.ClearAttachments()
		return nil
	case cabinetfault.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown CabinetFault nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CabinetFaultMutation) ResetField(name string) error {
	switch name {
	case cabinetfault.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cabinetfault.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cabinetfault.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case cabinetfault.FieldCreator:
		m.ResetCreator()
		return nil
	case cabinetfault.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case cabinetfault.FieldRemark:
		m.ResetRemark()
		return nil
	case cabinetfault.FieldCityID:
		m.ResetCityID()
		return nil
	case cabinetfault.FieldStatus:
		m.ResetStatus()
		return nil
	case cabinetfault.FieldBranchID:
		m.ResetBranchID()
		return nil
	case cabinetfault.FieldCabinetID:
		m.ResetCabinetID()
		return nil
	case cabinetfault.FieldRiderID:
		m.ResetRiderID()
		return nil
	case cabinetfault.FieldFault:
		m.ResetFault()
		return nil
	case cabinetfault.FieldAttachments:
		m.ResetAttachments()
		return nil
	case cabinetfault.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown CabinetFault field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CabinetFaultMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.city != nil {
		edges = append(edges, cabinetfault.EdgeCity)
	}
	if m.branch != nil {
		edges = append(edges, cabinetfault.EdgeBranch)
	}
	if m.cabinet != nil {
		edges = append(edges, cabinetfault.EdgeCabinet)
	}
	if m.rider != nil {
		edges = append(edges, cabinetfault.EdgeRider)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CabinetFaultMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cabinetfault.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case cabinetfault.EdgeBranch:
		if id := m.branch; id != nil {
			return []ent.Value{*id}
		}
	case cabinetfault.EdgeCabinet:
		if id := m.cabinet; id != nil {
			return []ent.Value{*id}
		}
	case cabinetfault.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CabinetFaultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CabinetFaultMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CabinetFaultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcity {
		edges = append(edges, cabinetfault.EdgeCity)
	}
	if m.clearedbranch {
		edges = append(edges, cabinetfault.EdgeBranch)
	}
	if m.clearedcabinet {
		edges = append(edges, cabinetfault.EdgeCabinet)
	}
	if m.clearedrider {
		edges = append(edges, cabinetfault.EdgeRider)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CabinetFaultMutation) EdgeCleared(name string) bool {
	switch name {
	case cabinetfault.EdgeCity:
		return m.clearedcity
	case cabinetfault.EdgeBranch:
		return m.clearedbranch
	case cabinetfault.EdgeCabinet:
		return m.clearedcabinet
	case cabinetfault.EdgeRider:
		return m.clearedrider
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CabinetFaultMutation) ClearEdge(name string) error {
	switch name {
	case cabinetfault.EdgeCity:
		m.ClearCity()
		return nil
	case cabinetfault.EdgeBranch:
		m.ClearBranch()
		return nil
	case cabinetfault.EdgeCabinet:
		m.ClearCabinet()
		return nil
	case cabinetfault.EdgeRider:
		m.ClearRider()
		return nil
	}
	return fmt.Errorf("unknown CabinetFault unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CabinetFaultMutation) ResetEdge(name string) error {
	switch name {
	case cabinetfault.EdgeCity:
		m.ResetCity()
		return nil
	case cabinetfault.EdgeBranch:
		m.ResetBranch()
		return nil
	case cabinetfault.EdgeCabinet:
		m.ResetCabinet()
		return nil
	case cabinetfault.EdgeRider:
		m.ResetRider()
		return nil
	}
	return fmt.Errorf("unknown CabinetFault edge %s", name)
}

// CityMutation represents an operation that mutates the City nodes in the graph.
type CityMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint64
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	creator            **model.Modifier
	last_modifier      **model.Modifier
	remark             *string
	open               *bool
	name               *string
	code               *string
	lng                *float64
	addlng             *float64
	lat                *float64
	addlat             *float64
	clearedFields      map[string]struct{}
	parent             *uint64
	clearedparent      bool
	children           map[uint64]struct{}
	removedchildren    map[uint64]struct{}
	clearedchildren    bool
	plans              map[uint64]struct{}
	removedplans       map[uint64]struct{}
	clearedplans       bool
	maintainers        map[uint64]struct{}
	removedmaintainers map[uint64]struct{}
	clearedmaintainers bool
	done               bool
	oldValue           func(context.Context) (*City, error)
	predicates         []predicate.City
}

var _ ent.Mutation = (*CityMutation)(nil)

// cityOption allows management of the mutation configuration using functional options.
type cityOption func(*CityMutation)

// newCityMutation creates new mutation for the City entity.
func newCityMutation(c config, op Op, opts ...cityOption) *CityMutation {
	m := &CityMutation{
		config:        c,
		op:            op,
		typ:           TypeCity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCityID sets the ID field of the mutation.
func withCityID(id uint64) cityOption {
	return func(m *CityMutation) {
		var (
			err   error
			once  sync.Once
			value *City
		)
		m.oldValue = func(ctx context.Context) (*City, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().City.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCity sets the old City of the mutation.
func withCity(node *City) cityOption {
	return func(m *CityMutation) {
		m.oldValue = func(context.Context) (*City, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of City entities.
func (m *CityMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CityMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CityMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().City.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CityMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CityMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CityMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[city.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CityMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[city.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CityMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, city.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *CityMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *CityMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *CityMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[city.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *CityMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[city.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *CityMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, city.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *CityMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *CityMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *CityMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[city.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *CityMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[city.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *CityMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, city.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *CityMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CityMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *CityMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[city.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *CityMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[city.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *CityMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, city.FieldRemark)
}

// SetOpen sets the "open" field.
func (m *CityMutation) SetOpen(b bool) {
	m.open = &b
}

// Open returns the value of the "open" field in the mutation.
func (m *CityMutation) Open() (r bool, exists bool) {
	v := m.open
	if v == nil {
		return
	}
	return *v, true
}

// OldOpen returns the old "open" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldOpen(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpen: %w", err)
	}
	return oldValue.Open, nil
}

// ClearOpen clears the value of the "open" field.
func (m *CityMutation) ClearOpen() {
	m.open = nil
	m.clearedFields[city.FieldOpen] = struct{}{}
}

// OpenCleared returns if the "open" field was cleared in this mutation.
func (m *CityMutation) OpenCleared() bool {
	_, ok := m.clearedFields[city.FieldOpen]
	return ok
}

// ResetOpen resets all changes to the "open" field.
func (m *CityMutation) ResetOpen() {
	m.open = nil
	delete(m.clearedFields, city.FieldOpen)
}

// SetName sets the "name" field.
func (m *CityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CityMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *CityMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CityMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CityMutation) ResetCode() {
	m.code = nil
}

// SetParentID sets the "parent_id" field.
func (m *CityMutation) SetParentID(u uint64) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CityMutation) ParentID() (r uint64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldParentID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *CityMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[city.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *CityMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[city.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CityMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, city.FieldParentID)
}

// SetLng sets the "lng" field.
func (m *CityMutation) SetLng(f float64) {
	m.lng = &f
	m.addlng = nil
}

// Lng returns the value of the "lng" field in the mutation.
func (m *CityMutation) Lng() (r float64, exists bool) {
	v := m.lng
	if v == nil {
		return
	}
	return *v, true
}

// OldLng returns the old "lng" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldLng(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLng is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLng requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLng: %w", err)
	}
	return oldValue.Lng, nil
}

// AddLng adds f to the "lng" field.
func (m *CityMutation) AddLng(f float64) {
	if m.addlng != nil {
		*m.addlng += f
	} else {
		m.addlng = &f
	}
}

// AddedLng returns the value that was added to the "lng" field in this mutation.
func (m *CityMutation) AddedLng() (r float64, exists bool) {
	v := m.addlng
	if v == nil {
		return
	}
	return *v, true
}

// ClearLng clears the value of the "lng" field.
func (m *CityMutation) ClearLng() {
	m.lng = nil
	m.addlng = nil
	m.clearedFields[city.FieldLng] = struct{}{}
}

// LngCleared returns if the "lng" field was cleared in this mutation.
func (m *CityMutation) LngCleared() bool {
	_, ok := m.clearedFields[city.FieldLng]
	return ok
}

// ResetLng resets all changes to the "lng" field.
func (m *CityMutation) ResetLng() {
	m.lng = nil
	m.addlng = nil
	delete(m.clearedFields, city.FieldLng)
}

// SetLat sets the "lat" field.
func (m *CityMutation) SetLat(f float64) {
	m.lat = &f
	m.addlat = nil
}

// Lat returns the value of the "lat" field in the mutation.
func (m *CityMutation) Lat() (r float64, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "lat" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// AddLat adds f to the "lat" field.
func (m *CityMutation) AddLat(f float64) {
	if m.addlat != nil {
		*m.addlat += f
	} else {
		m.addlat = &f
	}
}

// AddedLat returns the value that was added to the "lat" field in this mutation.
func (m *CityMutation) AddedLat() (r float64, exists bool) {
	v := m.addlat
	if v == nil {
		return
	}
	return *v, true
}

// ClearLat clears the value of the "lat" field.
func (m *CityMutation) ClearLat() {
	m.lat = nil
	m.addlat = nil
	m.clearedFields[city.FieldLat] = struct{}{}
}

// LatCleared returns if the "lat" field was cleared in this mutation.
func (m *CityMutation) LatCleared() bool {
	_, ok := m.clearedFields[city.FieldLat]
	return ok
}

// ResetLat resets all changes to the "lat" field.
func (m *CityMutation) ResetLat() {
	m.lat = nil
	m.addlat = nil
	delete(m.clearedFields, city.FieldLat)
}

// ClearParent clears the "parent" edge to the City entity.
func (m *CityMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[city.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the City entity was cleared.
func (m *CityMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CityMutation) ParentIDs() (ids []uint64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CityMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the City entity by ids.
func (m *CityMutation) AddChildIDs(ids ...uint64) {
	if m.children == nil {
		m.children = make(map[uint64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the City entity.
func (m *CityMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the City entity was cleared.
func (m *CityMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the City entity by IDs.
func (m *CityMutation) RemoveChildIDs(ids ...uint64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the City entity.
func (m *CityMutation) RemovedChildrenIDs() (ids []uint64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *CityMutation) ChildrenIDs() (ids []uint64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *CityMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddPlanIDs adds the "plans" edge to the Plan entity by ids.
func (m *CityMutation) AddPlanIDs(ids ...uint64) {
	if m.plans == nil {
		m.plans = make(map[uint64]struct{})
	}
	for i := range ids {
		m.plans[ids[i]] = struct{}{}
	}
}

// ClearPlans clears the "plans" edge to the Plan entity.
func (m *CityMutation) ClearPlans() {
	m.clearedplans = true
}

// PlansCleared reports if the "plans" edge to the Plan entity was cleared.
func (m *CityMutation) PlansCleared() bool {
	return m.clearedplans
}

// RemovePlanIDs removes the "plans" edge to the Plan entity by IDs.
func (m *CityMutation) RemovePlanIDs(ids ...uint64) {
	if m.removedplans == nil {
		m.removedplans = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.plans, ids[i])
		m.removedplans[ids[i]] = struct{}{}
	}
}

// RemovedPlans returns the removed IDs of the "plans" edge to the Plan entity.
func (m *CityMutation) RemovedPlansIDs() (ids []uint64) {
	for id := range m.removedplans {
		ids = append(ids, id)
	}
	return
}

// PlansIDs returns the "plans" edge IDs in the mutation.
func (m *CityMutation) PlansIDs() (ids []uint64) {
	for id := range m.plans {
		ids = append(ids, id)
	}
	return
}

// ResetPlans resets all changes to the "plans" edge.
func (m *CityMutation) ResetPlans() {
	m.plans = nil
	m.clearedplans = false
	m.removedplans = nil
}

// AddMaintainerIDs adds the "maintainers" edge to the Maintainer entity by ids.
func (m *CityMutation) AddMaintainerIDs(ids ...uint64) {
	if m.maintainers == nil {
		m.maintainers = make(map[uint64]struct{})
	}
	for i := range ids {
		m.maintainers[ids[i]] = struct{}{}
	}
}

// ClearMaintainers clears the "maintainers" edge to the Maintainer entity.
func (m *CityMutation) ClearMaintainers() {
	m.clearedmaintainers = true
}

// MaintainersCleared reports if the "maintainers" edge to the Maintainer entity was cleared.
func (m *CityMutation) MaintainersCleared() bool {
	return m.clearedmaintainers
}

// RemoveMaintainerIDs removes the "maintainers" edge to the Maintainer entity by IDs.
func (m *CityMutation) RemoveMaintainerIDs(ids ...uint64) {
	if m.removedmaintainers == nil {
		m.removedmaintainers = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.maintainers, ids[i])
		m.removedmaintainers[ids[i]] = struct{}{}
	}
}

// RemovedMaintainers returns the removed IDs of the "maintainers" edge to the Maintainer entity.
func (m *CityMutation) RemovedMaintainersIDs() (ids []uint64) {
	for id := range m.removedmaintainers {
		ids = append(ids, id)
	}
	return
}

// MaintainersIDs returns the "maintainers" edge IDs in the mutation.
func (m *CityMutation) MaintainersIDs() (ids []uint64) {
	for id := range m.maintainers {
		ids = append(ids, id)
	}
	return
}

// ResetMaintainers resets all changes to the "maintainers" edge.
func (m *CityMutation) ResetMaintainers() {
	m.maintainers = nil
	m.clearedmaintainers = false
	m.removedmaintainers = nil
}

// Where appends a list predicates to the CityMutation builder.
func (m *CityMutation) Where(ps ...predicate.City) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.City, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (City).
func (m *CityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CityMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, city.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, city.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, city.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, city.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, city.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, city.FieldRemark)
	}
	if m.open != nil {
		fields = append(fields, city.FieldOpen)
	}
	if m.name != nil {
		fields = append(fields, city.FieldName)
	}
	if m.code != nil {
		fields = append(fields, city.FieldCode)
	}
	if m.parent != nil {
		fields = append(fields, city.FieldParentID)
	}
	if m.lng != nil {
		fields = append(fields, city.FieldLng)
	}
	if m.lat != nil {
		fields = append(fields, city.FieldLat)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case city.FieldCreatedAt:
		return m.CreatedAt()
	case city.FieldUpdatedAt:
		return m.UpdatedAt()
	case city.FieldDeletedAt:
		return m.DeletedAt()
	case city.FieldCreator:
		return m.Creator()
	case city.FieldLastModifier:
		return m.LastModifier()
	case city.FieldRemark:
		return m.Remark()
	case city.FieldOpen:
		return m.Open()
	case city.FieldName:
		return m.Name()
	case city.FieldCode:
		return m.Code()
	case city.FieldParentID:
		return m.ParentID()
	case city.FieldLng:
		return m.Lng()
	case city.FieldLat:
		return m.Lat()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case city.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case city.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case city.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case city.FieldCreator:
		return m.OldCreator(ctx)
	case city.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case city.FieldRemark:
		return m.OldRemark(ctx)
	case city.FieldOpen:
		return m.OldOpen(ctx)
	case city.FieldName:
		return m.OldName(ctx)
	case city.FieldCode:
		return m.OldCode(ctx)
	case city.FieldParentID:
		return m.OldParentID(ctx)
	case city.FieldLng:
		return m.OldLng(ctx)
	case city.FieldLat:
		return m.OldLat(ctx)
	}
	return nil, fmt.Errorf("unknown City field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case city.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case city.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case city.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case city.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case city.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case city.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case city.FieldOpen:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpen(v)
		return nil
	case city.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case city.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case city.FieldParentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case city.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLng(v)
		return nil
	case city.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CityMutation) AddedFields() []string {
	var fields []string
	if m.addlng != nil {
		fields = append(fields, city.FieldLng)
	}
	if m.addlat != nil {
		fields = append(fields, city.FieldLat)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case city.FieldLng:
		return m.AddedLng()
	case city.FieldLat:
		return m.AddedLat()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case city.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLng(v)
		return nil
	case city.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLat(v)
		return nil
	}
	return fmt.Errorf("unknown City numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(city.FieldDeletedAt) {
		fields = append(fields, city.FieldDeletedAt)
	}
	if m.FieldCleared(city.FieldCreator) {
		fields = append(fields, city.FieldCreator)
	}
	if m.FieldCleared(city.FieldLastModifier) {
		fields = append(fields, city.FieldLastModifier)
	}
	if m.FieldCleared(city.FieldRemark) {
		fields = append(fields, city.FieldRemark)
	}
	if m.FieldCleared(city.FieldOpen) {
		fields = append(fields, city.FieldOpen)
	}
	if m.FieldCleared(city.FieldParentID) {
		fields = append(fields, city.FieldParentID)
	}
	if m.FieldCleared(city.FieldLng) {
		fields = append(fields, city.FieldLng)
	}
	if m.FieldCleared(city.FieldLat) {
		fields = append(fields, city.FieldLat)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CityMutation) ClearField(name string) error {
	switch name {
	case city.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case city.FieldCreator:
		m.ClearCreator()
		return nil
	case city.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case city.FieldRemark:
		m.ClearRemark()
		return nil
	case city.FieldOpen:
		m.ClearOpen()
		return nil
	case city.FieldParentID:
		m.ClearParentID()
		return nil
	case city.FieldLng:
		m.ClearLng()
		return nil
	case city.FieldLat:
		m.ClearLat()
		return nil
	}
	return fmt.Errorf("unknown City nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CityMutation) ResetField(name string) error {
	switch name {
	case city.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case city.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case city.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case city.FieldCreator:
		m.ResetCreator()
		return nil
	case city.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case city.FieldRemark:
		m.ResetRemark()
		return nil
	case city.FieldOpen:
		m.ResetOpen()
		return nil
	case city.FieldName:
		m.ResetName()
		return nil
	case city.FieldCode:
		m.ResetCode()
		return nil
	case city.FieldParentID:
		m.ResetParentID()
		return nil
	case city.FieldLng:
		m.ResetLng()
		return nil
	case city.FieldLat:
		m.ResetLat()
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CityMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.parent != nil {
		edges = append(edges, city.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, city.EdgeChildren)
	}
	if m.plans != nil {
		edges = append(edges, city.EdgePlans)
	}
	if m.maintainers != nil {
		edges = append(edges, city.EdgeMaintainers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case city.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case city.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case city.EdgePlans:
		ids := make([]ent.Value, 0, len(m.plans))
		for id := range m.plans {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeMaintainers:
		ids := make([]ent.Value, 0, len(m.maintainers))
		for id := range m.maintainers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, city.EdgeChildren)
	}
	if m.removedplans != nil {
		edges = append(edges, city.EdgePlans)
	}
	if m.removedmaintainers != nil {
		edges = append(edges, city.EdgeMaintainers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case city.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case city.EdgePlans:
		ids := make([]ent.Value, 0, len(m.removedplans))
		for id := range m.removedplans {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeMaintainers:
		ids := make([]ent.Value, 0, len(m.removedmaintainers))
		for id := range m.removedmaintainers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedparent {
		edges = append(edges, city.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, city.EdgeChildren)
	}
	if m.clearedplans {
		edges = append(edges, city.EdgePlans)
	}
	if m.clearedmaintainers {
		edges = append(edges, city.EdgeMaintainers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CityMutation) EdgeCleared(name string) bool {
	switch name {
	case city.EdgeParent:
		return m.clearedparent
	case city.EdgeChildren:
		return m.clearedchildren
	case city.EdgePlans:
		return m.clearedplans
	case city.EdgeMaintainers:
		return m.clearedmaintainers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CityMutation) ClearEdge(name string) error {
	switch name {
	case city.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown City unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CityMutation) ResetEdge(name string) error {
	switch name {
	case city.EdgeParent:
		m.ResetParent()
		return nil
	case city.EdgeChildren:
		m.ResetChildren()
		return nil
	case city.EdgePlans:
		m.ResetPlans()
		return nil
	case city.EdgeMaintainers:
		m.ResetMaintainers()
		return nil
	}
	return fmt.Errorf("unknown City edge %s", name)
}

// CommissionMutation represents an operation that mutates the Commission nodes in the graph.
type CommissionMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	creator          **model.Modifier
	last_modifier    **model.Modifier
	remark           *string
	amount           *float64
	addamount        *float64
	status           *uint8
	addstatus        *int8
	clearedFields    map[string]struct{}
	business         *uint64
	clearedbusiness  bool
	subscribe        *uint64
	clearedsubscribe bool
	plan             *uint64
	clearedplan      bool
	rider            *uint64
	clearedrider     bool
	_order           *uint64
	cleared_order    bool
	employee         *uint64
	clearedemployee  bool
	done             bool
	oldValue         func(context.Context) (*Commission, error)
	predicates       []predicate.Commission
}

var _ ent.Mutation = (*CommissionMutation)(nil)

// commissionOption allows management of the mutation configuration using functional options.
type commissionOption func(*CommissionMutation)

// newCommissionMutation creates new mutation for the Commission entity.
func newCommissionMutation(c config, op Op, opts ...commissionOption) *CommissionMutation {
	m := &CommissionMutation{
		config:        c,
		op:            op,
		typ:           TypeCommission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommissionID sets the ID field of the mutation.
func withCommissionID(id uint64) commissionOption {
	return func(m *CommissionMutation) {
		var (
			err   error
			once  sync.Once
			value *Commission
		)
		m.oldValue = func(ctx context.Context) (*Commission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Commission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCommission sets the old Commission of the mutation.
func withCommission(node *Commission) commissionOption {
	return func(m *CommissionMutation) {
		m.oldValue = func(context.Context) (*Commission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommissionMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommissionMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Commission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CommissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CommissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CommissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CommissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CommissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CommissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CommissionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CommissionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CommissionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[commission.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CommissionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[commission.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CommissionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, commission.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *CommissionMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *CommissionMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *CommissionMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[commission.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *CommissionMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[commission.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *CommissionMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, commission.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *CommissionMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *CommissionMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *CommissionMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[commission.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *CommissionMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[commission.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *CommissionMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, commission.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *CommissionMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CommissionMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *CommissionMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[commission.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *CommissionMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[commission.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *CommissionMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, commission.FieldRemark)
}

// SetBusinessID sets the "business_id" field.
func (m *CommissionMutation) SetBusinessID(u uint64) {
	m.business = &u
}

// BusinessID returns the value of the "business_id" field in the mutation.
func (m *CommissionMutation) BusinessID() (r uint64, exists bool) {
	v := m.business
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessID returns the old "business_id" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldBusinessID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessID: %w", err)
	}
	return oldValue.BusinessID, nil
}

// ClearBusinessID clears the value of the "business_id" field.
func (m *CommissionMutation) ClearBusinessID() {
	m.business = nil
	m.clearedFields[commission.FieldBusinessID] = struct{}{}
}

// BusinessIDCleared returns if the "business_id" field was cleared in this mutation.
func (m *CommissionMutation) BusinessIDCleared() bool {
	_, ok := m.clearedFields[commission.FieldBusinessID]
	return ok
}

// ResetBusinessID resets all changes to the "business_id" field.
func (m *CommissionMutation) ResetBusinessID() {
	m.business = nil
	delete(m.clearedFields, commission.FieldBusinessID)
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *CommissionMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *CommissionMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldSubscribeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ClearSubscribeID clears the value of the "subscribe_id" field.
func (m *CommissionMutation) ClearSubscribeID() {
	m.subscribe = nil
	m.clearedFields[commission.FieldSubscribeID] = struct{}{}
}

// SubscribeIDCleared returns if the "subscribe_id" field was cleared in this mutation.
func (m *CommissionMutation) SubscribeIDCleared() bool {
	_, ok := m.clearedFields[commission.FieldSubscribeID]
	return ok
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *CommissionMutation) ResetSubscribeID() {
	m.subscribe = nil
	delete(m.clearedFields, commission.FieldSubscribeID)
}

// SetPlanID sets the "plan_id" field.
func (m *CommissionMutation) SetPlanID(u uint64) {
	m.plan = &u
}

// PlanID returns the value of the "plan_id" field in the mutation.
func (m *CommissionMutation) PlanID() (r uint64, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanID returns the old "plan_id" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldPlanID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanID: %w", err)
	}
	return oldValue.PlanID, nil
}

// ClearPlanID clears the value of the "plan_id" field.
func (m *CommissionMutation) ClearPlanID() {
	m.plan = nil
	m.clearedFields[commission.FieldPlanID] = struct{}{}
}

// PlanIDCleared returns if the "plan_id" field was cleared in this mutation.
func (m *CommissionMutation) PlanIDCleared() bool {
	_, ok := m.clearedFields[commission.FieldPlanID]
	return ok
}

// ResetPlanID resets all changes to the "plan_id" field.
func (m *CommissionMutation) ResetPlanID() {
	m.plan = nil
	delete(m.clearedFields, commission.FieldPlanID)
}

// SetRiderID sets the "rider_id" field.
func (m *CommissionMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *CommissionMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldRiderID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ClearRiderID clears the value of the "rider_id" field.
func (m *CommissionMutation) ClearRiderID() {
	m.rider = nil
	m.clearedFields[commission.FieldRiderID] = struct{}{}
}

// RiderIDCleared returns if the "rider_id" field was cleared in this mutation.
func (m *CommissionMutation) RiderIDCleared() bool {
	_, ok := m.clearedFields[commission.FieldRiderID]
	return ok
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *CommissionMutation) ResetRiderID() {
	m.rider = nil
	delete(m.clearedFields, commission.FieldRiderID)
}

// SetOrderID sets the "order_id" field.
func (m *CommissionMutation) SetOrderID(u uint64) {
	m._order = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *CommissionMutation) OrderID() (r uint64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldOrderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *CommissionMutation) ResetOrderID() {
	m._order = nil
}

// SetAmount sets the "amount" field.
func (m *CommissionMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *CommissionMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *CommissionMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *CommissionMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *CommissionMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetStatus sets the "status" field.
func (m *CommissionMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CommissionMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *CommissionMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CommissionMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CommissionMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetEmployeeID sets the "employee_id" field.
func (m *CommissionMutation) SetEmployeeID(u uint64) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *CommissionMutation) EmployeeID() (r uint64, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Commission entity.
// If the Commission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommissionMutation) OldEmployeeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *CommissionMutation) ClearEmployeeID() {
	m.employee = nil
	m.clearedFields[commission.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *CommissionMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[commission.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *CommissionMutation) ResetEmployeeID() {
	m.employee = nil
	delete(m.clearedFields, commission.FieldEmployeeID)
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *CommissionMutation) ClearBusiness() {
	m.clearedbusiness = true
	m.clearedFields[commission.FieldBusinessID] = struct{}{}
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *CommissionMutation) BusinessCleared() bool {
	return m.BusinessIDCleared() || m.clearedbusiness
}

// BusinessIDs returns the "business" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessID instead. It exists only for internal usage by the builders.
func (m *CommissionMutation) BusinessIDs() (ids []uint64) {
	if id := m.business; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *CommissionMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *CommissionMutation) ClearSubscribe() {
	m.clearedsubscribe = true
	m.clearedFields[commission.FieldSubscribeID] = struct{}{}
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *CommissionMutation) SubscribeCleared() bool {
	return m.SubscribeIDCleared() || m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *CommissionMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *CommissionMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// ClearPlan clears the "plan" edge to the Plan entity.
func (m *CommissionMutation) ClearPlan() {
	m.clearedplan = true
	m.clearedFields[commission.FieldPlanID] = struct{}{}
}

// PlanCleared reports if the "plan" edge to the Plan entity was cleared.
func (m *CommissionMutation) PlanCleared() bool {
	return m.PlanIDCleared() || m.clearedplan
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *CommissionMutation) PlanIDs() (ids []uint64) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *CommissionMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *CommissionMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[commission.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *CommissionMutation) RiderCleared() bool {
	return m.RiderIDCleared() || m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *CommissionMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *CommissionMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *CommissionMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[commission.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *CommissionMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *CommissionMutation) OrderIDs() (ids []uint64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *CommissionMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *CommissionMutation) ClearEmployee() {
	m.clearedemployee = true
	m.clearedFields[commission.FieldEmployeeID] = struct{}{}
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *CommissionMutation) EmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *CommissionMutation) EmployeeIDs() (ids []uint64) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *CommissionMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// Where appends a list predicates to the CommissionMutation builder.
func (m *CommissionMutation) Where(ps ...predicate.Commission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Commission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Commission).
func (m *CommissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommissionMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, commission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, commission.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, commission.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, commission.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, commission.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, commission.FieldRemark)
	}
	if m.business != nil {
		fields = append(fields, commission.FieldBusinessID)
	}
	if m.subscribe != nil {
		fields = append(fields, commission.FieldSubscribeID)
	}
	if m.plan != nil {
		fields = append(fields, commission.FieldPlanID)
	}
	if m.rider != nil {
		fields = append(fields, commission.FieldRiderID)
	}
	if m._order != nil {
		fields = append(fields, commission.FieldOrderID)
	}
	if m.amount != nil {
		fields = append(fields, commission.FieldAmount)
	}
	if m.status != nil {
		fields = append(fields, commission.FieldStatus)
	}
	if m.employee != nil {
		fields = append(fields, commission.FieldEmployeeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case commission.FieldCreatedAt:
		return m.CreatedAt()
	case commission.FieldUpdatedAt:
		return m.UpdatedAt()
	case commission.FieldDeletedAt:
		return m.DeletedAt()
	case commission.FieldCreator:
		return m.Creator()
	case commission.FieldLastModifier:
		return m.LastModifier()
	case commission.FieldRemark:
		return m.Remark()
	case commission.FieldBusinessID:
		return m.BusinessID()
	case commission.FieldSubscribeID:
		return m.SubscribeID()
	case commission.FieldPlanID:
		return m.PlanID()
	case commission.FieldRiderID:
		return m.RiderID()
	case commission.FieldOrderID:
		return m.OrderID()
	case commission.FieldAmount:
		return m.Amount()
	case commission.FieldStatus:
		return m.Status()
	case commission.FieldEmployeeID:
		return m.EmployeeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case commission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case commission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case commission.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case commission.FieldCreator:
		return m.OldCreator(ctx)
	case commission.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case commission.FieldRemark:
		return m.OldRemark(ctx)
	case commission.FieldBusinessID:
		return m.OldBusinessID(ctx)
	case commission.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case commission.FieldPlanID:
		return m.OldPlanID(ctx)
	case commission.FieldRiderID:
		return m.OldRiderID(ctx)
	case commission.FieldOrderID:
		return m.OldOrderID(ctx)
	case commission.FieldAmount:
		return m.OldAmount(ctx)
	case commission.FieldStatus:
		return m.OldStatus(ctx)
	case commission.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	}
	return nil, fmt.Errorf("unknown Commission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case commission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case commission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case commission.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case commission.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case commission.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case commission.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case commission.FieldBusinessID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessID(v)
		return nil
	case commission.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case commission.FieldPlanID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanID(v)
		return nil
	case commission.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case commission.FieldOrderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case commission.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case commission.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case commission.FieldEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	}
	return fmt.Errorf("unknown Commission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommissionMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, commission.FieldAmount)
	}
	if m.addstatus != nil {
		fields = append(fields, commission.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case commission.FieldAmount:
		return m.AddedAmount()
	case commission.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case commission.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case commission.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Commission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(commission.FieldDeletedAt) {
		fields = append(fields, commission.FieldDeletedAt)
	}
	if m.FieldCleared(commission.FieldCreator) {
		fields = append(fields, commission.FieldCreator)
	}
	if m.FieldCleared(commission.FieldLastModifier) {
		fields = append(fields, commission.FieldLastModifier)
	}
	if m.FieldCleared(commission.FieldRemark) {
		fields = append(fields, commission.FieldRemark)
	}
	if m.FieldCleared(commission.FieldBusinessID) {
		fields = append(fields, commission.FieldBusinessID)
	}
	if m.FieldCleared(commission.FieldSubscribeID) {
		fields = append(fields, commission.FieldSubscribeID)
	}
	if m.FieldCleared(commission.FieldPlanID) {
		fields = append(fields, commission.FieldPlanID)
	}
	if m.FieldCleared(commission.FieldRiderID) {
		fields = append(fields, commission.FieldRiderID)
	}
	if m.FieldCleared(commission.FieldEmployeeID) {
		fields = append(fields, commission.FieldEmployeeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommissionMutation) ClearField(name string) error {
	switch name {
	case commission.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case commission.FieldCreator:
		m.ClearCreator()
		return nil
	case commission.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case commission.FieldRemark:
		m.ClearRemark()
		return nil
	case commission.FieldBusinessID:
		m.ClearBusinessID()
		return nil
	case commission.FieldSubscribeID:
		m.ClearSubscribeID()
		return nil
	case commission.FieldPlanID:
		m.ClearPlanID()
		return nil
	case commission.FieldRiderID:
		m.ClearRiderID()
		return nil
	case commission.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	}
	return fmt.Errorf("unknown Commission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommissionMutation) ResetField(name string) error {
	switch name {
	case commission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case commission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case commission.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case commission.FieldCreator:
		m.ResetCreator()
		return nil
	case commission.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case commission.FieldRemark:
		m.ResetRemark()
		return nil
	case commission.FieldBusinessID:
		m.ResetBusinessID()
		return nil
	case commission.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case commission.FieldPlanID:
		m.ResetPlanID()
		return nil
	case commission.FieldRiderID:
		m.ResetRiderID()
		return nil
	case commission.FieldOrderID:
		m.ResetOrderID()
		return nil
	case commission.FieldAmount:
		m.ResetAmount()
		return nil
	case commission.FieldStatus:
		m.ResetStatus()
		return nil
	case commission.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	}
	return fmt.Errorf("unknown Commission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.business != nil {
		edges = append(edges, commission.EdgeBusiness)
	}
	if m.subscribe != nil {
		edges = append(edges, commission.EdgeSubscribe)
	}
	if m.plan != nil {
		edges = append(edges, commission.EdgePlan)
	}
	if m.rider != nil {
		edges = append(edges, commission.EdgeRider)
	}
	if m._order != nil {
		edges = append(edges, commission.EdgeOrder)
	}
	if m.employee != nil {
		edges = append(edges, commission.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case commission.EdgeBusiness:
		if id := m.business; id != nil {
			return []ent.Value{*id}
		}
	case commission.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	case commission.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	case commission.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case commission.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	case commission.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedbusiness {
		edges = append(edges, commission.EdgeBusiness)
	}
	if m.clearedsubscribe {
		edges = append(edges, commission.EdgeSubscribe)
	}
	if m.clearedplan {
		edges = append(edges, commission.EdgePlan)
	}
	if m.clearedrider {
		edges = append(edges, commission.EdgeRider)
	}
	if m.cleared_order {
		edges = append(edges, commission.EdgeOrder)
	}
	if m.clearedemployee {
		edges = append(edges, commission.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommissionMutation) EdgeCleared(name string) bool {
	switch name {
	case commission.EdgeBusiness:
		return m.clearedbusiness
	case commission.EdgeSubscribe:
		return m.clearedsubscribe
	case commission.EdgePlan:
		return m.clearedplan
	case commission.EdgeRider:
		return m.clearedrider
	case commission.EdgeOrder:
		return m.cleared_order
	case commission.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommissionMutation) ClearEdge(name string) error {
	switch name {
	case commission.EdgeBusiness:
		m.ClearBusiness()
		return nil
	case commission.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	case commission.EdgePlan:
		m.ClearPlan()
		return nil
	case commission.EdgeRider:
		m.ClearRider()
		return nil
	case commission.EdgeOrder:
		m.ClearOrder()
		return nil
	case commission.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown Commission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommissionMutation) ResetEdge(name string) error {
	switch name {
	case commission.EdgeBusiness:
		m.ResetBusiness()
		return nil
	case commission.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	case commission.EdgePlan:
		m.ResetPlan()
		return nil
	case commission.EdgeRider:
		m.ResetRider()
		return nil
	case commission.EdgeOrder:
		m.ResetOrder()
		return nil
	case commission.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Commission edge %s", name)
}

// ContractMutation represents an operation that mutates the Contract nodes in the graph.
type ContractMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	creator          **model.Modifier
	last_modifier    **model.Modifier
	remark           *string
	status           *uint8
	addstatus        *int8
	flow_id          *string
	sn               *string
	files            *[]string
	appendfiles      []string
	effective        *bool
	rider_info       **model.ContractRider
	link             *string
	expires_at       *time.Time
	signed_at        *time.Time
	clearedFields    map[string]struct{}
	subscribe        *uint64
	clearedsubscribe bool
	employee         *uint64
	clearedemployee  bool
	rider            *uint64
	clearedrider     bool
	allocate         *uint64
	clearedallocate  bool
	done             bool
	oldValue         func(context.Context) (*Contract, error)
	predicates       []predicate.Contract
}

var _ ent.Mutation = (*ContractMutation)(nil)

// contractOption allows management of the mutation configuration using functional options.
type contractOption func(*ContractMutation)

// newContractMutation creates new mutation for the Contract entity.
func newContractMutation(c config, op Op, opts ...contractOption) *ContractMutation {
	m := &ContractMutation{
		config:        c,
		op:            op,
		typ:           TypeContract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContractID sets the ID field of the mutation.
func withContractID(id uint64) contractOption {
	return func(m *ContractMutation) {
		var (
			err   error
			once  sync.Once
			value *Contract
		)
		m.oldValue = func(ctx context.Context) (*Contract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContract sets the old Contract of the mutation.
func withContract(node *Contract) contractOption {
	return func(m *ContractMutation) {
		m.oldValue = func(context.Context) (*Contract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContractMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContractMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Contract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ContractMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContractMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContractMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ContractMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ContractMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ContractMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ContractMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ContractMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ContractMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[contract.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ContractMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[contract.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ContractMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, contract.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *ContractMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *ContractMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *ContractMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[contract.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *ContractMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[contract.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *ContractMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, contract.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *ContractMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *ContractMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *ContractMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[contract.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *ContractMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[contract.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *ContractMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, contract.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *ContractMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ContractMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ContractMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[contract.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ContractMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[contract.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ContractMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, contract.FieldRemark)
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *ContractMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *ContractMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldSubscribeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ClearSubscribeID clears the value of the "subscribe_id" field.
func (m *ContractMutation) ClearSubscribeID() {
	m.subscribe = nil
	m.clearedFields[contract.FieldSubscribeID] = struct{}{}
}

// SubscribeIDCleared returns if the "subscribe_id" field was cleared in this mutation.
func (m *ContractMutation) SubscribeIDCleared() bool {
	_, ok := m.clearedFields[contract.FieldSubscribeID]
	return ok
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *ContractMutation) ResetSubscribeID() {
	m.subscribe = nil
	delete(m.clearedFields, contract.FieldSubscribeID)
}

// SetEmployeeID sets the "employee_id" field.
func (m *ContractMutation) SetEmployeeID(u uint64) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *ContractMutation) EmployeeID() (r uint64, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldEmployeeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *ContractMutation) ClearEmployeeID() {
	m.employee = nil
	m.clearedFields[contract.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *ContractMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[contract.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *ContractMutation) ResetEmployeeID() {
	m.employee = nil
	delete(m.clearedFields, contract.FieldEmployeeID)
}

// SetStatus sets the "status" field.
func (m *ContractMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ContractMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *ContractMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ContractMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ContractMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetRiderID sets the "rider_id" field.
func (m *ContractMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *ContractMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *ContractMutation) ResetRiderID() {
	m.rider = nil
}

// SetFlowID sets the "flow_id" field.
func (m *ContractMutation) SetFlowID(s string) {
	m.flow_id = &s
}

// FlowID returns the value of the "flow_id" field in the mutation.
func (m *ContractMutation) FlowID() (r string, exists bool) {
	v := m.flow_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowID returns the old "flow_id" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldFlowID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowID: %w", err)
	}
	return oldValue.FlowID, nil
}

// ResetFlowID resets all changes to the "flow_id" field.
func (m *ContractMutation) ResetFlowID() {
	m.flow_id = nil
}

// SetSn sets the "sn" field.
func (m *ContractMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *ContractMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *ContractMutation) ResetSn() {
	m.sn = nil
}

// SetFiles sets the "files" field.
func (m *ContractMutation) SetFiles(s []string) {
	m.files = &s
	m.appendfiles = nil
}

// Files returns the value of the "files" field in the mutation.
func (m *ContractMutation) Files() (r []string, exists bool) {
	v := m.files
	if v == nil {
		return
	}
	return *v, true
}

// OldFiles returns the old "files" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldFiles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFiles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFiles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFiles: %w", err)
	}
	return oldValue.Files, nil
}

// AppendFiles adds s to the "files" field.
func (m *ContractMutation) AppendFiles(s []string) {
	m.appendfiles = append(m.appendfiles, s...)
}

// AppendedFiles returns the list of values that were appended to the "files" field in this mutation.
func (m *ContractMutation) AppendedFiles() ([]string, bool) {
	if len(m.appendfiles) == 0 {
		return nil, false
	}
	return m.appendfiles, true
}

// ClearFiles clears the value of the "files" field.
func (m *ContractMutation) ClearFiles() {
	m.files = nil
	m.appendfiles = nil
	m.clearedFields[contract.FieldFiles] = struct{}{}
}

// FilesCleared returns if the "files" field was cleared in this mutation.
func (m *ContractMutation) FilesCleared() bool {
	_, ok := m.clearedFields[contract.FieldFiles]
	return ok
}

// ResetFiles resets all changes to the "files" field.
func (m *ContractMutation) ResetFiles() {
	m.files = nil
	m.appendfiles = nil
	delete(m.clearedFields, contract.FieldFiles)
}

// SetEffective sets the "effective" field.
func (m *ContractMutation) SetEffective(b bool) {
	m.effective = &b
}

// Effective returns the value of the "effective" field in the mutation.
func (m *ContractMutation) Effective() (r bool, exists bool) {
	v := m.effective
	if v == nil {
		return
	}
	return *v, true
}

// OldEffective returns the old "effective" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldEffective(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEffective is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEffective requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEffective: %w", err)
	}
	return oldValue.Effective, nil
}

// ResetEffective resets all changes to the "effective" field.
func (m *ContractMutation) ResetEffective() {
	m.effective = nil
}

// SetRiderInfo sets the "rider_info" field.
func (m *ContractMutation) SetRiderInfo(mr *model.ContractRider) {
	m.rider_info = &mr
}

// RiderInfo returns the value of the "rider_info" field in the mutation.
func (m *ContractMutation) RiderInfo() (r *model.ContractRider, exists bool) {
	v := m.rider_info
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderInfo returns the old "rider_info" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldRiderInfo(ctx context.Context) (v *model.ContractRider, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderInfo: %w", err)
	}
	return oldValue.RiderInfo, nil
}

// ClearRiderInfo clears the value of the "rider_info" field.
func (m *ContractMutation) ClearRiderInfo() {
	m.rider_info = nil
	m.clearedFields[contract.FieldRiderInfo] = struct{}{}
}

// RiderInfoCleared returns if the "rider_info" field was cleared in this mutation.
func (m *ContractMutation) RiderInfoCleared() bool {
	_, ok := m.clearedFields[contract.FieldRiderInfo]
	return ok
}

// ResetRiderInfo resets all changes to the "rider_info" field.
func (m *ContractMutation) ResetRiderInfo() {
	m.rider_info = nil
	delete(m.clearedFields, contract.FieldRiderInfo)
}

// SetAllocateID sets the "allocate_id" field.
func (m *ContractMutation) SetAllocateID(u uint64) {
	m.allocate = &u
}

// AllocateID returns the value of the "allocate_id" field in the mutation.
func (m *ContractMutation) AllocateID() (r uint64, exists bool) {
	v := m.allocate
	if v == nil {
		return
	}
	return *v, true
}

// OldAllocateID returns the old "allocate_id" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldAllocateID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllocateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllocateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllocateID: %w", err)
	}
	return oldValue.AllocateID, nil
}

// ClearAllocateID clears the value of the "allocate_id" field.
func (m *ContractMutation) ClearAllocateID() {
	m.allocate = nil
	m.clearedFields[contract.FieldAllocateID] = struct{}{}
}

// AllocateIDCleared returns if the "allocate_id" field was cleared in this mutation.
func (m *ContractMutation) AllocateIDCleared() bool {
	_, ok := m.clearedFields[contract.FieldAllocateID]
	return ok
}

// ResetAllocateID resets all changes to the "allocate_id" field.
func (m *ContractMutation) ResetAllocateID() {
	m.allocate = nil
	delete(m.clearedFields, contract.FieldAllocateID)
}

// SetLink sets the "link" field.
func (m *ContractMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *ContractMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldLink(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ClearLink clears the value of the "link" field.
func (m *ContractMutation) ClearLink() {
	m.link = nil
	m.clearedFields[contract.FieldLink] = struct{}{}
}

// LinkCleared returns if the "link" field was cleared in this mutation.
func (m *ContractMutation) LinkCleared() bool {
	_, ok := m.clearedFields[contract.FieldLink]
	return ok
}

// ResetLink resets all changes to the "link" field.
func (m *ContractMutation) ResetLink() {
	m.link = nil
	delete(m.clearedFields, contract.FieldLink)
}

// SetExpiresAt sets the "expires_at" field.
func (m *ContractMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *ContractMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *ContractMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[contract.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *ContractMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[contract.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *ContractMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, contract.FieldExpiresAt)
}

// SetSignedAt sets the "signed_at" field.
func (m *ContractMutation) SetSignedAt(t time.Time) {
	m.signed_at = &t
}

// SignedAt returns the value of the "signed_at" field in the mutation.
func (m *ContractMutation) SignedAt() (r time.Time, exists bool) {
	v := m.signed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSignedAt returns the old "signed_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldSignedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignedAt: %w", err)
	}
	return oldValue.SignedAt, nil
}

// ClearSignedAt clears the value of the "signed_at" field.
func (m *ContractMutation) ClearSignedAt() {
	m.signed_at = nil
	m.clearedFields[contract.FieldSignedAt] = struct{}{}
}

// SignedAtCleared returns if the "signed_at" field was cleared in this mutation.
func (m *ContractMutation) SignedAtCleared() bool {
	_, ok := m.clearedFields[contract.FieldSignedAt]
	return ok
}

// ResetSignedAt resets all changes to the "signed_at" field.
func (m *ContractMutation) ResetSignedAt() {
	m.signed_at = nil
	delete(m.clearedFields, contract.FieldSignedAt)
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *ContractMutation) ClearSubscribe() {
	m.clearedsubscribe = true
	m.clearedFields[contract.FieldSubscribeID] = struct{}{}
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *ContractMutation) SubscribeCleared() bool {
	return m.SubscribeIDCleared() || m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *ContractMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *ContractMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *ContractMutation) ClearEmployee() {
	m.clearedemployee = true
	m.clearedFields[contract.FieldEmployeeID] = struct{}{}
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *ContractMutation) EmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *ContractMutation) EmployeeIDs() (ids []uint64) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *ContractMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *ContractMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[contract.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *ContractMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *ContractMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *ContractMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearAllocate clears the "allocate" edge to the Allocate entity.
func (m *ContractMutation) ClearAllocate() {
	m.clearedallocate = true
	m.clearedFields[contract.FieldAllocateID] = struct{}{}
}

// AllocateCleared reports if the "allocate" edge to the Allocate entity was cleared.
func (m *ContractMutation) AllocateCleared() bool {
	return m.AllocateIDCleared() || m.clearedallocate
}

// AllocateIDs returns the "allocate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AllocateID instead. It exists only for internal usage by the builders.
func (m *ContractMutation) AllocateIDs() (ids []uint64) {
	if id := m.allocate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAllocate resets all changes to the "allocate" edge.
func (m *ContractMutation) ResetAllocate() {
	m.allocate = nil
	m.clearedallocate = false
}

// Where appends a list predicates to the ContractMutation builder.
func (m *ContractMutation) Where(ps ...predicate.Contract) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContractMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContractMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Contract, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContractMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContractMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Contract).
func (m *ContractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContractMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, contract.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, contract.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, contract.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, contract.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, contract.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, contract.FieldRemark)
	}
	if m.subscribe != nil {
		fields = append(fields, contract.FieldSubscribeID)
	}
	if m.employee != nil {
		fields = append(fields, contract.FieldEmployeeID)
	}
	if m.status != nil {
		fields = append(fields, contract.FieldStatus)
	}
	if m.rider != nil {
		fields = append(fields, contract.FieldRiderID)
	}
	if m.flow_id != nil {
		fields = append(fields, contract.FieldFlowID)
	}
	if m.sn != nil {
		fields = append(fields, contract.FieldSn)
	}
	if m.files != nil {
		fields = append(fields, contract.FieldFiles)
	}
	if m.effective != nil {
		fields = append(fields, contract.FieldEffective)
	}
	if m.rider_info != nil {
		fields = append(fields, contract.FieldRiderInfo)
	}
	if m.allocate != nil {
		fields = append(fields, contract.FieldAllocateID)
	}
	if m.link != nil {
		fields = append(fields, contract.FieldLink)
	}
	if m.expires_at != nil {
		fields = append(fields, contract.FieldExpiresAt)
	}
	if m.signed_at != nil {
		fields = append(fields, contract.FieldSignedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contract.FieldCreatedAt:
		return m.CreatedAt()
	case contract.FieldUpdatedAt:
		return m.UpdatedAt()
	case contract.FieldDeletedAt:
		return m.DeletedAt()
	case contract.FieldCreator:
		return m.Creator()
	case contract.FieldLastModifier:
		return m.LastModifier()
	case contract.FieldRemark:
		return m.Remark()
	case contract.FieldSubscribeID:
		return m.SubscribeID()
	case contract.FieldEmployeeID:
		return m.EmployeeID()
	case contract.FieldStatus:
		return m.Status()
	case contract.FieldRiderID:
		return m.RiderID()
	case contract.FieldFlowID:
		return m.FlowID()
	case contract.FieldSn:
		return m.Sn()
	case contract.FieldFiles:
		return m.Files()
	case contract.FieldEffective:
		return m.Effective()
	case contract.FieldRiderInfo:
		return m.RiderInfo()
	case contract.FieldAllocateID:
		return m.AllocateID()
	case contract.FieldLink:
		return m.Link()
	case contract.FieldExpiresAt:
		return m.ExpiresAt()
	case contract.FieldSignedAt:
		return m.SignedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contract.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case contract.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case contract.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case contract.FieldCreator:
		return m.OldCreator(ctx)
	case contract.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case contract.FieldRemark:
		return m.OldRemark(ctx)
	case contract.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case contract.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case contract.FieldStatus:
		return m.OldStatus(ctx)
	case contract.FieldRiderID:
		return m.OldRiderID(ctx)
	case contract.FieldFlowID:
		return m.OldFlowID(ctx)
	case contract.FieldSn:
		return m.OldSn(ctx)
	case contract.FieldFiles:
		return m.OldFiles(ctx)
	case contract.FieldEffective:
		return m.OldEffective(ctx)
	case contract.FieldRiderInfo:
		return m.OldRiderInfo(ctx)
	case contract.FieldAllocateID:
		return m.OldAllocateID(ctx)
	case contract.FieldLink:
		return m.OldLink(ctx)
	case contract.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case contract.FieldSignedAt:
		return m.OldSignedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Contract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contract.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case contract.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case contract.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case contract.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case contract.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case contract.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case contract.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case contract.FieldEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case contract.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case contract.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case contract.FieldFlowID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowID(v)
		return nil
	case contract.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case contract.FieldFiles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFiles(v)
		return nil
	case contract.FieldEffective:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEffective(v)
		return nil
	case contract.FieldRiderInfo:
		v, ok := value.(*model.ContractRider)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderInfo(v)
		return nil
	case contract.FieldAllocateID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllocateID(v)
		return nil
	case contract.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case contract.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case contract.FieldSignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Contract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContractMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, contract.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContractMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contract.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContractMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contract.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Contract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContractMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contract.FieldDeletedAt) {
		fields = append(fields, contract.FieldDeletedAt)
	}
	if m.FieldCleared(contract.FieldCreator) {
		fields = append(fields, contract.FieldCreator)
	}
	if m.FieldCleared(contract.FieldLastModifier) {
		fields = append(fields, contract.FieldLastModifier)
	}
	if m.FieldCleared(contract.FieldRemark) {
		fields = append(fields, contract.FieldRemark)
	}
	if m.FieldCleared(contract.FieldSubscribeID) {
		fields = append(fields, contract.FieldSubscribeID)
	}
	if m.FieldCleared(contract.FieldEmployeeID) {
		fields = append(fields, contract.FieldEmployeeID)
	}
	if m.FieldCleared(contract.FieldFiles) {
		fields = append(fields, contract.FieldFiles)
	}
	if m.FieldCleared(contract.FieldRiderInfo) {
		fields = append(fields, contract.FieldRiderInfo)
	}
	if m.FieldCleared(contract.FieldAllocateID) {
		fields = append(fields, contract.FieldAllocateID)
	}
	if m.FieldCleared(contract.FieldLink) {
		fields = append(fields, contract.FieldLink)
	}
	if m.FieldCleared(contract.FieldExpiresAt) {
		fields = append(fields, contract.FieldExpiresAt)
	}
	if m.FieldCleared(contract.FieldSignedAt) {
		fields = append(fields, contract.FieldSignedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContractMutation) ClearField(name string) error {
	switch name {
	case contract.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case contract.FieldCreator:
		m.ClearCreator()
		return nil
	case contract.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case contract.FieldRemark:
		m.ClearRemark()
		return nil
	case contract.FieldSubscribeID:
		m.ClearSubscribeID()
		return nil
	case contract.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case contract.FieldFiles:
		m.ClearFiles()
		return nil
	case contract.FieldRiderInfo:
		m.ClearRiderInfo()
		return nil
	case contract.FieldAllocateID:
		m.ClearAllocateID()
		return nil
	case contract.FieldLink:
		m.ClearLink()
		return nil
	case contract.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case contract.FieldSignedAt:
		m.ClearSignedAt()
		return nil
	}
	return fmt.Errorf("unknown Contract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContractMutation) ResetField(name string) error {
	switch name {
	case contract.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case contract.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case contract.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case contract.FieldCreator:
		m.ResetCreator()
		return nil
	case contract.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case contract.FieldRemark:
		m.ResetRemark()
		return nil
	case contract.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case contract.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case contract.FieldStatus:
		m.ResetStatus()
		return nil
	case contract.FieldRiderID:
		m.ResetRiderID()
		return nil
	case contract.FieldFlowID:
		m.ResetFlowID()
		return nil
	case contract.FieldSn:
		m.ResetSn()
		return nil
	case contract.FieldFiles:
		m.ResetFiles()
		return nil
	case contract.FieldEffective:
		m.ResetEffective()
		return nil
	case contract.FieldRiderInfo:
		m.ResetRiderInfo()
		return nil
	case contract.FieldAllocateID:
		m.ResetAllocateID()
		return nil
	case contract.FieldLink:
		m.ResetLink()
		return nil
	case contract.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case contract.FieldSignedAt:
		m.ResetSignedAt()
		return nil
	}
	return fmt.Errorf("unknown Contract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContractMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.subscribe != nil {
		edges = append(edges, contract.EdgeSubscribe)
	}
	if m.employee != nil {
		edges = append(edges, contract.EdgeEmployee)
	}
	if m.rider != nil {
		edges = append(edges, contract.EdgeRider)
	}
	if m.allocate != nil {
		edges = append(edges, contract.EdgeAllocate)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContractMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contract.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	case contract.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case contract.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case contract.EdgeAllocate:
		if id := m.allocate; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContractMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedsubscribe {
		edges = append(edges, contract.EdgeSubscribe)
	}
	if m.clearedemployee {
		edges = append(edges, contract.EdgeEmployee)
	}
	if m.clearedrider {
		edges = append(edges, contract.EdgeRider)
	}
	if m.clearedallocate {
		edges = append(edges, contract.EdgeAllocate)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContractMutation) EdgeCleared(name string) bool {
	switch name {
	case contract.EdgeSubscribe:
		return m.clearedsubscribe
	case contract.EdgeEmployee:
		return m.clearedemployee
	case contract.EdgeRider:
		return m.clearedrider
	case contract.EdgeAllocate:
		return m.clearedallocate
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContractMutation) ClearEdge(name string) error {
	switch name {
	case contract.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	case contract.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case contract.EdgeRider:
		m.ClearRider()
		return nil
	case contract.EdgeAllocate:
		m.ClearAllocate()
		return nil
	}
	return fmt.Errorf("unknown Contract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContractMutation) ResetEdge(name string) error {
	switch name {
	case contract.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	case contract.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case contract.EdgeRider:
		m.ResetRider()
		return nil
	case contract.EdgeAllocate:
		m.ResetAllocate()
		return nil
	}
	return fmt.Errorf("unknown Contract edge %s", name)
}

// CouponMutation represents an operation that mutates the Coupon nodes in the graph.
type CouponMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	creator         **model.Modifier
	last_modifier   **model.Modifier
	remark          *string
	name            *string
	rule            *uint8
	addrule         *int8
	multiple        *bool
	amount          *float64
	addamount       *float64
	code            *string
	expires_at      *time.Time
	used_at         *time.Time
	duration        **model.CouponDuration
	plans           *[]*model.Plan
	appendplans     []*model.Plan
	cities          *[]model.City
	appendcities    []model.City
	clearedFields   map[string]struct{}
	rider           *uint64
	clearedrider    bool
	assembly        *uint64
	clearedassembly bool
	plan            *uint64
	clearedplan     bool
	template        *uint64
	clearedtemplate bool
	_order          *uint64
	cleared_order   bool
	done            bool
	oldValue        func(context.Context) (*Coupon, error)
	predicates      []predicate.Coupon
}

var _ ent.Mutation = (*CouponMutation)(nil)

// couponOption allows management of the mutation configuration using functional options.
type couponOption func(*CouponMutation)

// newCouponMutation creates new mutation for the Coupon entity.
func newCouponMutation(c config, op Op, opts ...couponOption) *CouponMutation {
	m := &CouponMutation{
		config:        c,
		op:            op,
		typ:           TypeCoupon,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponID sets the ID field of the mutation.
func withCouponID(id uint64) couponOption {
	return func(m *CouponMutation) {
		var (
			err   error
			once  sync.Once
			value *Coupon
		)
		m.oldValue = func(ctx context.Context) (*Coupon, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Coupon.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCoupon sets the old Coupon of the mutation.
func withCoupon(node *Coupon) couponOption {
	return func(m *CouponMutation) {
		m.oldValue = func(context.Context) (*Coupon, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CouponMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Coupon.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CouponMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CouponMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CouponMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CouponMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CouponMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CouponMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreator sets the "creator" field.
func (m *CouponMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *CouponMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *CouponMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[coupon.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *CouponMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[coupon.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *CouponMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, coupon.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *CouponMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *CouponMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *CouponMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[coupon.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *CouponMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[coupon.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *CouponMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, coupon.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *CouponMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CouponMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *CouponMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[coupon.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *CouponMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[coupon.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *CouponMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, coupon.FieldRemark)
}

// SetRiderID sets the "rider_id" field.
func (m *CouponMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *CouponMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldRiderID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ClearRiderID clears the value of the "rider_id" field.
func (m *CouponMutation) ClearRiderID() {
	m.rider = nil
	m.clearedFields[coupon.FieldRiderID] = struct{}{}
}

// RiderIDCleared returns if the "rider_id" field was cleared in this mutation.
func (m *CouponMutation) RiderIDCleared() bool {
	_, ok := m.clearedFields[coupon.FieldRiderID]
	return ok
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *CouponMutation) ResetRiderID() {
	m.rider = nil
	delete(m.clearedFields, coupon.FieldRiderID)
}

// SetAssemblyID sets the "assembly_id" field.
func (m *CouponMutation) SetAssemblyID(u uint64) {
	m.assembly = &u
}

// AssemblyID returns the value of the "assembly_id" field in the mutation.
func (m *CouponMutation) AssemblyID() (r uint64, exists bool) {
	v := m.assembly
	if v == nil {
		return
	}
	return *v, true
}

// OldAssemblyID returns the old "assembly_id" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldAssemblyID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssemblyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssemblyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssemblyID: %w", err)
	}
	return oldValue.AssemblyID, nil
}

// ResetAssemblyID resets all changes to the "assembly_id" field.
func (m *CouponMutation) ResetAssemblyID() {
	m.assembly = nil
}

// SetPlanID sets the "plan_id" field.
func (m *CouponMutation) SetPlanID(u uint64) {
	m.plan = &u
}

// PlanID returns the value of the "plan_id" field in the mutation.
func (m *CouponMutation) PlanID() (r uint64, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanID returns the old "plan_id" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldPlanID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanID: %w", err)
	}
	return oldValue.PlanID, nil
}

// ClearPlanID clears the value of the "plan_id" field.
func (m *CouponMutation) ClearPlanID() {
	m.plan = nil
	m.clearedFields[coupon.FieldPlanID] = struct{}{}
}

// PlanIDCleared returns if the "plan_id" field was cleared in this mutation.
func (m *CouponMutation) PlanIDCleared() bool {
	_, ok := m.clearedFields[coupon.FieldPlanID]
	return ok
}

// ResetPlanID resets all changes to the "plan_id" field.
func (m *CouponMutation) ResetPlanID() {
	m.plan = nil
	delete(m.clearedFields, coupon.FieldPlanID)
}

// SetTemplateID sets the "template_id" field.
func (m *CouponMutation) SetTemplateID(u uint64) {
	m.template = &u
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *CouponMutation) TemplateID() (r uint64, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldTemplateID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *CouponMutation) ResetTemplateID() {
	m.template = nil
}

// SetOrderID sets the "order_id" field.
func (m *CouponMutation) SetOrderID(u uint64) {
	m._order = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *CouponMutation) OrderID() (r uint64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldOrderID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *CouponMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[coupon.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *CouponMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[coupon.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *CouponMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, coupon.FieldOrderID)
}

// SetName sets the "name" field.
func (m *CouponMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CouponMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CouponMutation) ResetName() {
	m.name = nil
}

// SetRule sets the "rule" field.
func (m *CouponMutation) SetRule(u uint8) {
	m.rule = &u
	m.addrule = nil
}

// Rule returns the value of the "rule" field in the mutation.
func (m *CouponMutation) Rule() (r uint8, exists bool) {
	v := m.rule
	if v == nil {
		return
	}
	return *v, true
}

// OldRule returns the old "rule" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldRule(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRule: %w", err)
	}
	return oldValue.Rule, nil
}

// AddRule adds u to the "rule" field.
func (m *CouponMutation) AddRule(u int8) {
	if m.addrule != nil {
		*m.addrule += u
	} else {
		m.addrule = &u
	}
}

// AddedRule returns the value that was added to the "rule" field in this mutation.
func (m *CouponMutation) AddedRule() (r int8, exists bool) {
	v := m.addrule
	if v == nil {
		return
	}
	return *v, true
}

// ResetRule resets all changes to the "rule" field.
func (m *CouponMutation) ResetRule() {
	m.rule = nil
	m.addrule = nil
}

// SetMultiple sets the "multiple" field.
func (m *CouponMutation) SetMultiple(b bool) {
	m.multiple = &b
}

// Multiple returns the value of the "multiple" field in the mutation.
func (m *CouponMutation) Multiple() (r bool, exists bool) {
	v := m.multiple
	if v == nil {
		return
	}
	return *v, true
}

// OldMultiple returns the old "multiple" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldMultiple(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMultiple is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMultiple requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMultiple: %w", err)
	}
	return oldValue.Multiple, nil
}

// ResetMultiple resets all changes to the "multiple" field.
func (m *CouponMutation) ResetMultiple() {
	m.multiple = nil
}

// SetAmount sets the "amount" field.
func (m *CouponMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *CouponMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *CouponMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *CouponMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *CouponMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetCode sets the "code" field.
func (m *CouponMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CouponMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CouponMutation) ResetCode() {
	m.code = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *CouponMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *CouponMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *CouponMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[coupon.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *CouponMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[coupon.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *CouponMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, coupon.FieldExpiresAt)
}

// SetUsedAt sets the "used_at" field.
func (m *CouponMutation) SetUsedAt(t time.Time) {
	m.used_at = &t
}

// UsedAt returns the value of the "used_at" field in the mutation.
func (m *CouponMutation) UsedAt() (r time.Time, exists bool) {
	v := m.used_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUsedAt returns the old "used_at" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldUsedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsedAt: %w", err)
	}
	return oldValue.UsedAt, nil
}

// ClearUsedAt clears the value of the "used_at" field.
func (m *CouponMutation) ClearUsedAt() {
	m.used_at = nil
	m.clearedFields[coupon.FieldUsedAt] = struct{}{}
}

// UsedAtCleared returns if the "used_at" field was cleared in this mutation.
func (m *CouponMutation) UsedAtCleared() bool {
	_, ok := m.clearedFields[coupon.FieldUsedAt]
	return ok
}

// ResetUsedAt resets all changes to the "used_at" field.
func (m *CouponMutation) ResetUsedAt() {
	m.used_at = nil
	delete(m.clearedFields, coupon.FieldUsedAt)
}

// SetDuration sets the "duration" field.
func (m *CouponMutation) SetDuration(md *model.CouponDuration) {
	m.duration = &md
}

// Duration returns the value of the "duration" field in the mutation.
func (m *CouponMutation) Duration() (r *model.CouponDuration, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldDuration(ctx context.Context) (v *model.CouponDuration, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// ResetDuration resets all changes to the "duration" field.
func (m *CouponMutation) ResetDuration() {
	m.duration = nil
}

// SetPlans sets the "plans" field.
func (m *CouponMutation) SetPlans(value []*model.Plan) {
	m.plans = &value
	m.appendplans = nil
}

// Plans returns the value of the "plans" field in the mutation.
func (m *CouponMutation) Plans() (r []*model.Plan, exists bool) {
	v := m.plans
	if v == nil {
		return
	}
	return *v, true
}

// OldPlans returns the old "plans" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldPlans(ctx context.Context) (v []*model.Plan, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlans is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlans requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlans: %w", err)
	}
	return oldValue.Plans, nil
}

// AppendPlans adds value to the "plans" field.
func (m *CouponMutation) AppendPlans(value []*model.Plan) {
	m.appendplans = append(m.appendplans, value...)
}

// AppendedPlans returns the list of values that were appended to the "plans" field in this mutation.
func (m *CouponMutation) AppendedPlans() ([]*model.Plan, bool) {
	if len(m.appendplans) == 0 {
		return nil, false
	}
	return m.appendplans, true
}

// ClearPlans clears the value of the "plans" field.
func (m *CouponMutation) ClearPlans() {
	m.plans = nil
	m.appendplans = nil
	m.clearedFields[coupon.FieldPlans] = struct{}{}
}

// PlansCleared returns if the "plans" field was cleared in this mutation.
func (m *CouponMutation) PlansCleared() bool {
	_, ok := m.clearedFields[coupon.FieldPlans]
	return ok
}

// ResetPlans resets all changes to the "plans" field.
func (m *CouponMutation) ResetPlans() {
	m.plans = nil
	m.appendplans = nil
	delete(m.clearedFields, coupon.FieldPlans)
}

// SetCities sets the "cities" field.
func (m *CouponMutation) SetCities(value []model.City) {
	m.cities = &value
	m.appendcities = nil
}

// Cities returns the value of the "cities" field in the mutation.
func (m *CouponMutation) Cities() (r []model.City, exists bool) {
	v := m.cities
	if v == nil {
		return
	}
	return *v, true
}

// OldCities returns the old "cities" field's value of the Coupon entity.
// If the Coupon object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponMutation) OldCities(ctx context.Context) (v []model.City, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCities is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCities requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCities: %w", err)
	}
	return oldValue.Cities, nil
}

// AppendCities adds value to the "cities" field.
func (m *CouponMutation) AppendCities(value []model.City) {
	m.appendcities = append(m.appendcities, value...)
}

// AppendedCities returns the list of values that were appended to the "cities" field in this mutation.
func (m *CouponMutation) AppendedCities() ([]model.City, bool) {
	if len(m.appendcities) == 0 {
		return nil, false
	}
	return m.appendcities, true
}

// ClearCities clears the value of the "cities" field.
func (m *CouponMutation) ClearCities() {
	m.cities = nil
	m.appendcities = nil
	m.clearedFields[coupon.FieldCities] = struct{}{}
}

// CitiesCleared returns if the "cities" field was cleared in this mutation.
func (m *CouponMutation) CitiesCleared() bool {
	_, ok := m.clearedFields[coupon.FieldCities]
	return ok
}

// ResetCities resets all changes to the "cities" field.
func (m *CouponMutation) ResetCities() {
	m.cities = nil
	m.appendcities = nil
	delete(m.clearedFields, coupon.FieldCities)
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *CouponMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[coupon.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *CouponMutation) RiderCleared() bool {
	return m.RiderIDCleared() || m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *CouponMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *CouponMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearAssembly clears the "assembly" edge to the CouponAssembly entity.
func (m *CouponMutation) ClearAssembly() {
	m.clearedassembly = true
	m.clearedFields[coupon.FieldAssemblyID] = struct{}{}
}

// AssemblyCleared reports if the "assembly" edge to the CouponAssembly entity was cleared.
func (m *CouponMutation) AssemblyCleared() bool {
	return m.clearedassembly
}

// AssemblyIDs returns the "assembly" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssemblyID instead. It exists only for internal usage by the builders.
func (m *CouponMutation) AssemblyIDs() (ids []uint64) {
	if id := m.assembly; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssembly resets all changes to the "assembly" edge.
func (m *CouponMutation) ResetAssembly() {
	m.assembly = nil
	m.clearedassembly = false
}

// ClearPlan clears the "plan" edge to the Plan entity.
func (m *CouponMutation) ClearPlan() {
	m.clearedplan = true
	m.clearedFields[coupon.FieldPlanID] = struct{}{}
}

// PlanCleared reports if the "plan" edge to the Plan entity was cleared.
func (m *CouponMutation) PlanCleared() bool {
	return m.PlanIDCleared() || m.clearedplan
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *CouponMutation) PlanIDs() (ids []uint64) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *CouponMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// ClearTemplate clears the "template" edge to the CouponTemplate entity.
func (m *CouponMutation) ClearTemplate() {
	m.clearedtemplate = true
	m.clearedFields[coupon.FieldTemplateID] = struct{}{}
}

// TemplateCleared reports if the "template" edge to the CouponTemplate entity was cleared.
func (m *CouponMutation) TemplateCleared() bool {
	return m.clearedtemplate
}

// TemplateIDs returns the "template" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TemplateID instead. It exists only for internal usage by the builders.
func (m *CouponMutation) TemplateIDs() (ids []uint64) {
	if id := m.template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTemplate resets all changes to the "template" edge.
func (m *CouponMutation) ResetTemplate() {
	m.template = nil
	m.clearedtemplate = false
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *CouponMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[coupon.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *CouponMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *CouponMutation) OrderIDs() (ids []uint64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *CouponMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the CouponMutation builder.
func (m *CouponMutation) Where(ps ...predicate.Coupon) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CouponMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CouponMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Coupon, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CouponMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CouponMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Coupon).
func (m *CouponMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, coupon.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, coupon.FieldUpdatedAt)
	}
	if m.creator != nil {
		fields = append(fields, coupon.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, coupon.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, coupon.FieldRemark)
	}
	if m.rider != nil {
		fields = append(fields, coupon.FieldRiderID)
	}
	if m.assembly != nil {
		fields = append(fields, coupon.FieldAssemblyID)
	}
	if m.plan != nil {
		fields = append(fields, coupon.FieldPlanID)
	}
	if m.template != nil {
		fields = append(fields, coupon.FieldTemplateID)
	}
	if m._order != nil {
		fields = append(fields, coupon.FieldOrderID)
	}
	if m.name != nil {
		fields = append(fields, coupon.FieldName)
	}
	if m.rule != nil {
		fields = append(fields, coupon.FieldRule)
	}
	if m.multiple != nil {
		fields = append(fields, coupon.FieldMultiple)
	}
	if m.amount != nil {
		fields = append(fields, coupon.FieldAmount)
	}
	if m.code != nil {
		fields = append(fields, coupon.FieldCode)
	}
	if m.expires_at != nil {
		fields = append(fields, coupon.FieldExpiresAt)
	}
	if m.used_at != nil {
		fields = append(fields, coupon.FieldUsedAt)
	}
	if m.duration != nil {
		fields = append(fields, coupon.FieldDuration)
	}
	if m.plans != nil {
		fields = append(fields, coupon.FieldPlans)
	}
	if m.cities != nil {
		fields = append(fields, coupon.FieldCities)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coupon.FieldCreatedAt:
		return m.CreatedAt()
	case coupon.FieldUpdatedAt:
		return m.UpdatedAt()
	case coupon.FieldCreator:
		return m.Creator()
	case coupon.FieldLastModifier:
		return m.LastModifier()
	case coupon.FieldRemark:
		return m.Remark()
	case coupon.FieldRiderID:
		return m.RiderID()
	case coupon.FieldAssemblyID:
		return m.AssemblyID()
	case coupon.FieldPlanID:
		return m.PlanID()
	case coupon.FieldTemplateID:
		return m.TemplateID()
	case coupon.FieldOrderID:
		return m.OrderID()
	case coupon.FieldName:
		return m.Name()
	case coupon.FieldRule:
		return m.Rule()
	case coupon.FieldMultiple:
		return m.Multiple()
	case coupon.FieldAmount:
		return m.Amount()
	case coupon.FieldCode:
		return m.Code()
	case coupon.FieldExpiresAt:
		return m.ExpiresAt()
	case coupon.FieldUsedAt:
		return m.UsedAt()
	case coupon.FieldDuration:
		return m.Duration()
	case coupon.FieldPlans:
		return m.Plans()
	case coupon.FieldCities:
		return m.Cities()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coupon.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case coupon.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case coupon.FieldCreator:
		return m.OldCreator(ctx)
	case coupon.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case coupon.FieldRemark:
		return m.OldRemark(ctx)
	case coupon.FieldRiderID:
		return m.OldRiderID(ctx)
	case coupon.FieldAssemblyID:
		return m.OldAssemblyID(ctx)
	case coupon.FieldPlanID:
		return m.OldPlanID(ctx)
	case coupon.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case coupon.FieldOrderID:
		return m.OldOrderID(ctx)
	case coupon.FieldName:
		return m.OldName(ctx)
	case coupon.FieldRule:
		return m.OldRule(ctx)
	case coupon.FieldMultiple:
		return m.OldMultiple(ctx)
	case coupon.FieldAmount:
		return m.OldAmount(ctx)
	case coupon.FieldCode:
		return m.OldCode(ctx)
	case coupon.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case coupon.FieldUsedAt:
		return m.OldUsedAt(ctx)
	case coupon.FieldDuration:
		return m.OldDuration(ctx)
	case coupon.FieldPlans:
		return m.OldPlans(ctx)
	case coupon.FieldCities:
		return m.OldCities(ctx)
	}
	return nil, fmt.Errorf("unknown Coupon field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coupon.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case coupon.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case coupon.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case coupon.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case coupon.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case coupon.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case coupon.FieldAssemblyID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssemblyID(v)
		return nil
	case coupon.FieldPlanID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanID(v)
		return nil
	case coupon.FieldTemplateID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case coupon.FieldOrderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case coupon.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case coupon.FieldRule:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRule(v)
		return nil
	case coupon.FieldMultiple:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMultiple(v)
		return nil
	case coupon.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case coupon.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case coupon.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case coupon.FieldUsedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsedAt(v)
		return nil
	case coupon.FieldDuration:
		v, ok := value.(*model.CouponDuration)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case coupon.FieldPlans:
		v, ok := value.([]*model.Plan)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlans(v)
		return nil
	case coupon.FieldCities:
		v, ok := value.([]model.City)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCities(v)
		return nil
	}
	return fmt.Errorf("unknown Coupon field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponMutation) AddedFields() []string {
	var fields []string
	if m.addrule != nil {
		fields = append(fields, coupon.FieldRule)
	}
	if m.addamount != nil {
		fields = append(fields, coupon.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case coupon.FieldRule:
		return m.AddedRule()
	case coupon.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponMutation) AddField(name string, value ent.Value) error {
	switch name {
	case coupon.FieldRule:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRule(v)
		return nil
	case coupon.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Coupon numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(coupon.FieldCreator) {
		fields = append(fields, coupon.FieldCreator)
	}
	if m.FieldCleared(coupon.FieldLastModifier) {
		fields = append(fields, coupon.FieldLastModifier)
	}
	if m.FieldCleared(coupon.FieldRemark) {
		fields = append(fields, coupon.FieldRemark)
	}
	if m.FieldCleared(coupon.FieldRiderID) {
		fields = append(fields, coupon.FieldRiderID)
	}
	if m.FieldCleared(coupon.FieldPlanID) {
		fields = append(fields, coupon.FieldPlanID)
	}
	if m.FieldCleared(coupon.FieldOrderID) {
		fields = append(fields, coupon.FieldOrderID)
	}
	if m.FieldCleared(coupon.FieldExpiresAt) {
		fields = append(fields, coupon.FieldExpiresAt)
	}
	if m.FieldCleared(coupon.FieldUsedAt) {
		fields = append(fields, coupon.FieldUsedAt)
	}
	if m.FieldCleared(coupon.FieldPlans) {
		fields = append(fields, coupon.FieldPlans)
	}
	if m.FieldCleared(coupon.FieldCities) {
		fields = append(fields, coupon.FieldCities)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponMutation) ClearField(name string) error {
	switch name {
	case coupon.FieldCreator:
		m.ClearCreator()
		return nil
	case coupon.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case coupon.FieldRemark:
		m.ClearRemark()
		return nil
	case coupon.FieldRiderID:
		m.ClearRiderID()
		return nil
	case coupon.FieldPlanID:
		m.ClearPlanID()
		return nil
	case coupon.FieldOrderID:
		m.ClearOrderID()
		return nil
	case coupon.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	case coupon.FieldUsedAt:
		m.ClearUsedAt()
		return nil
	case coupon.FieldPlans:
		m.ClearPlans()
		return nil
	case coupon.FieldCities:
		m.ClearCities()
		return nil
	}
	return fmt.Errorf("unknown Coupon nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponMutation) ResetField(name string) error {
	switch name {
	case coupon.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case coupon.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case coupon.FieldCreator:
		m.ResetCreator()
		return nil
	case coupon.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case coupon.FieldRemark:
		m.ResetRemark()
		return nil
	case coupon.FieldRiderID:
		m.ResetRiderID()
		return nil
	case coupon.FieldAssemblyID:
		m.ResetAssemblyID()
		return nil
	case coupon.FieldPlanID:
		m.ResetPlanID()
		return nil
	case coupon.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case coupon.FieldOrderID:
		m.ResetOrderID()
		return nil
	case coupon.FieldName:
		m.ResetName()
		return nil
	case coupon.FieldRule:
		m.ResetRule()
		return nil
	case coupon.FieldMultiple:
		m.ResetMultiple()
		return nil
	case coupon.FieldAmount:
		m.ResetAmount()
		return nil
	case coupon.FieldCode:
		m.ResetCode()
		return nil
	case coupon.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case coupon.FieldUsedAt:
		m.ResetUsedAt()
		return nil
	case coupon.FieldDuration:
		m.ResetDuration()
		return nil
	case coupon.FieldPlans:
		m.ResetPlans()
		return nil
	case coupon.FieldCities:
		m.ResetCities()
		return nil
	}
	return fmt.Errorf("unknown Coupon field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.rider != nil {
		edges = append(edges, coupon.EdgeRider)
	}
	if m.assembly != nil {
		edges = append(edges, coupon.EdgeAssembly)
	}
	if m.plan != nil {
		edges = append(edges, coupon.EdgePlan)
	}
	if m.template != nil {
		edges = append(edges, coupon.EdgeTemplate)
	}
	if m._order != nil {
		edges = append(edges, coupon.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case coupon.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case coupon.EdgeAssembly:
		if id := m.assembly; id != nil {
			return []ent.Value{*id}
		}
	case coupon.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	case coupon.EdgeTemplate:
		if id := m.template; id != nil {
			return []ent.Value{*id}
		}
	case coupon.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedrider {
		edges = append(edges, coupon.EdgeRider)
	}
	if m.clearedassembly {
		edges = append(edges, coupon.EdgeAssembly)
	}
	if m.clearedplan {
		edges = append(edges, coupon.EdgePlan)
	}
	if m.clearedtemplate {
		edges = append(edges, coupon.EdgeTemplate)
	}
	if m.cleared_order {
		edges = append(edges, coupon.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponMutation) EdgeCleared(name string) bool {
	switch name {
	case coupon.EdgeRider:
		return m.clearedrider
	case coupon.EdgeAssembly:
		return m.clearedassembly
	case coupon.EdgePlan:
		return m.clearedplan
	case coupon.EdgeTemplate:
		return m.clearedtemplate
	case coupon.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponMutation) ClearEdge(name string) error {
	switch name {
	case coupon.EdgeRider:
		m.ClearRider()
		return nil
	case coupon.EdgeAssembly:
		m.ClearAssembly()
		return nil
	case coupon.EdgePlan:
		m.ClearPlan()
		return nil
	case coupon.EdgeTemplate:
		m.ClearTemplate()
		return nil
	case coupon.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown Coupon unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponMutation) ResetEdge(name string) error {
	switch name {
	case coupon.EdgeRider:
		m.ResetRider()
		return nil
	case coupon.EdgeAssembly:
		m.ResetAssembly()
		return nil
	case coupon.EdgePlan:
		m.ResetPlan()
		return nil
	case coupon.EdgeTemplate:
		m.ResetTemplate()
		return nil
	case coupon.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown Coupon edge %s", name)
}

// CouponAssemblyMutation represents an operation that mutates the CouponAssembly nodes in the graph.
type CouponAssemblyMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	creator         **model.Modifier
	last_modifier   **model.Modifier
	remark          *string
	name            *string
	number          *int
	addnumber       *int
	amount          *float64
	addamount       *float64
	target          *uint8
	addtarget       *int8
	meta            **model.CouponTemplateMeta
	clearedFields   map[string]struct{}
	template        *uint64
	clearedtemplate bool
	done            bool
	oldValue        func(context.Context) (*CouponAssembly, error)
	predicates      []predicate.CouponAssembly
}

var _ ent.Mutation = (*CouponAssemblyMutation)(nil)

// couponassemblyOption allows management of the mutation configuration using functional options.
type couponassemblyOption func(*CouponAssemblyMutation)

// newCouponAssemblyMutation creates new mutation for the CouponAssembly entity.
func newCouponAssemblyMutation(c config, op Op, opts ...couponassemblyOption) *CouponAssemblyMutation {
	m := &CouponAssemblyMutation{
		config:        c,
		op:            op,
		typ:           TypeCouponAssembly,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponAssemblyID sets the ID field of the mutation.
func withCouponAssemblyID(id uint64) couponassemblyOption {
	return func(m *CouponAssemblyMutation) {
		var (
			err   error
			once  sync.Once
			value *CouponAssembly
		)
		m.oldValue = func(ctx context.Context) (*CouponAssembly, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CouponAssembly.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCouponAssembly sets the old CouponAssembly of the mutation.
func withCouponAssembly(node *CouponAssembly) couponassemblyOption {
	return func(m *CouponAssemblyMutation) {
		m.oldValue = func(context.Context) (*CouponAssembly, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponAssemblyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponAssemblyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponAssemblyMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CouponAssemblyMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CouponAssembly.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CouponAssemblyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CouponAssemblyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CouponAssembly entity.
// If the CouponAssembly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAssemblyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CouponAssemblyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CouponAssemblyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CouponAssemblyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CouponAssembly entity.
// If the CouponAssembly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAssemblyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CouponAssemblyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreator sets the "creator" field.
func (m *CouponAssemblyMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *CouponAssemblyMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the CouponAssembly entity.
// If the CouponAssembly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAssemblyMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *CouponAssemblyMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[couponassembly.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *CouponAssemblyMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[couponassembly.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *CouponAssemblyMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, couponassembly.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *CouponAssemblyMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *CouponAssemblyMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the CouponAssembly entity.
// If the CouponAssembly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAssemblyMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *CouponAssemblyMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[couponassembly.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *CouponAssemblyMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[couponassembly.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *CouponAssemblyMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, couponassembly.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *CouponAssemblyMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CouponAssemblyMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the CouponAssembly entity.
// If the CouponAssembly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAssemblyMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *CouponAssemblyMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[couponassembly.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *CouponAssemblyMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[couponassembly.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *CouponAssemblyMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, couponassembly.FieldRemark)
}

// SetTemplateID sets the "template_id" field.
func (m *CouponAssemblyMutation) SetTemplateID(u uint64) {
	m.template = &u
}

// TemplateID returns the value of the "template_id" field in the mutation.
func (m *CouponAssemblyMutation) TemplateID() (r uint64, exists bool) {
	v := m.template
	if v == nil {
		return
	}
	return *v, true
}

// OldTemplateID returns the old "template_id" field's value of the CouponAssembly entity.
// If the CouponAssembly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAssemblyMutation) OldTemplateID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemplateID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemplateID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemplateID: %w", err)
	}
	return oldValue.TemplateID, nil
}

// ResetTemplateID resets all changes to the "template_id" field.
func (m *CouponAssemblyMutation) ResetTemplateID() {
	m.template = nil
}

// SetName sets the "name" field.
func (m *CouponAssemblyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CouponAssemblyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CouponAssembly entity.
// If the CouponAssembly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAssemblyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CouponAssemblyMutation) ResetName() {
	m.name = nil
}

// SetNumber sets the "number" field.
func (m *CouponAssemblyMutation) SetNumber(i int) {
	m.number = &i
	m.addnumber = nil
}

// Number returns the value of the "number" field in the mutation.
func (m *CouponAssemblyMutation) Number() (r int, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the CouponAssembly entity.
// If the CouponAssembly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAssemblyMutation) OldNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// AddNumber adds i to the "number" field.
func (m *CouponAssemblyMutation) AddNumber(i int) {
	if m.addnumber != nil {
		*m.addnumber += i
	} else {
		m.addnumber = &i
	}
}

// AddedNumber returns the value that was added to the "number" field in this mutation.
func (m *CouponAssemblyMutation) AddedNumber() (r int, exists bool) {
	v := m.addnumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumber resets all changes to the "number" field.
func (m *CouponAssemblyMutation) ResetNumber() {
	m.number = nil
	m.addnumber = nil
}

// SetAmount sets the "amount" field.
func (m *CouponAssemblyMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *CouponAssemblyMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the CouponAssembly entity.
// If the CouponAssembly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAssemblyMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *CouponAssemblyMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *CouponAssemblyMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *CouponAssemblyMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetTarget sets the "target" field.
func (m *CouponAssemblyMutation) SetTarget(u uint8) {
	m.target = &u
	m.addtarget = nil
}

// Target returns the value of the "target" field in the mutation.
func (m *CouponAssemblyMutation) Target() (r uint8, exists bool) {
	v := m.target
	if v == nil {
		return
	}
	return *v, true
}

// OldTarget returns the old "target" field's value of the CouponAssembly entity.
// If the CouponAssembly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAssemblyMutation) OldTarget(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTarget is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTarget requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTarget: %w", err)
	}
	return oldValue.Target, nil
}

// AddTarget adds u to the "target" field.
func (m *CouponAssemblyMutation) AddTarget(u int8) {
	if m.addtarget != nil {
		*m.addtarget += u
	} else {
		m.addtarget = &u
	}
}

// AddedTarget returns the value that was added to the "target" field in this mutation.
func (m *CouponAssemblyMutation) AddedTarget() (r int8, exists bool) {
	v := m.addtarget
	if v == nil {
		return
	}
	return *v, true
}

// ResetTarget resets all changes to the "target" field.
func (m *CouponAssemblyMutation) ResetTarget() {
	m.target = nil
	m.addtarget = nil
}

// SetMeta sets the "meta" field.
func (m *CouponAssemblyMutation) SetMeta(mtm *model.CouponTemplateMeta) {
	m.meta = &mtm
}

// Meta returns the value of the "meta" field in the mutation.
func (m *CouponAssemblyMutation) Meta() (r *model.CouponTemplateMeta, exists bool) {
	v := m.meta
	if v == nil {
		return
	}
	return *v, true
}

// OldMeta returns the old "meta" field's value of the CouponAssembly entity.
// If the CouponAssembly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponAssemblyMutation) OldMeta(ctx context.Context) (v *model.CouponTemplateMeta, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeta is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeta requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeta: %w", err)
	}
	return oldValue.Meta, nil
}

// ResetMeta resets all changes to the "meta" field.
func (m *CouponAssemblyMutation) ResetMeta() {
	m.meta = nil
}

// ClearTemplate clears the "template" edge to the CouponTemplate entity.
func (m *CouponAssemblyMutation) ClearTemplate() {
	m.clearedtemplate = true
	m.clearedFields[couponassembly.FieldTemplateID] = struct{}{}
}

// TemplateCleared reports if the "template" edge to the CouponTemplate entity was cleared.
func (m *CouponAssemblyMutation) TemplateCleared() bool {
	return m.clearedtemplate
}

// TemplateIDs returns the "template" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TemplateID instead. It exists only for internal usage by the builders.
func (m *CouponAssemblyMutation) TemplateIDs() (ids []uint64) {
	if id := m.template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTemplate resets all changes to the "template" edge.
func (m *CouponAssemblyMutation) ResetTemplate() {
	m.template = nil
	m.clearedtemplate = false
}

// Where appends a list predicates to the CouponAssemblyMutation builder.
func (m *CouponAssemblyMutation) Where(ps ...predicate.CouponAssembly) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CouponAssemblyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CouponAssemblyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CouponAssembly, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CouponAssemblyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CouponAssemblyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CouponAssembly).
func (m *CouponAssemblyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponAssemblyMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, couponassembly.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, couponassembly.FieldUpdatedAt)
	}
	if m.creator != nil {
		fields = append(fields, couponassembly.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, couponassembly.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, couponassembly.FieldRemark)
	}
	if m.template != nil {
		fields = append(fields, couponassembly.FieldTemplateID)
	}
	if m.name != nil {
		fields = append(fields, couponassembly.FieldName)
	}
	if m.number != nil {
		fields = append(fields, couponassembly.FieldNumber)
	}
	if m.amount != nil {
		fields = append(fields, couponassembly.FieldAmount)
	}
	if m.target != nil {
		fields = append(fields, couponassembly.FieldTarget)
	}
	if m.meta != nil {
		fields = append(fields, couponassembly.FieldMeta)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponAssemblyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case couponassembly.FieldCreatedAt:
		return m.CreatedAt()
	case couponassembly.FieldUpdatedAt:
		return m.UpdatedAt()
	case couponassembly.FieldCreator:
		return m.Creator()
	case couponassembly.FieldLastModifier:
		return m.LastModifier()
	case couponassembly.FieldRemark:
		return m.Remark()
	case couponassembly.FieldTemplateID:
		return m.TemplateID()
	case couponassembly.FieldName:
		return m.Name()
	case couponassembly.FieldNumber:
		return m.Number()
	case couponassembly.FieldAmount:
		return m.Amount()
	case couponassembly.FieldTarget:
		return m.Target()
	case couponassembly.FieldMeta:
		return m.Meta()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponAssemblyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case couponassembly.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case couponassembly.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case couponassembly.FieldCreator:
		return m.OldCreator(ctx)
	case couponassembly.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case couponassembly.FieldRemark:
		return m.OldRemark(ctx)
	case couponassembly.FieldTemplateID:
		return m.OldTemplateID(ctx)
	case couponassembly.FieldName:
		return m.OldName(ctx)
	case couponassembly.FieldNumber:
		return m.OldNumber(ctx)
	case couponassembly.FieldAmount:
		return m.OldAmount(ctx)
	case couponassembly.FieldTarget:
		return m.OldTarget(ctx)
	case couponassembly.FieldMeta:
		return m.OldMeta(ctx)
	}
	return nil, fmt.Errorf("unknown CouponAssembly field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponAssemblyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case couponassembly.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case couponassembly.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case couponassembly.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case couponassembly.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case couponassembly.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case couponassembly.FieldTemplateID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemplateID(v)
		return nil
	case couponassembly.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case couponassembly.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case couponassembly.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case couponassembly.FieldTarget:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTarget(v)
		return nil
	case couponassembly.FieldMeta:
		v, ok := value.(*model.CouponTemplateMeta)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeta(v)
		return nil
	}
	return fmt.Errorf("unknown CouponAssembly field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponAssemblyMutation) AddedFields() []string {
	var fields []string
	if m.addnumber != nil {
		fields = append(fields, couponassembly.FieldNumber)
	}
	if m.addamount != nil {
		fields = append(fields, couponassembly.FieldAmount)
	}
	if m.addtarget != nil {
		fields = append(fields, couponassembly.FieldTarget)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponAssemblyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case couponassembly.FieldNumber:
		return m.AddedNumber()
	case couponassembly.FieldAmount:
		return m.AddedAmount()
	case couponassembly.FieldTarget:
		return m.AddedTarget()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponAssemblyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case couponassembly.FieldNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumber(v)
		return nil
	case couponassembly.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case couponassembly.FieldTarget:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTarget(v)
		return nil
	}
	return fmt.Errorf("unknown CouponAssembly numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponAssemblyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(couponassembly.FieldCreator) {
		fields = append(fields, couponassembly.FieldCreator)
	}
	if m.FieldCleared(couponassembly.FieldLastModifier) {
		fields = append(fields, couponassembly.FieldLastModifier)
	}
	if m.FieldCleared(couponassembly.FieldRemark) {
		fields = append(fields, couponassembly.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponAssemblyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponAssemblyMutation) ClearField(name string) error {
	switch name {
	case couponassembly.FieldCreator:
		m.ClearCreator()
		return nil
	case couponassembly.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case couponassembly.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown CouponAssembly nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponAssemblyMutation) ResetField(name string) error {
	switch name {
	case couponassembly.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case couponassembly.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case couponassembly.FieldCreator:
		m.ResetCreator()
		return nil
	case couponassembly.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case couponassembly.FieldRemark:
		m.ResetRemark()
		return nil
	case couponassembly.FieldTemplateID:
		m.ResetTemplateID()
		return nil
	case couponassembly.FieldName:
		m.ResetName()
		return nil
	case couponassembly.FieldNumber:
		m.ResetNumber()
		return nil
	case couponassembly.FieldAmount:
		m.ResetAmount()
		return nil
	case couponassembly.FieldTarget:
		m.ResetTarget()
		return nil
	case couponassembly.FieldMeta:
		m.ResetMeta()
		return nil
	}
	return fmt.Errorf("unknown CouponAssembly field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponAssemblyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.template != nil {
		edges = append(edges, couponassembly.EdgeTemplate)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponAssemblyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case couponassembly.EdgeTemplate:
		if id := m.template; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponAssemblyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponAssemblyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponAssemblyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtemplate {
		edges = append(edges, couponassembly.EdgeTemplate)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponAssemblyMutation) EdgeCleared(name string) bool {
	switch name {
	case couponassembly.EdgeTemplate:
		return m.clearedtemplate
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponAssemblyMutation) ClearEdge(name string) error {
	switch name {
	case couponassembly.EdgeTemplate:
		m.ClearTemplate()
		return nil
	}
	return fmt.Errorf("unknown CouponAssembly unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponAssemblyMutation) ResetEdge(name string) error {
	switch name {
	case couponassembly.EdgeTemplate:
		m.ResetTemplate()
		return nil
	}
	return fmt.Errorf("unknown CouponAssembly edge %s", name)
}

// CouponTemplateMutation represents an operation that mutates the CouponTemplate nodes in the graph.
type CouponTemplateMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	created_at     *time.Time
	updated_at     *time.Time
	creator        **model.Modifier
	last_modifier  **model.Modifier
	remark         *string
	enable         *bool
	name           *string
	meta           **model.CouponTemplateMeta
	clearedFields  map[string]struct{}
	coupons        map[uint64]struct{}
	removedcoupons map[uint64]struct{}
	clearedcoupons bool
	done           bool
	oldValue       func(context.Context) (*CouponTemplate, error)
	predicates     []predicate.CouponTemplate
}

var _ ent.Mutation = (*CouponTemplateMutation)(nil)

// coupontemplateOption allows management of the mutation configuration using functional options.
type coupontemplateOption func(*CouponTemplateMutation)

// newCouponTemplateMutation creates new mutation for the CouponTemplate entity.
func newCouponTemplateMutation(c config, op Op, opts ...coupontemplateOption) *CouponTemplateMutation {
	m := &CouponTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeCouponTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCouponTemplateID sets the ID field of the mutation.
func withCouponTemplateID(id uint64) coupontemplateOption {
	return func(m *CouponTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *CouponTemplate
		)
		m.oldValue = func(ctx context.Context) (*CouponTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CouponTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCouponTemplate sets the old CouponTemplate of the mutation.
func withCouponTemplate(node *CouponTemplate) coupontemplateOption {
	return func(m *CouponTemplateMutation) {
		m.oldValue = func(context.Context) (*CouponTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CouponTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CouponTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CouponTemplateMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CouponTemplateMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CouponTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CouponTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CouponTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CouponTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CouponTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CouponTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CouponTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreator sets the "creator" field.
func (m *CouponTemplateMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *CouponTemplateMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *CouponTemplateMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[coupontemplate.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *CouponTemplateMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[coupontemplate.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *CouponTemplateMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, coupontemplate.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *CouponTemplateMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *CouponTemplateMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *CouponTemplateMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[coupontemplate.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *CouponTemplateMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[coupontemplate.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *CouponTemplateMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, coupontemplate.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *CouponTemplateMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CouponTemplateMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *CouponTemplateMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[coupontemplate.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *CouponTemplateMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[coupontemplate.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *CouponTemplateMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, coupontemplate.FieldRemark)
}

// SetEnable sets the "enable" field.
func (m *CouponTemplateMutation) SetEnable(b bool) {
	m.enable = &b
}

// Enable returns the value of the "enable" field in the mutation.
func (m *CouponTemplateMutation) Enable() (r bool, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// ResetEnable resets all changes to the "enable" field.
func (m *CouponTemplateMutation) ResetEnable() {
	m.enable = nil
}

// SetName sets the "name" field.
func (m *CouponTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CouponTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CouponTemplateMutation) ResetName() {
	m.name = nil
}

// SetMeta sets the "meta" field.
func (m *CouponTemplateMutation) SetMeta(mtm *model.CouponTemplateMeta) {
	m.meta = &mtm
}

// Meta returns the value of the "meta" field in the mutation.
func (m *CouponTemplateMutation) Meta() (r *model.CouponTemplateMeta, exists bool) {
	v := m.meta
	if v == nil {
		return
	}
	return *v, true
}

// OldMeta returns the old "meta" field's value of the CouponTemplate entity.
// If the CouponTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CouponTemplateMutation) OldMeta(ctx context.Context) (v *model.CouponTemplateMeta, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeta is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeta requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeta: %w", err)
	}
	return oldValue.Meta, nil
}

// ResetMeta resets all changes to the "meta" field.
func (m *CouponTemplateMutation) ResetMeta() {
	m.meta = nil
}

// AddCouponIDs adds the "coupons" edge to the Coupon entity by ids.
func (m *CouponTemplateMutation) AddCouponIDs(ids ...uint64) {
	if m.coupons == nil {
		m.coupons = make(map[uint64]struct{})
	}
	for i := range ids {
		m.coupons[ids[i]] = struct{}{}
	}
}

// ClearCoupons clears the "coupons" edge to the Coupon entity.
func (m *CouponTemplateMutation) ClearCoupons() {
	m.clearedcoupons = true
}

// CouponsCleared reports if the "coupons" edge to the Coupon entity was cleared.
func (m *CouponTemplateMutation) CouponsCleared() bool {
	return m.clearedcoupons
}

// RemoveCouponIDs removes the "coupons" edge to the Coupon entity by IDs.
func (m *CouponTemplateMutation) RemoveCouponIDs(ids ...uint64) {
	if m.removedcoupons == nil {
		m.removedcoupons = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.coupons, ids[i])
		m.removedcoupons[ids[i]] = struct{}{}
	}
}

// RemovedCoupons returns the removed IDs of the "coupons" edge to the Coupon entity.
func (m *CouponTemplateMutation) RemovedCouponsIDs() (ids []uint64) {
	for id := range m.removedcoupons {
		ids = append(ids, id)
	}
	return
}

// CouponsIDs returns the "coupons" edge IDs in the mutation.
func (m *CouponTemplateMutation) CouponsIDs() (ids []uint64) {
	for id := range m.coupons {
		ids = append(ids, id)
	}
	return
}

// ResetCoupons resets all changes to the "coupons" edge.
func (m *CouponTemplateMutation) ResetCoupons() {
	m.coupons = nil
	m.clearedcoupons = false
	m.removedcoupons = nil
}

// Where appends a list predicates to the CouponTemplateMutation builder.
func (m *CouponTemplateMutation) Where(ps ...predicate.CouponTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CouponTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CouponTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CouponTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CouponTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CouponTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CouponTemplate).
func (m *CouponTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CouponTemplateMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, coupontemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, coupontemplate.FieldUpdatedAt)
	}
	if m.creator != nil {
		fields = append(fields, coupontemplate.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, coupontemplate.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, coupontemplate.FieldRemark)
	}
	if m.enable != nil {
		fields = append(fields, coupontemplate.FieldEnable)
	}
	if m.name != nil {
		fields = append(fields, coupontemplate.FieldName)
	}
	if m.meta != nil {
		fields = append(fields, coupontemplate.FieldMeta)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CouponTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case coupontemplate.FieldCreatedAt:
		return m.CreatedAt()
	case coupontemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	case coupontemplate.FieldCreator:
		return m.Creator()
	case coupontemplate.FieldLastModifier:
		return m.LastModifier()
	case coupontemplate.FieldRemark:
		return m.Remark()
	case coupontemplate.FieldEnable:
		return m.Enable()
	case coupontemplate.FieldName:
		return m.Name()
	case coupontemplate.FieldMeta:
		return m.Meta()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CouponTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case coupontemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case coupontemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case coupontemplate.FieldCreator:
		return m.OldCreator(ctx)
	case coupontemplate.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case coupontemplate.FieldRemark:
		return m.OldRemark(ctx)
	case coupontemplate.FieldEnable:
		return m.OldEnable(ctx)
	case coupontemplate.FieldName:
		return m.OldName(ctx)
	case coupontemplate.FieldMeta:
		return m.OldMeta(ctx)
	}
	return nil, fmt.Errorf("unknown CouponTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case coupontemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case coupontemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case coupontemplate.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case coupontemplate.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case coupontemplate.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case coupontemplate.FieldEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case coupontemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case coupontemplate.FieldMeta:
		v, ok := value.(*model.CouponTemplateMeta)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeta(v)
		return nil
	}
	return fmt.Errorf("unknown CouponTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CouponTemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CouponTemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CouponTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CouponTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CouponTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(coupontemplate.FieldCreator) {
		fields = append(fields, coupontemplate.FieldCreator)
	}
	if m.FieldCleared(coupontemplate.FieldLastModifier) {
		fields = append(fields, coupontemplate.FieldLastModifier)
	}
	if m.FieldCleared(coupontemplate.FieldRemark) {
		fields = append(fields, coupontemplate.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CouponTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CouponTemplateMutation) ClearField(name string) error {
	switch name {
	case coupontemplate.FieldCreator:
		m.ClearCreator()
		return nil
	case coupontemplate.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case coupontemplate.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown CouponTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CouponTemplateMutation) ResetField(name string) error {
	switch name {
	case coupontemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case coupontemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case coupontemplate.FieldCreator:
		m.ResetCreator()
		return nil
	case coupontemplate.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case coupontemplate.FieldRemark:
		m.ResetRemark()
		return nil
	case coupontemplate.FieldEnable:
		m.ResetEnable()
		return nil
	case coupontemplate.FieldName:
		m.ResetName()
		return nil
	case coupontemplate.FieldMeta:
		m.ResetMeta()
		return nil
	}
	return fmt.Errorf("unknown CouponTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CouponTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.coupons != nil {
		edges = append(edges, coupontemplate.EdgeCoupons)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CouponTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case coupontemplate.EdgeCoupons:
		ids := make([]ent.Value, 0, len(m.coupons))
		for id := range m.coupons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CouponTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcoupons != nil {
		edges = append(edges, coupontemplate.EdgeCoupons)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CouponTemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case coupontemplate.EdgeCoupons:
		ids := make([]ent.Value, 0, len(m.removedcoupons))
		for id := range m.removedcoupons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CouponTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcoupons {
		edges = append(edges, coupontemplate.EdgeCoupons)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CouponTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case coupontemplate.EdgeCoupons:
		return m.clearedcoupons
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CouponTemplateMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CouponTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CouponTemplateMutation) ResetEdge(name string) error {
	switch name {
	case coupontemplate.EdgeCoupons:
		m.ResetCoupons()
		return nil
	}
	return fmt.Errorf("unknown CouponTemplate edge %s", name)
}

// EbikeMutation represents an operation that mutates the Ebike nodes in the graph.
type EbikeMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	status            *model.EbikeStatus
	enable            *bool
	sn                *string
	plate             *string
	machine           *string
	sim               *string
	color             *string
	ex_factory        *string
	clearedFields     map[string]struct{}
	brand             *uint64
	clearedbrand      bool
	rider             *uint64
	clearedrider      bool
	store             *uint64
	clearedstore      bool
	enterprise        *uint64
	clearedenterprise bool
	station           *uint64
	clearedstation    bool
	allocates         map[uint64]struct{}
	removedallocates  map[uint64]struct{}
	clearedallocates  bool
	done              bool
	oldValue          func(context.Context) (*Ebike, error)
	predicates        []predicate.Ebike
}

var _ ent.Mutation = (*EbikeMutation)(nil)

// ebikeOption allows management of the mutation configuration using functional options.
type ebikeOption func(*EbikeMutation)

// newEbikeMutation creates new mutation for the Ebike entity.
func newEbikeMutation(c config, op Op, opts ...ebikeOption) *EbikeMutation {
	m := &EbikeMutation{
		config:        c,
		op:            op,
		typ:           TypeEbike,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEbikeID sets the ID field of the mutation.
func withEbikeID(id uint64) ebikeOption {
	return func(m *EbikeMutation) {
		var (
			err   error
			once  sync.Once
			value *Ebike
		)
		m.oldValue = func(ctx context.Context) (*Ebike, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ebike.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEbike sets the old Ebike of the mutation.
func withEbike(node *Ebike) ebikeOption {
	return func(m *EbikeMutation) {
		m.oldValue = func(context.Context) (*Ebike, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EbikeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EbikeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EbikeMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EbikeMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ebike.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EbikeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EbikeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Ebike entity.
// If the Ebike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EbikeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EbikeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EbikeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Ebike entity.
// If the Ebike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EbikeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreator sets the "creator" field.
func (m *EbikeMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *EbikeMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Ebike entity.
// If the Ebike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *EbikeMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[ebike.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *EbikeMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[ebike.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *EbikeMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, ebike.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *EbikeMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *EbikeMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Ebike entity.
// If the Ebike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *EbikeMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[ebike.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *EbikeMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[ebike.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *EbikeMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, ebike.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *EbikeMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *EbikeMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Ebike entity.
// If the Ebike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *EbikeMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[ebike.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *EbikeMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[ebike.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *EbikeMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, ebike.FieldRemark)
}

// SetBrandID sets the "brand_id" field.
func (m *EbikeMutation) SetBrandID(u uint64) {
	m.brand = &u
}

// BrandID returns the value of the "brand_id" field in the mutation.
func (m *EbikeMutation) BrandID() (r uint64, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrandID returns the old "brand_id" field's value of the Ebike entity.
// If the Ebike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeMutation) OldBrandID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrandID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrandID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrandID: %w", err)
	}
	return oldValue.BrandID, nil
}

// ResetBrandID resets all changes to the "brand_id" field.
func (m *EbikeMutation) ResetBrandID() {
	m.brand = nil
}

// SetRiderID sets the "rider_id" field.
func (m *EbikeMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *EbikeMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the Ebike entity.
// If the Ebike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeMutation) OldRiderID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ClearRiderID clears the value of the "rider_id" field.
func (m *EbikeMutation) ClearRiderID() {
	m.rider = nil
	m.clearedFields[ebike.FieldRiderID] = struct{}{}
}

// RiderIDCleared returns if the "rider_id" field was cleared in this mutation.
func (m *EbikeMutation) RiderIDCleared() bool {
	_, ok := m.clearedFields[ebike.FieldRiderID]
	return ok
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *EbikeMutation) ResetRiderID() {
	m.rider = nil
	delete(m.clearedFields, ebike.FieldRiderID)
}

// SetStoreID sets the "store_id" field.
func (m *EbikeMutation) SetStoreID(u uint64) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *EbikeMutation) StoreID() (r uint64, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Ebike entity.
// If the Ebike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeMutation) OldStoreID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *EbikeMutation) ClearStoreID() {
	m.store = nil
	m.clearedFields[ebike.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *EbikeMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[ebike.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *EbikeMutation) ResetStoreID() {
	m.store = nil
	delete(m.clearedFields, ebike.FieldStoreID)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *EbikeMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *EbikeMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the Ebike entity.
// If the Ebike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeMutation) OldEnterpriseID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ClearEnterpriseID clears the value of the "enterprise_id" field.
func (m *EbikeMutation) ClearEnterpriseID() {
	m.enterprise = nil
	m.clearedFields[ebike.FieldEnterpriseID] = struct{}{}
}

// EnterpriseIDCleared returns if the "enterprise_id" field was cleared in this mutation.
func (m *EbikeMutation) EnterpriseIDCleared() bool {
	_, ok := m.clearedFields[ebike.FieldEnterpriseID]
	return ok
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *EbikeMutation) ResetEnterpriseID() {
	m.enterprise = nil
	delete(m.clearedFields, ebike.FieldEnterpriseID)
}

// SetStationID sets the "station_id" field.
func (m *EbikeMutation) SetStationID(u uint64) {
	m.station = &u
}

// StationID returns the value of the "station_id" field in the mutation.
func (m *EbikeMutation) StationID() (r uint64, exists bool) {
	v := m.station
	if v == nil {
		return
	}
	return *v, true
}

// OldStationID returns the old "station_id" field's value of the Ebike entity.
// If the Ebike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeMutation) OldStationID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStationID: %w", err)
	}
	return oldValue.StationID, nil
}

// ClearStationID clears the value of the "station_id" field.
func (m *EbikeMutation) ClearStationID() {
	m.station = nil
	m.clearedFields[ebike.FieldStationID] = struct{}{}
}

// StationIDCleared returns if the "station_id" field was cleared in this mutation.
func (m *EbikeMutation) StationIDCleared() bool {
	_, ok := m.clearedFields[ebike.FieldStationID]
	return ok
}

// ResetStationID resets all changes to the "station_id" field.
func (m *EbikeMutation) ResetStationID() {
	m.station = nil
	delete(m.clearedFields, ebike.FieldStationID)
}

// SetStatus sets the "status" field.
func (m *EbikeMutation) SetStatus(ms model.EbikeStatus) {
	m.status = &ms
}

// Status returns the value of the "status" field in the mutation.
func (m *EbikeMutation) Status() (r model.EbikeStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Ebike entity.
// If the Ebike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeMutation) OldStatus(ctx context.Context) (v model.EbikeStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EbikeMutation) ResetStatus() {
	m.status = nil
}

// SetEnable sets the "enable" field.
func (m *EbikeMutation) SetEnable(b bool) {
	m.enable = &b
}

// Enable returns the value of the "enable" field in the mutation.
func (m *EbikeMutation) Enable() (r bool, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the Ebike entity.
// If the Ebike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeMutation) OldEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// ResetEnable resets all changes to the "enable" field.
func (m *EbikeMutation) ResetEnable() {
	m.enable = nil
}

// SetSn sets the "sn" field.
func (m *EbikeMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *EbikeMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Ebike entity.
// If the Ebike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *EbikeMutation) ResetSn() {
	m.sn = nil
}

// SetPlate sets the "plate" field.
func (m *EbikeMutation) SetPlate(s string) {
	m.plate = &s
}

// Plate returns the value of the "plate" field in the mutation.
func (m *EbikeMutation) Plate() (r string, exists bool) {
	v := m.plate
	if v == nil {
		return
	}
	return *v, true
}

// OldPlate returns the old "plate" field's value of the Ebike entity.
// If the Ebike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeMutation) OldPlate(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlate: %w", err)
	}
	return oldValue.Plate, nil
}

// ClearPlate clears the value of the "plate" field.
func (m *EbikeMutation) ClearPlate() {
	m.plate = nil
	m.clearedFields[ebike.FieldPlate] = struct{}{}
}

// PlateCleared returns if the "plate" field was cleared in this mutation.
func (m *EbikeMutation) PlateCleared() bool {
	_, ok := m.clearedFields[ebike.FieldPlate]
	return ok
}

// ResetPlate resets all changes to the "plate" field.
func (m *EbikeMutation) ResetPlate() {
	m.plate = nil
	delete(m.clearedFields, ebike.FieldPlate)
}

// SetMachine sets the "machine" field.
func (m *EbikeMutation) SetMachine(s string) {
	m.machine = &s
}

// Machine returns the value of the "machine" field in the mutation.
func (m *EbikeMutation) Machine() (r string, exists bool) {
	v := m.machine
	if v == nil {
		return
	}
	return *v, true
}

// OldMachine returns the old "machine" field's value of the Ebike entity.
// If the Ebike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeMutation) OldMachine(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMachine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMachine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMachine: %w", err)
	}
	return oldValue.Machine, nil
}

// ClearMachine clears the value of the "machine" field.
func (m *EbikeMutation) ClearMachine() {
	m.machine = nil
	m.clearedFields[ebike.FieldMachine] = struct{}{}
}

// MachineCleared returns if the "machine" field was cleared in this mutation.
func (m *EbikeMutation) MachineCleared() bool {
	_, ok := m.clearedFields[ebike.FieldMachine]
	return ok
}

// ResetMachine resets all changes to the "machine" field.
func (m *EbikeMutation) ResetMachine() {
	m.machine = nil
	delete(m.clearedFields, ebike.FieldMachine)
}

// SetSim sets the "sim" field.
func (m *EbikeMutation) SetSim(s string) {
	m.sim = &s
}

// Sim returns the value of the "sim" field in the mutation.
func (m *EbikeMutation) Sim() (r string, exists bool) {
	v := m.sim
	if v == nil {
		return
	}
	return *v, true
}

// OldSim returns the old "sim" field's value of the Ebike entity.
// If the Ebike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeMutation) OldSim(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSim is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSim requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSim: %w", err)
	}
	return oldValue.Sim, nil
}

// ClearSim clears the value of the "sim" field.
func (m *EbikeMutation) ClearSim() {
	m.sim = nil
	m.clearedFields[ebike.FieldSim] = struct{}{}
}

// SimCleared returns if the "sim" field was cleared in this mutation.
func (m *EbikeMutation) SimCleared() bool {
	_, ok := m.clearedFields[ebike.FieldSim]
	return ok
}

// ResetSim resets all changes to the "sim" field.
func (m *EbikeMutation) ResetSim() {
	m.sim = nil
	delete(m.clearedFields, ebike.FieldSim)
}

// SetColor sets the "color" field.
func (m *EbikeMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *EbikeMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Ebike entity.
// If the Ebike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ResetColor resets all changes to the "color" field.
func (m *EbikeMutation) ResetColor() {
	m.color = nil
}

// SetExFactory sets the "ex_factory" field.
func (m *EbikeMutation) SetExFactory(s string) {
	m.ex_factory = &s
}

// ExFactory returns the value of the "ex_factory" field in the mutation.
func (m *EbikeMutation) ExFactory() (r string, exists bool) {
	v := m.ex_factory
	if v == nil {
		return
	}
	return *v, true
}

// OldExFactory returns the old "ex_factory" field's value of the Ebike entity.
// If the Ebike object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeMutation) OldExFactory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExFactory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExFactory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExFactory: %w", err)
	}
	return oldValue.ExFactory, nil
}

// ResetExFactory resets all changes to the "ex_factory" field.
func (m *EbikeMutation) ResetExFactory() {
	m.ex_factory = nil
}

// ClearBrand clears the "brand" edge to the EbikeBrand entity.
func (m *EbikeMutation) ClearBrand() {
	m.clearedbrand = true
	m.clearedFields[ebike.FieldBrandID] = struct{}{}
}

// BrandCleared reports if the "brand" edge to the EbikeBrand entity was cleared.
func (m *EbikeMutation) BrandCleared() bool {
	return m.clearedbrand
}

// BrandIDs returns the "brand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BrandID instead. It exists only for internal usage by the builders.
func (m *EbikeMutation) BrandIDs() (ids []uint64) {
	if id := m.brand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBrand resets all changes to the "brand" edge.
func (m *EbikeMutation) ResetBrand() {
	m.brand = nil
	m.clearedbrand = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *EbikeMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[ebike.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *EbikeMutation) RiderCleared() bool {
	return m.RiderIDCleared() || m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *EbikeMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *EbikeMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearStore clears the "store" edge to the Store entity.
func (m *EbikeMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[ebike.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *EbikeMutation) StoreCleared() bool {
	return m.StoreIDCleared() || m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *EbikeMutation) StoreIDs() (ids []uint64) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *EbikeMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *EbikeMutation) ClearEnterprise() {
	m.clearedenterprise = true
	m.clearedFields[ebike.FieldEnterpriseID] = struct{}{}
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *EbikeMutation) EnterpriseCleared() bool {
	return m.EnterpriseIDCleared() || m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *EbikeMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *EbikeMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// ClearStation clears the "station" edge to the EnterpriseStation entity.
func (m *EbikeMutation) ClearStation() {
	m.clearedstation = true
	m.clearedFields[ebike.FieldStationID] = struct{}{}
}

// StationCleared reports if the "station" edge to the EnterpriseStation entity was cleared.
func (m *EbikeMutation) StationCleared() bool {
	return m.StationIDCleared() || m.clearedstation
}

// StationIDs returns the "station" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StationID instead. It exists only for internal usage by the builders.
func (m *EbikeMutation) StationIDs() (ids []uint64) {
	if id := m.station; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStation resets all changes to the "station" edge.
func (m *EbikeMutation) ResetStation() {
	m.station = nil
	m.clearedstation = false
}

// AddAllocateIDs adds the "allocates" edge to the Allocate entity by ids.
func (m *EbikeMutation) AddAllocateIDs(ids ...uint64) {
	if m.allocates == nil {
		m.allocates = make(map[uint64]struct{})
	}
	for i := range ids {
		m.allocates[ids[i]] = struct{}{}
	}
}

// ClearAllocates clears the "allocates" edge to the Allocate entity.
func (m *EbikeMutation) ClearAllocates() {
	m.clearedallocates = true
}

// AllocatesCleared reports if the "allocates" edge to the Allocate entity was cleared.
func (m *EbikeMutation) AllocatesCleared() bool {
	return m.clearedallocates
}

// RemoveAllocateIDs removes the "allocates" edge to the Allocate entity by IDs.
func (m *EbikeMutation) RemoveAllocateIDs(ids ...uint64) {
	if m.removedallocates == nil {
		m.removedallocates = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.allocates, ids[i])
		m.removedallocates[ids[i]] = struct{}{}
	}
}

// RemovedAllocates returns the removed IDs of the "allocates" edge to the Allocate entity.
func (m *EbikeMutation) RemovedAllocatesIDs() (ids []uint64) {
	for id := range m.removedallocates {
		ids = append(ids, id)
	}
	return
}

// AllocatesIDs returns the "allocates" edge IDs in the mutation.
func (m *EbikeMutation) AllocatesIDs() (ids []uint64) {
	for id := range m.allocates {
		ids = append(ids, id)
	}
	return
}

// ResetAllocates resets all changes to the "allocates" edge.
func (m *EbikeMutation) ResetAllocates() {
	m.allocates = nil
	m.clearedallocates = false
	m.removedallocates = nil
}

// Where appends a list predicates to the EbikeMutation builder.
func (m *EbikeMutation) Where(ps ...predicate.Ebike) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EbikeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EbikeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Ebike, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EbikeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EbikeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Ebike).
func (m *EbikeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EbikeMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, ebike.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ebike.FieldUpdatedAt)
	}
	if m.creator != nil {
		fields = append(fields, ebike.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, ebike.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, ebike.FieldRemark)
	}
	if m.brand != nil {
		fields = append(fields, ebike.FieldBrandID)
	}
	if m.rider != nil {
		fields = append(fields, ebike.FieldRiderID)
	}
	if m.store != nil {
		fields = append(fields, ebike.FieldStoreID)
	}
	if m.enterprise != nil {
		fields = append(fields, ebike.FieldEnterpriseID)
	}
	if m.station != nil {
		fields = append(fields, ebike.FieldStationID)
	}
	if m.status != nil {
		fields = append(fields, ebike.FieldStatus)
	}
	if m.enable != nil {
		fields = append(fields, ebike.FieldEnable)
	}
	if m.sn != nil {
		fields = append(fields, ebike.FieldSn)
	}
	if m.plate != nil {
		fields = append(fields, ebike.FieldPlate)
	}
	if m.machine != nil {
		fields = append(fields, ebike.FieldMachine)
	}
	if m.sim != nil {
		fields = append(fields, ebike.FieldSim)
	}
	if m.color != nil {
		fields = append(fields, ebike.FieldColor)
	}
	if m.ex_factory != nil {
		fields = append(fields, ebike.FieldExFactory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EbikeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ebike.FieldCreatedAt:
		return m.CreatedAt()
	case ebike.FieldUpdatedAt:
		return m.UpdatedAt()
	case ebike.FieldCreator:
		return m.Creator()
	case ebike.FieldLastModifier:
		return m.LastModifier()
	case ebike.FieldRemark:
		return m.Remark()
	case ebike.FieldBrandID:
		return m.BrandID()
	case ebike.FieldRiderID:
		return m.RiderID()
	case ebike.FieldStoreID:
		return m.StoreID()
	case ebike.FieldEnterpriseID:
		return m.EnterpriseID()
	case ebike.FieldStationID:
		return m.StationID()
	case ebike.FieldStatus:
		return m.Status()
	case ebike.FieldEnable:
		return m.Enable()
	case ebike.FieldSn:
		return m.Sn()
	case ebike.FieldPlate:
		return m.Plate()
	case ebike.FieldMachine:
		return m.Machine()
	case ebike.FieldSim:
		return m.Sim()
	case ebike.FieldColor:
		return m.Color()
	case ebike.FieldExFactory:
		return m.ExFactory()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EbikeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ebike.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ebike.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ebike.FieldCreator:
		return m.OldCreator(ctx)
	case ebike.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case ebike.FieldRemark:
		return m.OldRemark(ctx)
	case ebike.FieldBrandID:
		return m.OldBrandID(ctx)
	case ebike.FieldRiderID:
		return m.OldRiderID(ctx)
	case ebike.FieldStoreID:
		return m.OldStoreID(ctx)
	case ebike.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case ebike.FieldStationID:
		return m.OldStationID(ctx)
	case ebike.FieldStatus:
		return m.OldStatus(ctx)
	case ebike.FieldEnable:
		return m.OldEnable(ctx)
	case ebike.FieldSn:
		return m.OldSn(ctx)
	case ebike.FieldPlate:
		return m.OldPlate(ctx)
	case ebike.FieldMachine:
		return m.OldMachine(ctx)
	case ebike.FieldSim:
		return m.OldSim(ctx)
	case ebike.FieldColor:
		return m.OldColor(ctx)
	case ebike.FieldExFactory:
		return m.OldExFactory(ctx)
	}
	return nil, fmt.Errorf("unknown Ebike field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EbikeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ebike.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ebike.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ebike.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case ebike.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case ebike.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case ebike.FieldBrandID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrandID(v)
		return nil
	case ebike.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case ebike.FieldStoreID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case ebike.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case ebike.FieldStationID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStationID(v)
		return nil
	case ebike.FieldStatus:
		v, ok := value.(model.EbikeStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case ebike.FieldEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case ebike.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case ebike.FieldPlate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlate(v)
		return nil
	case ebike.FieldMachine:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMachine(v)
		return nil
	case ebike.FieldSim:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSim(v)
		return nil
	case ebike.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case ebike.FieldExFactory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExFactory(v)
		return nil
	}
	return fmt.Errorf("unknown Ebike field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EbikeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EbikeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EbikeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ebike numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EbikeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ebike.FieldCreator) {
		fields = append(fields, ebike.FieldCreator)
	}
	if m.FieldCleared(ebike.FieldLastModifier) {
		fields = append(fields, ebike.FieldLastModifier)
	}
	if m.FieldCleared(ebike.FieldRemark) {
		fields = append(fields, ebike.FieldRemark)
	}
	if m.FieldCleared(ebike.FieldRiderID) {
		fields = append(fields, ebike.FieldRiderID)
	}
	if m.FieldCleared(ebike.FieldStoreID) {
		fields = append(fields, ebike.FieldStoreID)
	}
	if m.FieldCleared(ebike.FieldEnterpriseID) {
		fields = append(fields, ebike.FieldEnterpriseID)
	}
	if m.FieldCleared(ebike.FieldStationID) {
		fields = append(fields, ebike.FieldStationID)
	}
	if m.FieldCleared(ebike.FieldPlate) {
		fields = append(fields, ebike.FieldPlate)
	}
	if m.FieldCleared(ebike.FieldMachine) {
		fields = append(fields, ebike.FieldMachine)
	}
	if m.FieldCleared(ebike.FieldSim) {
		fields = append(fields, ebike.FieldSim)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EbikeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EbikeMutation) ClearField(name string) error {
	switch name {
	case ebike.FieldCreator:
		m.ClearCreator()
		return nil
	case ebike.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case ebike.FieldRemark:
		m.ClearRemark()
		return nil
	case ebike.FieldRiderID:
		m.ClearRiderID()
		return nil
	case ebike.FieldStoreID:
		m.ClearStoreID()
		return nil
	case ebike.FieldEnterpriseID:
		m.ClearEnterpriseID()
		return nil
	case ebike.FieldStationID:
		m.ClearStationID()
		return nil
	case ebike.FieldPlate:
		m.ClearPlate()
		return nil
	case ebike.FieldMachine:
		m.ClearMachine()
		return nil
	case ebike.FieldSim:
		m.ClearSim()
		return nil
	}
	return fmt.Errorf("unknown Ebike nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EbikeMutation) ResetField(name string) error {
	switch name {
	case ebike.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ebike.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ebike.FieldCreator:
		m.ResetCreator()
		return nil
	case ebike.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case ebike.FieldRemark:
		m.ResetRemark()
		return nil
	case ebike.FieldBrandID:
		m.ResetBrandID()
		return nil
	case ebike.FieldRiderID:
		m.ResetRiderID()
		return nil
	case ebike.FieldStoreID:
		m.ResetStoreID()
		return nil
	case ebike.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case ebike.FieldStationID:
		m.ResetStationID()
		return nil
	case ebike.FieldStatus:
		m.ResetStatus()
		return nil
	case ebike.FieldEnable:
		m.ResetEnable()
		return nil
	case ebike.FieldSn:
		m.ResetSn()
		return nil
	case ebike.FieldPlate:
		m.ResetPlate()
		return nil
	case ebike.FieldMachine:
		m.ResetMachine()
		return nil
	case ebike.FieldSim:
		m.ResetSim()
		return nil
	case ebike.FieldColor:
		m.ResetColor()
		return nil
	case ebike.FieldExFactory:
		m.ResetExFactory()
		return nil
	}
	return fmt.Errorf("unknown Ebike field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EbikeMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.brand != nil {
		edges = append(edges, ebike.EdgeBrand)
	}
	if m.rider != nil {
		edges = append(edges, ebike.EdgeRider)
	}
	if m.store != nil {
		edges = append(edges, ebike.EdgeStore)
	}
	if m.enterprise != nil {
		edges = append(edges, ebike.EdgeEnterprise)
	}
	if m.station != nil {
		edges = append(edges, ebike.EdgeStation)
	}
	if m.allocates != nil {
		edges = append(edges, ebike.EdgeAllocates)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EbikeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ebike.EdgeBrand:
		if id := m.brand; id != nil {
			return []ent.Value{*id}
		}
	case ebike.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case ebike.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	case ebike.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	case ebike.EdgeStation:
		if id := m.station; id != nil {
			return []ent.Value{*id}
		}
	case ebike.EdgeAllocates:
		ids := make([]ent.Value, 0, len(m.allocates))
		for id := range m.allocates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EbikeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedallocates != nil {
		edges = append(edges, ebike.EdgeAllocates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EbikeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ebike.EdgeAllocates:
		ids := make([]ent.Value, 0, len(m.removedallocates))
		for id := range m.removedallocates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EbikeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedbrand {
		edges = append(edges, ebike.EdgeBrand)
	}
	if m.clearedrider {
		edges = append(edges, ebike.EdgeRider)
	}
	if m.clearedstore {
		edges = append(edges, ebike.EdgeStore)
	}
	if m.clearedenterprise {
		edges = append(edges, ebike.EdgeEnterprise)
	}
	if m.clearedstation {
		edges = append(edges, ebike.EdgeStation)
	}
	if m.clearedallocates {
		edges = append(edges, ebike.EdgeAllocates)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EbikeMutation) EdgeCleared(name string) bool {
	switch name {
	case ebike.EdgeBrand:
		return m.clearedbrand
	case ebike.EdgeRider:
		return m.clearedrider
	case ebike.EdgeStore:
		return m.clearedstore
	case ebike.EdgeEnterprise:
		return m.clearedenterprise
	case ebike.EdgeStation:
		return m.clearedstation
	case ebike.EdgeAllocates:
		return m.clearedallocates
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EbikeMutation) ClearEdge(name string) error {
	switch name {
	case ebike.EdgeBrand:
		m.ClearBrand()
		return nil
	case ebike.EdgeRider:
		m.ClearRider()
		return nil
	case ebike.EdgeStore:
		m.ClearStore()
		return nil
	case ebike.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	case ebike.EdgeStation:
		m.ClearStation()
		return nil
	}
	return fmt.Errorf("unknown Ebike unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EbikeMutation) ResetEdge(name string) error {
	switch name {
	case ebike.EdgeBrand:
		m.ResetBrand()
		return nil
	case ebike.EdgeRider:
		m.ResetRider()
		return nil
	case ebike.EdgeStore:
		m.ResetStore()
		return nil
	case ebike.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	case ebike.EdgeStation:
		m.ResetStation()
		return nil
	case ebike.EdgeAllocates:
		m.ResetAllocates()
		return nil
	}
	return fmt.Errorf("unknown Ebike edge %s", name)
}

// EbikeBrandMutation represents an operation that mutates the EbikeBrand nodes in the graph.
type EbikeBrandMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	creator       **model.Modifier
	last_modifier **model.Modifier
	remark        *string
	name          *string
	cover         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*EbikeBrand, error)
	predicates    []predicate.EbikeBrand
}

var _ ent.Mutation = (*EbikeBrandMutation)(nil)

// ebikebrandOption allows management of the mutation configuration using functional options.
type ebikebrandOption func(*EbikeBrandMutation)

// newEbikeBrandMutation creates new mutation for the EbikeBrand entity.
func newEbikeBrandMutation(c config, op Op, opts ...ebikebrandOption) *EbikeBrandMutation {
	m := &EbikeBrandMutation{
		config:        c,
		op:            op,
		typ:           TypeEbikeBrand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEbikeBrandID sets the ID field of the mutation.
func withEbikeBrandID(id uint64) ebikebrandOption {
	return func(m *EbikeBrandMutation) {
		var (
			err   error
			once  sync.Once
			value *EbikeBrand
		)
		m.oldValue = func(ctx context.Context) (*EbikeBrand, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EbikeBrand.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEbikeBrand sets the old EbikeBrand of the mutation.
func withEbikeBrand(node *EbikeBrand) ebikebrandOption {
	return func(m *EbikeBrandMutation) {
		m.oldValue = func(context.Context) (*EbikeBrand, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EbikeBrandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EbikeBrandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EbikeBrandMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EbikeBrandMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EbikeBrand.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EbikeBrandMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EbikeBrandMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EbikeBrand entity.
// If the EbikeBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeBrandMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EbikeBrandMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EbikeBrandMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EbikeBrandMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EbikeBrand entity.
// If the EbikeBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeBrandMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EbikeBrandMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EbikeBrandMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EbikeBrandMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EbikeBrand entity.
// If the EbikeBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeBrandMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EbikeBrandMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[ebikebrand.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EbikeBrandMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[ebikebrand.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EbikeBrandMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, ebikebrand.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *EbikeBrandMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *EbikeBrandMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the EbikeBrand entity.
// If the EbikeBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeBrandMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *EbikeBrandMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[ebikebrand.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *EbikeBrandMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[ebikebrand.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *EbikeBrandMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, ebikebrand.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *EbikeBrandMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *EbikeBrandMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the EbikeBrand entity.
// If the EbikeBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeBrandMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *EbikeBrandMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[ebikebrand.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *EbikeBrandMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[ebikebrand.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *EbikeBrandMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, ebikebrand.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *EbikeBrandMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *EbikeBrandMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the EbikeBrand entity.
// If the EbikeBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeBrandMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *EbikeBrandMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[ebikebrand.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *EbikeBrandMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[ebikebrand.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *EbikeBrandMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, ebikebrand.FieldRemark)
}

// SetName sets the "name" field.
func (m *EbikeBrandMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EbikeBrandMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EbikeBrand entity.
// If the EbikeBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeBrandMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EbikeBrandMutation) ResetName() {
	m.name = nil
}

// SetCover sets the "cover" field.
func (m *EbikeBrandMutation) SetCover(s string) {
	m.cover = &s
}

// Cover returns the value of the "cover" field in the mutation.
func (m *EbikeBrandMutation) Cover() (r string, exists bool) {
	v := m.cover
	if v == nil {
		return
	}
	return *v, true
}

// OldCover returns the old "cover" field's value of the EbikeBrand entity.
// If the EbikeBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EbikeBrandMutation) OldCover(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCover: %w", err)
	}
	return oldValue.Cover, nil
}

// ResetCover resets all changes to the "cover" field.
func (m *EbikeBrandMutation) ResetCover() {
	m.cover = nil
}

// Where appends a list predicates to the EbikeBrandMutation builder.
func (m *EbikeBrandMutation) Where(ps ...predicate.EbikeBrand) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EbikeBrandMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EbikeBrandMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EbikeBrand, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EbikeBrandMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EbikeBrandMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EbikeBrand).
func (m *EbikeBrandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EbikeBrandMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, ebikebrand.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, ebikebrand.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, ebikebrand.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, ebikebrand.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, ebikebrand.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, ebikebrand.FieldRemark)
	}
	if m.name != nil {
		fields = append(fields, ebikebrand.FieldName)
	}
	if m.cover != nil {
		fields = append(fields, ebikebrand.FieldCover)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EbikeBrandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ebikebrand.FieldCreatedAt:
		return m.CreatedAt()
	case ebikebrand.FieldUpdatedAt:
		return m.UpdatedAt()
	case ebikebrand.FieldDeletedAt:
		return m.DeletedAt()
	case ebikebrand.FieldCreator:
		return m.Creator()
	case ebikebrand.FieldLastModifier:
		return m.LastModifier()
	case ebikebrand.FieldRemark:
		return m.Remark()
	case ebikebrand.FieldName:
		return m.Name()
	case ebikebrand.FieldCover:
		return m.Cover()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EbikeBrandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ebikebrand.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case ebikebrand.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case ebikebrand.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case ebikebrand.FieldCreator:
		return m.OldCreator(ctx)
	case ebikebrand.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case ebikebrand.FieldRemark:
		return m.OldRemark(ctx)
	case ebikebrand.FieldName:
		return m.OldName(ctx)
	case ebikebrand.FieldCover:
		return m.OldCover(ctx)
	}
	return nil, fmt.Errorf("unknown EbikeBrand field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EbikeBrandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ebikebrand.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case ebikebrand.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case ebikebrand.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case ebikebrand.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case ebikebrand.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case ebikebrand.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case ebikebrand.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ebikebrand.FieldCover:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCover(v)
		return nil
	}
	return fmt.Errorf("unknown EbikeBrand field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EbikeBrandMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EbikeBrandMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EbikeBrandMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EbikeBrand numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EbikeBrandMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ebikebrand.FieldDeletedAt) {
		fields = append(fields, ebikebrand.FieldDeletedAt)
	}
	if m.FieldCleared(ebikebrand.FieldCreator) {
		fields = append(fields, ebikebrand.FieldCreator)
	}
	if m.FieldCleared(ebikebrand.FieldLastModifier) {
		fields = append(fields, ebikebrand.FieldLastModifier)
	}
	if m.FieldCleared(ebikebrand.FieldRemark) {
		fields = append(fields, ebikebrand.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EbikeBrandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EbikeBrandMutation) ClearField(name string) error {
	switch name {
	case ebikebrand.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case ebikebrand.FieldCreator:
		m.ClearCreator()
		return nil
	case ebikebrand.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case ebikebrand.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown EbikeBrand nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EbikeBrandMutation) ResetField(name string) error {
	switch name {
	case ebikebrand.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case ebikebrand.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case ebikebrand.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case ebikebrand.FieldCreator:
		m.ResetCreator()
		return nil
	case ebikebrand.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case ebikebrand.FieldRemark:
		m.ResetRemark()
		return nil
	case ebikebrand.FieldName:
		m.ResetName()
		return nil
	case ebikebrand.FieldCover:
		m.ResetCover()
		return nil
	}
	return fmt.Errorf("unknown EbikeBrand field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EbikeBrandMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EbikeBrandMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EbikeBrandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EbikeBrandMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EbikeBrandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EbikeBrandMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EbikeBrandMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown EbikeBrand unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EbikeBrandMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown EbikeBrand edge %s", name)
}

// EmployeeMutation represents an operation that mutates the Employee nodes in the graph.
type EmployeeMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint64
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	creator            **model.Modifier
	last_modifier      **model.Modifier
	remark             *string
	sn                 *uuid.UUID
	name               *string
	phone              *string
	enable             *bool
	clearedFields      map[string]struct{}
	city               *uint64
	clearedcity        bool
	store              *uint64
	clearedstore       bool
	attendances        map[uint64]struct{}
	removedattendances map[uint64]struct{}
	clearedattendances bool
	stocks             map[uint64]struct{}
	removedstocks      map[uint64]struct{}
	clearedstocks      bool
	exchanges          map[uint64]struct{}
	removedexchanges   map[uint64]struct{}
	clearedexchanges   bool
	commissions        map[uint64]struct{}
	removedcommissions map[uint64]struct{}
	clearedcommissions bool
	assistances        map[uint64]struct{}
	removedassistances map[uint64]struct{}
	clearedassistances bool
	done               bool
	oldValue           func(context.Context) (*Employee, error)
	predicates         []predicate.Employee
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows management of the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for the Employee entity.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the ID field of the mutation.
func withEmployeeID(id uint64) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeeMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeeMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Employee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EmployeeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmployeeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmployeeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmployeeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmployeeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmployeeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EmployeeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EmployeeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EmployeeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[employee.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EmployeeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[employee.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EmployeeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, employee.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *EmployeeMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *EmployeeMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *EmployeeMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[employee.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *EmployeeMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[employee.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *EmployeeMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, employee.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *EmployeeMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *EmployeeMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *EmployeeMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[employee.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *EmployeeMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[employee.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *EmployeeMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, employee.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *EmployeeMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *EmployeeMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *EmployeeMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[employee.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *EmployeeMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[employee.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *EmployeeMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, employee.FieldRemark)
}

// SetCityID sets the "city_id" field.
func (m *EmployeeMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *EmployeeMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *EmployeeMutation) ResetCityID() {
	m.city = nil
}

// SetSn sets the "sn" field.
func (m *EmployeeMutation) SetSn(u uuid.UUID) {
	m.sn = &u
}

// Sn returns the value of the "sn" field in the mutation.
func (m *EmployeeMutation) Sn() (r uuid.UUID, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldSn(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ClearSn clears the value of the "sn" field.
func (m *EmployeeMutation) ClearSn() {
	m.sn = nil
	m.clearedFields[employee.FieldSn] = struct{}{}
}

// SnCleared returns if the "sn" field was cleared in this mutation.
func (m *EmployeeMutation) SnCleared() bool {
	_, ok := m.clearedFields[employee.FieldSn]
	return ok
}

// ResetSn resets all changes to the "sn" field.
func (m *EmployeeMutation) ResetSn() {
	m.sn = nil
	delete(m.clearedFields, employee.FieldSn)
}

// SetName sets the "name" field.
func (m *EmployeeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EmployeeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EmployeeMutation) ResetName() {
	m.name = nil
}

// SetPhone sets the "phone" field.
func (m *EmployeeMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *EmployeeMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *EmployeeMutation) ResetPhone() {
	m.phone = nil
}

// SetEnable sets the "enable" field.
func (m *EmployeeMutation) SetEnable(b bool) {
	m.enable = &b
}

// Enable returns the value of the "enable" field in the mutation.
func (m *EmployeeMutation) Enable() (r bool, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// ResetEnable resets all changes to the "enable" field.
func (m *EmployeeMutation) ResetEnable() {
	m.enable = nil
}

// ClearCity clears the "city" edge to the City entity.
func (m *EmployeeMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[employee.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *EmployeeMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *EmployeeMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// SetStoreID sets the "store" edge to the Store entity by id.
func (m *EmployeeMutation) SetStoreID(id uint64) {
	m.store = &id
}

// ClearStore clears the "store" edge to the Store entity.
func (m *EmployeeMutation) ClearStore() {
	m.clearedstore = true
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *EmployeeMutation) StoreCleared() bool {
	return m.clearedstore
}

// StoreID returns the "store" edge ID in the mutation.
func (m *EmployeeMutation) StoreID() (id uint64, exists bool) {
	if m.store != nil {
		return *m.store, true
	}
	return
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *EmployeeMutation) StoreIDs() (ids []uint64) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *EmployeeMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// AddAttendanceIDs adds the "attendances" edge to the Attendance entity by ids.
func (m *EmployeeMutation) AddAttendanceIDs(ids ...uint64) {
	if m.attendances == nil {
		m.attendances = make(map[uint64]struct{})
	}
	for i := range ids {
		m.attendances[ids[i]] = struct{}{}
	}
}

// ClearAttendances clears the "attendances" edge to the Attendance entity.
func (m *EmployeeMutation) ClearAttendances() {
	m.clearedattendances = true
}

// AttendancesCleared reports if the "attendances" edge to the Attendance entity was cleared.
func (m *EmployeeMutation) AttendancesCleared() bool {
	return m.clearedattendances
}

// RemoveAttendanceIDs removes the "attendances" edge to the Attendance entity by IDs.
func (m *EmployeeMutation) RemoveAttendanceIDs(ids ...uint64) {
	if m.removedattendances == nil {
		m.removedattendances = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.attendances, ids[i])
		m.removedattendances[ids[i]] = struct{}{}
	}
}

// RemovedAttendances returns the removed IDs of the "attendances" edge to the Attendance entity.
func (m *EmployeeMutation) RemovedAttendancesIDs() (ids []uint64) {
	for id := range m.removedattendances {
		ids = append(ids, id)
	}
	return
}

// AttendancesIDs returns the "attendances" edge IDs in the mutation.
func (m *EmployeeMutation) AttendancesIDs() (ids []uint64) {
	for id := range m.attendances {
		ids = append(ids, id)
	}
	return
}

// ResetAttendances resets all changes to the "attendances" edge.
func (m *EmployeeMutation) ResetAttendances() {
	m.attendances = nil
	m.clearedattendances = false
	m.removedattendances = nil
}

// AddStockIDs adds the "stocks" edge to the Stock entity by ids.
func (m *EmployeeMutation) AddStockIDs(ids ...uint64) {
	if m.stocks == nil {
		m.stocks = make(map[uint64]struct{})
	}
	for i := range ids {
		m.stocks[ids[i]] = struct{}{}
	}
}

// ClearStocks clears the "stocks" edge to the Stock entity.
func (m *EmployeeMutation) ClearStocks() {
	m.clearedstocks = true
}

// StocksCleared reports if the "stocks" edge to the Stock entity was cleared.
func (m *EmployeeMutation) StocksCleared() bool {
	return m.clearedstocks
}

// RemoveStockIDs removes the "stocks" edge to the Stock entity by IDs.
func (m *EmployeeMutation) RemoveStockIDs(ids ...uint64) {
	if m.removedstocks == nil {
		m.removedstocks = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.stocks, ids[i])
		m.removedstocks[ids[i]] = struct{}{}
	}
}

// RemovedStocks returns the removed IDs of the "stocks" edge to the Stock entity.
func (m *EmployeeMutation) RemovedStocksIDs() (ids []uint64) {
	for id := range m.removedstocks {
		ids = append(ids, id)
	}
	return
}

// StocksIDs returns the "stocks" edge IDs in the mutation.
func (m *EmployeeMutation) StocksIDs() (ids []uint64) {
	for id := range m.stocks {
		ids = append(ids, id)
	}
	return
}

// ResetStocks resets all changes to the "stocks" edge.
func (m *EmployeeMutation) ResetStocks() {
	m.stocks = nil
	m.clearedstocks = false
	m.removedstocks = nil
}

// AddExchangeIDs adds the "exchanges" edge to the Exchange entity by ids.
func (m *EmployeeMutation) AddExchangeIDs(ids ...uint64) {
	if m.exchanges == nil {
		m.exchanges = make(map[uint64]struct{})
	}
	for i := range ids {
		m.exchanges[ids[i]] = struct{}{}
	}
}

// ClearExchanges clears the "exchanges" edge to the Exchange entity.
func (m *EmployeeMutation) ClearExchanges() {
	m.clearedexchanges = true
}

// ExchangesCleared reports if the "exchanges" edge to the Exchange entity was cleared.
func (m *EmployeeMutation) ExchangesCleared() bool {
	return m.clearedexchanges
}

// RemoveExchangeIDs removes the "exchanges" edge to the Exchange entity by IDs.
func (m *EmployeeMutation) RemoveExchangeIDs(ids ...uint64) {
	if m.removedexchanges == nil {
		m.removedexchanges = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.exchanges, ids[i])
		m.removedexchanges[ids[i]] = struct{}{}
	}
}

// RemovedExchanges returns the removed IDs of the "exchanges" edge to the Exchange entity.
func (m *EmployeeMutation) RemovedExchangesIDs() (ids []uint64) {
	for id := range m.removedexchanges {
		ids = append(ids, id)
	}
	return
}

// ExchangesIDs returns the "exchanges" edge IDs in the mutation.
func (m *EmployeeMutation) ExchangesIDs() (ids []uint64) {
	for id := range m.exchanges {
		ids = append(ids, id)
	}
	return
}

// ResetExchanges resets all changes to the "exchanges" edge.
func (m *EmployeeMutation) ResetExchanges() {
	m.exchanges = nil
	m.clearedexchanges = false
	m.removedexchanges = nil
}

// AddCommissionIDs adds the "commissions" edge to the Commission entity by ids.
func (m *EmployeeMutation) AddCommissionIDs(ids ...uint64) {
	if m.commissions == nil {
		m.commissions = make(map[uint64]struct{})
	}
	for i := range ids {
		m.commissions[ids[i]] = struct{}{}
	}
}

// ClearCommissions clears the "commissions" edge to the Commission entity.
func (m *EmployeeMutation) ClearCommissions() {
	m.clearedcommissions = true
}

// CommissionsCleared reports if the "commissions" edge to the Commission entity was cleared.
func (m *EmployeeMutation) CommissionsCleared() bool {
	return m.clearedcommissions
}

// RemoveCommissionIDs removes the "commissions" edge to the Commission entity by IDs.
func (m *EmployeeMutation) RemoveCommissionIDs(ids ...uint64) {
	if m.removedcommissions == nil {
		m.removedcommissions = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.commissions, ids[i])
		m.removedcommissions[ids[i]] = struct{}{}
	}
}

// RemovedCommissions returns the removed IDs of the "commissions" edge to the Commission entity.
func (m *EmployeeMutation) RemovedCommissionsIDs() (ids []uint64) {
	for id := range m.removedcommissions {
		ids = append(ids, id)
	}
	return
}

// CommissionsIDs returns the "commissions" edge IDs in the mutation.
func (m *EmployeeMutation) CommissionsIDs() (ids []uint64) {
	for id := range m.commissions {
		ids = append(ids, id)
	}
	return
}

// ResetCommissions resets all changes to the "commissions" edge.
func (m *EmployeeMutation) ResetCommissions() {
	m.commissions = nil
	m.clearedcommissions = false
	m.removedcommissions = nil
}

// AddAssistanceIDs adds the "assistances" edge to the Assistance entity by ids.
func (m *EmployeeMutation) AddAssistanceIDs(ids ...uint64) {
	if m.assistances == nil {
		m.assistances = make(map[uint64]struct{})
	}
	for i := range ids {
		m.assistances[ids[i]] = struct{}{}
	}
}

// ClearAssistances clears the "assistances" edge to the Assistance entity.
func (m *EmployeeMutation) ClearAssistances() {
	m.clearedassistances = true
}

// AssistancesCleared reports if the "assistances" edge to the Assistance entity was cleared.
func (m *EmployeeMutation) AssistancesCleared() bool {
	return m.clearedassistances
}

// RemoveAssistanceIDs removes the "assistances" edge to the Assistance entity by IDs.
func (m *EmployeeMutation) RemoveAssistanceIDs(ids ...uint64) {
	if m.removedassistances == nil {
		m.removedassistances = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.assistances, ids[i])
		m.removedassistances[ids[i]] = struct{}{}
	}
}

// RemovedAssistances returns the removed IDs of the "assistances" edge to the Assistance entity.
func (m *EmployeeMutation) RemovedAssistancesIDs() (ids []uint64) {
	for id := range m.removedassistances {
		ids = append(ids, id)
	}
	return
}

// AssistancesIDs returns the "assistances" edge IDs in the mutation.
func (m *EmployeeMutation) AssistancesIDs() (ids []uint64) {
	for id := range m.assistances {
		ids = append(ids, id)
	}
	return
}

// ResetAssistances resets all changes to the "assistances" edge.
func (m *EmployeeMutation) ResetAssistances() {
	m.assistances = nil
	m.clearedassistances = false
	m.removedassistances = nil
}

// Where appends a list predicates to the EmployeeMutation builder.
func (m *EmployeeMutation) Where(ps ...predicate.Employee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Employee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, employee.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, employee.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, employee.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, employee.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, employee.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, employee.FieldRemark)
	}
	if m.city != nil {
		fields = append(fields, employee.FieldCityID)
	}
	if m.sn != nil {
		fields = append(fields, employee.FieldSn)
	}
	if m.name != nil {
		fields = append(fields, employee.FieldName)
	}
	if m.phone != nil {
		fields = append(fields, employee.FieldPhone)
	}
	if m.enable != nil {
		fields = append(fields, employee.FieldEnable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldCreatedAt:
		return m.CreatedAt()
	case employee.FieldUpdatedAt:
		return m.UpdatedAt()
	case employee.FieldDeletedAt:
		return m.DeletedAt()
	case employee.FieldCreator:
		return m.Creator()
	case employee.FieldLastModifier:
		return m.LastModifier()
	case employee.FieldRemark:
		return m.Remark()
	case employee.FieldCityID:
		return m.CityID()
	case employee.FieldSn:
		return m.Sn()
	case employee.FieldName:
		return m.Name()
	case employee.FieldPhone:
		return m.Phone()
	case employee.FieldEnable:
		return m.Enable()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case employee.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case employee.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case employee.FieldCreator:
		return m.OldCreator(ctx)
	case employee.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case employee.FieldRemark:
		return m.OldRemark(ctx)
	case employee.FieldCityID:
		return m.OldCityID(ctx)
	case employee.FieldSn:
		return m.OldSn(ctx)
	case employee.FieldName:
		return m.OldName(ctx)
	case employee.FieldPhone:
		return m.OldPhone(ctx)
	case employee.FieldEnable:
		return m.OldEnable(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case employee.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case employee.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case employee.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case employee.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case employee.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case employee.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case employee.FieldSn:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case employee.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case employee.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case employee.FieldEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(employee.FieldDeletedAt) {
		fields = append(fields, employee.FieldDeletedAt)
	}
	if m.FieldCleared(employee.FieldCreator) {
		fields = append(fields, employee.FieldCreator)
	}
	if m.FieldCleared(employee.FieldLastModifier) {
		fields = append(fields, employee.FieldLastModifier)
	}
	if m.FieldCleared(employee.FieldRemark) {
		fields = append(fields, employee.FieldRemark)
	}
	if m.FieldCleared(employee.FieldSn) {
		fields = append(fields, employee.FieldSn)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	switch name {
	case employee.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case employee.FieldCreator:
		m.ClearCreator()
		return nil
	case employee.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case employee.FieldRemark:
		m.ClearRemark()
		return nil
	case employee.FieldSn:
		m.ClearSn()
		return nil
	}
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case employee.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case employee.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case employee.FieldCreator:
		m.ResetCreator()
		return nil
	case employee.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case employee.FieldRemark:
		m.ResetRemark()
		return nil
	case employee.FieldCityID:
		m.ResetCityID()
		return nil
	case employee.FieldSn:
		m.ResetSn()
		return nil
	case employee.FieldName:
		m.ResetName()
		return nil
	case employee.FieldPhone:
		m.ResetPhone()
		return nil
	case employee.FieldEnable:
		m.ResetEnable()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.city != nil {
		edges = append(edges, employee.EdgeCity)
	}
	if m.store != nil {
		edges = append(edges, employee.EdgeStore)
	}
	if m.attendances != nil {
		edges = append(edges, employee.EdgeAttendances)
	}
	if m.stocks != nil {
		edges = append(edges, employee.EdgeStocks)
	}
	if m.exchanges != nil {
		edges = append(edges, employee.EdgeExchanges)
	}
	if m.commissions != nil {
		edges = append(edges, employee.EdgeCommissions)
	}
	if m.assistances != nil {
		edges = append(edges, employee.EdgeAssistances)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	case employee.EdgeAttendances:
		ids := make([]ent.Value, 0, len(m.attendances))
		for id := range m.attendances {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.stocks))
		for id := range m.stocks {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeExchanges:
		ids := make([]ent.Value, 0, len(m.exchanges))
		for id := range m.exchanges {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeCommissions:
		ids := make([]ent.Value, 0, len(m.commissions))
		for id := range m.commissions {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeAssistances:
		ids := make([]ent.Value, 0, len(m.assistances))
		for id := range m.assistances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedattendances != nil {
		edges = append(edges, employee.EdgeAttendances)
	}
	if m.removedstocks != nil {
		edges = append(edges, employee.EdgeStocks)
	}
	if m.removedexchanges != nil {
		edges = append(edges, employee.EdgeExchanges)
	}
	if m.removedcommissions != nil {
		edges = append(edges, employee.EdgeCommissions)
	}
	if m.removedassistances != nil {
		edges = append(edges, employee.EdgeAssistances)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeAttendances:
		ids := make([]ent.Value, 0, len(m.removedattendances))
		for id := range m.removedattendances {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.removedstocks))
		for id := range m.removedstocks {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeExchanges:
		ids := make([]ent.Value, 0, len(m.removedexchanges))
		for id := range m.removedexchanges {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeCommissions:
		ids := make([]ent.Value, 0, len(m.removedcommissions))
		for id := range m.removedcommissions {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeAssistances:
		ids := make([]ent.Value, 0, len(m.removedassistances))
		for id := range m.removedassistances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedcity {
		edges = append(edges, employee.EdgeCity)
	}
	if m.clearedstore {
		edges = append(edges, employee.EdgeStore)
	}
	if m.clearedattendances {
		edges = append(edges, employee.EdgeAttendances)
	}
	if m.clearedstocks {
		edges = append(edges, employee.EdgeStocks)
	}
	if m.clearedexchanges {
		edges = append(edges, employee.EdgeExchanges)
	}
	if m.clearedcommissions {
		edges = append(edges, employee.EdgeCommissions)
	}
	if m.clearedassistances {
		edges = append(edges, employee.EdgeAssistances)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	case employee.EdgeCity:
		return m.clearedcity
	case employee.EdgeStore:
		return m.clearedstore
	case employee.EdgeAttendances:
		return m.clearedattendances
	case employee.EdgeStocks:
		return m.clearedstocks
	case employee.EdgeExchanges:
		return m.clearedexchanges
	case employee.EdgeCommissions:
		return m.clearedcommissions
	case employee.EdgeAssistances:
		return m.clearedassistances
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	case employee.EdgeCity:
		m.ClearCity()
		return nil
	case employee.EdgeStore:
		m.ClearStore()
		return nil
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeCity:
		m.ResetCity()
		return nil
	case employee.EdgeStore:
		m.ResetStore()
		return nil
	case employee.EdgeAttendances:
		m.ResetAttendances()
		return nil
	case employee.EdgeStocks:
		m.ResetStocks()
		return nil
	case employee.EdgeExchanges:
		m.ResetExchanges()
		return nil
	case employee.EdgeCommissions:
		m.ResetCommissions()
		return nil
	case employee.EdgeAssistances:
		m.ResetAssistances()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// EnterpriseMutation represents an operation that mutates the Enterprise nodes in the graph.
type EnterpriseMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uint64
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	creator                      **model.Modifier
	last_modifier                **model.Modifier
	remark                       *string
	name                         *string
	company_name                 *string
	status                       *uint8
	addstatus                    *int8
	contact_name                 *string
	contact_phone                *string
	idcard_number                *string
	address                      *string
	payment                      *uint8
	addpayment                   *int8
	deposit                      *float64
	adddeposit                   *float64
	balance                      *float64
	addbalance                   *float64
	prepayment_total             *float64
	addprepayment_total          *float64
	suspensed_at                 *time.Time
	agent                        *bool
	use_store                    *bool
	days                         *[]int
	appenddays                   []int
	distance                     *float64
	adddistance                  *float64
	recharge_amount              *[]int
	appendrecharge_amount        []int
	sign_type                    *model.EnterpriseSignType
	clearedFields                map[string]struct{}
	city                         *uint64
	clearedcity                  bool
	riders                       map[uint64]struct{}
	removedriders                map[uint64]struct{}
	clearedriders                bool
	contracts                    map[uint64]struct{}
	removedcontracts             map[uint64]struct{}
	clearedcontracts             bool
	prices                       map[uint64]struct{}
	removedprices                map[uint64]struct{}
	clearedprices                bool
	subscribes                   map[uint64]struct{}
	removedsubscribes            map[uint64]struct{}
	clearedsubscribes            bool
	statements                   map[uint64]struct{}
	removedstatements            map[uint64]struct{}
	clearedstatements            bool
	stations                     map[uint64]struct{}
	removedstations              map[uint64]struct{}
	clearedstations              bool
	bills                        map[uint64]struct{}
	removedbills                 map[uint64]struct{}
	clearedbills                 bool
	batteries                    map[uint64]struct{}
	removedbatteries             map[uint64]struct{}
	clearedbatteries             bool
	agents                       map[uint64]struct{}
	removedagents                map[uint64]struct{}
	clearedagents                bool
	cabinets                     map[uint64]struct{}
	removedcabinets              map[uint64]struct{}
	clearedcabinets              bool
	stocks                       map[uint64]struct{}
	removedstocks                map[uint64]struct{}
	clearedstocks                bool
	swap_putin_batteries         map[uint64]struct{}
	removedswap_putin_batteries  map[uint64]struct{}
	clearedswap_putin_batteries  bool
	swap_putout_batteries        map[uint64]struct{}
	removedswap_putout_batteries map[uint64]struct{}
	clearedswap_putout_batteries bool
	done                         bool
	oldValue                     func(context.Context) (*Enterprise, error)
	predicates                   []predicate.Enterprise
}

var _ ent.Mutation = (*EnterpriseMutation)(nil)

// enterpriseOption allows management of the mutation configuration using functional options.
type enterpriseOption func(*EnterpriseMutation)

// newEnterpriseMutation creates new mutation for the Enterprise entity.
func newEnterpriseMutation(c config, op Op, opts ...enterpriseOption) *EnterpriseMutation {
	m := &EnterpriseMutation{
		config:        c,
		op:            op,
		typ:           TypeEnterprise,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnterpriseID sets the ID field of the mutation.
func withEnterpriseID(id uint64) enterpriseOption {
	return func(m *EnterpriseMutation) {
		var (
			err   error
			once  sync.Once
			value *Enterprise
		)
		m.oldValue = func(ctx context.Context) (*Enterprise, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Enterprise.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnterprise sets the old Enterprise of the mutation.
func withEnterprise(node *Enterprise) enterpriseOption {
	return func(m *EnterpriseMutation) {
		m.oldValue = func(context.Context) (*Enterprise, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnterpriseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnterpriseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnterpriseMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnterpriseMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Enterprise.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EnterpriseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnterpriseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnterpriseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnterpriseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnterpriseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnterpriseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EnterpriseMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EnterpriseMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EnterpriseMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[enterprise.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EnterpriseMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[enterprise.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EnterpriseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, enterprise.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *EnterpriseMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *EnterpriseMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *EnterpriseMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[enterprise.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *EnterpriseMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[enterprise.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *EnterpriseMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, enterprise.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *EnterpriseMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *EnterpriseMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *EnterpriseMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[enterprise.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *EnterpriseMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[enterprise.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *EnterpriseMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, enterprise.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *EnterpriseMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *EnterpriseMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *EnterpriseMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[enterprise.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *EnterpriseMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[enterprise.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *EnterpriseMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, enterprise.FieldRemark)
}

// SetCityID sets the "city_id" field.
func (m *EnterpriseMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *EnterpriseMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *EnterpriseMutation) ResetCityID() {
	m.city = nil
}

// SetName sets the "name" field.
func (m *EnterpriseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EnterpriseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EnterpriseMutation) ResetName() {
	m.name = nil
}

// SetCompanyName sets the "company_name" field.
func (m *EnterpriseMutation) SetCompanyName(s string) {
	m.company_name = &s
}

// CompanyName returns the value of the "company_name" field in the mutation.
func (m *EnterpriseMutation) CompanyName() (r string, exists bool) {
	v := m.company_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyName returns the old "company_name" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldCompanyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyName: %w", err)
	}
	return oldValue.CompanyName, nil
}

// ClearCompanyName clears the value of the "company_name" field.
func (m *EnterpriseMutation) ClearCompanyName() {
	m.company_name = nil
	m.clearedFields[enterprise.FieldCompanyName] = struct{}{}
}

// CompanyNameCleared returns if the "company_name" field was cleared in this mutation.
func (m *EnterpriseMutation) CompanyNameCleared() bool {
	_, ok := m.clearedFields[enterprise.FieldCompanyName]
	return ok
}

// ResetCompanyName resets all changes to the "company_name" field.
func (m *EnterpriseMutation) ResetCompanyName() {
	m.company_name = nil
	delete(m.clearedFields, enterprise.FieldCompanyName)
}

// SetStatus sets the "status" field.
func (m *EnterpriseMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *EnterpriseMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *EnterpriseMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *EnterpriseMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *EnterpriseMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetContactName sets the "contact_name" field.
func (m *EnterpriseMutation) SetContactName(s string) {
	m.contact_name = &s
}

// ContactName returns the value of the "contact_name" field in the mutation.
func (m *EnterpriseMutation) ContactName() (r string, exists bool) {
	v := m.contact_name
	if v == nil {
		return
	}
	return *v, true
}

// OldContactName returns the old "contact_name" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldContactName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactName: %w", err)
	}
	return oldValue.ContactName, nil
}

// ResetContactName resets all changes to the "contact_name" field.
func (m *EnterpriseMutation) ResetContactName() {
	m.contact_name = nil
}

// SetContactPhone sets the "contact_phone" field.
func (m *EnterpriseMutation) SetContactPhone(s string) {
	m.contact_phone = &s
}

// ContactPhone returns the value of the "contact_phone" field in the mutation.
func (m *EnterpriseMutation) ContactPhone() (r string, exists bool) {
	v := m.contact_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPhone returns the old "contact_phone" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldContactPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPhone: %w", err)
	}
	return oldValue.ContactPhone, nil
}

// ResetContactPhone resets all changes to the "contact_phone" field.
func (m *EnterpriseMutation) ResetContactPhone() {
	m.contact_phone = nil
}

// SetIdcardNumber sets the "idcard_number" field.
func (m *EnterpriseMutation) SetIdcardNumber(s string) {
	m.idcard_number = &s
}

// IdcardNumber returns the value of the "idcard_number" field in the mutation.
func (m *EnterpriseMutation) IdcardNumber() (r string, exists bool) {
	v := m.idcard_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIdcardNumber returns the old "idcard_number" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldIdcardNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdcardNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdcardNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdcardNumber: %w", err)
	}
	return oldValue.IdcardNumber, nil
}

// ResetIdcardNumber resets all changes to the "idcard_number" field.
func (m *EnterpriseMutation) ResetIdcardNumber() {
	m.idcard_number = nil
}

// SetAddress sets the "address" field.
func (m *EnterpriseMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *EnterpriseMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *EnterpriseMutation) ResetAddress() {
	m.address = nil
}

// SetPayment sets the "payment" field.
func (m *EnterpriseMutation) SetPayment(u uint8) {
	m.payment = &u
	m.addpayment = nil
}

// Payment returns the value of the "payment" field in the mutation.
func (m *EnterpriseMutation) Payment() (r uint8, exists bool) {
	v := m.payment
	if v == nil {
		return
	}
	return *v, true
}

// OldPayment returns the old "payment" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldPayment(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayment: %w", err)
	}
	return oldValue.Payment, nil
}

// AddPayment adds u to the "payment" field.
func (m *EnterpriseMutation) AddPayment(u int8) {
	if m.addpayment != nil {
		*m.addpayment += u
	} else {
		m.addpayment = &u
	}
}

// AddedPayment returns the value that was added to the "payment" field in this mutation.
func (m *EnterpriseMutation) AddedPayment() (r int8, exists bool) {
	v := m.addpayment
	if v == nil {
		return
	}
	return *v, true
}

// ResetPayment resets all changes to the "payment" field.
func (m *EnterpriseMutation) ResetPayment() {
	m.payment = nil
	m.addpayment = nil
}

// SetDeposit sets the "deposit" field.
func (m *EnterpriseMutation) SetDeposit(f float64) {
	m.deposit = &f
	m.adddeposit = nil
}

// Deposit returns the value of the "deposit" field in the mutation.
func (m *EnterpriseMutation) Deposit() (r float64, exists bool) {
	v := m.deposit
	if v == nil {
		return
	}
	return *v, true
}

// OldDeposit returns the old "deposit" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldDeposit(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeposit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeposit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeposit: %w", err)
	}
	return oldValue.Deposit, nil
}

// AddDeposit adds f to the "deposit" field.
func (m *EnterpriseMutation) AddDeposit(f float64) {
	if m.adddeposit != nil {
		*m.adddeposit += f
	} else {
		m.adddeposit = &f
	}
}

// AddedDeposit returns the value that was added to the "deposit" field in this mutation.
func (m *EnterpriseMutation) AddedDeposit() (r float64, exists bool) {
	v := m.adddeposit
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeposit resets all changes to the "deposit" field.
func (m *EnterpriseMutation) ResetDeposit() {
	m.deposit = nil
	m.adddeposit = nil
}

// SetBalance sets the "balance" field.
func (m *EnterpriseMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *EnterpriseMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *EnterpriseMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *EnterpriseMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *EnterpriseMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetPrepaymentTotal sets the "prepayment_total" field.
func (m *EnterpriseMutation) SetPrepaymentTotal(f float64) {
	m.prepayment_total = &f
	m.addprepayment_total = nil
}

// PrepaymentTotal returns the value of the "prepayment_total" field in the mutation.
func (m *EnterpriseMutation) PrepaymentTotal() (r float64, exists bool) {
	v := m.prepayment_total
	if v == nil {
		return
	}
	return *v, true
}

// OldPrepaymentTotal returns the old "prepayment_total" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldPrepaymentTotal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrepaymentTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrepaymentTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrepaymentTotal: %w", err)
	}
	return oldValue.PrepaymentTotal, nil
}

// AddPrepaymentTotal adds f to the "prepayment_total" field.
func (m *EnterpriseMutation) AddPrepaymentTotal(f float64) {
	if m.addprepayment_total != nil {
		*m.addprepayment_total += f
	} else {
		m.addprepayment_total = &f
	}
}

// AddedPrepaymentTotal returns the value that was added to the "prepayment_total" field in this mutation.
func (m *EnterpriseMutation) AddedPrepaymentTotal() (r float64, exists bool) {
	v := m.addprepayment_total
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrepaymentTotal resets all changes to the "prepayment_total" field.
func (m *EnterpriseMutation) ResetPrepaymentTotal() {
	m.prepayment_total = nil
	m.addprepayment_total = nil
}

// SetSuspensedAt sets the "suspensed_at" field.
func (m *EnterpriseMutation) SetSuspensedAt(t time.Time) {
	m.suspensed_at = &t
}

// SuspensedAt returns the value of the "suspensed_at" field in the mutation.
func (m *EnterpriseMutation) SuspensedAt() (r time.Time, exists bool) {
	v := m.suspensed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSuspensedAt returns the old "suspensed_at" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldSuspensedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuspensedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuspensedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuspensedAt: %w", err)
	}
	return oldValue.SuspensedAt, nil
}

// ClearSuspensedAt clears the value of the "suspensed_at" field.
func (m *EnterpriseMutation) ClearSuspensedAt() {
	m.suspensed_at = nil
	m.clearedFields[enterprise.FieldSuspensedAt] = struct{}{}
}

// SuspensedAtCleared returns if the "suspensed_at" field was cleared in this mutation.
func (m *EnterpriseMutation) SuspensedAtCleared() bool {
	_, ok := m.clearedFields[enterprise.FieldSuspensedAt]
	return ok
}

// ResetSuspensedAt resets all changes to the "suspensed_at" field.
func (m *EnterpriseMutation) ResetSuspensedAt() {
	m.suspensed_at = nil
	delete(m.clearedFields, enterprise.FieldSuspensedAt)
}

// SetAgent sets the "agent" field.
func (m *EnterpriseMutation) SetAgent(b bool) {
	m.agent = &b
}

// Agent returns the value of the "agent" field in the mutation.
func (m *EnterpriseMutation) Agent() (r bool, exists bool) {
	v := m.agent
	if v == nil {
		return
	}
	return *v, true
}

// OldAgent returns the old "agent" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldAgent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgent: %w", err)
	}
	return oldValue.Agent, nil
}

// ResetAgent resets all changes to the "agent" field.
func (m *EnterpriseMutation) ResetAgent() {
	m.agent = nil
}

// SetUseStore sets the "use_store" field.
func (m *EnterpriseMutation) SetUseStore(b bool) {
	m.use_store = &b
}

// UseStore returns the value of the "use_store" field in the mutation.
func (m *EnterpriseMutation) UseStore() (r bool, exists bool) {
	v := m.use_store
	if v == nil {
		return
	}
	return *v, true
}

// OldUseStore returns the old "use_store" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldUseStore(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseStore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseStore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseStore: %w", err)
	}
	return oldValue.UseStore, nil
}

// ClearUseStore clears the value of the "use_store" field.
func (m *EnterpriseMutation) ClearUseStore() {
	m.use_store = nil
	m.clearedFields[enterprise.FieldUseStore] = struct{}{}
}

// UseStoreCleared returns if the "use_store" field was cleared in this mutation.
func (m *EnterpriseMutation) UseStoreCleared() bool {
	_, ok := m.clearedFields[enterprise.FieldUseStore]
	return ok
}

// ResetUseStore resets all changes to the "use_store" field.
func (m *EnterpriseMutation) ResetUseStore() {
	m.use_store = nil
	delete(m.clearedFields, enterprise.FieldUseStore)
}

// SetDays sets the "days" field.
func (m *EnterpriseMutation) SetDays(i []int) {
	m.days = &i
	m.appenddays = nil
}

// Days returns the value of the "days" field in the mutation.
func (m *EnterpriseMutation) Days() (r []int, exists bool) {
	v := m.days
	if v == nil {
		return
	}
	return *v, true
}

// OldDays returns the old "days" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldDays(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDays: %w", err)
	}
	return oldValue.Days, nil
}

// AppendDays adds i to the "days" field.
func (m *EnterpriseMutation) AppendDays(i []int) {
	m.appenddays = append(m.appenddays, i...)
}

// AppendedDays returns the list of values that were appended to the "days" field in this mutation.
func (m *EnterpriseMutation) AppendedDays() ([]int, bool) {
	if len(m.appenddays) == 0 {
		return nil, false
	}
	return m.appenddays, true
}

// ClearDays clears the value of the "days" field.
func (m *EnterpriseMutation) ClearDays() {
	m.days = nil
	m.appenddays = nil
	m.clearedFields[enterprise.FieldDays] = struct{}{}
}

// DaysCleared returns if the "days" field was cleared in this mutation.
func (m *EnterpriseMutation) DaysCleared() bool {
	_, ok := m.clearedFields[enterprise.FieldDays]
	return ok
}

// ResetDays resets all changes to the "days" field.
func (m *EnterpriseMutation) ResetDays() {
	m.days = nil
	m.appenddays = nil
	delete(m.clearedFields, enterprise.FieldDays)
}

// SetDistance sets the "distance" field.
func (m *EnterpriseMutation) SetDistance(f float64) {
	m.distance = &f
	m.adddistance = nil
}

// Distance returns the value of the "distance" field in the mutation.
func (m *EnterpriseMutation) Distance() (r float64, exists bool) {
	v := m.distance
	if v == nil {
		return
	}
	return *v, true
}

// OldDistance returns the old "distance" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldDistance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDistance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDistance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistance: %w", err)
	}
	return oldValue.Distance, nil
}

// AddDistance adds f to the "distance" field.
func (m *EnterpriseMutation) AddDistance(f float64) {
	if m.adddistance != nil {
		*m.adddistance += f
	} else {
		m.adddistance = &f
	}
}

// AddedDistance returns the value that was added to the "distance" field in this mutation.
func (m *EnterpriseMutation) AddedDistance() (r float64, exists bool) {
	v := m.adddistance
	if v == nil {
		return
	}
	return *v, true
}

// ResetDistance resets all changes to the "distance" field.
func (m *EnterpriseMutation) ResetDistance() {
	m.distance = nil
	m.adddistance = nil
}

// SetRechargeAmount sets the "recharge_amount" field.
func (m *EnterpriseMutation) SetRechargeAmount(i []int) {
	m.recharge_amount = &i
	m.appendrecharge_amount = nil
}

// RechargeAmount returns the value of the "recharge_amount" field in the mutation.
func (m *EnterpriseMutation) RechargeAmount() (r []int, exists bool) {
	v := m.recharge_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldRechargeAmount returns the old "recharge_amount" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldRechargeAmount(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRechargeAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRechargeAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRechargeAmount: %w", err)
	}
	return oldValue.RechargeAmount, nil
}

// AppendRechargeAmount adds i to the "recharge_amount" field.
func (m *EnterpriseMutation) AppendRechargeAmount(i []int) {
	m.appendrecharge_amount = append(m.appendrecharge_amount, i...)
}

// AppendedRechargeAmount returns the list of values that were appended to the "recharge_amount" field in this mutation.
func (m *EnterpriseMutation) AppendedRechargeAmount() ([]int, bool) {
	if len(m.appendrecharge_amount) == 0 {
		return nil, false
	}
	return m.appendrecharge_amount, true
}

// ClearRechargeAmount clears the value of the "recharge_amount" field.
func (m *EnterpriseMutation) ClearRechargeAmount() {
	m.recharge_amount = nil
	m.appendrecharge_amount = nil
	m.clearedFields[enterprise.FieldRechargeAmount] = struct{}{}
}

// RechargeAmountCleared returns if the "recharge_amount" field was cleared in this mutation.
func (m *EnterpriseMutation) RechargeAmountCleared() bool {
	_, ok := m.clearedFields[enterprise.FieldRechargeAmount]
	return ok
}

// ResetRechargeAmount resets all changes to the "recharge_amount" field.
func (m *EnterpriseMutation) ResetRechargeAmount() {
	m.recharge_amount = nil
	m.appendrecharge_amount = nil
	delete(m.clearedFields, enterprise.FieldRechargeAmount)
}

// SetSignType sets the "sign_type" field.
func (m *EnterpriseMutation) SetSignType(mst model.EnterpriseSignType) {
	m.sign_type = &mst
}

// SignType returns the value of the "sign_type" field in the mutation.
func (m *EnterpriseMutation) SignType() (r model.EnterpriseSignType, exists bool) {
	v := m.sign_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSignType returns the old "sign_type" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldSignType(ctx context.Context) (v model.EnterpriseSignType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignType: %w", err)
	}
	return oldValue.SignType, nil
}

// ClearSignType clears the value of the "sign_type" field.
func (m *EnterpriseMutation) ClearSignType() {
	m.sign_type = nil
	m.clearedFields[enterprise.FieldSignType] = struct{}{}
}

// SignTypeCleared returns if the "sign_type" field was cleared in this mutation.
func (m *EnterpriseMutation) SignTypeCleared() bool {
	_, ok := m.clearedFields[enterprise.FieldSignType]
	return ok
}

// ResetSignType resets all changes to the "sign_type" field.
func (m *EnterpriseMutation) ResetSignType() {
	m.sign_type = nil
	delete(m.clearedFields, enterprise.FieldSignType)
}

// ClearCity clears the "city" edge to the City entity.
func (m *EnterpriseMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[enterprise.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *EnterpriseMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *EnterpriseMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *EnterpriseMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// AddRiderIDs adds the "riders" edge to the Rider entity by ids.
func (m *EnterpriseMutation) AddRiderIDs(ids ...uint64) {
	if m.riders == nil {
		m.riders = make(map[uint64]struct{})
	}
	for i := range ids {
		m.riders[ids[i]] = struct{}{}
	}
}

// ClearRiders clears the "riders" edge to the Rider entity.
func (m *EnterpriseMutation) ClearRiders() {
	m.clearedriders = true
}

// RidersCleared reports if the "riders" edge to the Rider entity was cleared.
func (m *EnterpriseMutation) RidersCleared() bool {
	return m.clearedriders
}

// RemoveRiderIDs removes the "riders" edge to the Rider entity by IDs.
func (m *EnterpriseMutation) RemoveRiderIDs(ids ...uint64) {
	if m.removedriders == nil {
		m.removedriders = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.riders, ids[i])
		m.removedriders[ids[i]] = struct{}{}
	}
}

// RemovedRiders returns the removed IDs of the "riders" edge to the Rider entity.
func (m *EnterpriseMutation) RemovedRidersIDs() (ids []uint64) {
	for id := range m.removedriders {
		ids = append(ids, id)
	}
	return
}

// RidersIDs returns the "riders" edge IDs in the mutation.
func (m *EnterpriseMutation) RidersIDs() (ids []uint64) {
	for id := range m.riders {
		ids = append(ids, id)
	}
	return
}

// ResetRiders resets all changes to the "riders" edge.
func (m *EnterpriseMutation) ResetRiders() {
	m.riders = nil
	m.clearedriders = false
	m.removedriders = nil
}

// AddContractIDs adds the "contracts" edge to the EnterpriseContract entity by ids.
func (m *EnterpriseMutation) AddContractIDs(ids ...uint64) {
	if m.contracts == nil {
		m.contracts = make(map[uint64]struct{})
	}
	for i := range ids {
		m.contracts[ids[i]] = struct{}{}
	}
}

// ClearContracts clears the "contracts" edge to the EnterpriseContract entity.
func (m *EnterpriseMutation) ClearContracts() {
	m.clearedcontracts = true
}

// ContractsCleared reports if the "contracts" edge to the EnterpriseContract entity was cleared.
func (m *EnterpriseMutation) ContractsCleared() bool {
	return m.clearedcontracts
}

// RemoveContractIDs removes the "contracts" edge to the EnterpriseContract entity by IDs.
func (m *EnterpriseMutation) RemoveContractIDs(ids ...uint64) {
	if m.removedcontracts == nil {
		m.removedcontracts = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.contracts, ids[i])
		m.removedcontracts[ids[i]] = struct{}{}
	}
}

// RemovedContracts returns the removed IDs of the "contracts" edge to the EnterpriseContract entity.
func (m *EnterpriseMutation) RemovedContractsIDs() (ids []uint64) {
	for id := range m.removedcontracts {
		ids = append(ids, id)
	}
	return
}

// ContractsIDs returns the "contracts" edge IDs in the mutation.
func (m *EnterpriseMutation) ContractsIDs() (ids []uint64) {
	for id := range m.contracts {
		ids = append(ids, id)
	}
	return
}

// ResetContracts resets all changes to the "contracts" edge.
func (m *EnterpriseMutation) ResetContracts() {
	m.contracts = nil
	m.clearedcontracts = false
	m.removedcontracts = nil
}

// AddPriceIDs adds the "prices" edge to the EnterprisePrice entity by ids.
func (m *EnterpriseMutation) AddPriceIDs(ids ...uint64) {
	if m.prices == nil {
		m.prices = make(map[uint64]struct{})
	}
	for i := range ids {
		m.prices[ids[i]] = struct{}{}
	}
}

// ClearPrices clears the "prices" edge to the EnterprisePrice entity.
func (m *EnterpriseMutation) ClearPrices() {
	m.clearedprices = true
}

// PricesCleared reports if the "prices" edge to the EnterprisePrice entity was cleared.
func (m *EnterpriseMutation) PricesCleared() bool {
	return m.clearedprices
}

// RemovePriceIDs removes the "prices" edge to the EnterprisePrice entity by IDs.
func (m *EnterpriseMutation) RemovePriceIDs(ids ...uint64) {
	if m.removedprices == nil {
		m.removedprices = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.prices, ids[i])
		m.removedprices[ids[i]] = struct{}{}
	}
}

// RemovedPrices returns the removed IDs of the "prices" edge to the EnterprisePrice entity.
func (m *EnterpriseMutation) RemovedPricesIDs() (ids []uint64) {
	for id := range m.removedprices {
		ids = append(ids, id)
	}
	return
}

// PricesIDs returns the "prices" edge IDs in the mutation.
func (m *EnterpriseMutation) PricesIDs() (ids []uint64) {
	for id := range m.prices {
		ids = append(ids, id)
	}
	return
}

// ResetPrices resets all changes to the "prices" edge.
func (m *EnterpriseMutation) ResetPrices() {
	m.prices = nil
	m.clearedprices = false
	m.removedprices = nil
}

// AddSubscribeIDs adds the "subscribes" edge to the Subscribe entity by ids.
func (m *EnterpriseMutation) AddSubscribeIDs(ids ...uint64) {
	if m.subscribes == nil {
		m.subscribes = make(map[uint64]struct{})
	}
	for i := range ids {
		m.subscribes[ids[i]] = struct{}{}
	}
}

// ClearSubscribes clears the "subscribes" edge to the Subscribe entity.
func (m *EnterpriseMutation) ClearSubscribes() {
	m.clearedsubscribes = true
}

// SubscribesCleared reports if the "subscribes" edge to the Subscribe entity was cleared.
func (m *EnterpriseMutation) SubscribesCleared() bool {
	return m.clearedsubscribes
}

// RemoveSubscribeIDs removes the "subscribes" edge to the Subscribe entity by IDs.
func (m *EnterpriseMutation) RemoveSubscribeIDs(ids ...uint64) {
	if m.removedsubscribes == nil {
		m.removedsubscribes = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.subscribes, ids[i])
		m.removedsubscribes[ids[i]] = struct{}{}
	}
}

// RemovedSubscribes returns the removed IDs of the "subscribes" edge to the Subscribe entity.
func (m *EnterpriseMutation) RemovedSubscribesIDs() (ids []uint64) {
	for id := range m.removedsubscribes {
		ids = append(ids, id)
	}
	return
}

// SubscribesIDs returns the "subscribes" edge IDs in the mutation.
func (m *EnterpriseMutation) SubscribesIDs() (ids []uint64) {
	for id := range m.subscribes {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribes resets all changes to the "subscribes" edge.
func (m *EnterpriseMutation) ResetSubscribes() {
	m.subscribes = nil
	m.clearedsubscribes = false
	m.removedsubscribes = nil
}

// AddStatementIDs adds the "statements" edge to the EnterpriseStatement entity by ids.
func (m *EnterpriseMutation) AddStatementIDs(ids ...uint64) {
	if m.statements == nil {
		m.statements = make(map[uint64]struct{})
	}
	for i := range ids {
		m.statements[ids[i]] = struct{}{}
	}
}

// ClearStatements clears the "statements" edge to the EnterpriseStatement entity.
func (m *EnterpriseMutation) ClearStatements() {
	m.clearedstatements = true
}

// StatementsCleared reports if the "statements" edge to the EnterpriseStatement entity was cleared.
func (m *EnterpriseMutation) StatementsCleared() bool {
	return m.clearedstatements
}

// RemoveStatementIDs removes the "statements" edge to the EnterpriseStatement entity by IDs.
func (m *EnterpriseMutation) RemoveStatementIDs(ids ...uint64) {
	if m.removedstatements == nil {
		m.removedstatements = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.statements, ids[i])
		m.removedstatements[ids[i]] = struct{}{}
	}
}

// RemovedStatements returns the removed IDs of the "statements" edge to the EnterpriseStatement entity.
func (m *EnterpriseMutation) RemovedStatementsIDs() (ids []uint64) {
	for id := range m.removedstatements {
		ids = append(ids, id)
	}
	return
}

// StatementsIDs returns the "statements" edge IDs in the mutation.
func (m *EnterpriseMutation) StatementsIDs() (ids []uint64) {
	for id := range m.statements {
		ids = append(ids, id)
	}
	return
}

// ResetStatements resets all changes to the "statements" edge.
func (m *EnterpriseMutation) ResetStatements() {
	m.statements = nil
	m.clearedstatements = false
	m.removedstatements = nil
}

// AddStationIDs adds the "stations" edge to the EnterpriseStation entity by ids.
func (m *EnterpriseMutation) AddStationIDs(ids ...uint64) {
	if m.stations == nil {
		m.stations = make(map[uint64]struct{})
	}
	for i := range ids {
		m.stations[ids[i]] = struct{}{}
	}
}

// ClearStations clears the "stations" edge to the EnterpriseStation entity.
func (m *EnterpriseMutation) ClearStations() {
	m.clearedstations = true
}

// StationsCleared reports if the "stations" edge to the EnterpriseStation entity was cleared.
func (m *EnterpriseMutation) StationsCleared() bool {
	return m.clearedstations
}

// RemoveStationIDs removes the "stations" edge to the EnterpriseStation entity by IDs.
func (m *EnterpriseMutation) RemoveStationIDs(ids ...uint64) {
	if m.removedstations == nil {
		m.removedstations = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.stations, ids[i])
		m.removedstations[ids[i]] = struct{}{}
	}
}

// RemovedStations returns the removed IDs of the "stations" edge to the EnterpriseStation entity.
func (m *EnterpriseMutation) RemovedStationsIDs() (ids []uint64) {
	for id := range m.removedstations {
		ids = append(ids, id)
	}
	return
}

// StationsIDs returns the "stations" edge IDs in the mutation.
func (m *EnterpriseMutation) StationsIDs() (ids []uint64) {
	for id := range m.stations {
		ids = append(ids, id)
	}
	return
}

// ResetStations resets all changes to the "stations" edge.
func (m *EnterpriseMutation) ResetStations() {
	m.stations = nil
	m.clearedstations = false
	m.removedstations = nil
}

// AddBillIDs adds the "bills" edge to the EnterpriseBill entity by ids.
func (m *EnterpriseMutation) AddBillIDs(ids ...uint64) {
	if m.bills == nil {
		m.bills = make(map[uint64]struct{})
	}
	for i := range ids {
		m.bills[ids[i]] = struct{}{}
	}
}

// ClearBills clears the "bills" edge to the EnterpriseBill entity.
func (m *EnterpriseMutation) ClearBills() {
	m.clearedbills = true
}

// BillsCleared reports if the "bills" edge to the EnterpriseBill entity was cleared.
func (m *EnterpriseMutation) BillsCleared() bool {
	return m.clearedbills
}

// RemoveBillIDs removes the "bills" edge to the EnterpriseBill entity by IDs.
func (m *EnterpriseMutation) RemoveBillIDs(ids ...uint64) {
	if m.removedbills == nil {
		m.removedbills = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.bills, ids[i])
		m.removedbills[ids[i]] = struct{}{}
	}
}

// RemovedBills returns the removed IDs of the "bills" edge to the EnterpriseBill entity.
func (m *EnterpriseMutation) RemovedBillsIDs() (ids []uint64) {
	for id := range m.removedbills {
		ids = append(ids, id)
	}
	return
}

// BillsIDs returns the "bills" edge IDs in the mutation.
func (m *EnterpriseMutation) BillsIDs() (ids []uint64) {
	for id := range m.bills {
		ids = append(ids, id)
	}
	return
}

// ResetBills resets all changes to the "bills" edge.
func (m *EnterpriseMutation) ResetBills() {
	m.bills = nil
	m.clearedbills = false
	m.removedbills = nil
}

// AddBatteryIDs adds the "batteries" edge to the Battery entity by ids.
func (m *EnterpriseMutation) AddBatteryIDs(ids ...uint64) {
	if m.batteries == nil {
		m.batteries = make(map[uint64]struct{})
	}
	for i := range ids {
		m.batteries[ids[i]] = struct{}{}
	}
}

// ClearBatteries clears the "batteries" edge to the Battery entity.
func (m *EnterpriseMutation) ClearBatteries() {
	m.clearedbatteries = true
}

// BatteriesCleared reports if the "batteries" edge to the Battery entity was cleared.
func (m *EnterpriseMutation) BatteriesCleared() bool {
	return m.clearedbatteries
}

// RemoveBatteryIDs removes the "batteries" edge to the Battery entity by IDs.
func (m *EnterpriseMutation) RemoveBatteryIDs(ids ...uint64) {
	if m.removedbatteries == nil {
		m.removedbatteries = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.batteries, ids[i])
		m.removedbatteries[ids[i]] = struct{}{}
	}
}

// RemovedBatteries returns the removed IDs of the "batteries" edge to the Battery entity.
func (m *EnterpriseMutation) RemovedBatteriesIDs() (ids []uint64) {
	for id := range m.removedbatteries {
		ids = append(ids, id)
	}
	return
}

// BatteriesIDs returns the "batteries" edge IDs in the mutation.
func (m *EnterpriseMutation) BatteriesIDs() (ids []uint64) {
	for id := range m.batteries {
		ids = append(ids, id)
	}
	return
}

// ResetBatteries resets all changes to the "batteries" edge.
func (m *EnterpriseMutation) ResetBatteries() {
	m.batteries = nil
	m.clearedbatteries = false
	m.removedbatteries = nil
}

// AddAgentIDs adds the "agents" edge to the Agent entity by ids.
func (m *EnterpriseMutation) AddAgentIDs(ids ...uint64) {
	if m.agents == nil {
		m.agents = make(map[uint64]struct{})
	}
	for i := range ids {
		m.agents[ids[i]] = struct{}{}
	}
}

// ClearAgents clears the "agents" edge to the Agent entity.
func (m *EnterpriseMutation) ClearAgents() {
	m.clearedagents = true
}

// AgentsCleared reports if the "agents" edge to the Agent entity was cleared.
func (m *EnterpriseMutation) AgentsCleared() bool {
	return m.clearedagents
}

// RemoveAgentIDs removes the "agents" edge to the Agent entity by IDs.
func (m *EnterpriseMutation) RemoveAgentIDs(ids ...uint64) {
	if m.removedagents == nil {
		m.removedagents = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.agents, ids[i])
		m.removedagents[ids[i]] = struct{}{}
	}
}

// RemovedAgents returns the removed IDs of the "agents" edge to the Agent entity.
func (m *EnterpriseMutation) RemovedAgentsIDs() (ids []uint64) {
	for id := range m.removedagents {
		ids = append(ids, id)
	}
	return
}

// AgentsIDs returns the "agents" edge IDs in the mutation.
func (m *EnterpriseMutation) AgentsIDs() (ids []uint64) {
	for id := range m.agents {
		ids = append(ids, id)
	}
	return
}

// ResetAgents resets all changes to the "agents" edge.
func (m *EnterpriseMutation) ResetAgents() {
	m.agents = nil
	m.clearedagents = false
	m.removedagents = nil
}

// AddCabinetIDs adds the "cabinets" edge to the Cabinet entity by ids.
func (m *EnterpriseMutation) AddCabinetIDs(ids ...uint64) {
	if m.cabinets == nil {
		m.cabinets = make(map[uint64]struct{})
	}
	for i := range ids {
		m.cabinets[ids[i]] = struct{}{}
	}
}

// ClearCabinets clears the "cabinets" edge to the Cabinet entity.
func (m *EnterpriseMutation) ClearCabinets() {
	m.clearedcabinets = true
}

// CabinetsCleared reports if the "cabinets" edge to the Cabinet entity was cleared.
func (m *EnterpriseMutation) CabinetsCleared() bool {
	return m.clearedcabinets
}

// RemoveCabinetIDs removes the "cabinets" edge to the Cabinet entity by IDs.
func (m *EnterpriseMutation) RemoveCabinetIDs(ids ...uint64) {
	if m.removedcabinets == nil {
		m.removedcabinets = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.cabinets, ids[i])
		m.removedcabinets[ids[i]] = struct{}{}
	}
}

// RemovedCabinets returns the removed IDs of the "cabinets" edge to the Cabinet entity.
func (m *EnterpriseMutation) RemovedCabinetsIDs() (ids []uint64) {
	for id := range m.removedcabinets {
		ids = append(ids, id)
	}
	return
}

// CabinetsIDs returns the "cabinets" edge IDs in the mutation.
func (m *EnterpriseMutation) CabinetsIDs() (ids []uint64) {
	for id := range m.cabinets {
		ids = append(ids, id)
	}
	return
}

// ResetCabinets resets all changes to the "cabinets" edge.
func (m *EnterpriseMutation) ResetCabinets() {
	m.cabinets = nil
	m.clearedcabinets = false
	m.removedcabinets = nil
}

// AddStockIDs adds the "stocks" edge to the Stock entity by ids.
func (m *EnterpriseMutation) AddStockIDs(ids ...uint64) {
	if m.stocks == nil {
		m.stocks = make(map[uint64]struct{})
	}
	for i := range ids {
		m.stocks[ids[i]] = struct{}{}
	}
}

// ClearStocks clears the "stocks" edge to the Stock entity.
func (m *EnterpriseMutation) ClearStocks() {
	m.clearedstocks = true
}

// StocksCleared reports if the "stocks" edge to the Stock entity was cleared.
func (m *EnterpriseMutation) StocksCleared() bool {
	return m.clearedstocks
}

// RemoveStockIDs removes the "stocks" edge to the Stock entity by IDs.
func (m *EnterpriseMutation) RemoveStockIDs(ids ...uint64) {
	if m.removedstocks == nil {
		m.removedstocks = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.stocks, ids[i])
		m.removedstocks[ids[i]] = struct{}{}
	}
}

// RemovedStocks returns the removed IDs of the "stocks" edge to the Stock entity.
func (m *EnterpriseMutation) RemovedStocksIDs() (ids []uint64) {
	for id := range m.removedstocks {
		ids = append(ids, id)
	}
	return
}

// StocksIDs returns the "stocks" edge IDs in the mutation.
func (m *EnterpriseMutation) StocksIDs() (ids []uint64) {
	for id := range m.stocks {
		ids = append(ids, id)
	}
	return
}

// ResetStocks resets all changes to the "stocks" edge.
func (m *EnterpriseMutation) ResetStocks() {
	m.stocks = nil
	m.clearedstocks = false
	m.removedstocks = nil
}

// AddSwapPutinBatteryIDs adds the "swap_putin_batteries" edge to the EnterpriseBatterySwap entity by ids.
func (m *EnterpriseMutation) AddSwapPutinBatteryIDs(ids ...uint64) {
	if m.swap_putin_batteries == nil {
		m.swap_putin_batteries = make(map[uint64]struct{})
	}
	for i := range ids {
		m.swap_putin_batteries[ids[i]] = struct{}{}
	}
}

// ClearSwapPutinBatteries clears the "swap_putin_batteries" edge to the EnterpriseBatterySwap entity.
func (m *EnterpriseMutation) ClearSwapPutinBatteries() {
	m.clearedswap_putin_batteries = true
}

// SwapPutinBatteriesCleared reports if the "swap_putin_batteries" edge to the EnterpriseBatterySwap entity was cleared.
func (m *EnterpriseMutation) SwapPutinBatteriesCleared() bool {
	return m.clearedswap_putin_batteries
}

// RemoveSwapPutinBatteryIDs removes the "swap_putin_batteries" edge to the EnterpriseBatterySwap entity by IDs.
func (m *EnterpriseMutation) RemoveSwapPutinBatteryIDs(ids ...uint64) {
	if m.removedswap_putin_batteries == nil {
		m.removedswap_putin_batteries = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.swap_putin_batteries, ids[i])
		m.removedswap_putin_batteries[ids[i]] = struct{}{}
	}
}

// RemovedSwapPutinBatteries returns the removed IDs of the "swap_putin_batteries" edge to the EnterpriseBatterySwap entity.
func (m *EnterpriseMutation) RemovedSwapPutinBatteriesIDs() (ids []uint64) {
	for id := range m.removedswap_putin_batteries {
		ids = append(ids, id)
	}
	return
}

// SwapPutinBatteriesIDs returns the "swap_putin_batteries" edge IDs in the mutation.
func (m *EnterpriseMutation) SwapPutinBatteriesIDs() (ids []uint64) {
	for id := range m.swap_putin_batteries {
		ids = append(ids, id)
	}
	return
}

// ResetSwapPutinBatteries resets all changes to the "swap_putin_batteries" edge.
func (m *EnterpriseMutation) ResetSwapPutinBatteries() {
	m.swap_putin_batteries = nil
	m.clearedswap_putin_batteries = false
	m.removedswap_putin_batteries = nil
}

// AddSwapPutoutBatteryIDs adds the "swap_putout_batteries" edge to the EnterpriseBatterySwap entity by ids.
func (m *EnterpriseMutation) AddSwapPutoutBatteryIDs(ids ...uint64) {
	if m.swap_putout_batteries == nil {
		m.swap_putout_batteries = make(map[uint64]struct{})
	}
	for i := range ids {
		m.swap_putout_batteries[ids[i]] = struct{}{}
	}
}

// ClearSwapPutoutBatteries clears the "swap_putout_batteries" edge to the EnterpriseBatterySwap entity.
func (m *EnterpriseMutation) ClearSwapPutoutBatteries() {
	m.clearedswap_putout_batteries = true
}

// SwapPutoutBatteriesCleared reports if the "swap_putout_batteries" edge to the EnterpriseBatterySwap entity was cleared.
func (m *EnterpriseMutation) SwapPutoutBatteriesCleared() bool {
	return m.clearedswap_putout_batteries
}

// RemoveSwapPutoutBatteryIDs removes the "swap_putout_batteries" edge to the EnterpriseBatterySwap entity by IDs.
func (m *EnterpriseMutation) RemoveSwapPutoutBatteryIDs(ids ...uint64) {
	if m.removedswap_putout_batteries == nil {
		m.removedswap_putout_batteries = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.swap_putout_batteries, ids[i])
		m.removedswap_putout_batteries[ids[i]] = struct{}{}
	}
}

// RemovedSwapPutoutBatteries returns the removed IDs of the "swap_putout_batteries" edge to the EnterpriseBatterySwap entity.
func (m *EnterpriseMutation) RemovedSwapPutoutBatteriesIDs() (ids []uint64) {
	for id := range m.removedswap_putout_batteries {
		ids = append(ids, id)
	}
	return
}

// SwapPutoutBatteriesIDs returns the "swap_putout_batteries" edge IDs in the mutation.
func (m *EnterpriseMutation) SwapPutoutBatteriesIDs() (ids []uint64) {
	for id := range m.swap_putout_batteries {
		ids = append(ids, id)
	}
	return
}

// ResetSwapPutoutBatteries resets all changes to the "swap_putout_batteries" edge.
func (m *EnterpriseMutation) ResetSwapPutoutBatteries() {
	m.swap_putout_batteries = nil
	m.clearedswap_putout_batteries = false
	m.removedswap_putout_batteries = nil
}

// Where appends a list predicates to the EnterpriseMutation builder.
func (m *EnterpriseMutation) Where(ps ...predicate.Enterprise) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnterpriseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnterpriseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Enterprise, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnterpriseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnterpriseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Enterprise).
func (m *EnterpriseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnterpriseMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.created_at != nil {
		fields = append(fields, enterprise.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enterprise.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, enterprise.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, enterprise.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, enterprise.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, enterprise.FieldRemark)
	}
	if m.city != nil {
		fields = append(fields, enterprise.FieldCityID)
	}
	if m.name != nil {
		fields = append(fields, enterprise.FieldName)
	}
	if m.company_name != nil {
		fields = append(fields, enterprise.FieldCompanyName)
	}
	if m.status != nil {
		fields = append(fields, enterprise.FieldStatus)
	}
	if m.contact_name != nil {
		fields = append(fields, enterprise.FieldContactName)
	}
	if m.contact_phone != nil {
		fields = append(fields, enterprise.FieldContactPhone)
	}
	if m.idcard_number != nil {
		fields = append(fields, enterprise.FieldIdcardNumber)
	}
	if m.address != nil {
		fields = append(fields, enterprise.FieldAddress)
	}
	if m.payment != nil {
		fields = append(fields, enterprise.FieldPayment)
	}
	if m.deposit != nil {
		fields = append(fields, enterprise.FieldDeposit)
	}
	if m.balance != nil {
		fields = append(fields, enterprise.FieldBalance)
	}
	if m.prepayment_total != nil {
		fields = append(fields, enterprise.FieldPrepaymentTotal)
	}
	if m.suspensed_at != nil {
		fields = append(fields, enterprise.FieldSuspensedAt)
	}
	if m.agent != nil {
		fields = append(fields, enterprise.FieldAgent)
	}
	if m.use_store != nil {
		fields = append(fields, enterprise.FieldUseStore)
	}
	if m.days != nil {
		fields = append(fields, enterprise.FieldDays)
	}
	if m.distance != nil {
		fields = append(fields, enterprise.FieldDistance)
	}
	if m.recharge_amount != nil {
		fields = append(fields, enterprise.FieldRechargeAmount)
	}
	if m.sign_type != nil {
		fields = append(fields, enterprise.FieldSignType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnterpriseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enterprise.FieldCreatedAt:
		return m.CreatedAt()
	case enterprise.FieldUpdatedAt:
		return m.UpdatedAt()
	case enterprise.FieldDeletedAt:
		return m.DeletedAt()
	case enterprise.FieldCreator:
		return m.Creator()
	case enterprise.FieldLastModifier:
		return m.LastModifier()
	case enterprise.FieldRemark:
		return m.Remark()
	case enterprise.FieldCityID:
		return m.CityID()
	case enterprise.FieldName:
		return m.Name()
	case enterprise.FieldCompanyName:
		return m.CompanyName()
	case enterprise.FieldStatus:
		return m.Status()
	case enterprise.FieldContactName:
		return m.ContactName()
	case enterprise.FieldContactPhone:
		return m.ContactPhone()
	case enterprise.FieldIdcardNumber:
		return m.IdcardNumber()
	case enterprise.FieldAddress:
		return m.Address()
	case enterprise.FieldPayment:
		return m.Payment()
	case enterprise.FieldDeposit:
		return m.Deposit()
	case enterprise.FieldBalance:
		return m.Balance()
	case enterprise.FieldPrepaymentTotal:
		return m.PrepaymentTotal()
	case enterprise.FieldSuspensedAt:
		return m.SuspensedAt()
	case enterprise.FieldAgent:
		return m.Agent()
	case enterprise.FieldUseStore:
		return m.UseStore()
	case enterprise.FieldDays:
		return m.Days()
	case enterprise.FieldDistance:
		return m.Distance()
	case enterprise.FieldRechargeAmount:
		return m.RechargeAmount()
	case enterprise.FieldSignType:
		return m.SignType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnterpriseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enterprise.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enterprise.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case enterprise.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case enterprise.FieldCreator:
		return m.OldCreator(ctx)
	case enterprise.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case enterprise.FieldRemark:
		return m.OldRemark(ctx)
	case enterprise.FieldCityID:
		return m.OldCityID(ctx)
	case enterprise.FieldName:
		return m.OldName(ctx)
	case enterprise.FieldCompanyName:
		return m.OldCompanyName(ctx)
	case enterprise.FieldStatus:
		return m.OldStatus(ctx)
	case enterprise.FieldContactName:
		return m.OldContactName(ctx)
	case enterprise.FieldContactPhone:
		return m.OldContactPhone(ctx)
	case enterprise.FieldIdcardNumber:
		return m.OldIdcardNumber(ctx)
	case enterprise.FieldAddress:
		return m.OldAddress(ctx)
	case enterprise.FieldPayment:
		return m.OldPayment(ctx)
	case enterprise.FieldDeposit:
		return m.OldDeposit(ctx)
	case enterprise.FieldBalance:
		return m.OldBalance(ctx)
	case enterprise.FieldPrepaymentTotal:
		return m.OldPrepaymentTotal(ctx)
	case enterprise.FieldSuspensedAt:
		return m.OldSuspensedAt(ctx)
	case enterprise.FieldAgent:
		return m.OldAgent(ctx)
	case enterprise.FieldUseStore:
		return m.OldUseStore(ctx)
	case enterprise.FieldDays:
		return m.OldDays(ctx)
	case enterprise.FieldDistance:
		return m.OldDistance(ctx)
	case enterprise.FieldRechargeAmount:
		return m.OldRechargeAmount(ctx)
	case enterprise.FieldSignType:
		return m.OldSignType(ctx)
	}
	return nil, fmt.Errorf("unknown Enterprise field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enterprise.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enterprise.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case enterprise.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case enterprise.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case enterprise.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case enterprise.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case enterprise.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case enterprise.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case enterprise.FieldCompanyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyName(v)
		return nil
	case enterprise.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case enterprise.FieldContactName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactName(v)
		return nil
	case enterprise.FieldContactPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPhone(v)
		return nil
	case enterprise.FieldIdcardNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdcardNumber(v)
		return nil
	case enterprise.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case enterprise.FieldPayment:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayment(v)
		return nil
	case enterprise.FieldDeposit:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeposit(v)
		return nil
	case enterprise.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case enterprise.FieldPrepaymentTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrepaymentTotal(v)
		return nil
	case enterprise.FieldSuspensedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuspensedAt(v)
		return nil
	case enterprise.FieldAgent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgent(v)
		return nil
	case enterprise.FieldUseStore:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseStore(v)
		return nil
	case enterprise.FieldDays:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDays(v)
		return nil
	case enterprise.FieldDistance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistance(v)
		return nil
	case enterprise.FieldRechargeAmount:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRechargeAmount(v)
		return nil
	case enterprise.FieldSignType:
		v, ok := value.(model.EnterpriseSignType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignType(v)
		return nil
	}
	return fmt.Errorf("unknown Enterprise field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnterpriseMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, enterprise.FieldStatus)
	}
	if m.addpayment != nil {
		fields = append(fields, enterprise.FieldPayment)
	}
	if m.adddeposit != nil {
		fields = append(fields, enterprise.FieldDeposit)
	}
	if m.addbalance != nil {
		fields = append(fields, enterprise.FieldBalance)
	}
	if m.addprepayment_total != nil {
		fields = append(fields, enterprise.FieldPrepaymentTotal)
	}
	if m.adddistance != nil {
		fields = append(fields, enterprise.FieldDistance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnterpriseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case enterprise.FieldStatus:
		return m.AddedStatus()
	case enterprise.FieldPayment:
		return m.AddedPayment()
	case enterprise.FieldDeposit:
		return m.AddedDeposit()
	case enterprise.FieldBalance:
		return m.AddedBalance()
	case enterprise.FieldPrepaymentTotal:
		return m.AddedPrepaymentTotal()
	case enterprise.FieldDistance:
		return m.AddedDistance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case enterprise.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case enterprise.FieldPayment:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayment(v)
		return nil
	case enterprise.FieldDeposit:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeposit(v)
		return nil
	case enterprise.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case enterprise.FieldPrepaymentTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrepaymentTotal(v)
		return nil
	case enterprise.FieldDistance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDistance(v)
		return nil
	}
	return fmt.Errorf("unknown Enterprise numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnterpriseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(enterprise.FieldDeletedAt) {
		fields = append(fields, enterprise.FieldDeletedAt)
	}
	if m.FieldCleared(enterprise.FieldCreator) {
		fields = append(fields, enterprise.FieldCreator)
	}
	if m.FieldCleared(enterprise.FieldLastModifier) {
		fields = append(fields, enterprise.FieldLastModifier)
	}
	if m.FieldCleared(enterprise.FieldRemark) {
		fields = append(fields, enterprise.FieldRemark)
	}
	if m.FieldCleared(enterprise.FieldCompanyName) {
		fields = append(fields, enterprise.FieldCompanyName)
	}
	if m.FieldCleared(enterprise.FieldSuspensedAt) {
		fields = append(fields, enterprise.FieldSuspensedAt)
	}
	if m.FieldCleared(enterprise.FieldUseStore) {
		fields = append(fields, enterprise.FieldUseStore)
	}
	if m.FieldCleared(enterprise.FieldDays) {
		fields = append(fields, enterprise.FieldDays)
	}
	if m.FieldCleared(enterprise.FieldRechargeAmount) {
		fields = append(fields, enterprise.FieldRechargeAmount)
	}
	if m.FieldCleared(enterprise.FieldSignType) {
		fields = append(fields, enterprise.FieldSignType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnterpriseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnterpriseMutation) ClearField(name string) error {
	switch name {
	case enterprise.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case enterprise.FieldCreator:
		m.ClearCreator()
		return nil
	case enterprise.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case enterprise.FieldRemark:
		m.ClearRemark()
		return nil
	case enterprise.FieldCompanyName:
		m.ClearCompanyName()
		return nil
	case enterprise.FieldSuspensedAt:
		m.ClearSuspensedAt()
		return nil
	case enterprise.FieldUseStore:
		m.ClearUseStore()
		return nil
	case enterprise.FieldDays:
		m.ClearDays()
		return nil
	case enterprise.FieldRechargeAmount:
		m.ClearRechargeAmount()
		return nil
	case enterprise.FieldSignType:
		m.ClearSignType()
		return nil
	}
	return fmt.Errorf("unknown Enterprise nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnterpriseMutation) ResetField(name string) error {
	switch name {
	case enterprise.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enterprise.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case enterprise.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case enterprise.FieldCreator:
		m.ResetCreator()
		return nil
	case enterprise.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case enterprise.FieldRemark:
		m.ResetRemark()
		return nil
	case enterprise.FieldCityID:
		m.ResetCityID()
		return nil
	case enterprise.FieldName:
		m.ResetName()
		return nil
	case enterprise.FieldCompanyName:
		m.ResetCompanyName()
		return nil
	case enterprise.FieldStatus:
		m.ResetStatus()
		return nil
	case enterprise.FieldContactName:
		m.ResetContactName()
		return nil
	case enterprise.FieldContactPhone:
		m.ResetContactPhone()
		return nil
	case enterprise.FieldIdcardNumber:
		m.ResetIdcardNumber()
		return nil
	case enterprise.FieldAddress:
		m.ResetAddress()
		return nil
	case enterprise.FieldPayment:
		m.ResetPayment()
		return nil
	case enterprise.FieldDeposit:
		m.ResetDeposit()
		return nil
	case enterprise.FieldBalance:
		m.ResetBalance()
		return nil
	case enterprise.FieldPrepaymentTotal:
		m.ResetPrepaymentTotal()
		return nil
	case enterprise.FieldSuspensedAt:
		m.ResetSuspensedAt()
		return nil
	case enterprise.FieldAgent:
		m.ResetAgent()
		return nil
	case enterprise.FieldUseStore:
		m.ResetUseStore()
		return nil
	case enterprise.FieldDays:
		m.ResetDays()
		return nil
	case enterprise.FieldDistance:
		m.ResetDistance()
		return nil
	case enterprise.FieldRechargeAmount:
		m.ResetRechargeAmount()
		return nil
	case enterprise.FieldSignType:
		m.ResetSignType()
		return nil
	}
	return fmt.Errorf("unknown Enterprise field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnterpriseMutation) AddedEdges() []string {
	edges := make([]string, 0, 14)
	if m.city != nil {
		edges = append(edges, enterprise.EdgeCity)
	}
	if m.riders != nil {
		edges = append(edges, enterprise.EdgeRiders)
	}
	if m.contracts != nil {
		edges = append(edges, enterprise.EdgeContracts)
	}
	if m.prices != nil {
		edges = append(edges, enterprise.EdgePrices)
	}
	if m.subscribes != nil {
		edges = append(edges, enterprise.EdgeSubscribes)
	}
	if m.statements != nil {
		edges = append(edges, enterprise.EdgeStatements)
	}
	if m.stations != nil {
		edges = append(edges, enterprise.EdgeStations)
	}
	if m.bills != nil {
		edges = append(edges, enterprise.EdgeBills)
	}
	if m.batteries != nil {
		edges = append(edges, enterprise.EdgeBatteries)
	}
	if m.agents != nil {
		edges = append(edges, enterprise.EdgeAgents)
	}
	if m.cabinets != nil {
		edges = append(edges, enterprise.EdgeCabinets)
	}
	if m.stocks != nil {
		edges = append(edges, enterprise.EdgeStocks)
	}
	if m.swap_putin_batteries != nil {
		edges = append(edges, enterprise.EdgeSwapPutinBatteries)
	}
	if m.swap_putout_batteries != nil {
		edges = append(edges, enterprise.EdgeSwapPutoutBatteries)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnterpriseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enterprise.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case enterprise.EdgeRiders:
		ids := make([]ent.Value, 0, len(m.riders))
		for id := range m.riders {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeContracts:
		ids := make([]ent.Value, 0, len(m.contracts))
		for id := range m.contracts {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgePrices:
		ids := make([]ent.Value, 0, len(m.prices))
		for id := range m.prices {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeSubscribes:
		ids := make([]ent.Value, 0, len(m.subscribes))
		for id := range m.subscribes {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeStatements:
		ids := make([]ent.Value, 0, len(m.statements))
		for id := range m.statements {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeStations:
		ids := make([]ent.Value, 0, len(m.stations))
		for id := range m.stations {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeBills:
		ids := make([]ent.Value, 0, len(m.bills))
		for id := range m.bills {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeBatteries:
		ids := make([]ent.Value, 0, len(m.batteries))
		for id := range m.batteries {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeAgents:
		ids := make([]ent.Value, 0, len(m.agents))
		for id := range m.agents {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeCabinets:
		ids := make([]ent.Value, 0, len(m.cabinets))
		for id := range m.cabinets {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.stocks))
		for id := range m.stocks {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeSwapPutinBatteries:
		ids := make([]ent.Value, 0, len(m.swap_putin_batteries))
		for id := range m.swap_putin_batteries {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeSwapPutoutBatteries:
		ids := make([]ent.Value, 0, len(m.swap_putout_batteries))
		for id := range m.swap_putout_batteries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnterpriseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 14)
	if m.removedriders != nil {
		edges = append(edges, enterprise.EdgeRiders)
	}
	if m.removedcontracts != nil {
		edges = append(edges, enterprise.EdgeContracts)
	}
	if m.removedprices != nil {
		edges = append(edges, enterprise.EdgePrices)
	}
	if m.removedsubscribes != nil {
		edges = append(edges, enterprise.EdgeSubscribes)
	}
	if m.removedstatements != nil {
		edges = append(edges, enterprise.EdgeStatements)
	}
	if m.removedstations != nil {
		edges = append(edges, enterprise.EdgeStations)
	}
	if m.removedbills != nil {
		edges = append(edges, enterprise.EdgeBills)
	}
	if m.removedbatteries != nil {
		edges = append(edges, enterprise.EdgeBatteries)
	}
	if m.removedagents != nil {
		edges = append(edges, enterprise.EdgeAgents)
	}
	if m.removedcabinets != nil {
		edges = append(edges, enterprise.EdgeCabinets)
	}
	if m.removedstocks != nil {
		edges = append(edges, enterprise.EdgeStocks)
	}
	if m.removedswap_putin_batteries != nil {
		edges = append(edges, enterprise.EdgeSwapPutinBatteries)
	}
	if m.removedswap_putout_batteries != nil {
		edges = append(edges, enterprise.EdgeSwapPutoutBatteries)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnterpriseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case enterprise.EdgeRiders:
		ids := make([]ent.Value, 0, len(m.removedriders))
		for id := range m.removedriders {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeContracts:
		ids := make([]ent.Value, 0, len(m.removedcontracts))
		for id := range m.removedcontracts {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgePrices:
		ids := make([]ent.Value, 0, len(m.removedprices))
		for id := range m.removedprices {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeSubscribes:
		ids := make([]ent.Value, 0, len(m.removedsubscribes))
		for id := range m.removedsubscribes {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeStatements:
		ids := make([]ent.Value, 0, len(m.removedstatements))
		for id := range m.removedstatements {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeStations:
		ids := make([]ent.Value, 0, len(m.removedstations))
		for id := range m.removedstations {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeBills:
		ids := make([]ent.Value, 0, len(m.removedbills))
		for id := range m.removedbills {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeBatteries:
		ids := make([]ent.Value, 0, len(m.removedbatteries))
		for id := range m.removedbatteries {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeAgents:
		ids := make([]ent.Value, 0, len(m.removedagents))
		for id := range m.removedagents {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeCabinets:
		ids := make([]ent.Value, 0, len(m.removedcabinets))
		for id := range m.removedcabinets {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.removedstocks))
		for id := range m.removedstocks {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeSwapPutinBatteries:
		ids := make([]ent.Value, 0, len(m.removedswap_putin_batteries))
		for id := range m.removedswap_putin_batteries {
			ids = append(ids, id)
		}
		return ids
	case enterprise.EdgeSwapPutoutBatteries:
		ids := make([]ent.Value, 0, len(m.removedswap_putout_batteries))
		for id := range m.removedswap_putout_batteries {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnterpriseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 14)
	if m.clearedcity {
		edges = append(edges, enterprise.EdgeCity)
	}
	if m.clearedriders {
		edges = append(edges, enterprise.EdgeRiders)
	}
	if m.clearedcontracts {
		edges = append(edges, enterprise.EdgeContracts)
	}
	if m.clearedprices {
		edges = append(edges, enterprise.EdgePrices)
	}
	if m.clearedsubscribes {
		edges = append(edges, enterprise.EdgeSubscribes)
	}
	if m.clearedstatements {
		edges = append(edges, enterprise.EdgeStatements)
	}
	if m.clearedstations {
		edges = append(edges, enterprise.EdgeStations)
	}
	if m.clearedbills {
		edges = append(edges, enterprise.EdgeBills)
	}
	if m.clearedbatteries {
		edges = append(edges, enterprise.EdgeBatteries)
	}
	if m.clearedagents {
		edges = append(edges, enterprise.EdgeAgents)
	}
	if m.clearedcabinets {
		edges = append(edges, enterprise.EdgeCabinets)
	}
	if m.clearedstocks {
		edges = append(edges, enterprise.EdgeStocks)
	}
	if m.clearedswap_putin_batteries {
		edges = append(edges, enterprise.EdgeSwapPutinBatteries)
	}
	if m.clearedswap_putout_batteries {
		edges = append(edges, enterprise.EdgeSwapPutoutBatteries)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnterpriseMutation) EdgeCleared(name string) bool {
	switch name {
	case enterprise.EdgeCity:
		return m.clearedcity
	case enterprise.EdgeRiders:
		return m.clearedriders
	case enterprise.EdgeContracts:
		return m.clearedcontracts
	case enterprise.EdgePrices:
		return m.clearedprices
	case enterprise.EdgeSubscribes:
		return m.clearedsubscribes
	case enterprise.EdgeStatements:
		return m.clearedstatements
	case enterprise.EdgeStations:
		return m.clearedstations
	case enterprise.EdgeBills:
		return m.clearedbills
	case enterprise.EdgeBatteries:
		return m.clearedbatteries
	case enterprise.EdgeAgents:
		return m.clearedagents
	case enterprise.EdgeCabinets:
		return m.clearedcabinets
	case enterprise.EdgeStocks:
		return m.clearedstocks
	case enterprise.EdgeSwapPutinBatteries:
		return m.clearedswap_putin_batteries
	case enterprise.EdgeSwapPutoutBatteries:
		return m.clearedswap_putout_batteries
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnterpriseMutation) ClearEdge(name string) error {
	switch name {
	case enterprise.EdgeCity:
		m.ClearCity()
		return nil
	}
	return fmt.Errorf("unknown Enterprise unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnterpriseMutation) ResetEdge(name string) error {
	switch name {
	case enterprise.EdgeCity:
		m.ResetCity()
		return nil
	case enterprise.EdgeRiders:
		m.ResetRiders()
		return nil
	case enterprise.EdgeContracts:
		m.ResetContracts()
		return nil
	case enterprise.EdgePrices:
		m.ResetPrices()
		return nil
	case enterprise.EdgeSubscribes:
		m.ResetSubscribes()
		return nil
	case enterprise.EdgeStatements:
		m.ResetStatements()
		return nil
	case enterprise.EdgeStations:
		m.ResetStations()
		return nil
	case enterprise.EdgeBills:
		m.ResetBills()
		return nil
	case enterprise.EdgeBatteries:
		m.ResetBatteries()
		return nil
	case enterprise.EdgeAgents:
		m.ResetAgents()
		return nil
	case enterprise.EdgeCabinets:
		m.ResetCabinets()
		return nil
	case enterprise.EdgeStocks:
		m.ResetStocks()
		return nil
	case enterprise.EdgeSwapPutinBatteries:
		m.ResetSwapPutinBatteries()
		return nil
	case enterprise.EdgeSwapPutoutBatteries:
		m.ResetSwapPutoutBatteries()
		return nil
	}
	return fmt.Errorf("unknown Enterprise edge %s", name)
}

// EnterpriseBatterySwapMutation represents an operation that mutates the EnterpriseBatterySwap nodes in the graph.
type EnterpriseBatterySwapMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uint64
	created_at               *time.Time
	updated_at               *time.Time
	putin_sn                 *string
	putout_sn                *string
	clearedFields            map[string]struct{}
	exchange                 *uint64
	clearedexchange          bool
	cabinet                  *uint64
	clearedcabinet           bool
	putin                    *uint64
	clearedputin             bool
	putin_enterprise         *uint64
	clearedputin_enterprise  bool
	putin_station            *uint64
	clearedputin_station     bool
	putout                   *uint64
	clearedputout            bool
	putout_enterprise        *uint64
	clearedputout_enterprise bool
	putout_station           *uint64
	clearedputout_station    bool
	done                     bool
	oldValue                 func(context.Context) (*EnterpriseBatterySwap, error)
	predicates               []predicate.EnterpriseBatterySwap
}

var _ ent.Mutation = (*EnterpriseBatterySwapMutation)(nil)

// enterprisebatteryswapOption allows management of the mutation configuration using functional options.
type enterprisebatteryswapOption func(*EnterpriseBatterySwapMutation)

// newEnterpriseBatterySwapMutation creates new mutation for the EnterpriseBatterySwap entity.
func newEnterpriseBatterySwapMutation(c config, op Op, opts ...enterprisebatteryswapOption) *EnterpriseBatterySwapMutation {
	m := &EnterpriseBatterySwapMutation{
		config:        c,
		op:            op,
		typ:           TypeEnterpriseBatterySwap,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnterpriseBatterySwapID sets the ID field of the mutation.
func withEnterpriseBatterySwapID(id uint64) enterprisebatteryswapOption {
	return func(m *EnterpriseBatterySwapMutation) {
		var (
			err   error
			once  sync.Once
			value *EnterpriseBatterySwap
		)
		m.oldValue = func(ctx context.Context) (*EnterpriseBatterySwap, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnterpriseBatterySwap.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnterpriseBatterySwap sets the old EnterpriseBatterySwap of the mutation.
func withEnterpriseBatterySwap(node *EnterpriseBatterySwap) enterprisebatteryswapOption {
	return func(m *EnterpriseBatterySwapMutation) {
		m.oldValue = func(context.Context) (*EnterpriseBatterySwap, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnterpriseBatterySwapMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnterpriseBatterySwapMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnterpriseBatterySwapMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnterpriseBatterySwapMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnterpriseBatterySwap.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EnterpriseBatterySwapMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnterpriseBatterySwapMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EnterpriseBatterySwap entity.
// If the EnterpriseBatterySwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBatterySwapMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnterpriseBatterySwapMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnterpriseBatterySwapMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnterpriseBatterySwapMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EnterpriseBatterySwap entity.
// If the EnterpriseBatterySwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBatterySwapMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnterpriseBatterySwapMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetExchangeID sets the "exchange_id" field.
func (m *EnterpriseBatterySwapMutation) SetExchangeID(u uint64) {
	m.exchange = &u
}

// ExchangeID returns the value of the "exchange_id" field in the mutation.
func (m *EnterpriseBatterySwapMutation) ExchangeID() (r uint64, exists bool) {
	v := m.exchange
	if v == nil {
		return
	}
	return *v, true
}

// OldExchangeID returns the old "exchange_id" field's value of the EnterpriseBatterySwap entity.
// If the EnterpriseBatterySwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBatterySwapMutation) OldExchangeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExchangeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExchangeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExchangeID: %w", err)
	}
	return oldValue.ExchangeID, nil
}

// ResetExchangeID resets all changes to the "exchange_id" field.
func (m *EnterpriseBatterySwapMutation) ResetExchangeID() {
	m.exchange = nil
}

// SetCabinetID sets the "cabinet_id" field.
func (m *EnterpriseBatterySwapMutation) SetCabinetID(u uint64) {
	m.cabinet = &u
}

// CabinetID returns the value of the "cabinet_id" field in the mutation.
func (m *EnterpriseBatterySwapMutation) CabinetID() (r uint64, exists bool) {
	v := m.cabinet
	if v == nil {
		return
	}
	return *v, true
}

// OldCabinetID returns the old "cabinet_id" field's value of the EnterpriseBatterySwap entity.
// If the EnterpriseBatterySwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBatterySwapMutation) OldCabinetID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCabinetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCabinetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCabinetID: %w", err)
	}
	return oldValue.CabinetID, nil
}

// ResetCabinetID resets all changes to the "cabinet_id" field.
func (m *EnterpriseBatterySwapMutation) ResetCabinetID() {
	m.cabinet = nil
}

// SetPutinID sets the "putin_id" field.
func (m *EnterpriseBatterySwapMutation) SetPutinID(u uint64) {
	m.putin = &u
}

// PutinID returns the value of the "putin_id" field in the mutation.
func (m *EnterpriseBatterySwapMutation) PutinID() (r uint64, exists bool) {
	v := m.putin
	if v == nil {
		return
	}
	return *v, true
}

// OldPutinID returns the old "putin_id" field's value of the EnterpriseBatterySwap entity.
// If the EnterpriseBatterySwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBatterySwapMutation) OldPutinID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPutinID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPutinID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPutinID: %w", err)
	}
	return oldValue.PutinID, nil
}

// ResetPutinID resets all changes to the "putin_id" field.
func (m *EnterpriseBatterySwapMutation) ResetPutinID() {
	m.putin = nil
}

// SetPutinSn sets the "putin_sn" field.
func (m *EnterpriseBatterySwapMutation) SetPutinSn(s string) {
	m.putin_sn = &s
}

// PutinSn returns the value of the "putin_sn" field in the mutation.
func (m *EnterpriseBatterySwapMutation) PutinSn() (r string, exists bool) {
	v := m.putin_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldPutinSn returns the old "putin_sn" field's value of the EnterpriseBatterySwap entity.
// If the EnterpriseBatterySwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBatterySwapMutation) OldPutinSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPutinSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPutinSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPutinSn: %w", err)
	}
	return oldValue.PutinSn, nil
}

// ResetPutinSn resets all changes to the "putin_sn" field.
func (m *EnterpriseBatterySwapMutation) ResetPutinSn() {
	m.putin_sn = nil
}

// SetPutinEnterpriseID sets the "putin_enterprise_id" field.
func (m *EnterpriseBatterySwapMutation) SetPutinEnterpriseID(u uint64) {
	m.putin_enterprise = &u
}

// PutinEnterpriseID returns the value of the "putin_enterprise_id" field in the mutation.
func (m *EnterpriseBatterySwapMutation) PutinEnterpriseID() (r uint64, exists bool) {
	v := m.putin_enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldPutinEnterpriseID returns the old "putin_enterprise_id" field's value of the EnterpriseBatterySwap entity.
// If the EnterpriseBatterySwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBatterySwapMutation) OldPutinEnterpriseID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPutinEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPutinEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPutinEnterpriseID: %w", err)
	}
	return oldValue.PutinEnterpriseID, nil
}

// ClearPutinEnterpriseID clears the value of the "putin_enterprise_id" field.
func (m *EnterpriseBatterySwapMutation) ClearPutinEnterpriseID() {
	m.putin_enterprise = nil
	m.clearedFields[enterprisebatteryswap.FieldPutinEnterpriseID] = struct{}{}
}

// PutinEnterpriseIDCleared returns if the "putin_enterprise_id" field was cleared in this mutation.
func (m *EnterpriseBatterySwapMutation) PutinEnterpriseIDCleared() bool {
	_, ok := m.clearedFields[enterprisebatteryswap.FieldPutinEnterpriseID]
	return ok
}

// ResetPutinEnterpriseID resets all changes to the "putin_enterprise_id" field.
func (m *EnterpriseBatterySwapMutation) ResetPutinEnterpriseID() {
	m.putin_enterprise = nil
	delete(m.clearedFields, enterprisebatteryswap.FieldPutinEnterpriseID)
}

// SetPutinStationID sets the "putin_station_id" field.
func (m *EnterpriseBatterySwapMutation) SetPutinStationID(u uint64) {
	m.putin_station = &u
}

// PutinStationID returns the value of the "putin_station_id" field in the mutation.
func (m *EnterpriseBatterySwapMutation) PutinStationID() (r uint64, exists bool) {
	v := m.putin_station
	if v == nil {
		return
	}
	return *v, true
}

// OldPutinStationID returns the old "putin_station_id" field's value of the EnterpriseBatterySwap entity.
// If the EnterpriseBatterySwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBatterySwapMutation) OldPutinStationID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPutinStationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPutinStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPutinStationID: %w", err)
	}
	return oldValue.PutinStationID, nil
}

// ClearPutinStationID clears the value of the "putin_station_id" field.
func (m *EnterpriseBatterySwapMutation) ClearPutinStationID() {
	m.putin_station = nil
	m.clearedFields[enterprisebatteryswap.FieldPutinStationID] = struct{}{}
}

// PutinStationIDCleared returns if the "putin_station_id" field was cleared in this mutation.
func (m *EnterpriseBatterySwapMutation) PutinStationIDCleared() bool {
	_, ok := m.clearedFields[enterprisebatteryswap.FieldPutinStationID]
	return ok
}

// ResetPutinStationID resets all changes to the "putin_station_id" field.
func (m *EnterpriseBatterySwapMutation) ResetPutinStationID() {
	m.putin_station = nil
	delete(m.clearedFields, enterprisebatteryswap.FieldPutinStationID)
}

// SetPutoutID sets the "putout_id" field.
func (m *EnterpriseBatterySwapMutation) SetPutoutID(u uint64) {
	m.putout = &u
}

// PutoutID returns the value of the "putout_id" field in the mutation.
func (m *EnterpriseBatterySwapMutation) PutoutID() (r uint64, exists bool) {
	v := m.putout
	if v == nil {
		return
	}
	return *v, true
}

// OldPutoutID returns the old "putout_id" field's value of the EnterpriseBatterySwap entity.
// If the EnterpriseBatterySwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBatterySwapMutation) OldPutoutID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPutoutID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPutoutID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPutoutID: %w", err)
	}
	return oldValue.PutoutID, nil
}

// ResetPutoutID resets all changes to the "putout_id" field.
func (m *EnterpriseBatterySwapMutation) ResetPutoutID() {
	m.putout = nil
}

// SetPutoutSn sets the "putout_sn" field.
func (m *EnterpriseBatterySwapMutation) SetPutoutSn(s string) {
	m.putout_sn = &s
}

// PutoutSn returns the value of the "putout_sn" field in the mutation.
func (m *EnterpriseBatterySwapMutation) PutoutSn() (r string, exists bool) {
	v := m.putout_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldPutoutSn returns the old "putout_sn" field's value of the EnterpriseBatterySwap entity.
// If the EnterpriseBatterySwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBatterySwapMutation) OldPutoutSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPutoutSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPutoutSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPutoutSn: %w", err)
	}
	return oldValue.PutoutSn, nil
}

// ResetPutoutSn resets all changes to the "putout_sn" field.
func (m *EnterpriseBatterySwapMutation) ResetPutoutSn() {
	m.putout_sn = nil
}

// SetPutoutEnterpriseID sets the "putout_enterprise_id" field.
func (m *EnterpriseBatterySwapMutation) SetPutoutEnterpriseID(u uint64) {
	m.putout_enterprise = &u
}

// PutoutEnterpriseID returns the value of the "putout_enterprise_id" field in the mutation.
func (m *EnterpriseBatterySwapMutation) PutoutEnterpriseID() (r uint64, exists bool) {
	v := m.putout_enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldPutoutEnterpriseID returns the old "putout_enterprise_id" field's value of the EnterpriseBatterySwap entity.
// If the EnterpriseBatterySwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBatterySwapMutation) OldPutoutEnterpriseID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPutoutEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPutoutEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPutoutEnterpriseID: %w", err)
	}
	return oldValue.PutoutEnterpriseID, nil
}

// ClearPutoutEnterpriseID clears the value of the "putout_enterprise_id" field.
func (m *EnterpriseBatterySwapMutation) ClearPutoutEnterpriseID() {
	m.putout_enterprise = nil
	m.clearedFields[enterprisebatteryswap.FieldPutoutEnterpriseID] = struct{}{}
}

// PutoutEnterpriseIDCleared returns if the "putout_enterprise_id" field was cleared in this mutation.
func (m *EnterpriseBatterySwapMutation) PutoutEnterpriseIDCleared() bool {
	_, ok := m.clearedFields[enterprisebatteryswap.FieldPutoutEnterpriseID]
	return ok
}

// ResetPutoutEnterpriseID resets all changes to the "putout_enterprise_id" field.
func (m *EnterpriseBatterySwapMutation) ResetPutoutEnterpriseID() {
	m.putout_enterprise = nil
	delete(m.clearedFields, enterprisebatteryswap.FieldPutoutEnterpriseID)
}

// SetPutoutStationID sets the "putout_station_id" field.
func (m *EnterpriseBatterySwapMutation) SetPutoutStationID(u uint64) {
	m.putout_station = &u
}

// PutoutStationID returns the value of the "putout_station_id" field in the mutation.
func (m *EnterpriseBatterySwapMutation) PutoutStationID() (r uint64, exists bool) {
	v := m.putout_station
	if v == nil {
		return
	}
	return *v, true
}

// OldPutoutStationID returns the old "putout_station_id" field's value of the EnterpriseBatterySwap entity.
// If the EnterpriseBatterySwap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBatterySwapMutation) OldPutoutStationID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPutoutStationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPutoutStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPutoutStationID: %w", err)
	}
	return oldValue.PutoutStationID, nil
}

// ClearPutoutStationID clears the value of the "putout_station_id" field.
func (m *EnterpriseBatterySwapMutation) ClearPutoutStationID() {
	m.putout_station = nil
	m.clearedFields[enterprisebatteryswap.FieldPutoutStationID] = struct{}{}
}

// PutoutStationIDCleared returns if the "putout_station_id" field was cleared in this mutation.
func (m *EnterpriseBatterySwapMutation) PutoutStationIDCleared() bool {
	_, ok := m.clearedFields[enterprisebatteryswap.FieldPutoutStationID]
	return ok
}

// ResetPutoutStationID resets all changes to the "putout_station_id" field.
func (m *EnterpriseBatterySwapMutation) ResetPutoutStationID() {
	m.putout_station = nil
	delete(m.clearedFields, enterprisebatteryswap.FieldPutoutStationID)
}

// ClearExchange clears the "exchange" edge to the Exchange entity.
func (m *EnterpriseBatterySwapMutation) ClearExchange() {
	m.clearedexchange = true
	m.clearedFields[enterprisebatteryswap.FieldExchangeID] = struct{}{}
}

// ExchangeCleared reports if the "exchange" edge to the Exchange entity was cleared.
func (m *EnterpriseBatterySwapMutation) ExchangeCleared() bool {
	return m.clearedexchange
}

// ExchangeIDs returns the "exchange" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ExchangeID instead. It exists only for internal usage by the builders.
func (m *EnterpriseBatterySwapMutation) ExchangeIDs() (ids []uint64) {
	if id := m.exchange; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExchange resets all changes to the "exchange" edge.
func (m *EnterpriseBatterySwapMutation) ResetExchange() {
	m.exchange = nil
	m.clearedexchange = false
}

// ClearCabinet clears the "cabinet" edge to the Cabinet entity.
func (m *EnterpriseBatterySwapMutation) ClearCabinet() {
	m.clearedcabinet = true
	m.clearedFields[enterprisebatteryswap.FieldCabinetID] = struct{}{}
}

// CabinetCleared reports if the "cabinet" edge to the Cabinet entity was cleared.
func (m *EnterpriseBatterySwapMutation) CabinetCleared() bool {
	return m.clearedcabinet
}

// CabinetIDs returns the "cabinet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CabinetID instead. It exists only for internal usage by the builders.
func (m *EnterpriseBatterySwapMutation) CabinetIDs() (ids []uint64) {
	if id := m.cabinet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCabinet resets all changes to the "cabinet" edge.
func (m *EnterpriseBatterySwapMutation) ResetCabinet() {
	m.cabinet = nil
	m.clearedcabinet = false
}

// ClearPutin clears the "putin" edge to the Battery entity.
func (m *EnterpriseBatterySwapMutation) ClearPutin() {
	m.clearedputin = true
	m.clearedFields[enterprisebatteryswap.FieldPutinID] = struct{}{}
}

// PutinCleared reports if the "putin" edge to the Battery entity was cleared.
func (m *EnterpriseBatterySwapMutation) PutinCleared() bool {
	return m.clearedputin
}

// PutinIDs returns the "putin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PutinID instead. It exists only for internal usage by the builders.
func (m *EnterpriseBatterySwapMutation) PutinIDs() (ids []uint64) {
	if id := m.putin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPutin resets all changes to the "putin" edge.
func (m *EnterpriseBatterySwapMutation) ResetPutin() {
	m.putin = nil
	m.clearedputin = false
}

// ClearPutinEnterprise clears the "putin_enterprise" edge to the Enterprise entity.
func (m *EnterpriseBatterySwapMutation) ClearPutinEnterprise() {
	m.clearedputin_enterprise = true
	m.clearedFields[enterprisebatteryswap.FieldPutinEnterpriseID] = struct{}{}
}

// PutinEnterpriseCleared reports if the "putin_enterprise" edge to the Enterprise entity was cleared.
func (m *EnterpriseBatterySwapMutation) PutinEnterpriseCleared() bool {
	return m.PutinEnterpriseIDCleared() || m.clearedputin_enterprise
}

// PutinEnterpriseIDs returns the "putin_enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PutinEnterpriseID instead. It exists only for internal usage by the builders.
func (m *EnterpriseBatterySwapMutation) PutinEnterpriseIDs() (ids []uint64) {
	if id := m.putin_enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPutinEnterprise resets all changes to the "putin_enterprise" edge.
func (m *EnterpriseBatterySwapMutation) ResetPutinEnterprise() {
	m.putin_enterprise = nil
	m.clearedputin_enterprise = false
}

// ClearPutinStation clears the "putin_station" edge to the EnterpriseStation entity.
func (m *EnterpriseBatterySwapMutation) ClearPutinStation() {
	m.clearedputin_station = true
	m.clearedFields[enterprisebatteryswap.FieldPutinStationID] = struct{}{}
}

// PutinStationCleared reports if the "putin_station" edge to the EnterpriseStation entity was cleared.
func (m *EnterpriseBatterySwapMutation) PutinStationCleared() bool {
	return m.PutinStationIDCleared() || m.clearedputin_station
}

// PutinStationIDs returns the "putin_station" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PutinStationID instead. It exists only for internal usage by the builders.
func (m *EnterpriseBatterySwapMutation) PutinStationIDs() (ids []uint64) {
	if id := m.putin_station; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPutinStation resets all changes to the "putin_station" edge.
func (m *EnterpriseBatterySwapMutation) ResetPutinStation() {
	m.putin_station = nil
	m.clearedputin_station = false
}

// ClearPutout clears the "putout" edge to the Battery entity.
func (m *EnterpriseBatterySwapMutation) ClearPutout() {
	m.clearedputout = true
	m.clearedFields[enterprisebatteryswap.FieldPutoutID] = struct{}{}
}

// PutoutCleared reports if the "putout" edge to the Battery entity was cleared.
func (m *EnterpriseBatterySwapMutation) PutoutCleared() bool {
	return m.clearedputout
}

// PutoutIDs returns the "putout" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PutoutID instead. It exists only for internal usage by the builders.
func (m *EnterpriseBatterySwapMutation) PutoutIDs() (ids []uint64) {
	if id := m.putout; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPutout resets all changes to the "putout" edge.
func (m *EnterpriseBatterySwapMutation) ResetPutout() {
	m.putout = nil
	m.clearedputout = false
}

// ClearPutoutEnterprise clears the "putout_enterprise" edge to the Enterprise entity.
func (m *EnterpriseBatterySwapMutation) ClearPutoutEnterprise() {
	m.clearedputout_enterprise = true
	m.clearedFields[enterprisebatteryswap.FieldPutoutEnterpriseID] = struct{}{}
}

// PutoutEnterpriseCleared reports if the "putout_enterprise" edge to the Enterprise entity was cleared.
func (m *EnterpriseBatterySwapMutation) PutoutEnterpriseCleared() bool {
	return m.PutoutEnterpriseIDCleared() || m.clearedputout_enterprise
}

// PutoutEnterpriseIDs returns the "putout_enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PutoutEnterpriseID instead. It exists only for internal usage by the builders.
func (m *EnterpriseBatterySwapMutation) PutoutEnterpriseIDs() (ids []uint64) {
	if id := m.putout_enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPutoutEnterprise resets all changes to the "putout_enterprise" edge.
func (m *EnterpriseBatterySwapMutation) ResetPutoutEnterprise() {
	m.putout_enterprise = nil
	m.clearedputout_enterprise = false
}

// ClearPutoutStation clears the "putout_station" edge to the EnterpriseStation entity.
func (m *EnterpriseBatterySwapMutation) ClearPutoutStation() {
	m.clearedputout_station = true
	m.clearedFields[enterprisebatteryswap.FieldPutoutStationID] = struct{}{}
}

// PutoutStationCleared reports if the "putout_station" edge to the EnterpriseStation entity was cleared.
func (m *EnterpriseBatterySwapMutation) PutoutStationCleared() bool {
	return m.PutoutStationIDCleared() || m.clearedputout_station
}

// PutoutStationIDs returns the "putout_station" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PutoutStationID instead. It exists only for internal usage by the builders.
func (m *EnterpriseBatterySwapMutation) PutoutStationIDs() (ids []uint64) {
	if id := m.putout_station; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPutoutStation resets all changes to the "putout_station" edge.
func (m *EnterpriseBatterySwapMutation) ResetPutoutStation() {
	m.putout_station = nil
	m.clearedputout_station = false
}

// Where appends a list predicates to the EnterpriseBatterySwapMutation builder.
func (m *EnterpriseBatterySwapMutation) Where(ps ...predicate.EnterpriseBatterySwap) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnterpriseBatterySwapMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnterpriseBatterySwapMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EnterpriseBatterySwap, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnterpriseBatterySwapMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnterpriseBatterySwapMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EnterpriseBatterySwap).
func (m *EnterpriseBatterySwapMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnterpriseBatterySwapMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, enterprisebatteryswap.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enterprisebatteryswap.FieldUpdatedAt)
	}
	if m.exchange != nil {
		fields = append(fields, enterprisebatteryswap.FieldExchangeID)
	}
	if m.cabinet != nil {
		fields = append(fields, enterprisebatteryswap.FieldCabinetID)
	}
	if m.putin != nil {
		fields = append(fields, enterprisebatteryswap.FieldPutinID)
	}
	if m.putin_sn != nil {
		fields = append(fields, enterprisebatteryswap.FieldPutinSn)
	}
	if m.putin_enterprise != nil {
		fields = append(fields, enterprisebatteryswap.FieldPutinEnterpriseID)
	}
	if m.putin_station != nil {
		fields = append(fields, enterprisebatteryswap.FieldPutinStationID)
	}
	if m.putout != nil {
		fields = append(fields, enterprisebatteryswap.FieldPutoutID)
	}
	if m.putout_sn != nil {
		fields = append(fields, enterprisebatteryswap.FieldPutoutSn)
	}
	if m.putout_enterprise != nil {
		fields = append(fields, enterprisebatteryswap.FieldPutoutEnterpriseID)
	}
	if m.putout_station != nil {
		fields = append(fields, enterprisebatteryswap.FieldPutoutStationID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnterpriseBatterySwapMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enterprisebatteryswap.FieldCreatedAt:
		return m.CreatedAt()
	case enterprisebatteryswap.FieldUpdatedAt:
		return m.UpdatedAt()
	case enterprisebatteryswap.FieldExchangeID:
		return m.ExchangeID()
	case enterprisebatteryswap.FieldCabinetID:
		return m.CabinetID()
	case enterprisebatteryswap.FieldPutinID:
		return m.PutinID()
	case enterprisebatteryswap.FieldPutinSn:
		return m.PutinSn()
	case enterprisebatteryswap.FieldPutinEnterpriseID:
		return m.PutinEnterpriseID()
	case enterprisebatteryswap.FieldPutinStationID:
		return m.PutinStationID()
	case enterprisebatteryswap.FieldPutoutID:
		return m.PutoutID()
	case enterprisebatteryswap.FieldPutoutSn:
		return m.PutoutSn()
	case enterprisebatteryswap.FieldPutoutEnterpriseID:
		return m.PutoutEnterpriseID()
	case enterprisebatteryswap.FieldPutoutStationID:
		return m.PutoutStationID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnterpriseBatterySwapMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enterprisebatteryswap.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enterprisebatteryswap.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case enterprisebatteryswap.FieldExchangeID:
		return m.OldExchangeID(ctx)
	case enterprisebatteryswap.FieldCabinetID:
		return m.OldCabinetID(ctx)
	case enterprisebatteryswap.FieldPutinID:
		return m.OldPutinID(ctx)
	case enterprisebatteryswap.FieldPutinSn:
		return m.OldPutinSn(ctx)
	case enterprisebatteryswap.FieldPutinEnterpriseID:
		return m.OldPutinEnterpriseID(ctx)
	case enterprisebatteryswap.FieldPutinStationID:
		return m.OldPutinStationID(ctx)
	case enterprisebatteryswap.FieldPutoutID:
		return m.OldPutoutID(ctx)
	case enterprisebatteryswap.FieldPutoutSn:
		return m.OldPutoutSn(ctx)
	case enterprisebatteryswap.FieldPutoutEnterpriseID:
		return m.OldPutoutEnterpriseID(ctx)
	case enterprisebatteryswap.FieldPutoutStationID:
		return m.OldPutoutStationID(ctx)
	}
	return nil, fmt.Errorf("unknown EnterpriseBatterySwap field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseBatterySwapMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enterprisebatteryswap.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enterprisebatteryswap.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case enterprisebatteryswap.FieldExchangeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExchangeID(v)
		return nil
	case enterprisebatteryswap.FieldCabinetID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCabinetID(v)
		return nil
	case enterprisebatteryswap.FieldPutinID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPutinID(v)
		return nil
	case enterprisebatteryswap.FieldPutinSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPutinSn(v)
		return nil
	case enterprisebatteryswap.FieldPutinEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPutinEnterpriseID(v)
		return nil
	case enterprisebatteryswap.FieldPutinStationID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPutinStationID(v)
		return nil
	case enterprisebatteryswap.FieldPutoutID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPutoutID(v)
		return nil
	case enterprisebatteryswap.FieldPutoutSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPutoutSn(v)
		return nil
	case enterprisebatteryswap.FieldPutoutEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPutoutEnterpriseID(v)
		return nil
	case enterprisebatteryswap.FieldPutoutStationID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPutoutStationID(v)
		return nil
	}
	return fmt.Errorf("unknown EnterpriseBatterySwap field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnterpriseBatterySwapMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnterpriseBatterySwapMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseBatterySwapMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EnterpriseBatterySwap numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnterpriseBatterySwapMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(enterprisebatteryswap.FieldPutinEnterpriseID) {
		fields = append(fields, enterprisebatteryswap.FieldPutinEnterpriseID)
	}
	if m.FieldCleared(enterprisebatteryswap.FieldPutinStationID) {
		fields = append(fields, enterprisebatteryswap.FieldPutinStationID)
	}
	if m.FieldCleared(enterprisebatteryswap.FieldPutoutEnterpriseID) {
		fields = append(fields, enterprisebatteryswap.FieldPutoutEnterpriseID)
	}
	if m.FieldCleared(enterprisebatteryswap.FieldPutoutStationID) {
		fields = append(fields, enterprisebatteryswap.FieldPutoutStationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnterpriseBatterySwapMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnterpriseBatterySwapMutation) ClearField(name string) error {
	switch name {
	case enterprisebatteryswap.FieldPutinEnterpriseID:
		m.ClearPutinEnterpriseID()
		return nil
	case enterprisebatteryswap.FieldPutinStationID:
		m.ClearPutinStationID()
		return nil
	case enterprisebatteryswap.FieldPutoutEnterpriseID:
		m.ClearPutoutEnterpriseID()
		return nil
	case enterprisebatteryswap.FieldPutoutStationID:
		m.ClearPutoutStationID()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseBatterySwap nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnterpriseBatterySwapMutation) ResetField(name string) error {
	switch name {
	case enterprisebatteryswap.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enterprisebatteryswap.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case enterprisebatteryswap.FieldExchangeID:
		m.ResetExchangeID()
		return nil
	case enterprisebatteryswap.FieldCabinetID:
		m.ResetCabinetID()
		return nil
	case enterprisebatteryswap.FieldPutinID:
		m.ResetPutinID()
		return nil
	case enterprisebatteryswap.FieldPutinSn:
		m.ResetPutinSn()
		return nil
	case enterprisebatteryswap.FieldPutinEnterpriseID:
		m.ResetPutinEnterpriseID()
		return nil
	case enterprisebatteryswap.FieldPutinStationID:
		m.ResetPutinStationID()
		return nil
	case enterprisebatteryswap.FieldPutoutID:
		m.ResetPutoutID()
		return nil
	case enterprisebatteryswap.FieldPutoutSn:
		m.ResetPutoutSn()
		return nil
	case enterprisebatteryswap.FieldPutoutEnterpriseID:
		m.ResetPutoutEnterpriseID()
		return nil
	case enterprisebatteryswap.FieldPutoutStationID:
		m.ResetPutoutStationID()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseBatterySwap field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnterpriseBatterySwapMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.exchange != nil {
		edges = append(edges, enterprisebatteryswap.EdgeExchange)
	}
	if m.cabinet != nil {
		edges = append(edges, enterprisebatteryswap.EdgeCabinet)
	}
	if m.putin != nil {
		edges = append(edges, enterprisebatteryswap.EdgePutin)
	}
	if m.putin_enterprise != nil {
		edges = append(edges, enterprisebatteryswap.EdgePutinEnterprise)
	}
	if m.putin_station != nil {
		edges = append(edges, enterprisebatteryswap.EdgePutinStation)
	}
	if m.putout != nil {
		edges = append(edges, enterprisebatteryswap.EdgePutout)
	}
	if m.putout_enterprise != nil {
		edges = append(edges, enterprisebatteryswap.EdgePutoutEnterprise)
	}
	if m.putout_station != nil {
		edges = append(edges, enterprisebatteryswap.EdgePutoutStation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnterpriseBatterySwapMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enterprisebatteryswap.EdgeExchange:
		if id := m.exchange; id != nil {
			return []ent.Value{*id}
		}
	case enterprisebatteryswap.EdgeCabinet:
		if id := m.cabinet; id != nil {
			return []ent.Value{*id}
		}
	case enterprisebatteryswap.EdgePutin:
		if id := m.putin; id != nil {
			return []ent.Value{*id}
		}
	case enterprisebatteryswap.EdgePutinEnterprise:
		if id := m.putin_enterprise; id != nil {
			return []ent.Value{*id}
		}
	case enterprisebatteryswap.EdgePutinStation:
		if id := m.putin_station; id != nil {
			return []ent.Value{*id}
		}
	case enterprisebatteryswap.EdgePutout:
		if id := m.putout; id != nil {
			return []ent.Value{*id}
		}
	case enterprisebatteryswap.EdgePutoutEnterprise:
		if id := m.putout_enterprise; id != nil {
			return []ent.Value{*id}
		}
	case enterprisebatteryswap.EdgePutoutStation:
		if id := m.putout_station; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnterpriseBatterySwapMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnterpriseBatterySwapMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnterpriseBatterySwapMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedexchange {
		edges = append(edges, enterprisebatteryswap.EdgeExchange)
	}
	if m.clearedcabinet {
		edges = append(edges, enterprisebatteryswap.EdgeCabinet)
	}
	if m.clearedputin {
		edges = append(edges, enterprisebatteryswap.EdgePutin)
	}
	if m.clearedputin_enterprise {
		edges = append(edges, enterprisebatteryswap.EdgePutinEnterprise)
	}
	if m.clearedputin_station {
		edges = append(edges, enterprisebatteryswap.EdgePutinStation)
	}
	if m.clearedputout {
		edges = append(edges, enterprisebatteryswap.EdgePutout)
	}
	if m.clearedputout_enterprise {
		edges = append(edges, enterprisebatteryswap.EdgePutoutEnterprise)
	}
	if m.clearedputout_station {
		edges = append(edges, enterprisebatteryswap.EdgePutoutStation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnterpriseBatterySwapMutation) EdgeCleared(name string) bool {
	switch name {
	case enterprisebatteryswap.EdgeExchange:
		return m.clearedexchange
	case enterprisebatteryswap.EdgeCabinet:
		return m.clearedcabinet
	case enterprisebatteryswap.EdgePutin:
		return m.clearedputin
	case enterprisebatteryswap.EdgePutinEnterprise:
		return m.clearedputin_enterprise
	case enterprisebatteryswap.EdgePutinStation:
		return m.clearedputin_station
	case enterprisebatteryswap.EdgePutout:
		return m.clearedputout
	case enterprisebatteryswap.EdgePutoutEnterprise:
		return m.clearedputout_enterprise
	case enterprisebatteryswap.EdgePutoutStation:
		return m.clearedputout_station
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnterpriseBatterySwapMutation) ClearEdge(name string) error {
	switch name {
	case enterprisebatteryswap.EdgeExchange:
		m.ClearExchange()
		return nil
	case enterprisebatteryswap.EdgeCabinet:
		m.ClearCabinet()
		return nil
	case enterprisebatteryswap.EdgePutin:
		m.ClearPutin()
		return nil
	case enterprisebatteryswap.EdgePutinEnterprise:
		m.ClearPutinEnterprise()
		return nil
	case enterprisebatteryswap.EdgePutinStation:
		m.ClearPutinStation()
		return nil
	case enterprisebatteryswap.EdgePutout:
		m.ClearPutout()
		return nil
	case enterprisebatteryswap.EdgePutoutEnterprise:
		m.ClearPutoutEnterprise()
		return nil
	case enterprisebatteryswap.EdgePutoutStation:
		m.ClearPutoutStation()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseBatterySwap unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnterpriseBatterySwapMutation) ResetEdge(name string) error {
	switch name {
	case enterprisebatteryswap.EdgeExchange:
		m.ResetExchange()
		return nil
	case enterprisebatteryswap.EdgeCabinet:
		m.ResetCabinet()
		return nil
	case enterprisebatteryswap.EdgePutin:
		m.ResetPutin()
		return nil
	case enterprisebatteryswap.EdgePutinEnterprise:
		m.ResetPutinEnterprise()
		return nil
	case enterprisebatteryswap.EdgePutinStation:
		m.ResetPutinStation()
		return nil
	case enterprisebatteryswap.EdgePutout:
		m.ResetPutout()
		return nil
	case enterprisebatteryswap.EdgePutoutEnterprise:
		m.ResetPutoutEnterprise()
		return nil
	case enterprisebatteryswap.EdgePutoutStation:
		m.ResetPutoutStation()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseBatterySwap edge %s", name)
}

// EnterpriseBillMutation represents an operation that mutates the EnterpriseBill nodes in the graph.
type EnterpriseBillMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	start             *time.Time
	end               *time.Time
	days              *int
	adddays           *int
	price             *float64
	addprice          *float64
	cost              *float64
	addcost           *float64
	model             *string
	clearedFields     map[string]struct{}
	rider             *uint64
	clearedrider      bool
	city              *uint64
	clearedcity       bool
	station           *uint64
	clearedstation    bool
	enterprise        *uint64
	clearedenterprise bool
	statement         *uint64
	clearedstatement  bool
	subscribe         *uint64
	clearedsubscribe  bool
	done              bool
	oldValue          func(context.Context) (*EnterpriseBill, error)
	predicates        []predicate.EnterpriseBill
}

var _ ent.Mutation = (*EnterpriseBillMutation)(nil)

// enterprisebillOption allows management of the mutation configuration using functional options.
type enterprisebillOption func(*EnterpriseBillMutation)

// newEnterpriseBillMutation creates new mutation for the EnterpriseBill entity.
func newEnterpriseBillMutation(c config, op Op, opts ...enterprisebillOption) *EnterpriseBillMutation {
	m := &EnterpriseBillMutation{
		config:        c,
		op:            op,
		typ:           TypeEnterpriseBill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnterpriseBillID sets the ID field of the mutation.
func withEnterpriseBillID(id uint64) enterprisebillOption {
	return func(m *EnterpriseBillMutation) {
		var (
			err   error
			once  sync.Once
			value *EnterpriseBill
		)
		m.oldValue = func(ctx context.Context) (*EnterpriseBill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnterpriseBill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnterpriseBill sets the old EnterpriseBill of the mutation.
func withEnterpriseBill(node *EnterpriseBill) enterprisebillOption {
	return func(m *EnterpriseBillMutation) {
		m.oldValue = func(context.Context) (*EnterpriseBill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnterpriseBillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnterpriseBillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnterpriseBillMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnterpriseBillMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnterpriseBill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EnterpriseBillMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnterpriseBillMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnterpriseBillMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnterpriseBillMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnterpriseBillMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnterpriseBillMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EnterpriseBillMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EnterpriseBillMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EnterpriseBillMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[enterprisebill.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EnterpriseBillMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[enterprisebill.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EnterpriseBillMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, enterprisebill.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *EnterpriseBillMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *EnterpriseBillMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *EnterpriseBillMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[enterprisebill.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *EnterpriseBillMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[enterprisebill.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *EnterpriseBillMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, enterprisebill.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *EnterpriseBillMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *EnterpriseBillMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *EnterpriseBillMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[enterprisebill.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *EnterpriseBillMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[enterprisebill.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *EnterpriseBillMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, enterprisebill.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *EnterpriseBillMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *EnterpriseBillMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *EnterpriseBillMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[enterprisebill.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *EnterpriseBillMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[enterprisebill.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *EnterpriseBillMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, enterprisebill.FieldRemark)
}

// SetRiderID sets the "rider_id" field.
func (m *EnterpriseBillMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *EnterpriseBillMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *EnterpriseBillMutation) ResetRiderID() {
	m.rider = nil
}

// SetCityID sets the "city_id" field.
func (m *EnterpriseBillMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *EnterpriseBillMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *EnterpriseBillMutation) ResetCityID() {
	m.city = nil
}

// SetStationID sets the "station_id" field.
func (m *EnterpriseBillMutation) SetStationID(u uint64) {
	m.station = &u
}

// StationID returns the value of the "station_id" field in the mutation.
func (m *EnterpriseBillMutation) StationID() (r uint64, exists bool) {
	v := m.station
	if v == nil {
		return
	}
	return *v, true
}

// OldStationID returns the old "station_id" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldStationID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStationID: %w", err)
	}
	return oldValue.StationID, nil
}

// ClearStationID clears the value of the "station_id" field.
func (m *EnterpriseBillMutation) ClearStationID() {
	m.station = nil
	m.clearedFields[enterprisebill.FieldStationID] = struct{}{}
}

// StationIDCleared returns if the "station_id" field was cleared in this mutation.
func (m *EnterpriseBillMutation) StationIDCleared() bool {
	_, ok := m.clearedFields[enterprisebill.FieldStationID]
	return ok
}

// ResetStationID resets all changes to the "station_id" field.
func (m *EnterpriseBillMutation) ResetStationID() {
	m.station = nil
	delete(m.clearedFields, enterprisebill.FieldStationID)
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *EnterpriseBillMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *EnterpriseBillMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldSubscribeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *EnterpriseBillMutation) ResetSubscribeID() {
	m.subscribe = nil
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *EnterpriseBillMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *EnterpriseBillMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldEnterpriseID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *EnterpriseBillMutation) ResetEnterpriseID() {
	m.enterprise = nil
}

// SetStatementID sets the "statement_id" field.
func (m *EnterpriseBillMutation) SetStatementID(u uint64) {
	m.statement = &u
}

// StatementID returns the value of the "statement_id" field in the mutation.
func (m *EnterpriseBillMutation) StatementID() (r uint64, exists bool) {
	v := m.statement
	if v == nil {
		return
	}
	return *v, true
}

// OldStatementID returns the old "statement_id" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldStatementID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatementID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatementID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatementID: %w", err)
	}
	return oldValue.StatementID, nil
}

// ResetStatementID resets all changes to the "statement_id" field.
func (m *EnterpriseBillMutation) ResetStatementID() {
	m.statement = nil
}

// SetStart sets the "start" field.
func (m *EnterpriseBillMutation) SetStart(t time.Time) {
	m.start = &t
}

// Start returns the value of the "start" field in the mutation.
func (m *EnterpriseBillMutation) Start() (r time.Time, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// ResetStart resets all changes to the "start" field.
func (m *EnterpriseBillMutation) ResetStart() {
	m.start = nil
}

// SetEnd sets the "end" field.
func (m *EnterpriseBillMutation) SetEnd(t time.Time) {
	m.end = &t
}

// End returns the value of the "end" field in the mutation.
func (m *EnterpriseBillMutation) End() (r time.Time, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// ResetEnd resets all changes to the "end" field.
func (m *EnterpriseBillMutation) ResetEnd() {
	m.end = nil
}

// SetDays sets the "days" field.
func (m *EnterpriseBillMutation) SetDays(i int) {
	m.days = &i
	m.adddays = nil
}

// Days returns the value of the "days" field in the mutation.
func (m *EnterpriseBillMutation) Days() (r int, exists bool) {
	v := m.days
	if v == nil {
		return
	}
	return *v, true
}

// OldDays returns the old "days" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDays: %w", err)
	}
	return oldValue.Days, nil
}

// AddDays adds i to the "days" field.
func (m *EnterpriseBillMutation) AddDays(i int) {
	if m.adddays != nil {
		*m.adddays += i
	} else {
		m.adddays = &i
	}
}

// AddedDays returns the value that was added to the "days" field in this mutation.
func (m *EnterpriseBillMutation) AddedDays() (r int, exists bool) {
	v := m.adddays
	if v == nil {
		return
	}
	return *v, true
}

// ResetDays resets all changes to the "days" field.
func (m *EnterpriseBillMutation) ResetDays() {
	m.days = nil
	m.adddays = nil
}

// SetPrice sets the "price" field.
func (m *EnterpriseBillMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *EnterpriseBillMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *EnterpriseBillMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *EnterpriseBillMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *EnterpriseBillMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetCost sets the "cost" field.
func (m *EnterpriseBillMutation) SetCost(f float64) {
	m.cost = &f
	m.addcost = nil
}

// Cost returns the value of the "cost" field in the mutation.
func (m *EnterpriseBillMutation) Cost() (r float64, exists bool) {
	v := m.cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCost returns the old "cost" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCost: %w", err)
	}
	return oldValue.Cost, nil
}

// AddCost adds f to the "cost" field.
func (m *EnterpriseBillMutation) AddCost(f float64) {
	if m.addcost != nil {
		*m.addcost += f
	} else {
		m.addcost = &f
	}
}

// AddedCost returns the value that was added to the "cost" field in this mutation.
func (m *EnterpriseBillMutation) AddedCost() (r float64, exists bool) {
	v := m.addcost
	if v == nil {
		return
	}
	return *v, true
}

// ResetCost resets all changes to the "cost" field.
func (m *EnterpriseBillMutation) ResetCost() {
	m.cost = nil
	m.addcost = nil
}

// SetModel sets the "model" field.
func (m *EnterpriseBillMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *EnterpriseBillMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the EnterpriseBill entity.
// If the EnterpriseBill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseBillMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *EnterpriseBillMutation) ResetModel() {
	m.model = nil
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *EnterpriseBillMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[enterprisebill.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *EnterpriseBillMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *EnterpriseBillMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *EnterpriseBillMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *EnterpriseBillMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[enterprisebill.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *EnterpriseBillMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *EnterpriseBillMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *EnterpriseBillMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearStation clears the "station" edge to the EnterpriseStation entity.
func (m *EnterpriseBillMutation) ClearStation() {
	m.clearedstation = true
	m.clearedFields[enterprisebill.FieldStationID] = struct{}{}
}

// StationCleared reports if the "station" edge to the EnterpriseStation entity was cleared.
func (m *EnterpriseBillMutation) StationCleared() bool {
	return m.StationIDCleared() || m.clearedstation
}

// StationIDs returns the "station" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StationID instead. It exists only for internal usage by the builders.
func (m *EnterpriseBillMutation) StationIDs() (ids []uint64) {
	if id := m.station; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStation resets all changes to the "station" edge.
func (m *EnterpriseBillMutation) ResetStation() {
	m.station = nil
	m.clearedstation = false
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *EnterpriseBillMutation) ClearEnterprise() {
	m.clearedenterprise = true
	m.clearedFields[enterprisebill.FieldEnterpriseID] = struct{}{}
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *EnterpriseBillMutation) EnterpriseCleared() bool {
	return m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *EnterpriseBillMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *EnterpriseBillMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// ClearStatement clears the "statement" edge to the EnterpriseStatement entity.
func (m *EnterpriseBillMutation) ClearStatement() {
	m.clearedstatement = true
	m.clearedFields[enterprisebill.FieldStatementID] = struct{}{}
}

// StatementCleared reports if the "statement" edge to the EnterpriseStatement entity was cleared.
func (m *EnterpriseBillMutation) StatementCleared() bool {
	return m.clearedstatement
}

// StatementIDs returns the "statement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StatementID instead. It exists only for internal usage by the builders.
func (m *EnterpriseBillMutation) StatementIDs() (ids []uint64) {
	if id := m.statement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatement resets all changes to the "statement" edge.
func (m *EnterpriseBillMutation) ResetStatement() {
	m.statement = nil
	m.clearedstatement = false
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *EnterpriseBillMutation) ClearSubscribe() {
	m.clearedsubscribe = true
	m.clearedFields[enterprisebill.FieldSubscribeID] = struct{}{}
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *EnterpriseBillMutation) SubscribeCleared() bool {
	return m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *EnterpriseBillMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *EnterpriseBillMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// Where appends a list predicates to the EnterpriseBillMutation builder.
func (m *EnterpriseBillMutation) Where(ps ...predicate.EnterpriseBill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnterpriseBillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnterpriseBillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EnterpriseBill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnterpriseBillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnterpriseBillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EnterpriseBill).
func (m *EnterpriseBillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnterpriseBillMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, enterprisebill.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enterprisebill.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, enterprisebill.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, enterprisebill.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, enterprisebill.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, enterprisebill.FieldRemark)
	}
	if m.rider != nil {
		fields = append(fields, enterprisebill.FieldRiderID)
	}
	if m.city != nil {
		fields = append(fields, enterprisebill.FieldCityID)
	}
	if m.station != nil {
		fields = append(fields, enterprisebill.FieldStationID)
	}
	if m.subscribe != nil {
		fields = append(fields, enterprisebill.FieldSubscribeID)
	}
	if m.enterprise != nil {
		fields = append(fields, enterprisebill.FieldEnterpriseID)
	}
	if m.statement != nil {
		fields = append(fields, enterprisebill.FieldStatementID)
	}
	if m.start != nil {
		fields = append(fields, enterprisebill.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, enterprisebill.FieldEnd)
	}
	if m.days != nil {
		fields = append(fields, enterprisebill.FieldDays)
	}
	if m.price != nil {
		fields = append(fields, enterprisebill.FieldPrice)
	}
	if m.cost != nil {
		fields = append(fields, enterprisebill.FieldCost)
	}
	if m.model != nil {
		fields = append(fields, enterprisebill.FieldModel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnterpriseBillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enterprisebill.FieldCreatedAt:
		return m.CreatedAt()
	case enterprisebill.FieldUpdatedAt:
		return m.UpdatedAt()
	case enterprisebill.FieldDeletedAt:
		return m.DeletedAt()
	case enterprisebill.FieldCreator:
		return m.Creator()
	case enterprisebill.FieldLastModifier:
		return m.LastModifier()
	case enterprisebill.FieldRemark:
		return m.Remark()
	case enterprisebill.FieldRiderID:
		return m.RiderID()
	case enterprisebill.FieldCityID:
		return m.CityID()
	case enterprisebill.FieldStationID:
		return m.StationID()
	case enterprisebill.FieldSubscribeID:
		return m.SubscribeID()
	case enterprisebill.FieldEnterpriseID:
		return m.EnterpriseID()
	case enterprisebill.FieldStatementID:
		return m.StatementID()
	case enterprisebill.FieldStart:
		return m.Start()
	case enterprisebill.FieldEnd:
		return m.End()
	case enterprisebill.FieldDays:
		return m.Days()
	case enterprisebill.FieldPrice:
		return m.Price()
	case enterprisebill.FieldCost:
		return m.Cost()
	case enterprisebill.FieldModel:
		return m.Model()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnterpriseBillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enterprisebill.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enterprisebill.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case enterprisebill.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case enterprisebill.FieldCreator:
		return m.OldCreator(ctx)
	case enterprisebill.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case enterprisebill.FieldRemark:
		return m.OldRemark(ctx)
	case enterprisebill.FieldRiderID:
		return m.OldRiderID(ctx)
	case enterprisebill.FieldCityID:
		return m.OldCityID(ctx)
	case enterprisebill.FieldStationID:
		return m.OldStationID(ctx)
	case enterprisebill.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case enterprisebill.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case enterprisebill.FieldStatementID:
		return m.OldStatementID(ctx)
	case enterprisebill.FieldStart:
		return m.OldStart(ctx)
	case enterprisebill.FieldEnd:
		return m.OldEnd(ctx)
	case enterprisebill.FieldDays:
		return m.OldDays(ctx)
	case enterprisebill.FieldPrice:
		return m.OldPrice(ctx)
	case enterprisebill.FieldCost:
		return m.OldCost(ctx)
	case enterprisebill.FieldModel:
		return m.OldModel(ctx)
	}
	return nil, fmt.Errorf("unknown EnterpriseBill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseBillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enterprisebill.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enterprisebill.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case enterprisebill.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case enterprisebill.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case enterprisebill.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case enterprisebill.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case enterprisebill.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case enterprisebill.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case enterprisebill.FieldStationID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStationID(v)
		return nil
	case enterprisebill.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case enterprisebill.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case enterprisebill.FieldStatementID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatementID(v)
		return nil
	case enterprisebill.FieldStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case enterprisebill.FieldEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case enterprisebill.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDays(v)
		return nil
	case enterprisebill.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case enterprisebill.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCost(v)
		return nil
	case enterprisebill.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	}
	return fmt.Errorf("unknown EnterpriseBill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnterpriseBillMutation) AddedFields() []string {
	var fields []string
	if m.adddays != nil {
		fields = append(fields, enterprisebill.FieldDays)
	}
	if m.addprice != nil {
		fields = append(fields, enterprisebill.FieldPrice)
	}
	if m.addcost != nil {
		fields = append(fields, enterprisebill.FieldCost)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnterpriseBillMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case enterprisebill.FieldDays:
		return m.AddedDays()
	case enterprisebill.FieldPrice:
		return m.AddedPrice()
	case enterprisebill.FieldCost:
		return m.AddedCost()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseBillMutation) AddField(name string, value ent.Value) error {
	switch name {
	case enterprisebill.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDays(v)
		return nil
	case enterprisebill.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case enterprisebill.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCost(v)
		return nil
	}
	return fmt.Errorf("unknown EnterpriseBill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnterpriseBillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(enterprisebill.FieldDeletedAt) {
		fields = append(fields, enterprisebill.FieldDeletedAt)
	}
	if m.FieldCleared(enterprisebill.FieldCreator) {
		fields = append(fields, enterprisebill.FieldCreator)
	}
	if m.FieldCleared(enterprisebill.FieldLastModifier) {
		fields = append(fields, enterprisebill.FieldLastModifier)
	}
	if m.FieldCleared(enterprisebill.FieldRemark) {
		fields = append(fields, enterprisebill.FieldRemark)
	}
	if m.FieldCleared(enterprisebill.FieldStationID) {
		fields = append(fields, enterprisebill.FieldStationID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnterpriseBillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnterpriseBillMutation) ClearField(name string) error {
	switch name {
	case enterprisebill.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case enterprisebill.FieldCreator:
		m.ClearCreator()
		return nil
	case enterprisebill.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case enterprisebill.FieldRemark:
		m.ClearRemark()
		return nil
	case enterprisebill.FieldStationID:
		m.ClearStationID()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseBill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnterpriseBillMutation) ResetField(name string) error {
	switch name {
	case enterprisebill.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enterprisebill.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case enterprisebill.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case enterprisebill.FieldCreator:
		m.ResetCreator()
		return nil
	case enterprisebill.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case enterprisebill.FieldRemark:
		m.ResetRemark()
		return nil
	case enterprisebill.FieldRiderID:
		m.ResetRiderID()
		return nil
	case enterprisebill.FieldCityID:
		m.ResetCityID()
		return nil
	case enterprisebill.FieldStationID:
		m.ResetStationID()
		return nil
	case enterprisebill.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case enterprisebill.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case enterprisebill.FieldStatementID:
		m.ResetStatementID()
		return nil
	case enterprisebill.FieldStart:
		m.ResetStart()
		return nil
	case enterprisebill.FieldEnd:
		m.ResetEnd()
		return nil
	case enterprisebill.FieldDays:
		m.ResetDays()
		return nil
	case enterprisebill.FieldPrice:
		m.ResetPrice()
		return nil
	case enterprisebill.FieldCost:
		m.ResetCost()
		return nil
	case enterprisebill.FieldModel:
		m.ResetModel()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseBill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnterpriseBillMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.rider != nil {
		edges = append(edges, enterprisebill.EdgeRider)
	}
	if m.city != nil {
		edges = append(edges, enterprisebill.EdgeCity)
	}
	if m.station != nil {
		edges = append(edges, enterprisebill.EdgeStation)
	}
	if m.enterprise != nil {
		edges = append(edges, enterprisebill.EdgeEnterprise)
	}
	if m.statement != nil {
		edges = append(edges, enterprisebill.EdgeStatement)
	}
	if m.subscribe != nil {
		edges = append(edges, enterprisebill.EdgeSubscribe)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnterpriseBillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enterprisebill.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case enterprisebill.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case enterprisebill.EdgeStation:
		if id := m.station; id != nil {
			return []ent.Value{*id}
		}
	case enterprisebill.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	case enterprisebill.EdgeStatement:
		if id := m.statement; id != nil {
			return []ent.Value{*id}
		}
	case enterprisebill.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnterpriseBillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnterpriseBillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnterpriseBillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedrider {
		edges = append(edges, enterprisebill.EdgeRider)
	}
	if m.clearedcity {
		edges = append(edges, enterprisebill.EdgeCity)
	}
	if m.clearedstation {
		edges = append(edges, enterprisebill.EdgeStation)
	}
	if m.clearedenterprise {
		edges = append(edges, enterprisebill.EdgeEnterprise)
	}
	if m.clearedstatement {
		edges = append(edges, enterprisebill.EdgeStatement)
	}
	if m.clearedsubscribe {
		edges = append(edges, enterprisebill.EdgeSubscribe)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnterpriseBillMutation) EdgeCleared(name string) bool {
	switch name {
	case enterprisebill.EdgeRider:
		return m.clearedrider
	case enterprisebill.EdgeCity:
		return m.clearedcity
	case enterprisebill.EdgeStation:
		return m.clearedstation
	case enterprisebill.EdgeEnterprise:
		return m.clearedenterprise
	case enterprisebill.EdgeStatement:
		return m.clearedstatement
	case enterprisebill.EdgeSubscribe:
		return m.clearedsubscribe
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnterpriseBillMutation) ClearEdge(name string) error {
	switch name {
	case enterprisebill.EdgeRider:
		m.ClearRider()
		return nil
	case enterprisebill.EdgeCity:
		m.ClearCity()
		return nil
	case enterprisebill.EdgeStation:
		m.ClearStation()
		return nil
	case enterprisebill.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	case enterprisebill.EdgeStatement:
		m.ClearStatement()
		return nil
	case enterprisebill.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseBill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnterpriseBillMutation) ResetEdge(name string) error {
	switch name {
	case enterprisebill.EdgeRider:
		m.ResetRider()
		return nil
	case enterprisebill.EdgeCity:
		m.ResetCity()
		return nil
	case enterprisebill.EdgeStation:
		m.ResetStation()
		return nil
	case enterprisebill.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	case enterprisebill.EdgeStatement:
		m.ResetStatement()
		return nil
	case enterprisebill.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseBill edge %s", name)
}

// EnterpriseContractMutation represents an operation that mutates the EnterpriseContract nodes in the graph.
type EnterpriseContractMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	start             *time.Time
	end               *time.Time
	file              *string
	clearedFields     map[string]struct{}
	enterprise        *uint64
	clearedenterprise bool
	done              bool
	oldValue          func(context.Context) (*EnterpriseContract, error)
	predicates        []predicate.EnterpriseContract
}

var _ ent.Mutation = (*EnterpriseContractMutation)(nil)

// enterprisecontractOption allows management of the mutation configuration using functional options.
type enterprisecontractOption func(*EnterpriseContractMutation)

// newEnterpriseContractMutation creates new mutation for the EnterpriseContract entity.
func newEnterpriseContractMutation(c config, op Op, opts ...enterprisecontractOption) *EnterpriseContractMutation {
	m := &EnterpriseContractMutation{
		config:        c,
		op:            op,
		typ:           TypeEnterpriseContract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnterpriseContractID sets the ID field of the mutation.
func withEnterpriseContractID(id uint64) enterprisecontractOption {
	return func(m *EnterpriseContractMutation) {
		var (
			err   error
			once  sync.Once
			value *EnterpriseContract
		)
		m.oldValue = func(ctx context.Context) (*EnterpriseContract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnterpriseContract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnterpriseContract sets the old EnterpriseContract of the mutation.
func withEnterpriseContract(node *EnterpriseContract) enterprisecontractOption {
	return func(m *EnterpriseContractMutation) {
		m.oldValue = func(context.Context) (*EnterpriseContract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnterpriseContractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnterpriseContractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnterpriseContractMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnterpriseContractMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnterpriseContract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EnterpriseContractMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnterpriseContractMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EnterpriseContract entity.
// If the EnterpriseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseContractMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnterpriseContractMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnterpriseContractMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnterpriseContractMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EnterpriseContract entity.
// If the EnterpriseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseContractMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnterpriseContractMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EnterpriseContractMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EnterpriseContractMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EnterpriseContract entity.
// If the EnterpriseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseContractMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EnterpriseContractMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[enterprisecontract.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EnterpriseContractMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[enterprisecontract.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EnterpriseContractMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, enterprisecontract.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *EnterpriseContractMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *EnterpriseContractMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the EnterpriseContract entity.
// If the EnterpriseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseContractMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *EnterpriseContractMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[enterprisecontract.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *EnterpriseContractMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[enterprisecontract.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *EnterpriseContractMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, enterprisecontract.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *EnterpriseContractMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *EnterpriseContractMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the EnterpriseContract entity.
// If the EnterpriseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseContractMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *EnterpriseContractMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[enterprisecontract.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *EnterpriseContractMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[enterprisecontract.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *EnterpriseContractMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, enterprisecontract.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *EnterpriseContractMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *EnterpriseContractMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the EnterpriseContract entity.
// If the EnterpriseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseContractMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *EnterpriseContractMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[enterprisecontract.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *EnterpriseContractMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[enterprisecontract.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *EnterpriseContractMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, enterprisecontract.FieldRemark)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *EnterpriseContractMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *EnterpriseContractMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the EnterpriseContract entity.
// If the EnterpriseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseContractMutation) OldEnterpriseID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *EnterpriseContractMutation) ResetEnterpriseID() {
	m.enterprise = nil
}

// SetStart sets the "start" field.
func (m *EnterpriseContractMutation) SetStart(t time.Time) {
	m.start = &t
}

// Start returns the value of the "start" field in the mutation.
func (m *EnterpriseContractMutation) Start() (r time.Time, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the EnterpriseContract entity.
// If the EnterpriseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseContractMutation) OldStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// ResetStart resets all changes to the "start" field.
func (m *EnterpriseContractMutation) ResetStart() {
	m.start = nil
}

// SetEnd sets the "end" field.
func (m *EnterpriseContractMutation) SetEnd(t time.Time) {
	m.end = &t
}

// End returns the value of the "end" field in the mutation.
func (m *EnterpriseContractMutation) End() (r time.Time, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the EnterpriseContract entity.
// If the EnterpriseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseContractMutation) OldEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// ResetEnd resets all changes to the "end" field.
func (m *EnterpriseContractMutation) ResetEnd() {
	m.end = nil
}

// SetFile sets the "file" field.
func (m *EnterpriseContractMutation) SetFile(s string) {
	m.file = &s
}

// File returns the value of the "file" field in the mutation.
func (m *EnterpriseContractMutation) File() (r string, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldFile returns the old "file" field's value of the EnterpriseContract entity.
// If the EnterpriseContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseContractMutation) OldFile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFile: %w", err)
	}
	return oldValue.File, nil
}

// ResetFile resets all changes to the "file" field.
func (m *EnterpriseContractMutation) ResetFile() {
	m.file = nil
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *EnterpriseContractMutation) ClearEnterprise() {
	m.clearedenterprise = true
	m.clearedFields[enterprisecontract.FieldEnterpriseID] = struct{}{}
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *EnterpriseContractMutation) EnterpriseCleared() bool {
	return m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *EnterpriseContractMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *EnterpriseContractMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// Where appends a list predicates to the EnterpriseContractMutation builder.
func (m *EnterpriseContractMutation) Where(ps ...predicate.EnterpriseContract) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnterpriseContractMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnterpriseContractMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EnterpriseContract, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnterpriseContractMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnterpriseContractMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EnterpriseContract).
func (m *EnterpriseContractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnterpriseContractMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, enterprisecontract.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enterprisecontract.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, enterprisecontract.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, enterprisecontract.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, enterprisecontract.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, enterprisecontract.FieldRemark)
	}
	if m.enterprise != nil {
		fields = append(fields, enterprisecontract.FieldEnterpriseID)
	}
	if m.start != nil {
		fields = append(fields, enterprisecontract.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, enterprisecontract.FieldEnd)
	}
	if m.file != nil {
		fields = append(fields, enterprisecontract.FieldFile)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnterpriseContractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enterprisecontract.FieldCreatedAt:
		return m.CreatedAt()
	case enterprisecontract.FieldUpdatedAt:
		return m.UpdatedAt()
	case enterprisecontract.FieldDeletedAt:
		return m.DeletedAt()
	case enterprisecontract.FieldCreator:
		return m.Creator()
	case enterprisecontract.FieldLastModifier:
		return m.LastModifier()
	case enterprisecontract.FieldRemark:
		return m.Remark()
	case enterprisecontract.FieldEnterpriseID:
		return m.EnterpriseID()
	case enterprisecontract.FieldStart:
		return m.Start()
	case enterprisecontract.FieldEnd:
		return m.End()
	case enterprisecontract.FieldFile:
		return m.File()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnterpriseContractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enterprisecontract.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enterprisecontract.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case enterprisecontract.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case enterprisecontract.FieldCreator:
		return m.OldCreator(ctx)
	case enterprisecontract.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case enterprisecontract.FieldRemark:
		return m.OldRemark(ctx)
	case enterprisecontract.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case enterprisecontract.FieldStart:
		return m.OldStart(ctx)
	case enterprisecontract.FieldEnd:
		return m.OldEnd(ctx)
	case enterprisecontract.FieldFile:
		return m.OldFile(ctx)
	}
	return nil, fmt.Errorf("unknown EnterpriseContract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseContractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enterprisecontract.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enterprisecontract.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case enterprisecontract.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case enterprisecontract.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case enterprisecontract.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case enterprisecontract.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case enterprisecontract.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case enterprisecontract.FieldStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case enterprisecontract.FieldEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case enterprisecontract.FieldFile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFile(v)
		return nil
	}
	return fmt.Errorf("unknown EnterpriseContract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnterpriseContractMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnterpriseContractMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseContractMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EnterpriseContract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnterpriseContractMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(enterprisecontract.FieldDeletedAt) {
		fields = append(fields, enterprisecontract.FieldDeletedAt)
	}
	if m.FieldCleared(enterprisecontract.FieldCreator) {
		fields = append(fields, enterprisecontract.FieldCreator)
	}
	if m.FieldCleared(enterprisecontract.FieldLastModifier) {
		fields = append(fields, enterprisecontract.FieldLastModifier)
	}
	if m.FieldCleared(enterprisecontract.FieldRemark) {
		fields = append(fields, enterprisecontract.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnterpriseContractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnterpriseContractMutation) ClearField(name string) error {
	switch name {
	case enterprisecontract.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case enterprisecontract.FieldCreator:
		m.ClearCreator()
		return nil
	case enterprisecontract.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case enterprisecontract.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseContract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnterpriseContractMutation) ResetField(name string) error {
	switch name {
	case enterprisecontract.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enterprisecontract.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case enterprisecontract.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case enterprisecontract.FieldCreator:
		m.ResetCreator()
		return nil
	case enterprisecontract.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case enterprisecontract.FieldRemark:
		m.ResetRemark()
		return nil
	case enterprisecontract.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case enterprisecontract.FieldStart:
		m.ResetStart()
		return nil
	case enterprisecontract.FieldEnd:
		m.ResetEnd()
		return nil
	case enterprisecontract.FieldFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseContract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnterpriseContractMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.enterprise != nil {
		edges = append(edges, enterprisecontract.EdgeEnterprise)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnterpriseContractMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enterprisecontract.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnterpriseContractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnterpriseContractMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnterpriseContractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedenterprise {
		edges = append(edges, enterprisecontract.EdgeEnterprise)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnterpriseContractMutation) EdgeCleared(name string) bool {
	switch name {
	case enterprisecontract.EdgeEnterprise:
		return m.clearedenterprise
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnterpriseContractMutation) ClearEdge(name string) error {
	switch name {
	case enterprisecontract.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseContract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnterpriseContractMutation) ResetEdge(name string) error {
	switch name {
	case enterprisecontract.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseContract edge %s", name)
}

// EnterprisePrepaymentMutation represents an operation that mutates the EnterprisePrepayment nodes in the graph.
type EnterprisePrepaymentMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	amount            *float64
	addamount         *float64
	payway            *model.Payway
	trade_no          *string
	clearedFields     map[string]struct{}
	enterprise        *uint64
	clearedenterprise bool
	agent             *uint64
	clearedagent      bool
	done              bool
	oldValue          func(context.Context) (*EnterprisePrepayment, error)
	predicates        []predicate.EnterprisePrepayment
}

var _ ent.Mutation = (*EnterprisePrepaymentMutation)(nil)

// enterpriseprepaymentOption allows management of the mutation configuration using functional options.
type enterpriseprepaymentOption func(*EnterprisePrepaymentMutation)

// newEnterprisePrepaymentMutation creates new mutation for the EnterprisePrepayment entity.
func newEnterprisePrepaymentMutation(c config, op Op, opts ...enterpriseprepaymentOption) *EnterprisePrepaymentMutation {
	m := &EnterprisePrepaymentMutation{
		config:        c,
		op:            op,
		typ:           TypeEnterprisePrepayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnterprisePrepaymentID sets the ID field of the mutation.
func withEnterprisePrepaymentID(id uint64) enterpriseprepaymentOption {
	return func(m *EnterprisePrepaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *EnterprisePrepayment
		)
		m.oldValue = func(ctx context.Context) (*EnterprisePrepayment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnterprisePrepayment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnterprisePrepayment sets the old EnterprisePrepayment of the mutation.
func withEnterprisePrepayment(node *EnterprisePrepayment) enterpriseprepaymentOption {
	return func(m *EnterprisePrepaymentMutation) {
		m.oldValue = func(context.Context) (*EnterprisePrepayment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnterprisePrepaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnterprisePrepaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnterprisePrepaymentMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnterprisePrepaymentMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnterprisePrepayment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EnterprisePrepaymentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnterprisePrepaymentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EnterprisePrepayment entity.
// If the EnterprisePrepayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePrepaymentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnterprisePrepaymentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnterprisePrepaymentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnterprisePrepaymentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EnterprisePrepayment entity.
// If the EnterprisePrepayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePrepaymentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnterprisePrepaymentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreator sets the "creator" field.
func (m *EnterprisePrepaymentMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *EnterprisePrepaymentMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the EnterprisePrepayment entity.
// If the EnterprisePrepayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePrepaymentMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *EnterprisePrepaymentMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[enterpriseprepayment.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *EnterprisePrepaymentMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[enterpriseprepayment.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *EnterprisePrepaymentMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, enterpriseprepayment.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *EnterprisePrepaymentMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *EnterprisePrepaymentMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the EnterprisePrepayment entity.
// If the EnterprisePrepayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePrepaymentMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *EnterprisePrepaymentMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[enterpriseprepayment.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *EnterprisePrepaymentMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[enterpriseprepayment.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *EnterprisePrepaymentMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, enterpriseprepayment.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *EnterprisePrepaymentMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *EnterprisePrepaymentMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the EnterprisePrepayment entity.
// If the EnterprisePrepayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePrepaymentMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *EnterprisePrepaymentMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[enterpriseprepayment.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *EnterprisePrepaymentMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[enterpriseprepayment.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *EnterprisePrepaymentMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, enterpriseprepayment.FieldRemark)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *EnterprisePrepaymentMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *EnterprisePrepaymentMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the EnterprisePrepayment entity.
// If the EnterprisePrepayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePrepaymentMutation) OldEnterpriseID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *EnterprisePrepaymentMutation) ResetEnterpriseID() {
	m.enterprise = nil
}

// SetAgentID sets the "agent_id" field.
func (m *EnterprisePrepaymentMutation) SetAgentID(u uint64) {
	m.agent = &u
}

// AgentID returns the value of the "agent_id" field in the mutation.
func (m *EnterprisePrepaymentMutation) AgentID() (r uint64, exists bool) {
	v := m.agent
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentID returns the old "agent_id" field's value of the EnterprisePrepayment entity.
// If the EnterprisePrepayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePrepaymentMutation) OldAgentID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentID: %w", err)
	}
	return oldValue.AgentID, nil
}

// ClearAgentID clears the value of the "agent_id" field.
func (m *EnterprisePrepaymentMutation) ClearAgentID() {
	m.agent = nil
	m.clearedFields[enterpriseprepayment.FieldAgentID] = struct{}{}
}

// AgentIDCleared returns if the "agent_id" field was cleared in this mutation.
func (m *EnterprisePrepaymentMutation) AgentIDCleared() bool {
	_, ok := m.clearedFields[enterpriseprepayment.FieldAgentID]
	return ok
}

// ResetAgentID resets all changes to the "agent_id" field.
func (m *EnterprisePrepaymentMutation) ResetAgentID() {
	m.agent = nil
	delete(m.clearedFields, enterpriseprepayment.FieldAgentID)
}

// SetAmount sets the "amount" field.
func (m *EnterprisePrepaymentMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *EnterprisePrepaymentMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the EnterprisePrepayment entity.
// If the EnterprisePrepayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePrepaymentMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *EnterprisePrepaymentMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *EnterprisePrepaymentMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *EnterprisePrepaymentMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetPayway sets the "payway" field.
func (m *EnterprisePrepaymentMutation) SetPayway(value model.Payway) {
	m.payway = &value
}

// Payway returns the value of the "payway" field in the mutation.
func (m *EnterprisePrepaymentMutation) Payway() (r model.Payway, exists bool) {
	v := m.payway
	if v == nil {
		return
	}
	return *v, true
}

// OldPayway returns the old "payway" field's value of the EnterprisePrepayment entity.
// If the EnterprisePrepayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePrepaymentMutation) OldPayway(ctx context.Context) (v model.Payway, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayway: %w", err)
	}
	return oldValue.Payway, nil
}

// ResetPayway resets all changes to the "payway" field.
func (m *EnterprisePrepaymentMutation) ResetPayway() {
	m.payway = nil
}

// SetTradeNo sets the "trade_no" field.
func (m *EnterprisePrepaymentMutation) SetTradeNo(s string) {
	m.trade_no = &s
}

// TradeNo returns the value of the "trade_no" field in the mutation.
func (m *EnterprisePrepaymentMutation) TradeNo() (r string, exists bool) {
	v := m.trade_no
	if v == nil {
		return
	}
	return *v, true
}

// OldTradeNo returns the old "trade_no" field's value of the EnterprisePrepayment entity.
// If the EnterprisePrepayment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePrepaymentMutation) OldTradeNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTradeNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTradeNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTradeNo: %w", err)
	}
	return oldValue.TradeNo, nil
}

// ClearTradeNo clears the value of the "trade_no" field.
func (m *EnterprisePrepaymentMutation) ClearTradeNo() {
	m.trade_no = nil
	m.clearedFields[enterpriseprepayment.FieldTradeNo] = struct{}{}
}

// TradeNoCleared returns if the "trade_no" field was cleared in this mutation.
func (m *EnterprisePrepaymentMutation) TradeNoCleared() bool {
	_, ok := m.clearedFields[enterpriseprepayment.FieldTradeNo]
	return ok
}

// ResetTradeNo resets all changes to the "trade_no" field.
func (m *EnterprisePrepaymentMutation) ResetTradeNo() {
	m.trade_no = nil
	delete(m.clearedFields, enterpriseprepayment.FieldTradeNo)
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *EnterprisePrepaymentMutation) ClearEnterprise() {
	m.clearedenterprise = true
	m.clearedFields[enterpriseprepayment.FieldEnterpriseID] = struct{}{}
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *EnterprisePrepaymentMutation) EnterpriseCleared() bool {
	return m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *EnterprisePrepaymentMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *EnterprisePrepaymentMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// ClearAgent clears the "agent" edge to the Agent entity.
func (m *EnterprisePrepaymentMutation) ClearAgent() {
	m.clearedagent = true
	m.clearedFields[enterpriseprepayment.FieldAgentID] = struct{}{}
}

// AgentCleared reports if the "agent" edge to the Agent entity was cleared.
func (m *EnterprisePrepaymentMutation) AgentCleared() bool {
	return m.AgentIDCleared() || m.clearedagent
}

// AgentIDs returns the "agent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentID instead. It exists only for internal usage by the builders.
func (m *EnterprisePrepaymentMutation) AgentIDs() (ids []uint64) {
	if id := m.agent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgent resets all changes to the "agent" edge.
func (m *EnterprisePrepaymentMutation) ResetAgent() {
	m.agent = nil
	m.clearedagent = false
}

// Where appends a list predicates to the EnterprisePrepaymentMutation builder.
func (m *EnterprisePrepaymentMutation) Where(ps ...predicate.EnterprisePrepayment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnterprisePrepaymentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnterprisePrepaymentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EnterprisePrepayment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnterprisePrepaymentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnterprisePrepaymentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EnterprisePrepayment).
func (m *EnterprisePrepaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnterprisePrepaymentMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, enterpriseprepayment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enterpriseprepayment.FieldUpdatedAt)
	}
	if m.creator != nil {
		fields = append(fields, enterpriseprepayment.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, enterpriseprepayment.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, enterpriseprepayment.FieldRemark)
	}
	if m.enterprise != nil {
		fields = append(fields, enterpriseprepayment.FieldEnterpriseID)
	}
	if m.agent != nil {
		fields = append(fields, enterpriseprepayment.FieldAgentID)
	}
	if m.amount != nil {
		fields = append(fields, enterpriseprepayment.FieldAmount)
	}
	if m.payway != nil {
		fields = append(fields, enterpriseprepayment.FieldPayway)
	}
	if m.trade_no != nil {
		fields = append(fields, enterpriseprepayment.FieldTradeNo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnterprisePrepaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enterpriseprepayment.FieldCreatedAt:
		return m.CreatedAt()
	case enterpriseprepayment.FieldUpdatedAt:
		return m.UpdatedAt()
	case enterpriseprepayment.FieldCreator:
		return m.Creator()
	case enterpriseprepayment.FieldLastModifier:
		return m.LastModifier()
	case enterpriseprepayment.FieldRemark:
		return m.Remark()
	case enterpriseprepayment.FieldEnterpriseID:
		return m.EnterpriseID()
	case enterpriseprepayment.FieldAgentID:
		return m.AgentID()
	case enterpriseprepayment.FieldAmount:
		return m.Amount()
	case enterpriseprepayment.FieldPayway:
		return m.Payway()
	case enterpriseprepayment.FieldTradeNo:
		return m.TradeNo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnterprisePrepaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enterpriseprepayment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enterpriseprepayment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case enterpriseprepayment.FieldCreator:
		return m.OldCreator(ctx)
	case enterpriseprepayment.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case enterpriseprepayment.FieldRemark:
		return m.OldRemark(ctx)
	case enterpriseprepayment.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case enterpriseprepayment.FieldAgentID:
		return m.OldAgentID(ctx)
	case enterpriseprepayment.FieldAmount:
		return m.OldAmount(ctx)
	case enterpriseprepayment.FieldPayway:
		return m.OldPayway(ctx)
	case enterpriseprepayment.FieldTradeNo:
		return m.OldTradeNo(ctx)
	}
	return nil, fmt.Errorf("unknown EnterprisePrepayment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterprisePrepaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enterpriseprepayment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enterpriseprepayment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case enterpriseprepayment.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case enterpriseprepayment.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case enterpriseprepayment.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case enterpriseprepayment.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case enterpriseprepayment.FieldAgentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentID(v)
		return nil
	case enterpriseprepayment.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case enterpriseprepayment.FieldPayway:
		v, ok := value.(model.Payway)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayway(v)
		return nil
	case enterpriseprepayment.FieldTradeNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTradeNo(v)
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrepayment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnterprisePrepaymentMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, enterpriseprepayment.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnterprisePrepaymentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case enterpriseprepayment.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterprisePrepaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case enterpriseprepayment.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrepayment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnterprisePrepaymentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(enterpriseprepayment.FieldCreator) {
		fields = append(fields, enterpriseprepayment.FieldCreator)
	}
	if m.FieldCleared(enterpriseprepayment.FieldLastModifier) {
		fields = append(fields, enterpriseprepayment.FieldLastModifier)
	}
	if m.FieldCleared(enterpriseprepayment.FieldRemark) {
		fields = append(fields, enterpriseprepayment.FieldRemark)
	}
	if m.FieldCleared(enterpriseprepayment.FieldAgentID) {
		fields = append(fields, enterpriseprepayment.FieldAgentID)
	}
	if m.FieldCleared(enterpriseprepayment.FieldTradeNo) {
		fields = append(fields, enterpriseprepayment.FieldTradeNo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnterprisePrepaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnterprisePrepaymentMutation) ClearField(name string) error {
	switch name {
	case enterpriseprepayment.FieldCreator:
		m.ClearCreator()
		return nil
	case enterpriseprepayment.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case enterpriseprepayment.FieldRemark:
		m.ClearRemark()
		return nil
	case enterpriseprepayment.FieldAgentID:
		m.ClearAgentID()
		return nil
	case enterpriseprepayment.FieldTradeNo:
		m.ClearTradeNo()
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrepayment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnterprisePrepaymentMutation) ResetField(name string) error {
	switch name {
	case enterpriseprepayment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enterpriseprepayment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case enterpriseprepayment.FieldCreator:
		m.ResetCreator()
		return nil
	case enterpriseprepayment.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case enterpriseprepayment.FieldRemark:
		m.ResetRemark()
		return nil
	case enterpriseprepayment.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case enterpriseprepayment.FieldAgentID:
		m.ResetAgentID()
		return nil
	case enterpriseprepayment.FieldAmount:
		m.ResetAmount()
		return nil
	case enterpriseprepayment.FieldPayway:
		m.ResetPayway()
		return nil
	case enterpriseprepayment.FieldTradeNo:
		m.ResetTradeNo()
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrepayment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnterprisePrepaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.enterprise != nil {
		edges = append(edges, enterpriseprepayment.EdgeEnterprise)
	}
	if m.agent != nil {
		edges = append(edges, enterpriseprepayment.EdgeAgent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnterprisePrepaymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enterpriseprepayment.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	case enterpriseprepayment.EdgeAgent:
		if id := m.agent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnterprisePrepaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnterprisePrepaymentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnterprisePrepaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedenterprise {
		edges = append(edges, enterpriseprepayment.EdgeEnterprise)
	}
	if m.clearedagent {
		edges = append(edges, enterpriseprepayment.EdgeAgent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnterprisePrepaymentMutation) EdgeCleared(name string) bool {
	switch name {
	case enterpriseprepayment.EdgeEnterprise:
		return m.clearedenterprise
	case enterpriseprepayment.EdgeAgent:
		return m.clearedagent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnterprisePrepaymentMutation) ClearEdge(name string) error {
	switch name {
	case enterpriseprepayment.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	case enterpriseprepayment.EdgeAgent:
		m.ClearAgent()
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrepayment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnterprisePrepaymentMutation) ResetEdge(name string) error {
	switch name {
	case enterpriseprepayment.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	case enterpriseprepayment.EdgeAgent:
		m.ResetAgent()
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrepayment edge %s", name)
}

// EnterprisePriceMutation represents an operation that mutates the EnterprisePrice nodes in the graph.
type EnterprisePriceMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	price             *float64
	addprice          *float64
	model             *string
	intelligent       *bool
	clearedFields     map[string]struct{}
	city              *uint64
	clearedcity       bool
	brand             *uint64
	clearedbrand      bool
	enterprise        *uint64
	clearedenterprise bool
	done              bool
	oldValue          func(context.Context) (*EnterprisePrice, error)
	predicates        []predicate.EnterprisePrice
}

var _ ent.Mutation = (*EnterprisePriceMutation)(nil)

// enterprisepriceOption allows management of the mutation configuration using functional options.
type enterprisepriceOption func(*EnterprisePriceMutation)

// newEnterprisePriceMutation creates new mutation for the EnterprisePrice entity.
func newEnterprisePriceMutation(c config, op Op, opts ...enterprisepriceOption) *EnterprisePriceMutation {
	m := &EnterprisePriceMutation{
		config:        c,
		op:            op,
		typ:           TypeEnterprisePrice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnterprisePriceID sets the ID field of the mutation.
func withEnterprisePriceID(id uint64) enterprisepriceOption {
	return func(m *EnterprisePriceMutation) {
		var (
			err   error
			once  sync.Once
			value *EnterprisePrice
		)
		m.oldValue = func(ctx context.Context) (*EnterprisePrice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnterprisePrice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnterprisePrice sets the old EnterprisePrice of the mutation.
func withEnterprisePrice(node *EnterprisePrice) enterprisepriceOption {
	return func(m *EnterprisePriceMutation) {
		m.oldValue = func(context.Context) (*EnterprisePrice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnterprisePriceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnterprisePriceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnterprisePriceMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnterprisePriceMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnterprisePrice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EnterprisePriceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnterprisePriceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EnterprisePrice entity.
// If the EnterprisePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePriceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnterprisePriceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnterprisePriceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnterprisePriceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EnterprisePrice entity.
// If the EnterprisePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePriceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnterprisePriceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EnterprisePriceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EnterprisePriceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EnterprisePrice entity.
// If the EnterprisePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePriceMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EnterprisePriceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[enterpriseprice.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EnterprisePriceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[enterpriseprice.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EnterprisePriceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, enterpriseprice.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *EnterprisePriceMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *EnterprisePriceMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the EnterprisePrice entity.
// If the EnterprisePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePriceMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *EnterprisePriceMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[enterpriseprice.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *EnterprisePriceMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[enterpriseprice.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *EnterprisePriceMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, enterpriseprice.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *EnterprisePriceMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *EnterprisePriceMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the EnterprisePrice entity.
// If the EnterprisePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePriceMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *EnterprisePriceMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[enterpriseprice.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *EnterprisePriceMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[enterpriseprice.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *EnterprisePriceMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, enterpriseprice.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *EnterprisePriceMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *EnterprisePriceMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the EnterprisePrice entity.
// If the EnterprisePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePriceMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *EnterprisePriceMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[enterpriseprice.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *EnterprisePriceMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[enterpriseprice.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *EnterprisePriceMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, enterpriseprice.FieldRemark)
}

// SetCityID sets the "city_id" field.
func (m *EnterprisePriceMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *EnterprisePriceMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the EnterprisePrice entity.
// If the EnterprisePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePriceMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *EnterprisePriceMutation) ResetCityID() {
	m.city = nil
}

// SetBrandID sets the "brand_id" field.
func (m *EnterprisePriceMutation) SetBrandID(u uint64) {
	m.brand = &u
}

// BrandID returns the value of the "brand_id" field in the mutation.
func (m *EnterprisePriceMutation) BrandID() (r uint64, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrandID returns the old "brand_id" field's value of the EnterprisePrice entity.
// If the EnterprisePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePriceMutation) OldBrandID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrandID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrandID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrandID: %w", err)
	}
	return oldValue.BrandID, nil
}

// ClearBrandID clears the value of the "brand_id" field.
func (m *EnterprisePriceMutation) ClearBrandID() {
	m.brand = nil
	m.clearedFields[enterpriseprice.FieldBrandID] = struct{}{}
}

// BrandIDCleared returns if the "brand_id" field was cleared in this mutation.
func (m *EnterprisePriceMutation) BrandIDCleared() bool {
	_, ok := m.clearedFields[enterpriseprice.FieldBrandID]
	return ok
}

// ResetBrandID resets all changes to the "brand_id" field.
func (m *EnterprisePriceMutation) ResetBrandID() {
	m.brand = nil
	delete(m.clearedFields, enterpriseprice.FieldBrandID)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *EnterprisePriceMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *EnterprisePriceMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the EnterprisePrice entity.
// If the EnterprisePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePriceMutation) OldEnterpriseID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *EnterprisePriceMutation) ResetEnterpriseID() {
	m.enterprise = nil
}

// SetPrice sets the "price" field.
func (m *EnterprisePriceMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *EnterprisePriceMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the EnterprisePrice entity.
// If the EnterprisePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePriceMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *EnterprisePriceMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *EnterprisePriceMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *EnterprisePriceMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetModel sets the "model" field.
func (m *EnterprisePriceMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *EnterprisePriceMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the EnterprisePrice entity.
// If the EnterprisePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePriceMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *EnterprisePriceMutation) ResetModel() {
	m.model = nil
}

// SetIntelligent sets the "intelligent" field.
func (m *EnterprisePriceMutation) SetIntelligent(b bool) {
	m.intelligent = &b
}

// Intelligent returns the value of the "intelligent" field in the mutation.
func (m *EnterprisePriceMutation) Intelligent() (r bool, exists bool) {
	v := m.intelligent
	if v == nil {
		return
	}
	return *v, true
}

// OldIntelligent returns the old "intelligent" field's value of the EnterprisePrice entity.
// If the EnterprisePrice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterprisePriceMutation) OldIntelligent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntelligent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntelligent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntelligent: %w", err)
	}
	return oldValue.Intelligent, nil
}

// ResetIntelligent resets all changes to the "intelligent" field.
func (m *EnterprisePriceMutation) ResetIntelligent() {
	m.intelligent = nil
}

// ClearCity clears the "city" edge to the City entity.
func (m *EnterprisePriceMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[enterpriseprice.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *EnterprisePriceMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *EnterprisePriceMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *EnterprisePriceMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearBrand clears the "brand" edge to the EbikeBrand entity.
func (m *EnterprisePriceMutation) ClearBrand() {
	m.clearedbrand = true
	m.clearedFields[enterpriseprice.FieldBrandID] = struct{}{}
}

// BrandCleared reports if the "brand" edge to the EbikeBrand entity was cleared.
func (m *EnterprisePriceMutation) BrandCleared() bool {
	return m.BrandIDCleared() || m.clearedbrand
}

// BrandIDs returns the "brand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BrandID instead. It exists only for internal usage by the builders.
func (m *EnterprisePriceMutation) BrandIDs() (ids []uint64) {
	if id := m.brand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBrand resets all changes to the "brand" edge.
func (m *EnterprisePriceMutation) ResetBrand() {
	m.brand = nil
	m.clearedbrand = false
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *EnterprisePriceMutation) ClearEnterprise() {
	m.clearedenterprise = true
	m.clearedFields[enterpriseprice.FieldEnterpriseID] = struct{}{}
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *EnterprisePriceMutation) EnterpriseCleared() bool {
	return m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *EnterprisePriceMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *EnterprisePriceMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// Where appends a list predicates to the EnterprisePriceMutation builder.
func (m *EnterprisePriceMutation) Where(ps ...predicate.EnterprisePrice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnterprisePriceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnterprisePriceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EnterprisePrice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnterprisePriceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnterprisePriceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EnterprisePrice).
func (m *EnterprisePriceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnterprisePriceMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, enterpriseprice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enterpriseprice.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, enterpriseprice.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, enterpriseprice.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, enterpriseprice.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, enterpriseprice.FieldRemark)
	}
	if m.city != nil {
		fields = append(fields, enterpriseprice.FieldCityID)
	}
	if m.brand != nil {
		fields = append(fields, enterpriseprice.FieldBrandID)
	}
	if m.enterprise != nil {
		fields = append(fields, enterpriseprice.FieldEnterpriseID)
	}
	if m.price != nil {
		fields = append(fields, enterpriseprice.FieldPrice)
	}
	if m.model != nil {
		fields = append(fields, enterpriseprice.FieldModel)
	}
	if m.intelligent != nil {
		fields = append(fields, enterpriseprice.FieldIntelligent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnterprisePriceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enterpriseprice.FieldCreatedAt:
		return m.CreatedAt()
	case enterpriseprice.FieldUpdatedAt:
		return m.UpdatedAt()
	case enterpriseprice.FieldDeletedAt:
		return m.DeletedAt()
	case enterpriseprice.FieldCreator:
		return m.Creator()
	case enterpriseprice.FieldLastModifier:
		return m.LastModifier()
	case enterpriseprice.FieldRemark:
		return m.Remark()
	case enterpriseprice.FieldCityID:
		return m.CityID()
	case enterpriseprice.FieldBrandID:
		return m.BrandID()
	case enterpriseprice.FieldEnterpriseID:
		return m.EnterpriseID()
	case enterpriseprice.FieldPrice:
		return m.Price()
	case enterpriseprice.FieldModel:
		return m.Model()
	case enterpriseprice.FieldIntelligent:
		return m.Intelligent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnterprisePriceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enterpriseprice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enterpriseprice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case enterpriseprice.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case enterpriseprice.FieldCreator:
		return m.OldCreator(ctx)
	case enterpriseprice.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case enterpriseprice.FieldRemark:
		return m.OldRemark(ctx)
	case enterpriseprice.FieldCityID:
		return m.OldCityID(ctx)
	case enterpriseprice.FieldBrandID:
		return m.OldBrandID(ctx)
	case enterpriseprice.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case enterpriseprice.FieldPrice:
		return m.OldPrice(ctx)
	case enterpriseprice.FieldModel:
		return m.OldModel(ctx)
	case enterpriseprice.FieldIntelligent:
		return m.OldIntelligent(ctx)
	}
	return nil, fmt.Errorf("unknown EnterprisePrice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterprisePriceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enterpriseprice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enterpriseprice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case enterpriseprice.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case enterpriseprice.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case enterpriseprice.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case enterpriseprice.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case enterpriseprice.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case enterpriseprice.FieldBrandID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrandID(v)
		return nil
	case enterpriseprice.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case enterpriseprice.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case enterpriseprice.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case enterpriseprice.FieldIntelligent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntelligent(v)
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnterprisePriceMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, enterpriseprice.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnterprisePriceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case enterpriseprice.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterprisePriceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case enterpriseprice.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnterprisePriceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(enterpriseprice.FieldDeletedAt) {
		fields = append(fields, enterpriseprice.FieldDeletedAt)
	}
	if m.FieldCleared(enterpriseprice.FieldCreator) {
		fields = append(fields, enterpriseprice.FieldCreator)
	}
	if m.FieldCleared(enterpriseprice.FieldLastModifier) {
		fields = append(fields, enterpriseprice.FieldLastModifier)
	}
	if m.FieldCleared(enterpriseprice.FieldRemark) {
		fields = append(fields, enterpriseprice.FieldRemark)
	}
	if m.FieldCleared(enterpriseprice.FieldBrandID) {
		fields = append(fields, enterpriseprice.FieldBrandID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnterprisePriceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnterprisePriceMutation) ClearField(name string) error {
	switch name {
	case enterpriseprice.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case enterpriseprice.FieldCreator:
		m.ClearCreator()
		return nil
	case enterpriseprice.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case enterpriseprice.FieldRemark:
		m.ClearRemark()
		return nil
	case enterpriseprice.FieldBrandID:
		m.ClearBrandID()
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnterprisePriceMutation) ResetField(name string) error {
	switch name {
	case enterpriseprice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enterpriseprice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case enterpriseprice.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case enterpriseprice.FieldCreator:
		m.ResetCreator()
		return nil
	case enterpriseprice.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case enterpriseprice.FieldRemark:
		m.ResetRemark()
		return nil
	case enterpriseprice.FieldCityID:
		m.ResetCityID()
		return nil
	case enterpriseprice.FieldBrandID:
		m.ResetBrandID()
		return nil
	case enterpriseprice.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case enterpriseprice.FieldPrice:
		m.ResetPrice()
		return nil
	case enterpriseprice.FieldModel:
		m.ResetModel()
		return nil
	case enterpriseprice.FieldIntelligent:
		m.ResetIntelligent()
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnterprisePriceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.city != nil {
		edges = append(edges, enterpriseprice.EdgeCity)
	}
	if m.brand != nil {
		edges = append(edges, enterpriseprice.EdgeBrand)
	}
	if m.enterprise != nil {
		edges = append(edges, enterpriseprice.EdgeEnterprise)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnterprisePriceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enterpriseprice.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case enterpriseprice.EdgeBrand:
		if id := m.brand; id != nil {
			return []ent.Value{*id}
		}
	case enterpriseprice.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnterprisePriceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnterprisePriceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnterprisePriceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcity {
		edges = append(edges, enterpriseprice.EdgeCity)
	}
	if m.clearedbrand {
		edges = append(edges, enterpriseprice.EdgeBrand)
	}
	if m.clearedenterprise {
		edges = append(edges, enterpriseprice.EdgeEnterprise)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnterprisePriceMutation) EdgeCleared(name string) bool {
	switch name {
	case enterpriseprice.EdgeCity:
		return m.clearedcity
	case enterpriseprice.EdgeBrand:
		return m.clearedbrand
	case enterpriseprice.EdgeEnterprise:
		return m.clearedenterprise
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnterprisePriceMutation) ClearEdge(name string) error {
	switch name {
	case enterpriseprice.EdgeCity:
		m.ClearCity()
		return nil
	case enterpriseprice.EdgeBrand:
		m.ClearBrand()
		return nil
	case enterpriseprice.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnterprisePriceMutation) ResetEdge(name string) error {
	switch name {
	case enterpriseprice.EdgeCity:
		m.ResetCity()
		return nil
	case enterpriseprice.EdgeBrand:
		m.ResetBrand()
		return nil
	case enterpriseprice.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	}
	return fmt.Errorf("unknown EnterprisePrice edge %s", name)
}

// EnterpriseStatementMutation represents an operation that mutates the EnterpriseStatement nodes in the graph.
type EnterpriseStatementMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	cost              *float64
	addcost           *float64
	settled_at        *time.Time
	days              *int
	adddays           *int
	rider_number      *int
	addrider_number   *int
	date              *time.Time
	start             *time.Time
	end               *time.Time
	clearedFields     map[string]struct{}
	enterprise        *uint64
	clearedenterprise bool
	bills             map[uint64]struct{}
	removedbills      map[uint64]struct{}
	clearedbills      bool
	done              bool
	oldValue          func(context.Context) (*EnterpriseStatement, error)
	predicates        []predicate.EnterpriseStatement
}

var _ ent.Mutation = (*EnterpriseStatementMutation)(nil)

// enterprisestatementOption allows management of the mutation configuration using functional options.
type enterprisestatementOption func(*EnterpriseStatementMutation)

// newEnterpriseStatementMutation creates new mutation for the EnterpriseStatement entity.
func newEnterpriseStatementMutation(c config, op Op, opts ...enterprisestatementOption) *EnterpriseStatementMutation {
	m := &EnterpriseStatementMutation{
		config:        c,
		op:            op,
		typ:           TypeEnterpriseStatement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnterpriseStatementID sets the ID field of the mutation.
func withEnterpriseStatementID(id uint64) enterprisestatementOption {
	return func(m *EnterpriseStatementMutation) {
		var (
			err   error
			once  sync.Once
			value *EnterpriseStatement
		)
		m.oldValue = func(ctx context.Context) (*EnterpriseStatement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnterpriseStatement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnterpriseStatement sets the old EnterpriseStatement of the mutation.
func withEnterpriseStatement(node *EnterpriseStatement) enterprisestatementOption {
	return func(m *EnterpriseStatementMutation) {
		m.oldValue = func(context.Context) (*EnterpriseStatement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnterpriseStatementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnterpriseStatementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnterpriseStatementMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnterpriseStatementMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnterpriseStatement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EnterpriseStatementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnterpriseStatementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnterpriseStatementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnterpriseStatementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnterpriseStatementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnterpriseStatementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EnterpriseStatementMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EnterpriseStatementMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EnterpriseStatementMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[enterprisestatement.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EnterpriseStatementMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[enterprisestatement.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EnterpriseStatementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, enterprisestatement.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *EnterpriseStatementMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *EnterpriseStatementMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *EnterpriseStatementMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[enterprisestatement.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *EnterpriseStatementMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[enterprisestatement.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *EnterpriseStatementMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, enterprisestatement.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *EnterpriseStatementMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *EnterpriseStatementMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *EnterpriseStatementMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[enterprisestatement.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *EnterpriseStatementMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[enterprisestatement.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *EnterpriseStatementMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, enterprisestatement.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *EnterpriseStatementMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *EnterpriseStatementMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *EnterpriseStatementMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[enterprisestatement.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *EnterpriseStatementMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[enterprisestatement.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *EnterpriseStatementMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, enterprisestatement.FieldRemark)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *EnterpriseStatementMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *EnterpriseStatementMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldEnterpriseID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *EnterpriseStatementMutation) ResetEnterpriseID() {
	m.enterprise = nil
}

// SetCost sets the "cost" field.
func (m *EnterpriseStatementMutation) SetCost(f float64) {
	m.cost = &f
	m.addcost = nil
}

// Cost returns the value of the "cost" field in the mutation.
func (m *EnterpriseStatementMutation) Cost() (r float64, exists bool) {
	v := m.cost
	if v == nil {
		return
	}
	return *v, true
}

// OldCost returns the old "cost" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldCost(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCost: %w", err)
	}
	return oldValue.Cost, nil
}

// AddCost adds f to the "cost" field.
func (m *EnterpriseStatementMutation) AddCost(f float64) {
	if m.addcost != nil {
		*m.addcost += f
	} else {
		m.addcost = &f
	}
}

// AddedCost returns the value that was added to the "cost" field in this mutation.
func (m *EnterpriseStatementMutation) AddedCost() (r float64, exists bool) {
	v := m.addcost
	if v == nil {
		return
	}
	return *v, true
}

// ResetCost resets all changes to the "cost" field.
func (m *EnterpriseStatementMutation) ResetCost() {
	m.cost = nil
	m.addcost = nil
}

// SetSettledAt sets the "settled_at" field.
func (m *EnterpriseStatementMutation) SetSettledAt(t time.Time) {
	m.settled_at = &t
}

// SettledAt returns the value of the "settled_at" field in the mutation.
func (m *EnterpriseStatementMutation) SettledAt() (r time.Time, exists bool) {
	v := m.settled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSettledAt returns the old "settled_at" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldSettledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettledAt: %w", err)
	}
	return oldValue.SettledAt, nil
}

// ClearSettledAt clears the value of the "settled_at" field.
func (m *EnterpriseStatementMutation) ClearSettledAt() {
	m.settled_at = nil
	m.clearedFields[enterprisestatement.FieldSettledAt] = struct{}{}
}

// SettledAtCleared returns if the "settled_at" field was cleared in this mutation.
func (m *EnterpriseStatementMutation) SettledAtCleared() bool {
	_, ok := m.clearedFields[enterprisestatement.FieldSettledAt]
	return ok
}

// ResetSettledAt resets all changes to the "settled_at" field.
func (m *EnterpriseStatementMutation) ResetSettledAt() {
	m.settled_at = nil
	delete(m.clearedFields, enterprisestatement.FieldSettledAt)
}

// SetDays sets the "days" field.
func (m *EnterpriseStatementMutation) SetDays(i int) {
	m.days = &i
	m.adddays = nil
}

// Days returns the value of the "days" field in the mutation.
func (m *EnterpriseStatementMutation) Days() (r int, exists bool) {
	v := m.days
	if v == nil {
		return
	}
	return *v, true
}

// OldDays returns the old "days" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDays: %w", err)
	}
	return oldValue.Days, nil
}

// AddDays adds i to the "days" field.
func (m *EnterpriseStatementMutation) AddDays(i int) {
	if m.adddays != nil {
		*m.adddays += i
	} else {
		m.adddays = &i
	}
}

// AddedDays returns the value that was added to the "days" field in this mutation.
func (m *EnterpriseStatementMutation) AddedDays() (r int, exists bool) {
	v := m.adddays
	if v == nil {
		return
	}
	return *v, true
}

// ResetDays resets all changes to the "days" field.
func (m *EnterpriseStatementMutation) ResetDays() {
	m.days = nil
	m.adddays = nil
}

// SetRiderNumber sets the "rider_number" field.
func (m *EnterpriseStatementMutation) SetRiderNumber(i int) {
	m.rider_number = &i
	m.addrider_number = nil
}

// RiderNumber returns the value of the "rider_number" field in the mutation.
func (m *EnterpriseStatementMutation) RiderNumber() (r int, exists bool) {
	v := m.rider_number
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderNumber returns the old "rider_number" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldRiderNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderNumber: %w", err)
	}
	return oldValue.RiderNumber, nil
}

// AddRiderNumber adds i to the "rider_number" field.
func (m *EnterpriseStatementMutation) AddRiderNumber(i int) {
	if m.addrider_number != nil {
		*m.addrider_number += i
	} else {
		m.addrider_number = &i
	}
}

// AddedRiderNumber returns the value that was added to the "rider_number" field in this mutation.
func (m *EnterpriseStatementMutation) AddedRiderNumber() (r int, exists bool) {
	v := m.addrider_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetRiderNumber resets all changes to the "rider_number" field.
func (m *EnterpriseStatementMutation) ResetRiderNumber() {
	m.rider_number = nil
	m.addrider_number = nil
}

// SetDate sets the "date" field.
func (m *EnterpriseStatementMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *EnterpriseStatementMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ClearDate clears the value of the "date" field.
func (m *EnterpriseStatementMutation) ClearDate() {
	m.date = nil
	m.clearedFields[enterprisestatement.FieldDate] = struct{}{}
}

// DateCleared returns if the "date" field was cleared in this mutation.
func (m *EnterpriseStatementMutation) DateCleared() bool {
	_, ok := m.clearedFields[enterprisestatement.FieldDate]
	return ok
}

// ResetDate resets all changes to the "date" field.
func (m *EnterpriseStatementMutation) ResetDate() {
	m.date = nil
	delete(m.clearedFields, enterprisestatement.FieldDate)
}

// SetStart sets the "start" field.
func (m *EnterpriseStatementMutation) SetStart(t time.Time) {
	m.start = &t
}

// Start returns the value of the "start" field in the mutation.
func (m *EnterpriseStatementMutation) Start() (r time.Time, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// ResetStart resets all changes to the "start" field.
func (m *EnterpriseStatementMutation) ResetStart() {
	m.start = nil
}

// SetEnd sets the "end" field.
func (m *EnterpriseStatementMutation) SetEnd(t time.Time) {
	m.end = &t
}

// End returns the value of the "end" field in the mutation.
func (m *EnterpriseStatementMutation) End() (r time.Time, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the EnterpriseStatement entity.
// If the EnterpriseStatement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStatementMutation) OldEnd(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// ClearEnd clears the value of the "end" field.
func (m *EnterpriseStatementMutation) ClearEnd() {
	m.end = nil
	m.clearedFields[enterprisestatement.FieldEnd] = struct{}{}
}

// EndCleared returns if the "end" field was cleared in this mutation.
func (m *EnterpriseStatementMutation) EndCleared() bool {
	_, ok := m.clearedFields[enterprisestatement.FieldEnd]
	return ok
}

// ResetEnd resets all changes to the "end" field.
func (m *EnterpriseStatementMutation) ResetEnd() {
	m.end = nil
	delete(m.clearedFields, enterprisestatement.FieldEnd)
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *EnterpriseStatementMutation) ClearEnterprise() {
	m.clearedenterprise = true
	m.clearedFields[enterprisestatement.FieldEnterpriseID] = struct{}{}
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *EnterpriseStatementMutation) EnterpriseCleared() bool {
	return m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *EnterpriseStatementMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *EnterpriseStatementMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// AddBillIDs adds the "bills" edge to the EnterpriseBill entity by ids.
func (m *EnterpriseStatementMutation) AddBillIDs(ids ...uint64) {
	if m.bills == nil {
		m.bills = make(map[uint64]struct{})
	}
	for i := range ids {
		m.bills[ids[i]] = struct{}{}
	}
}

// ClearBills clears the "bills" edge to the EnterpriseBill entity.
func (m *EnterpriseStatementMutation) ClearBills() {
	m.clearedbills = true
}

// BillsCleared reports if the "bills" edge to the EnterpriseBill entity was cleared.
func (m *EnterpriseStatementMutation) BillsCleared() bool {
	return m.clearedbills
}

// RemoveBillIDs removes the "bills" edge to the EnterpriseBill entity by IDs.
func (m *EnterpriseStatementMutation) RemoveBillIDs(ids ...uint64) {
	if m.removedbills == nil {
		m.removedbills = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.bills, ids[i])
		m.removedbills[ids[i]] = struct{}{}
	}
}

// RemovedBills returns the removed IDs of the "bills" edge to the EnterpriseBill entity.
func (m *EnterpriseStatementMutation) RemovedBillsIDs() (ids []uint64) {
	for id := range m.removedbills {
		ids = append(ids, id)
	}
	return
}

// BillsIDs returns the "bills" edge IDs in the mutation.
func (m *EnterpriseStatementMutation) BillsIDs() (ids []uint64) {
	for id := range m.bills {
		ids = append(ids, id)
	}
	return
}

// ResetBills resets all changes to the "bills" edge.
func (m *EnterpriseStatementMutation) ResetBills() {
	m.bills = nil
	m.clearedbills = false
	m.removedbills = nil
}

// Where appends a list predicates to the EnterpriseStatementMutation builder.
func (m *EnterpriseStatementMutation) Where(ps ...predicate.EnterpriseStatement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnterpriseStatementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnterpriseStatementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EnterpriseStatement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnterpriseStatementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnterpriseStatementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EnterpriseStatement).
func (m *EnterpriseStatementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnterpriseStatementMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, enterprisestatement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enterprisestatement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, enterprisestatement.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, enterprisestatement.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, enterprisestatement.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, enterprisestatement.FieldRemark)
	}
	if m.enterprise != nil {
		fields = append(fields, enterprisestatement.FieldEnterpriseID)
	}
	if m.cost != nil {
		fields = append(fields, enterprisestatement.FieldCost)
	}
	if m.settled_at != nil {
		fields = append(fields, enterprisestatement.FieldSettledAt)
	}
	if m.days != nil {
		fields = append(fields, enterprisestatement.FieldDays)
	}
	if m.rider_number != nil {
		fields = append(fields, enterprisestatement.FieldRiderNumber)
	}
	if m.date != nil {
		fields = append(fields, enterprisestatement.FieldDate)
	}
	if m.start != nil {
		fields = append(fields, enterprisestatement.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, enterprisestatement.FieldEnd)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnterpriseStatementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enterprisestatement.FieldCreatedAt:
		return m.CreatedAt()
	case enterprisestatement.FieldUpdatedAt:
		return m.UpdatedAt()
	case enterprisestatement.FieldDeletedAt:
		return m.DeletedAt()
	case enterprisestatement.FieldCreator:
		return m.Creator()
	case enterprisestatement.FieldLastModifier:
		return m.LastModifier()
	case enterprisestatement.FieldRemark:
		return m.Remark()
	case enterprisestatement.FieldEnterpriseID:
		return m.EnterpriseID()
	case enterprisestatement.FieldCost:
		return m.Cost()
	case enterprisestatement.FieldSettledAt:
		return m.SettledAt()
	case enterprisestatement.FieldDays:
		return m.Days()
	case enterprisestatement.FieldRiderNumber:
		return m.RiderNumber()
	case enterprisestatement.FieldDate:
		return m.Date()
	case enterprisestatement.FieldStart:
		return m.Start()
	case enterprisestatement.FieldEnd:
		return m.End()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnterpriseStatementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enterprisestatement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enterprisestatement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case enterprisestatement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case enterprisestatement.FieldCreator:
		return m.OldCreator(ctx)
	case enterprisestatement.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case enterprisestatement.FieldRemark:
		return m.OldRemark(ctx)
	case enterprisestatement.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case enterprisestatement.FieldCost:
		return m.OldCost(ctx)
	case enterprisestatement.FieldSettledAt:
		return m.OldSettledAt(ctx)
	case enterprisestatement.FieldDays:
		return m.OldDays(ctx)
	case enterprisestatement.FieldRiderNumber:
		return m.OldRiderNumber(ctx)
	case enterprisestatement.FieldDate:
		return m.OldDate(ctx)
	case enterprisestatement.FieldStart:
		return m.OldStart(ctx)
	case enterprisestatement.FieldEnd:
		return m.OldEnd(ctx)
	}
	return nil, fmt.Errorf("unknown EnterpriseStatement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseStatementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enterprisestatement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enterprisestatement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case enterprisestatement.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case enterprisestatement.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case enterprisestatement.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case enterprisestatement.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case enterprisestatement.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case enterprisestatement.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCost(v)
		return nil
	case enterprisestatement.FieldSettledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettledAt(v)
		return nil
	case enterprisestatement.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDays(v)
		return nil
	case enterprisestatement.FieldRiderNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderNumber(v)
		return nil
	case enterprisestatement.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case enterprisestatement.FieldStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case enterprisestatement.FieldEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	}
	return fmt.Errorf("unknown EnterpriseStatement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnterpriseStatementMutation) AddedFields() []string {
	var fields []string
	if m.addcost != nil {
		fields = append(fields, enterprisestatement.FieldCost)
	}
	if m.adddays != nil {
		fields = append(fields, enterprisestatement.FieldDays)
	}
	if m.addrider_number != nil {
		fields = append(fields, enterprisestatement.FieldRiderNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnterpriseStatementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case enterprisestatement.FieldCost:
		return m.AddedCost()
	case enterprisestatement.FieldDays:
		return m.AddedDays()
	case enterprisestatement.FieldRiderNumber:
		return m.AddedRiderNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseStatementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case enterprisestatement.FieldCost:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCost(v)
		return nil
	case enterprisestatement.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDays(v)
		return nil
	case enterprisestatement.FieldRiderNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRiderNumber(v)
		return nil
	}
	return fmt.Errorf("unknown EnterpriseStatement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnterpriseStatementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(enterprisestatement.FieldDeletedAt) {
		fields = append(fields, enterprisestatement.FieldDeletedAt)
	}
	if m.FieldCleared(enterprisestatement.FieldCreator) {
		fields = append(fields, enterprisestatement.FieldCreator)
	}
	if m.FieldCleared(enterprisestatement.FieldLastModifier) {
		fields = append(fields, enterprisestatement.FieldLastModifier)
	}
	if m.FieldCleared(enterprisestatement.FieldRemark) {
		fields = append(fields, enterprisestatement.FieldRemark)
	}
	if m.FieldCleared(enterprisestatement.FieldSettledAt) {
		fields = append(fields, enterprisestatement.FieldSettledAt)
	}
	if m.FieldCleared(enterprisestatement.FieldDate) {
		fields = append(fields, enterprisestatement.FieldDate)
	}
	if m.FieldCleared(enterprisestatement.FieldEnd) {
		fields = append(fields, enterprisestatement.FieldEnd)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnterpriseStatementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnterpriseStatementMutation) ClearField(name string) error {
	switch name {
	case enterprisestatement.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case enterprisestatement.FieldCreator:
		m.ClearCreator()
		return nil
	case enterprisestatement.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case enterprisestatement.FieldRemark:
		m.ClearRemark()
		return nil
	case enterprisestatement.FieldSettledAt:
		m.ClearSettledAt()
		return nil
	case enterprisestatement.FieldDate:
		m.ClearDate()
		return nil
	case enterprisestatement.FieldEnd:
		m.ClearEnd()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseStatement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnterpriseStatementMutation) ResetField(name string) error {
	switch name {
	case enterprisestatement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enterprisestatement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case enterprisestatement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case enterprisestatement.FieldCreator:
		m.ResetCreator()
		return nil
	case enterprisestatement.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case enterprisestatement.FieldRemark:
		m.ResetRemark()
		return nil
	case enterprisestatement.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case enterprisestatement.FieldCost:
		m.ResetCost()
		return nil
	case enterprisestatement.FieldSettledAt:
		m.ResetSettledAt()
		return nil
	case enterprisestatement.FieldDays:
		m.ResetDays()
		return nil
	case enterprisestatement.FieldRiderNumber:
		m.ResetRiderNumber()
		return nil
	case enterprisestatement.FieldDate:
		m.ResetDate()
		return nil
	case enterprisestatement.FieldStart:
		m.ResetStart()
		return nil
	case enterprisestatement.FieldEnd:
		m.ResetEnd()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseStatement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnterpriseStatementMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.enterprise != nil {
		edges = append(edges, enterprisestatement.EdgeEnterprise)
	}
	if m.bills != nil {
		edges = append(edges, enterprisestatement.EdgeBills)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnterpriseStatementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enterprisestatement.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	case enterprisestatement.EdgeBills:
		ids := make([]ent.Value, 0, len(m.bills))
		for id := range m.bills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnterpriseStatementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbills != nil {
		edges = append(edges, enterprisestatement.EdgeBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnterpriseStatementMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case enterprisestatement.EdgeBills:
		ids := make([]ent.Value, 0, len(m.removedbills))
		for id := range m.removedbills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnterpriseStatementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedenterprise {
		edges = append(edges, enterprisestatement.EdgeEnterprise)
	}
	if m.clearedbills {
		edges = append(edges, enterprisestatement.EdgeBills)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnterpriseStatementMutation) EdgeCleared(name string) bool {
	switch name {
	case enterprisestatement.EdgeEnterprise:
		return m.clearedenterprise
	case enterprisestatement.EdgeBills:
		return m.clearedbills
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnterpriseStatementMutation) ClearEdge(name string) error {
	switch name {
	case enterprisestatement.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseStatement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnterpriseStatementMutation) ResetEdge(name string) error {
	switch name {
	case enterprisestatement.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	case enterprisestatement.EdgeBills:
		m.ResetBills()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseStatement edge %s", name)
}

// EnterpriseStationMutation represents an operation that mutates the EnterpriseStation nodes in the graph.
type EnterpriseStationMutation struct {
	config
	op                           Op
	typ                          string
	id                           *uint64
	created_at                   *time.Time
	updated_at                   *time.Time
	deleted_at                   *time.Time
	creator                      **model.Modifier
	last_modifier                **model.Modifier
	remark                       *string
	name                         *string
	clearedFields                map[string]struct{}
	city                         *uint64
	clearedcity                  bool
	enterprise                   *uint64
	clearedenterprise            bool
	agents                       map[uint64]struct{}
	removedagents                map[uint64]struct{}
	clearedagents                bool
	swap_putin_batteries         map[uint64]struct{}
	removedswap_putin_batteries  map[uint64]struct{}
	clearedswap_putin_batteries  bool
	swap_putout_batteries        map[uint64]struct{}
	removedswap_putout_batteries map[uint64]struct{}
	clearedswap_putout_batteries bool
	cabinets                     map[uint64]struct{}
	removedcabinets              map[uint64]struct{}
	clearedcabinets              bool
	batteries                    map[uint64]struct{}
	removedbatteries             map[uint64]struct{}
	clearedbatteries             bool
	stocks                       map[uint64]struct{}
	removedstocks                map[uint64]struct{}
	clearedstocks                bool
	done                         bool
	oldValue                     func(context.Context) (*EnterpriseStation, error)
	predicates                   []predicate.EnterpriseStation
}

var _ ent.Mutation = (*EnterpriseStationMutation)(nil)

// enterprisestationOption allows management of the mutation configuration using functional options.
type enterprisestationOption func(*EnterpriseStationMutation)

// newEnterpriseStationMutation creates new mutation for the EnterpriseStation entity.
func newEnterpriseStationMutation(c config, op Op, opts ...enterprisestationOption) *EnterpriseStationMutation {
	m := &EnterpriseStationMutation{
		config:        c,
		op:            op,
		typ:           TypeEnterpriseStation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnterpriseStationID sets the ID field of the mutation.
func withEnterpriseStationID(id uint64) enterprisestationOption {
	return func(m *EnterpriseStationMutation) {
		var (
			err   error
			once  sync.Once
			value *EnterpriseStation
		)
		m.oldValue = func(ctx context.Context) (*EnterpriseStation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EnterpriseStation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnterpriseStation sets the old EnterpriseStation of the mutation.
func withEnterpriseStation(node *EnterpriseStation) enterprisestationOption {
	return func(m *EnterpriseStationMutation) {
		m.oldValue = func(context.Context) (*EnterpriseStation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnterpriseStationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnterpriseStationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnterpriseStationMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnterpriseStationMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EnterpriseStation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EnterpriseStationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnterpriseStationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EnterpriseStation entity.
// If the EnterpriseStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnterpriseStationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnterpriseStationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnterpriseStationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EnterpriseStation entity.
// If the EnterpriseStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnterpriseStationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EnterpriseStationMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EnterpriseStationMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the EnterpriseStation entity.
// If the EnterpriseStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStationMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EnterpriseStationMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[enterprisestation.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EnterpriseStationMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[enterprisestation.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EnterpriseStationMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, enterprisestation.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *EnterpriseStationMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *EnterpriseStationMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the EnterpriseStation entity.
// If the EnterpriseStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStationMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *EnterpriseStationMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[enterprisestation.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *EnterpriseStationMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[enterprisestation.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *EnterpriseStationMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, enterprisestation.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *EnterpriseStationMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *EnterpriseStationMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the EnterpriseStation entity.
// If the EnterpriseStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStationMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *EnterpriseStationMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[enterprisestation.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *EnterpriseStationMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[enterprisestation.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *EnterpriseStationMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, enterprisestation.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *EnterpriseStationMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *EnterpriseStationMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the EnterpriseStation entity.
// If the EnterpriseStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStationMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *EnterpriseStationMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[enterprisestation.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *EnterpriseStationMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[enterprisestation.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *EnterpriseStationMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, enterprisestation.FieldRemark)
}

// SetCityID sets the "city_id" field.
func (m *EnterpriseStationMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *EnterpriseStationMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the EnterpriseStation entity.
// If the EnterpriseStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStationMutation) OldCityID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ClearCityID clears the value of the "city_id" field.
func (m *EnterpriseStationMutation) ClearCityID() {
	m.city = nil
	m.clearedFields[enterprisestation.FieldCityID] = struct{}{}
}

// CityIDCleared returns if the "city_id" field was cleared in this mutation.
func (m *EnterpriseStationMutation) CityIDCleared() bool {
	_, ok := m.clearedFields[enterprisestation.FieldCityID]
	return ok
}

// ResetCityID resets all changes to the "city_id" field.
func (m *EnterpriseStationMutation) ResetCityID() {
	m.city = nil
	delete(m.clearedFields, enterprisestation.FieldCityID)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *EnterpriseStationMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *EnterpriseStationMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the EnterpriseStation entity.
// If the EnterpriseStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStationMutation) OldEnterpriseID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *EnterpriseStationMutation) ResetEnterpriseID() {
	m.enterprise = nil
}

// SetName sets the "name" field.
func (m *EnterpriseStationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EnterpriseStationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EnterpriseStation entity.
// If the EnterpriseStation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseStationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EnterpriseStationMutation) ResetName() {
	m.name = nil
}

// ClearCity clears the "city" edge to the City entity.
func (m *EnterpriseStationMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[enterprisestation.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *EnterpriseStationMutation) CityCleared() bool {
	return m.CityIDCleared() || m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *EnterpriseStationMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *EnterpriseStationMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *EnterpriseStationMutation) ClearEnterprise() {
	m.clearedenterprise = true
	m.clearedFields[enterprisestation.FieldEnterpriseID] = struct{}{}
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *EnterpriseStationMutation) EnterpriseCleared() bool {
	return m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *EnterpriseStationMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *EnterpriseStationMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// AddAgentIDs adds the "agents" edge to the Agent entity by ids.
func (m *EnterpriseStationMutation) AddAgentIDs(ids ...uint64) {
	if m.agents == nil {
		m.agents = make(map[uint64]struct{})
	}
	for i := range ids {
		m.agents[ids[i]] = struct{}{}
	}
}

// ClearAgents clears the "agents" edge to the Agent entity.
func (m *EnterpriseStationMutation) ClearAgents() {
	m.clearedagents = true
}

// AgentsCleared reports if the "agents" edge to the Agent entity was cleared.
func (m *EnterpriseStationMutation) AgentsCleared() bool {
	return m.clearedagents
}

// RemoveAgentIDs removes the "agents" edge to the Agent entity by IDs.
func (m *EnterpriseStationMutation) RemoveAgentIDs(ids ...uint64) {
	if m.removedagents == nil {
		m.removedagents = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.agents, ids[i])
		m.removedagents[ids[i]] = struct{}{}
	}
}

// RemovedAgents returns the removed IDs of the "agents" edge to the Agent entity.
func (m *EnterpriseStationMutation) RemovedAgentsIDs() (ids []uint64) {
	for id := range m.removedagents {
		ids = append(ids, id)
	}
	return
}

// AgentsIDs returns the "agents" edge IDs in the mutation.
func (m *EnterpriseStationMutation) AgentsIDs() (ids []uint64) {
	for id := range m.agents {
		ids = append(ids, id)
	}
	return
}

// ResetAgents resets all changes to the "agents" edge.
func (m *EnterpriseStationMutation) ResetAgents() {
	m.agents = nil
	m.clearedagents = false
	m.removedagents = nil
}

// AddSwapPutinBatteryIDs adds the "swap_putin_batteries" edge to the EnterpriseBatterySwap entity by ids.
func (m *EnterpriseStationMutation) AddSwapPutinBatteryIDs(ids ...uint64) {
	if m.swap_putin_batteries == nil {
		m.swap_putin_batteries = make(map[uint64]struct{})
	}
	for i := range ids {
		m.swap_putin_batteries[ids[i]] = struct{}{}
	}
}

// ClearSwapPutinBatteries clears the "swap_putin_batteries" edge to the EnterpriseBatterySwap entity.
func (m *EnterpriseStationMutation) ClearSwapPutinBatteries() {
	m.clearedswap_putin_batteries = true
}

// SwapPutinBatteriesCleared reports if the "swap_putin_batteries" edge to the EnterpriseBatterySwap entity was cleared.
func (m *EnterpriseStationMutation) SwapPutinBatteriesCleared() bool {
	return m.clearedswap_putin_batteries
}

// RemoveSwapPutinBatteryIDs removes the "swap_putin_batteries" edge to the EnterpriseBatterySwap entity by IDs.
func (m *EnterpriseStationMutation) RemoveSwapPutinBatteryIDs(ids ...uint64) {
	if m.removedswap_putin_batteries == nil {
		m.removedswap_putin_batteries = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.swap_putin_batteries, ids[i])
		m.removedswap_putin_batteries[ids[i]] = struct{}{}
	}
}

// RemovedSwapPutinBatteries returns the removed IDs of the "swap_putin_batteries" edge to the EnterpriseBatterySwap entity.
func (m *EnterpriseStationMutation) RemovedSwapPutinBatteriesIDs() (ids []uint64) {
	for id := range m.removedswap_putin_batteries {
		ids = append(ids, id)
	}
	return
}

// SwapPutinBatteriesIDs returns the "swap_putin_batteries" edge IDs in the mutation.
func (m *EnterpriseStationMutation) SwapPutinBatteriesIDs() (ids []uint64) {
	for id := range m.swap_putin_batteries {
		ids = append(ids, id)
	}
	return
}

// ResetSwapPutinBatteries resets all changes to the "swap_putin_batteries" edge.
func (m *EnterpriseStationMutation) ResetSwapPutinBatteries() {
	m.swap_putin_batteries = nil
	m.clearedswap_putin_batteries = false
	m.removedswap_putin_batteries = nil
}

// AddSwapPutoutBatteryIDs adds the "swap_putout_batteries" edge to the EnterpriseBatterySwap entity by ids.
func (m *EnterpriseStationMutation) AddSwapPutoutBatteryIDs(ids ...uint64) {
	if m.swap_putout_batteries == nil {
		m.swap_putout_batteries = make(map[uint64]struct{})
	}
	for i := range ids {
		m.swap_putout_batteries[ids[i]] = struct{}{}
	}
}

// ClearSwapPutoutBatteries clears the "swap_putout_batteries" edge to the EnterpriseBatterySwap entity.
func (m *EnterpriseStationMutation) ClearSwapPutoutBatteries() {
	m.clearedswap_putout_batteries = true
}

// SwapPutoutBatteriesCleared reports if the "swap_putout_batteries" edge to the EnterpriseBatterySwap entity was cleared.
func (m *EnterpriseStationMutation) SwapPutoutBatteriesCleared() bool {
	return m.clearedswap_putout_batteries
}

// RemoveSwapPutoutBatteryIDs removes the "swap_putout_batteries" edge to the EnterpriseBatterySwap entity by IDs.
func (m *EnterpriseStationMutation) RemoveSwapPutoutBatteryIDs(ids ...uint64) {
	if m.removedswap_putout_batteries == nil {
		m.removedswap_putout_batteries = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.swap_putout_batteries, ids[i])
		m.removedswap_putout_batteries[ids[i]] = struct{}{}
	}
}

// RemovedSwapPutoutBatteries returns the removed IDs of the "swap_putout_batteries" edge to the EnterpriseBatterySwap entity.
func (m *EnterpriseStationMutation) RemovedSwapPutoutBatteriesIDs() (ids []uint64) {
	for id := range m.removedswap_putout_batteries {
		ids = append(ids, id)
	}
	return
}

// SwapPutoutBatteriesIDs returns the "swap_putout_batteries" edge IDs in the mutation.
func (m *EnterpriseStationMutation) SwapPutoutBatteriesIDs() (ids []uint64) {
	for id := range m.swap_putout_batteries {
		ids = append(ids, id)
	}
	return
}

// ResetSwapPutoutBatteries resets all changes to the "swap_putout_batteries" edge.
func (m *EnterpriseStationMutation) ResetSwapPutoutBatteries() {
	m.swap_putout_batteries = nil
	m.clearedswap_putout_batteries = false
	m.removedswap_putout_batteries = nil
}

// AddCabinetIDs adds the "cabinets" edge to the Cabinet entity by ids.
func (m *EnterpriseStationMutation) AddCabinetIDs(ids ...uint64) {
	if m.cabinets == nil {
		m.cabinets = make(map[uint64]struct{})
	}
	for i := range ids {
		m.cabinets[ids[i]] = struct{}{}
	}
}

// ClearCabinets clears the "cabinets" edge to the Cabinet entity.
func (m *EnterpriseStationMutation) ClearCabinets() {
	m.clearedcabinets = true
}

// CabinetsCleared reports if the "cabinets" edge to the Cabinet entity was cleared.
func (m *EnterpriseStationMutation) CabinetsCleared() bool {
	return m.clearedcabinets
}

// RemoveCabinetIDs removes the "cabinets" edge to the Cabinet entity by IDs.
func (m *EnterpriseStationMutation) RemoveCabinetIDs(ids ...uint64) {
	if m.removedcabinets == nil {
		m.removedcabinets = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.cabinets, ids[i])
		m.removedcabinets[ids[i]] = struct{}{}
	}
}

// RemovedCabinets returns the removed IDs of the "cabinets" edge to the Cabinet entity.
func (m *EnterpriseStationMutation) RemovedCabinetsIDs() (ids []uint64) {
	for id := range m.removedcabinets {
		ids = append(ids, id)
	}
	return
}

// CabinetsIDs returns the "cabinets" edge IDs in the mutation.
func (m *EnterpriseStationMutation) CabinetsIDs() (ids []uint64) {
	for id := range m.cabinets {
		ids = append(ids, id)
	}
	return
}

// ResetCabinets resets all changes to the "cabinets" edge.
func (m *EnterpriseStationMutation) ResetCabinets() {
	m.cabinets = nil
	m.clearedcabinets = false
	m.removedcabinets = nil
}

// AddBatteryIDs adds the "batteries" edge to the Battery entity by ids.
func (m *EnterpriseStationMutation) AddBatteryIDs(ids ...uint64) {
	if m.batteries == nil {
		m.batteries = make(map[uint64]struct{})
	}
	for i := range ids {
		m.batteries[ids[i]] = struct{}{}
	}
}

// ClearBatteries clears the "batteries" edge to the Battery entity.
func (m *EnterpriseStationMutation) ClearBatteries() {
	m.clearedbatteries = true
}

// BatteriesCleared reports if the "batteries" edge to the Battery entity was cleared.
func (m *EnterpriseStationMutation) BatteriesCleared() bool {
	return m.clearedbatteries
}

// RemoveBatteryIDs removes the "batteries" edge to the Battery entity by IDs.
func (m *EnterpriseStationMutation) RemoveBatteryIDs(ids ...uint64) {
	if m.removedbatteries == nil {
		m.removedbatteries = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.batteries, ids[i])
		m.removedbatteries[ids[i]] = struct{}{}
	}
}

// RemovedBatteries returns the removed IDs of the "batteries" edge to the Battery entity.
func (m *EnterpriseStationMutation) RemovedBatteriesIDs() (ids []uint64) {
	for id := range m.removedbatteries {
		ids = append(ids, id)
	}
	return
}

// BatteriesIDs returns the "batteries" edge IDs in the mutation.
func (m *EnterpriseStationMutation) BatteriesIDs() (ids []uint64) {
	for id := range m.batteries {
		ids = append(ids, id)
	}
	return
}

// ResetBatteries resets all changes to the "batteries" edge.
func (m *EnterpriseStationMutation) ResetBatteries() {
	m.batteries = nil
	m.clearedbatteries = false
	m.removedbatteries = nil
}

// AddStockIDs adds the "stocks" edge to the Stock entity by ids.
func (m *EnterpriseStationMutation) AddStockIDs(ids ...uint64) {
	if m.stocks == nil {
		m.stocks = make(map[uint64]struct{})
	}
	for i := range ids {
		m.stocks[ids[i]] = struct{}{}
	}
}

// ClearStocks clears the "stocks" edge to the Stock entity.
func (m *EnterpriseStationMutation) ClearStocks() {
	m.clearedstocks = true
}

// StocksCleared reports if the "stocks" edge to the Stock entity was cleared.
func (m *EnterpriseStationMutation) StocksCleared() bool {
	return m.clearedstocks
}

// RemoveStockIDs removes the "stocks" edge to the Stock entity by IDs.
func (m *EnterpriseStationMutation) RemoveStockIDs(ids ...uint64) {
	if m.removedstocks == nil {
		m.removedstocks = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.stocks, ids[i])
		m.removedstocks[ids[i]] = struct{}{}
	}
}

// RemovedStocks returns the removed IDs of the "stocks" edge to the Stock entity.
func (m *EnterpriseStationMutation) RemovedStocksIDs() (ids []uint64) {
	for id := range m.removedstocks {
		ids = append(ids, id)
	}
	return
}

// StocksIDs returns the "stocks" edge IDs in the mutation.
func (m *EnterpriseStationMutation) StocksIDs() (ids []uint64) {
	for id := range m.stocks {
		ids = append(ids, id)
	}
	return
}

// ResetStocks resets all changes to the "stocks" edge.
func (m *EnterpriseStationMutation) ResetStocks() {
	m.stocks = nil
	m.clearedstocks = false
	m.removedstocks = nil
}

// Where appends a list predicates to the EnterpriseStationMutation builder.
func (m *EnterpriseStationMutation) Where(ps ...predicate.EnterpriseStation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EnterpriseStationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EnterpriseStationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EnterpriseStation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EnterpriseStationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EnterpriseStationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EnterpriseStation).
func (m *EnterpriseStationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnterpriseStationMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, enterprisestation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enterprisestation.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, enterprisestation.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, enterprisestation.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, enterprisestation.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, enterprisestation.FieldRemark)
	}
	if m.city != nil {
		fields = append(fields, enterprisestation.FieldCityID)
	}
	if m.enterprise != nil {
		fields = append(fields, enterprisestation.FieldEnterpriseID)
	}
	if m.name != nil {
		fields = append(fields, enterprisestation.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnterpriseStationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enterprisestation.FieldCreatedAt:
		return m.CreatedAt()
	case enterprisestation.FieldUpdatedAt:
		return m.UpdatedAt()
	case enterprisestation.FieldDeletedAt:
		return m.DeletedAt()
	case enterprisestation.FieldCreator:
		return m.Creator()
	case enterprisestation.FieldLastModifier:
		return m.LastModifier()
	case enterprisestation.FieldRemark:
		return m.Remark()
	case enterprisestation.FieldCityID:
		return m.CityID()
	case enterprisestation.FieldEnterpriseID:
		return m.EnterpriseID()
	case enterprisestation.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnterpriseStationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enterprisestation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enterprisestation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case enterprisestation.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case enterprisestation.FieldCreator:
		return m.OldCreator(ctx)
	case enterprisestation.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case enterprisestation.FieldRemark:
		return m.OldRemark(ctx)
	case enterprisestation.FieldCityID:
		return m.OldCityID(ctx)
	case enterprisestation.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case enterprisestation.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown EnterpriseStation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseStationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enterprisestation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enterprisestation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case enterprisestation.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case enterprisestation.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case enterprisestation.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case enterprisestation.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case enterprisestation.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case enterprisestation.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case enterprisestation.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown EnterpriseStation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnterpriseStationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnterpriseStationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseStationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EnterpriseStation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnterpriseStationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(enterprisestation.FieldDeletedAt) {
		fields = append(fields, enterprisestation.FieldDeletedAt)
	}
	if m.FieldCleared(enterprisestation.FieldCreator) {
		fields = append(fields, enterprisestation.FieldCreator)
	}
	if m.FieldCleared(enterprisestation.FieldLastModifier) {
		fields = append(fields, enterprisestation.FieldLastModifier)
	}
	if m.FieldCleared(enterprisestation.FieldRemark) {
		fields = append(fields, enterprisestation.FieldRemark)
	}
	if m.FieldCleared(enterprisestation.FieldCityID) {
		fields = append(fields, enterprisestation.FieldCityID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnterpriseStationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnterpriseStationMutation) ClearField(name string) error {
	switch name {
	case enterprisestation.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case enterprisestation.FieldCreator:
		m.ClearCreator()
		return nil
	case enterprisestation.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case enterprisestation.FieldRemark:
		m.ClearRemark()
		return nil
	case enterprisestation.FieldCityID:
		m.ClearCityID()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseStation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnterpriseStationMutation) ResetField(name string) error {
	switch name {
	case enterprisestation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enterprisestation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case enterprisestation.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case enterprisestation.FieldCreator:
		m.ResetCreator()
		return nil
	case enterprisestation.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case enterprisestation.FieldRemark:
		m.ResetRemark()
		return nil
	case enterprisestation.FieldCityID:
		m.ResetCityID()
		return nil
	case enterprisestation.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case enterprisestation.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseStation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnterpriseStationMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.city != nil {
		edges = append(edges, enterprisestation.EdgeCity)
	}
	if m.enterprise != nil {
		edges = append(edges, enterprisestation.EdgeEnterprise)
	}
	if m.agents != nil {
		edges = append(edges, enterprisestation.EdgeAgents)
	}
	if m.swap_putin_batteries != nil {
		edges = append(edges, enterprisestation.EdgeSwapPutinBatteries)
	}
	if m.swap_putout_batteries != nil {
		edges = append(edges, enterprisestation.EdgeSwapPutoutBatteries)
	}
	if m.cabinets != nil {
		edges = append(edges, enterprisestation.EdgeCabinets)
	}
	if m.batteries != nil {
		edges = append(edges, enterprisestation.EdgeBatteries)
	}
	if m.stocks != nil {
		edges = append(edges, enterprisestation.EdgeStocks)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnterpriseStationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enterprisestation.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case enterprisestation.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	case enterprisestation.EdgeAgents:
		ids := make([]ent.Value, 0, len(m.agents))
		for id := range m.agents {
			ids = append(ids, id)
		}
		return ids
	case enterprisestation.EdgeSwapPutinBatteries:
		ids := make([]ent.Value, 0, len(m.swap_putin_batteries))
		for id := range m.swap_putin_batteries {
			ids = append(ids, id)
		}
		return ids
	case enterprisestation.EdgeSwapPutoutBatteries:
		ids := make([]ent.Value, 0, len(m.swap_putout_batteries))
		for id := range m.swap_putout_batteries {
			ids = append(ids, id)
		}
		return ids
	case enterprisestation.EdgeCabinets:
		ids := make([]ent.Value, 0, len(m.cabinets))
		for id := range m.cabinets {
			ids = append(ids, id)
		}
		return ids
	case enterprisestation.EdgeBatteries:
		ids := make([]ent.Value, 0, len(m.batteries))
		for id := range m.batteries {
			ids = append(ids, id)
		}
		return ids
	case enterprisestation.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.stocks))
		for id := range m.stocks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnterpriseStationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedagents != nil {
		edges = append(edges, enterprisestation.EdgeAgents)
	}
	if m.removedswap_putin_batteries != nil {
		edges = append(edges, enterprisestation.EdgeSwapPutinBatteries)
	}
	if m.removedswap_putout_batteries != nil {
		edges = append(edges, enterprisestation.EdgeSwapPutoutBatteries)
	}
	if m.removedcabinets != nil {
		edges = append(edges, enterprisestation.EdgeCabinets)
	}
	if m.removedbatteries != nil {
		edges = append(edges, enterprisestation.EdgeBatteries)
	}
	if m.removedstocks != nil {
		edges = append(edges, enterprisestation.EdgeStocks)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnterpriseStationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case enterprisestation.EdgeAgents:
		ids := make([]ent.Value, 0, len(m.removedagents))
		for id := range m.removedagents {
			ids = append(ids, id)
		}
		return ids
	case enterprisestation.EdgeSwapPutinBatteries:
		ids := make([]ent.Value, 0, len(m.removedswap_putin_batteries))
		for id := range m.removedswap_putin_batteries {
			ids = append(ids, id)
		}
		return ids
	case enterprisestation.EdgeSwapPutoutBatteries:
		ids := make([]ent.Value, 0, len(m.removedswap_putout_batteries))
		for id := range m.removedswap_putout_batteries {
			ids = append(ids, id)
		}
		return ids
	case enterprisestation.EdgeCabinets:
		ids := make([]ent.Value, 0, len(m.removedcabinets))
		for id := range m.removedcabinets {
			ids = append(ids, id)
		}
		return ids
	case enterprisestation.EdgeBatteries:
		ids := make([]ent.Value, 0, len(m.removedbatteries))
		for id := range m.removedbatteries {
			ids = append(ids, id)
		}
		return ids
	case enterprisestation.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.removedstocks))
		for id := range m.removedstocks {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnterpriseStationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedcity {
		edges = append(edges, enterprisestation.EdgeCity)
	}
	if m.clearedenterprise {
		edges = append(edges, enterprisestation.EdgeEnterprise)
	}
	if m.clearedagents {
		edges = append(edges, enterprisestation.EdgeAgents)
	}
	if m.clearedswap_putin_batteries {
		edges = append(edges, enterprisestation.EdgeSwapPutinBatteries)
	}
	if m.clearedswap_putout_batteries {
		edges = append(edges, enterprisestation.EdgeSwapPutoutBatteries)
	}
	if m.clearedcabinets {
		edges = append(edges, enterprisestation.EdgeCabinets)
	}
	if m.clearedbatteries {
		edges = append(edges, enterprisestation.EdgeBatteries)
	}
	if m.clearedstocks {
		edges = append(edges, enterprisestation.EdgeStocks)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnterpriseStationMutation) EdgeCleared(name string) bool {
	switch name {
	case enterprisestation.EdgeCity:
		return m.clearedcity
	case enterprisestation.EdgeEnterprise:
		return m.clearedenterprise
	case enterprisestation.EdgeAgents:
		return m.clearedagents
	case enterprisestation.EdgeSwapPutinBatteries:
		return m.clearedswap_putin_batteries
	case enterprisestation.EdgeSwapPutoutBatteries:
		return m.clearedswap_putout_batteries
	case enterprisestation.EdgeCabinets:
		return m.clearedcabinets
	case enterprisestation.EdgeBatteries:
		return m.clearedbatteries
	case enterprisestation.EdgeStocks:
		return m.clearedstocks
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnterpriseStationMutation) ClearEdge(name string) error {
	switch name {
	case enterprisestation.EdgeCity:
		m.ClearCity()
		return nil
	case enterprisestation.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseStation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnterpriseStationMutation) ResetEdge(name string) error {
	switch name {
	case enterprisestation.EdgeCity:
		m.ResetCity()
		return nil
	case enterprisestation.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	case enterprisestation.EdgeAgents:
		m.ResetAgents()
		return nil
	case enterprisestation.EdgeSwapPutinBatteries:
		m.ResetSwapPutinBatteries()
		return nil
	case enterprisestation.EdgeSwapPutoutBatteries:
		m.ResetSwapPutoutBatteries()
		return nil
	case enterprisestation.EdgeCabinets:
		m.ResetCabinets()
		return nil
	case enterprisestation.EdgeBatteries:
		m.ResetBatteries()
		return nil
	case enterprisestation.EdgeStocks:
		m.ResetStocks()
		return nil
	}
	return fmt.Errorf("unknown EnterpriseStation edge %s", name)
}

// ExceptionMutation represents an operation that mutates the Exception nodes in the graph.
type ExceptionMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	status            *uint8
	addstatus         *int8
	name              *string
	model             *string
	num               *int
	addnum            *int
	reason            *string
	description       *string
	attachments       *[]string
	appendattachments []string
	clearedFields     map[string]struct{}
	city              *uint64
	clearedcity       bool
	employee          *uint64
	clearedemployee   bool
	store             *uint64
	clearedstore      bool
	done              bool
	oldValue          func(context.Context) (*Exception, error)
	predicates        []predicate.Exception
}

var _ ent.Mutation = (*ExceptionMutation)(nil)

// exceptionOption allows management of the mutation configuration using functional options.
type exceptionOption func(*ExceptionMutation)

// newExceptionMutation creates new mutation for the Exception entity.
func newExceptionMutation(c config, op Op, opts ...exceptionOption) *ExceptionMutation {
	m := &ExceptionMutation{
		config:        c,
		op:            op,
		typ:           TypeException,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExceptionID sets the ID field of the mutation.
func withExceptionID(id uint64) exceptionOption {
	return func(m *ExceptionMutation) {
		var (
			err   error
			once  sync.Once
			value *Exception
		)
		m.oldValue = func(ctx context.Context) (*Exception, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exception.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withException sets the old Exception of the mutation.
func withException(node *Exception) exceptionOption {
	return func(m *ExceptionMutation) {
		m.oldValue = func(context.Context) (*Exception, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExceptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExceptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExceptionMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExceptionMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exception.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ExceptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExceptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExceptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExceptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExceptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExceptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ExceptionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ExceptionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ExceptionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[exception.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ExceptionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[exception.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ExceptionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, exception.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *ExceptionMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *ExceptionMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *ExceptionMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[exception.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *ExceptionMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[exception.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *ExceptionMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, exception.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *ExceptionMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *ExceptionMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *ExceptionMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[exception.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *ExceptionMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[exception.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *ExceptionMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, exception.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *ExceptionMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ExceptionMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ExceptionMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[exception.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ExceptionMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[exception.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ExceptionMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, exception.FieldRemark)
}

// SetCityID sets the "city_id" field.
func (m *ExceptionMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *ExceptionMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *ExceptionMutation) ResetCityID() {
	m.city = nil
}

// SetEmployeeID sets the "employee_id" field.
func (m *ExceptionMutation) SetEmployeeID(u uint64) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *ExceptionMutation) EmployeeID() (r uint64, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldEmployeeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *ExceptionMutation) ResetEmployeeID() {
	m.employee = nil
}

// SetStatus sets the "status" field.
func (m *ExceptionMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ExceptionMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *ExceptionMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ExceptionMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ExceptionMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetStoreID sets the "store_id" field.
func (m *ExceptionMutation) SetStoreID(u uint64) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *ExceptionMutation) StoreID() (r uint64, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldStoreID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *ExceptionMutation) ResetStoreID() {
	m.store = nil
}

// SetName sets the "name" field.
func (m *ExceptionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ExceptionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ExceptionMutation) ResetName() {
	m.name = nil
}

// SetModel sets the "model" field.
func (m *ExceptionMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *ExceptionMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldModel(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *ExceptionMutation) ClearModel() {
	m.model = nil
	m.clearedFields[exception.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *ExceptionMutation) ModelCleared() bool {
	_, ok := m.clearedFields[exception.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *ExceptionMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, exception.FieldModel)
}

// SetNum sets the "num" field.
func (m *ExceptionMutation) SetNum(i int) {
	m.num = &i
	m.addnum = nil
}

// Num returns the value of the "num" field in the mutation.
func (m *ExceptionMutation) Num() (r int, exists bool) {
	v := m.num
	if v == nil {
		return
	}
	return *v, true
}

// OldNum returns the old "num" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNum: %w", err)
	}
	return oldValue.Num, nil
}

// AddNum adds i to the "num" field.
func (m *ExceptionMutation) AddNum(i int) {
	if m.addnum != nil {
		*m.addnum += i
	} else {
		m.addnum = &i
	}
}

// AddedNum returns the value that was added to the "num" field in this mutation.
func (m *ExceptionMutation) AddedNum() (r int, exists bool) {
	v := m.addnum
	if v == nil {
		return
	}
	return *v, true
}

// ResetNum resets all changes to the "num" field.
func (m *ExceptionMutation) ResetNum() {
	m.num = nil
	m.addnum = nil
}

// SetReason sets the "reason" field.
func (m *ExceptionMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *ExceptionMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *ExceptionMutation) ResetReason() {
	m.reason = nil
}

// SetDescription sets the "description" field.
func (m *ExceptionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ExceptionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ExceptionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[exception.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ExceptionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[exception.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ExceptionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, exception.FieldDescription)
}

// SetAttachments sets the "attachments" field.
func (m *ExceptionMutation) SetAttachments(s []string) {
	m.attachments = &s
	m.appendattachments = nil
}

// Attachments returns the value of the "attachments" field in the mutation.
func (m *ExceptionMutation) Attachments() (r []string, exists bool) {
	v := m.attachments
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachments returns the old "attachments" field's value of the Exception entity.
// If the Exception object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExceptionMutation) OldAttachments(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttachments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttachments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachments: %w", err)
	}
	return oldValue.Attachments, nil
}

// AppendAttachments adds s to the "attachments" field.
func (m *ExceptionMutation) AppendAttachments(s []string) {
	m.appendattachments = append(m.appendattachments, s...)
}

// AppendedAttachments returns the list of values that were appended to the "attachments" field in this mutation.
func (m *ExceptionMutation) AppendedAttachments() ([]string, bool) {
	if len(m.appendattachments) == 0 {
		return nil, false
	}
	return m.appendattachments, true
}

// ClearAttachments clears the value of the "attachments" field.
func (m *ExceptionMutation) ClearAttachments() {
	m.attachments = nil
	m.appendattachments = nil
	m.clearedFields[exception.FieldAttachments] = struct{}{}
}

// AttachmentsCleared returns if the "attachments" field was cleared in this mutation.
func (m *ExceptionMutation) AttachmentsCleared() bool {
	_, ok := m.clearedFields[exception.FieldAttachments]
	return ok
}

// ResetAttachments resets all changes to the "attachments" field.
func (m *ExceptionMutation) ResetAttachments() {
	m.attachments = nil
	m.appendattachments = nil
	delete(m.clearedFields, exception.FieldAttachments)
}

// ClearCity clears the "city" edge to the City entity.
func (m *ExceptionMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[exception.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *ExceptionMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *ExceptionMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *ExceptionMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *ExceptionMutation) ClearEmployee() {
	m.clearedemployee = true
	m.clearedFields[exception.FieldEmployeeID] = struct{}{}
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *ExceptionMutation) EmployeeCleared() bool {
	return m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *ExceptionMutation) EmployeeIDs() (ids []uint64) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *ExceptionMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// ClearStore clears the "store" edge to the Store entity.
func (m *ExceptionMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[exception.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *ExceptionMutation) StoreCleared() bool {
	return m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *ExceptionMutation) StoreIDs() (ids []uint64) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *ExceptionMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// Where appends a list predicates to the ExceptionMutation builder.
func (m *ExceptionMutation) Where(ps ...predicate.Exception) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExceptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExceptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Exception, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExceptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExceptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Exception).
func (m *ExceptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExceptionMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, exception.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, exception.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, exception.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, exception.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, exception.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, exception.FieldRemark)
	}
	if m.city != nil {
		fields = append(fields, exception.FieldCityID)
	}
	if m.employee != nil {
		fields = append(fields, exception.FieldEmployeeID)
	}
	if m.status != nil {
		fields = append(fields, exception.FieldStatus)
	}
	if m.store != nil {
		fields = append(fields, exception.FieldStoreID)
	}
	if m.name != nil {
		fields = append(fields, exception.FieldName)
	}
	if m.model != nil {
		fields = append(fields, exception.FieldModel)
	}
	if m.num != nil {
		fields = append(fields, exception.FieldNum)
	}
	if m.reason != nil {
		fields = append(fields, exception.FieldReason)
	}
	if m.description != nil {
		fields = append(fields, exception.FieldDescription)
	}
	if m.attachments != nil {
		fields = append(fields, exception.FieldAttachments)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExceptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exception.FieldCreatedAt:
		return m.CreatedAt()
	case exception.FieldUpdatedAt:
		return m.UpdatedAt()
	case exception.FieldDeletedAt:
		return m.DeletedAt()
	case exception.FieldCreator:
		return m.Creator()
	case exception.FieldLastModifier:
		return m.LastModifier()
	case exception.FieldRemark:
		return m.Remark()
	case exception.FieldCityID:
		return m.CityID()
	case exception.FieldEmployeeID:
		return m.EmployeeID()
	case exception.FieldStatus:
		return m.Status()
	case exception.FieldStoreID:
		return m.StoreID()
	case exception.FieldName:
		return m.Name()
	case exception.FieldModel:
		return m.Model()
	case exception.FieldNum:
		return m.Num()
	case exception.FieldReason:
		return m.Reason()
	case exception.FieldDescription:
		return m.Description()
	case exception.FieldAttachments:
		return m.Attachments()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExceptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exception.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case exception.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case exception.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case exception.FieldCreator:
		return m.OldCreator(ctx)
	case exception.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case exception.FieldRemark:
		return m.OldRemark(ctx)
	case exception.FieldCityID:
		return m.OldCityID(ctx)
	case exception.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case exception.FieldStatus:
		return m.OldStatus(ctx)
	case exception.FieldStoreID:
		return m.OldStoreID(ctx)
	case exception.FieldName:
		return m.OldName(ctx)
	case exception.FieldModel:
		return m.OldModel(ctx)
	case exception.FieldNum:
		return m.OldNum(ctx)
	case exception.FieldReason:
		return m.OldReason(ctx)
	case exception.FieldDescription:
		return m.OldDescription(ctx)
	case exception.FieldAttachments:
		return m.OldAttachments(ctx)
	}
	return nil, fmt.Errorf("unknown Exception field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExceptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exception.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case exception.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case exception.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case exception.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case exception.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case exception.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case exception.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case exception.FieldEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case exception.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case exception.FieldStoreID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case exception.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case exception.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case exception.FieldNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNum(v)
		return nil
	case exception.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case exception.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case exception.FieldAttachments:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachments(v)
		return nil
	}
	return fmt.Errorf("unknown Exception field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExceptionMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, exception.FieldStatus)
	}
	if m.addnum != nil {
		fields = append(fields, exception.FieldNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExceptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case exception.FieldStatus:
		return m.AddedStatus()
	case exception.FieldNum:
		return m.AddedNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExceptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case exception.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case exception.FieldNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNum(v)
		return nil
	}
	return fmt.Errorf("unknown Exception numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExceptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exception.FieldDeletedAt) {
		fields = append(fields, exception.FieldDeletedAt)
	}
	if m.FieldCleared(exception.FieldCreator) {
		fields = append(fields, exception.FieldCreator)
	}
	if m.FieldCleared(exception.FieldLastModifier) {
		fields = append(fields, exception.FieldLastModifier)
	}
	if m.FieldCleared(exception.FieldRemark) {
		fields = append(fields, exception.FieldRemark)
	}
	if m.FieldCleared(exception.FieldModel) {
		fields = append(fields, exception.FieldModel)
	}
	if m.FieldCleared(exception.FieldDescription) {
		fields = append(fields, exception.FieldDescription)
	}
	if m.FieldCleared(exception.FieldAttachments) {
		fields = append(fields, exception.FieldAttachments)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExceptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExceptionMutation) ClearField(name string) error {
	switch name {
	case exception.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case exception.FieldCreator:
		m.ClearCreator()
		return nil
	case exception.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case exception.FieldRemark:
		m.ClearRemark()
		return nil
	case exception.FieldModel:
		m.ClearModel()
		return nil
	case exception.FieldDescription:
		m.ClearDescription()
		return nil
	case exception.FieldAttachments:
		m.ClearAttachments()
		return nil
	}
	return fmt.Errorf("unknown Exception nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExceptionMutation) ResetField(name string) error {
	switch name {
	case exception.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case exception.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case exception.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case exception.FieldCreator:
		m.ResetCreator()
		return nil
	case exception.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case exception.FieldRemark:
		m.ResetRemark()
		return nil
	case exception.FieldCityID:
		m.ResetCityID()
		return nil
	case exception.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case exception.FieldStatus:
		m.ResetStatus()
		return nil
	case exception.FieldStoreID:
		m.ResetStoreID()
		return nil
	case exception.FieldName:
		m.ResetName()
		return nil
	case exception.FieldModel:
		m.ResetModel()
		return nil
	case exception.FieldNum:
		m.ResetNum()
		return nil
	case exception.FieldReason:
		m.ResetReason()
		return nil
	case exception.FieldDescription:
		m.ResetDescription()
		return nil
	case exception.FieldAttachments:
		m.ResetAttachments()
		return nil
	}
	return fmt.Errorf("unknown Exception field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExceptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.city != nil {
		edges = append(edges, exception.EdgeCity)
	}
	if m.employee != nil {
		edges = append(edges, exception.EdgeEmployee)
	}
	if m.store != nil {
		edges = append(edges, exception.EdgeStore)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExceptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exception.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case exception.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case exception.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExceptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExceptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExceptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcity {
		edges = append(edges, exception.EdgeCity)
	}
	if m.clearedemployee {
		edges = append(edges, exception.EdgeEmployee)
	}
	if m.clearedstore {
		edges = append(edges, exception.EdgeStore)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExceptionMutation) EdgeCleared(name string) bool {
	switch name {
	case exception.EdgeCity:
		return m.clearedcity
	case exception.EdgeEmployee:
		return m.clearedemployee
	case exception.EdgeStore:
		return m.clearedstore
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExceptionMutation) ClearEdge(name string) error {
	switch name {
	case exception.EdgeCity:
		m.ClearCity()
		return nil
	case exception.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case exception.EdgeStore:
		m.ClearStore()
		return nil
	}
	return fmt.Errorf("unknown Exception unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExceptionMutation) ResetEdge(name string) error {
	switch name {
	case exception.EdgeCity:
		m.ResetCity()
		return nil
	case exception.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case exception.EdgeStore:
		m.ResetStore()
		return nil
	}
	return fmt.Errorf("unknown Exception edge %s", name)
}

// ExchangeMutation represents an operation that mutates the Exchange nodes in the graph.
type ExchangeMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	uuid              *string
	success           *bool
	model             *string
	alternative       *bool
	start_at          *time.Time
	finish_at         *time.Time
	duration          *int
	addduration       *int
	rider_battery     *string
	putin_battery     *string
	putout_battery    *string
	cabinet_info      **model.ExchangeCabinetInfo
	empty             **model.BinInfo
	fully             **model.BinInfo
	steps             *[]*model.ExchangeStepInfo
	appendsteps       []*model.ExchangeStepInfo
	message           *string
	clearedFields     map[string]struct{}
	subscribe         *uint64
	clearedsubscribe  bool
	city              *uint64
	clearedcity       bool
	store             *uint64
	clearedstore      bool
	enterprise        *uint64
	clearedenterprise bool
	station           *uint64
	clearedstation    bool
	cabinet           *uint64
	clearedcabinet    bool
	rider             *uint64
	clearedrider      bool
	employee          *uint64
	clearedemployee   bool
	done              bool
	oldValue          func(context.Context) (*Exchange, error)
	predicates        []predicate.Exchange
}

var _ ent.Mutation = (*ExchangeMutation)(nil)

// exchangeOption allows management of the mutation configuration using functional options.
type exchangeOption func(*ExchangeMutation)

// newExchangeMutation creates new mutation for the Exchange entity.
func newExchangeMutation(c config, op Op, opts ...exchangeOption) *ExchangeMutation {
	m := &ExchangeMutation{
		config:        c,
		op:            op,
		typ:           TypeExchange,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExchangeID sets the ID field of the mutation.
func withExchangeID(id uint64) exchangeOption {
	return func(m *ExchangeMutation) {
		var (
			err   error
			once  sync.Once
			value *Exchange
		)
		m.oldValue = func(ctx context.Context) (*Exchange, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Exchange.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExchange sets the old Exchange of the mutation.
func withExchange(node *Exchange) exchangeOption {
	return func(m *ExchangeMutation) {
		m.oldValue = func(context.Context) (*Exchange, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExchangeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExchangeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExchangeMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExchangeMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Exchange.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ExchangeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExchangeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExchangeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExchangeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExchangeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExchangeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ExchangeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ExchangeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ExchangeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[exchange.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ExchangeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[exchange.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ExchangeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, exchange.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *ExchangeMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *ExchangeMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *ExchangeMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[exchange.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *ExchangeMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[exchange.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *ExchangeMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, exchange.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *ExchangeMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *ExchangeMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *ExchangeMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[exchange.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *ExchangeMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[exchange.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *ExchangeMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, exchange.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *ExchangeMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ExchangeMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ExchangeMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[exchange.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ExchangeMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[exchange.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ExchangeMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, exchange.FieldRemark)
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *ExchangeMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *ExchangeMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldSubscribeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *ExchangeMutation) ResetSubscribeID() {
	m.subscribe = nil
}

// SetCityID sets the "city_id" field.
func (m *ExchangeMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *ExchangeMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *ExchangeMutation) ResetCityID() {
	m.city = nil
}

// SetStoreID sets the "store_id" field.
func (m *ExchangeMutation) SetStoreID(u uint64) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *ExchangeMutation) StoreID() (r uint64, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldStoreID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *ExchangeMutation) ClearStoreID() {
	m.store = nil
	m.clearedFields[exchange.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *ExchangeMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[exchange.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *ExchangeMutation) ResetStoreID() {
	m.store = nil
	delete(m.clearedFields, exchange.FieldStoreID)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *ExchangeMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *ExchangeMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldEnterpriseID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ClearEnterpriseID clears the value of the "enterprise_id" field.
func (m *ExchangeMutation) ClearEnterpriseID() {
	m.enterprise = nil
	m.clearedFields[exchange.FieldEnterpriseID] = struct{}{}
}

// EnterpriseIDCleared returns if the "enterprise_id" field was cleared in this mutation.
func (m *ExchangeMutation) EnterpriseIDCleared() bool {
	_, ok := m.clearedFields[exchange.FieldEnterpriseID]
	return ok
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *ExchangeMutation) ResetEnterpriseID() {
	m.enterprise = nil
	delete(m.clearedFields, exchange.FieldEnterpriseID)
}

// SetStationID sets the "station_id" field.
func (m *ExchangeMutation) SetStationID(u uint64) {
	m.station = &u
}

// StationID returns the value of the "station_id" field in the mutation.
func (m *ExchangeMutation) StationID() (r uint64, exists bool) {
	v := m.station
	if v == nil {
		return
	}
	return *v, true
}

// OldStationID returns the old "station_id" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldStationID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStationID: %w", err)
	}
	return oldValue.StationID, nil
}

// ClearStationID clears the value of the "station_id" field.
func (m *ExchangeMutation) ClearStationID() {
	m.station = nil
	m.clearedFields[exchange.FieldStationID] = struct{}{}
}

// StationIDCleared returns if the "station_id" field was cleared in this mutation.
func (m *ExchangeMutation) StationIDCleared() bool {
	_, ok := m.clearedFields[exchange.FieldStationID]
	return ok
}

// ResetStationID resets all changes to the "station_id" field.
func (m *ExchangeMutation) ResetStationID() {
	m.station = nil
	delete(m.clearedFields, exchange.FieldStationID)
}

// SetRiderID sets the "rider_id" field.
func (m *ExchangeMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *ExchangeMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *ExchangeMutation) ResetRiderID() {
	m.rider = nil
}

// SetEmployeeID sets the "employee_id" field.
func (m *ExchangeMutation) SetEmployeeID(u uint64) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *ExchangeMutation) EmployeeID() (r uint64, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldEmployeeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *ExchangeMutation) ClearEmployeeID() {
	m.employee = nil
	m.clearedFields[exchange.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *ExchangeMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[exchange.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *ExchangeMutation) ResetEmployeeID() {
	m.employee = nil
	delete(m.clearedFields, exchange.FieldEmployeeID)
}

// SetUUID sets the "uuid" field.
func (m *ExchangeMutation) SetUUID(s string) {
	m.uuid = &s
}

// UUID returns the value of the "uuid" field in the mutation.
func (m *ExchangeMutation) UUID() (r string, exists bool) {
	v := m.uuid
	if v == nil {
		return
	}
	return *v, true
}

// OldUUID returns the old "uuid" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldUUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUUID: %w", err)
	}
	return oldValue.UUID, nil
}

// ResetUUID resets all changes to the "uuid" field.
func (m *ExchangeMutation) ResetUUID() {
	m.uuid = nil
}

// SetCabinetID sets the "cabinet_id" field.
func (m *ExchangeMutation) SetCabinetID(u uint64) {
	m.cabinet = &u
}

// CabinetID returns the value of the "cabinet_id" field in the mutation.
func (m *ExchangeMutation) CabinetID() (r uint64, exists bool) {
	v := m.cabinet
	if v == nil {
		return
	}
	return *v, true
}

// OldCabinetID returns the old "cabinet_id" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldCabinetID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCabinetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCabinetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCabinetID: %w", err)
	}
	return oldValue.CabinetID, nil
}

// ClearCabinetID clears the value of the "cabinet_id" field.
func (m *ExchangeMutation) ClearCabinetID() {
	m.cabinet = nil
	m.clearedFields[exchange.FieldCabinetID] = struct{}{}
}

// CabinetIDCleared returns if the "cabinet_id" field was cleared in this mutation.
func (m *ExchangeMutation) CabinetIDCleared() bool {
	_, ok := m.clearedFields[exchange.FieldCabinetID]
	return ok
}

// ResetCabinetID resets all changes to the "cabinet_id" field.
func (m *ExchangeMutation) ResetCabinetID() {
	m.cabinet = nil
	delete(m.clearedFields, exchange.FieldCabinetID)
}

// SetSuccess sets the "success" field.
func (m *ExchangeMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *ExchangeMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *ExchangeMutation) ResetSuccess() {
	m.success = nil
}

// SetModel sets the "model" field.
func (m *ExchangeMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *ExchangeMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *ExchangeMutation) ResetModel() {
	m.model = nil
}

// SetAlternative sets the "alternative" field.
func (m *ExchangeMutation) SetAlternative(b bool) {
	m.alternative = &b
}

// Alternative returns the value of the "alternative" field in the mutation.
func (m *ExchangeMutation) Alternative() (r bool, exists bool) {
	v := m.alternative
	if v == nil {
		return
	}
	return *v, true
}

// OldAlternative returns the old "alternative" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldAlternative(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlternative is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlternative requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlternative: %w", err)
	}
	return oldValue.Alternative, nil
}

// ResetAlternative resets all changes to the "alternative" field.
func (m *ExchangeMutation) ResetAlternative() {
	m.alternative = nil
}

// SetStartAt sets the "start_at" field.
func (m *ExchangeMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *ExchangeMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *ExchangeMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[exchange.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *ExchangeMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[exchange.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *ExchangeMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, exchange.FieldStartAt)
}

// SetFinishAt sets the "finish_at" field.
func (m *ExchangeMutation) SetFinishAt(t time.Time) {
	m.finish_at = &t
}

// FinishAt returns the value of the "finish_at" field in the mutation.
func (m *ExchangeMutation) FinishAt() (r time.Time, exists bool) {
	v := m.finish_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishAt returns the old "finish_at" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldFinishAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishAt: %w", err)
	}
	return oldValue.FinishAt, nil
}

// ClearFinishAt clears the value of the "finish_at" field.
func (m *ExchangeMutation) ClearFinishAt() {
	m.finish_at = nil
	m.clearedFields[exchange.FieldFinishAt] = struct{}{}
}

// FinishAtCleared returns if the "finish_at" field was cleared in this mutation.
func (m *ExchangeMutation) FinishAtCleared() bool {
	_, ok := m.clearedFields[exchange.FieldFinishAt]
	return ok
}

// ResetFinishAt resets all changes to the "finish_at" field.
func (m *ExchangeMutation) ResetFinishAt() {
	m.finish_at = nil
	delete(m.clearedFields, exchange.FieldFinishAt)
}

// SetDuration sets the "duration" field.
func (m *ExchangeMutation) SetDuration(i int) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *ExchangeMutation) Duration() (r int, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldDuration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *ExchangeMutation) AddDuration(i int) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *ExchangeMutation) AddedDuration() (r int, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of the "duration" field.
func (m *ExchangeMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[exchange.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *ExchangeMutation) DurationCleared() bool {
	_, ok := m.clearedFields[exchange.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *ExchangeMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, exchange.FieldDuration)
}

// SetRiderBattery sets the "rider_battery" field.
func (m *ExchangeMutation) SetRiderBattery(s string) {
	m.rider_battery = &s
}

// RiderBattery returns the value of the "rider_battery" field in the mutation.
func (m *ExchangeMutation) RiderBattery() (r string, exists bool) {
	v := m.rider_battery
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderBattery returns the old "rider_battery" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldRiderBattery(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderBattery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderBattery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderBattery: %w", err)
	}
	return oldValue.RiderBattery, nil
}

// ClearRiderBattery clears the value of the "rider_battery" field.
func (m *ExchangeMutation) ClearRiderBattery() {
	m.rider_battery = nil
	m.clearedFields[exchange.FieldRiderBattery] = struct{}{}
}

// RiderBatteryCleared returns if the "rider_battery" field was cleared in this mutation.
func (m *ExchangeMutation) RiderBatteryCleared() bool {
	_, ok := m.clearedFields[exchange.FieldRiderBattery]
	return ok
}

// ResetRiderBattery resets all changes to the "rider_battery" field.
func (m *ExchangeMutation) ResetRiderBattery() {
	m.rider_battery = nil
	delete(m.clearedFields, exchange.FieldRiderBattery)
}

// SetPutinBattery sets the "putin_battery" field.
func (m *ExchangeMutation) SetPutinBattery(s string) {
	m.putin_battery = &s
}

// PutinBattery returns the value of the "putin_battery" field in the mutation.
func (m *ExchangeMutation) PutinBattery() (r string, exists bool) {
	v := m.putin_battery
	if v == nil {
		return
	}
	return *v, true
}

// OldPutinBattery returns the old "putin_battery" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldPutinBattery(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPutinBattery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPutinBattery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPutinBattery: %w", err)
	}
	return oldValue.PutinBattery, nil
}

// ClearPutinBattery clears the value of the "putin_battery" field.
func (m *ExchangeMutation) ClearPutinBattery() {
	m.putin_battery = nil
	m.clearedFields[exchange.FieldPutinBattery] = struct{}{}
}

// PutinBatteryCleared returns if the "putin_battery" field was cleared in this mutation.
func (m *ExchangeMutation) PutinBatteryCleared() bool {
	_, ok := m.clearedFields[exchange.FieldPutinBattery]
	return ok
}

// ResetPutinBattery resets all changes to the "putin_battery" field.
func (m *ExchangeMutation) ResetPutinBattery() {
	m.putin_battery = nil
	delete(m.clearedFields, exchange.FieldPutinBattery)
}

// SetPutoutBattery sets the "putout_battery" field.
func (m *ExchangeMutation) SetPutoutBattery(s string) {
	m.putout_battery = &s
}

// PutoutBattery returns the value of the "putout_battery" field in the mutation.
func (m *ExchangeMutation) PutoutBattery() (r string, exists bool) {
	v := m.putout_battery
	if v == nil {
		return
	}
	return *v, true
}

// OldPutoutBattery returns the old "putout_battery" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldPutoutBattery(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPutoutBattery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPutoutBattery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPutoutBattery: %w", err)
	}
	return oldValue.PutoutBattery, nil
}

// ClearPutoutBattery clears the value of the "putout_battery" field.
func (m *ExchangeMutation) ClearPutoutBattery() {
	m.putout_battery = nil
	m.clearedFields[exchange.FieldPutoutBattery] = struct{}{}
}

// PutoutBatteryCleared returns if the "putout_battery" field was cleared in this mutation.
func (m *ExchangeMutation) PutoutBatteryCleared() bool {
	_, ok := m.clearedFields[exchange.FieldPutoutBattery]
	return ok
}

// ResetPutoutBattery resets all changes to the "putout_battery" field.
func (m *ExchangeMutation) ResetPutoutBattery() {
	m.putout_battery = nil
	delete(m.clearedFields, exchange.FieldPutoutBattery)
}

// SetCabinetInfo sets the "cabinet_info" field.
func (m *ExchangeMutation) SetCabinetInfo(mci *model.ExchangeCabinetInfo) {
	m.cabinet_info = &mci
}

// CabinetInfo returns the value of the "cabinet_info" field in the mutation.
func (m *ExchangeMutation) CabinetInfo() (r *model.ExchangeCabinetInfo, exists bool) {
	v := m.cabinet_info
	if v == nil {
		return
	}
	return *v, true
}

// OldCabinetInfo returns the old "cabinet_info" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldCabinetInfo(ctx context.Context) (v *model.ExchangeCabinetInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCabinetInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCabinetInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCabinetInfo: %w", err)
	}
	return oldValue.CabinetInfo, nil
}

// ClearCabinetInfo clears the value of the "cabinet_info" field.
func (m *ExchangeMutation) ClearCabinetInfo() {
	m.cabinet_info = nil
	m.clearedFields[exchange.FieldCabinetInfo] = struct{}{}
}

// CabinetInfoCleared returns if the "cabinet_info" field was cleared in this mutation.
func (m *ExchangeMutation) CabinetInfoCleared() bool {
	_, ok := m.clearedFields[exchange.FieldCabinetInfo]
	return ok
}

// ResetCabinetInfo resets all changes to the "cabinet_info" field.
func (m *ExchangeMutation) ResetCabinetInfo() {
	m.cabinet_info = nil
	delete(m.clearedFields, exchange.FieldCabinetInfo)
}

// SetEmpty sets the "empty" field.
func (m *ExchangeMutation) SetEmpty(mi *model.BinInfo) {
	m.empty = &mi
}

// Empty returns the value of the "empty" field in the mutation.
func (m *ExchangeMutation) Empty() (r *model.BinInfo, exists bool) {
	v := m.empty
	if v == nil {
		return
	}
	return *v, true
}

// OldEmpty returns the old "empty" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldEmpty(ctx context.Context) (v *model.BinInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmpty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmpty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmpty: %w", err)
	}
	return oldValue.Empty, nil
}

// ClearEmpty clears the value of the "empty" field.
func (m *ExchangeMutation) ClearEmpty() {
	m.empty = nil
	m.clearedFields[exchange.FieldEmpty] = struct{}{}
}

// EmptyCleared returns if the "empty" field was cleared in this mutation.
func (m *ExchangeMutation) EmptyCleared() bool {
	_, ok := m.clearedFields[exchange.FieldEmpty]
	return ok
}

// ResetEmpty resets all changes to the "empty" field.
func (m *ExchangeMutation) ResetEmpty() {
	m.empty = nil
	delete(m.clearedFields, exchange.FieldEmpty)
}

// SetFully sets the "fully" field.
func (m *ExchangeMutation) SetFully(mi *model.BinInfo) {
	m.fully = &mi
}

// Fully returns the value of the "fully" field in the mutation.
func (m *ExchangeMutation) Fully() (r *model.BinInfo, exists bool) {
	v := m.fully
	if v == nil {
		return
	}
	return *v, true
}

// OldFully returns the old "fully" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldFully(ctx context.Context) (v *model.BinInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFully is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFully requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFully: %w", err)
	}
	return oldValue.Fully, nil
}

// ClearFully clears the value of the "fully" field.
func (m *ExchangeMutation) ClearFully() {
	m.fully = nil
	m.clearedFields[exchange.FieldFully] = struct{}{}
}

// FullyCleared returns if the "fully" field was cleared in this mutation.
func (m *ExchangeMutation) FullyCleared() bool {
	_, ok := m.clearedFields[exchange.FieldFully]
	return ok
}

// ResetFully resets all changes to the "fully" field.
func (m *ExchangeMutation) ResetFully() {
	m.fully = nil
	delete(m.clearedFields, exchange.FieldFully)
}

// SetSteps sets the "steps" field.
func (m *ExchangeMutation) SetSteps(msi []*model.ExchangeStepInfo) {
	m.steps = &msi
	m.appendsteps = nil
}

// Steps returns the value of the "steps" field in the mutation.
func (m *ExchangeMutation) Steps() (r []*model.ExchangeStepInfo, exists bool) {
	v := m.steps
	if v == nil {
		return
	}
	return *v, true
}

// OldSteps returns the old "steps" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldSteps(ctx context.Context) (v []*model.ExchangeStepInfo, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSteps is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSteps requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSteps: %w", err)
	}
	return oldValue.Steps, nil
}

// AppendSteps adds msi to the "steps" field.
func (m *ExchangeMutation) AppendSteps(msi []*model.ExchangeStepInfo) {
	m.appendsteps = append(m.appendsteps, msi...)
}

// AppendedSteps returns the list of values that were appended to the "steps" field in this mutation.
func (m *ExchangeMutation) AppendedSteps() ([]*model.ExchangeStepInfo, bool) {
	if len(m.appendsteps) == 0 {
		return nil, false
	}
	return m.appendsteps, true
}

// ClearSteps clears the value of the "steps" field.
func (m *ExchangeMutation) ClearSteps() {
	m.steps = nil
	m.appendsteps = nil
	m.clearedFields[exchange.FieldSteps] = struct{}{}
}

// StepsCleared returns if the "steps" field was cleared in this mutation.
func (m *ExchangeMutation) StepsCleared() bool {
	_, ok := m.clearedFields[exchange.FieldSteps]
	return ok
}

// ResetSteps resets all changes to the "steps" field.
func (m *ExchangeMutation) ResetSteps() {
	m.steps = nil
	m.appendsteps = nil
	delete(m.clearedFields, exchange.FieldSteps)
}

// SetMessage sets the "message" field.
func (m *ExchangeMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *ExchangeMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Exchange entity.
// If the Exchange object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExchangeMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *ExchangeMutation) ResetMessage() {
	m.message = nil
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *ExchangeMutation) ClearSubscribe() {
	m.clearedsubscribe = true
	m.clearedFields[exchange.FieldSubscribeID] = struct{}{}
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *ExchangeMutation) SubscribeCleared() bool {
	return m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *ExchangeMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *ExchangeMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *ExchangeMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[exchange.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *ExchangeMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *ExchangeMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *ExchangeMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearStore clears the "store" edge to the Store entity.
func (m *ExchangeMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[exchange.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *ExchangeMutation) StoreCleared() bool {
	return m.StoreIDCleared() || m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *ExchangeMutation) StoreIDs() (ids []uint64) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *ExchangeMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *ExchangeMutation) ClearEnterprise() {
	m.clearedenterprise = true
	m.clearedFields[exchange.FieldEnterpriseID] = struct{}{}
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *ExchangeMutation) EnterpriseCleared() bool {
	return m.EnterpriseIDCleared() || m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *ExchangeMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *ExchangeMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// ClearStation clears the "station" edge to the EnterpriseStation entity.
func (m *ExchangeMutation) ClearStation() {
	m.clearedstation = true
	m.clearedFields[exchange.FieldStationID] = struct{}{}
}

// StationCleared reports if the "station" edge to the EnterpriseStation entity was cleared.
func (m *ExchangeMutation) StationCleared() bool {
	return m.StationIDCleared() || m.clearedstation
}

// StationIDs returns the "station" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StationID instead. It exists only for internal usage by the builders.
func (m *ExchangeMutation) StationIDs() (ids []uint64) {
	if id := m.station; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStation resets all changes to the "station" edge.
func (m *ExchangeMutation) ResetStation() {
	m.station = nil
	m.clearedstation = false
}

// ClearCabinet clears the "cabinet" edge to the Cabinet entity.
func (m *ExchangeMutation) ClearCabinet() {
	m.clearedcabinet = true
	m.clearedFields[exchange.FieldCabinetID] = struct{}{}
}

// CabinetCleared reports if the "cabinet" edge to the Cabinet entity was cleared.
func (m *ExchangeMutation) CabinetCleared() bool {
	return m.CabinetIDCleared() || m.clearedcabinet
}

// CabinetIDs returns the "cabinet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CabinetID instead. It exists only for internal usage by the builders.
func (m *ExchangeMutation) CabinetIDs() (ids []uint64) {
	if id := m.cabinet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCabinet resets all changes to the "cabinet" edge.
func (m *ExchangeMutation) ResetCabinet() {
	m.cabinet = nil
	m.clearedcabinet = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *ExchangeMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[exchange.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *ExchangeMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *ExchangeMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *ExchangeMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *ExchangeMutation) ClearEmployee() {
	m.clearedemployee = true
	m.clearedFields[exchange.FieldEmployeeID] = struct{}{}
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *ExchangeMutation) EmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *ExchangeMutation) EmployeeIDs() (ids []uint64) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *ExchangeMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// Where appends a list predicates to the ExchangeMutation builder.
func (m *ExchangeMutation) Where(ps ...predicate.Exchange) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExchangeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExchangeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Exchange, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExchangeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExchangeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Exchange).
func (m *ExchangeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExchangeMutation) Fields() []string {
	fields := make([]string, 0, 29)
	if m.created_at != nil {
		fields = append(fields, exchange.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, exchange.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, exchange.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, exchange.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, exchange.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, exchange.FieldRemark)
	}
	if m.subscribe != nil {
		fields = append(fields, exchange.FieldSubscribeID)
	}
	if m.city != nil {
		fields = append(fields, exchange.FieldCityID)
	}
	if m.store != nil {
		fields = append(fields, exchange.FieldStoreID)
	}
	if m.enterprise != nil {
		fields = append(fields, exchange.FieldEnterpriseID)
	}
	if m.station != nil {
		fields = append(fields, exchange.FieldStationID)
	}
	if m.rider != nil {
		fields = append(fields, exchange.FieldRiderID)
	}
	if m.employee != nil {
		fields = append(fields, exchange.FieldEmployeeID)
	}
	if m.uuid != nil {
		fields = append(fields, exchange.FieldUUID)
	}
	if m.cabinet != nil {
		fields = append(fields, exchange.FieldCabinetID)
	}
	if m.success != nil {
		fields = append(fields, exchange.FieldSuccess)
	}
	if m.model != nil {
		fields = append(fields, exchange.FieldModel)
	}
	if m.alternative != nil {
		fields = append(fields, exchange.FieldAlternative)
	}
	if m.start_at != nil {
		fields = append(fields, exchange.FieldStartAt)
	}
	if m.finish_at != nil {
		fields = append(fields, exchange.FieldFinishAt)
	}
	if m.duration != nil {
		fields = append(fields, exchange.FieldDuration)
	}
	if m.rider_battery != nil {
		fields = append(fields, exchange.FieldRiderBattery)
	}
	if m.putin_battery != nil {
		fields = append(fields, exchange.FieldPutinBattery)
	}
	if m.putout_battery != nil {
		fields = append(fields, exchange.FieldPutoutBattery)
	}
	if m.cabinet_info != nil {
		fields = append(fields, exchange.FieldCabinetInfo)
	}
	if m.empty != nil {
		fields = append(fields, exchange.FieldEmpty)
	}
	if m.fully != nil {
		fields = append(fields, exchange.FieldFully)
	}
	if m.steps != nil {
		fields = append(fields, exchange.FieldSteps)
	}
	if m.message != nil {
		fields = append(fields, exchange.FieldMessage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExchangeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case exchange.FieldCreatedAt:
		return m.CreatedAt()
	case exchange.FieldUpdatedAt:
		return m.UpdatedAt()
	case exchange.FieldDeletedAt:
		return m.DeletedAt()
	case exchange.FieldCreator:
		return m.Creator()
	case exchange.FieldLastModifier:
		return m.LastModifier()
	case exchange.FieldRemark:
		return m.Remark()
	case exchange.FieldSubscribeID:
		return m.SubscribeID()
	case exchange.FieldCityID:
		return m.CityID()
	case exchange.FieldStoreID:
		return m.StoreID()
	case exchange.FieldEnterpriseID:
		return m.EnterpriseID()
	case exchange.FieldStationID:
		return m.StationID()
	case exchange.FieldRiderID:
		return m.RiderID()
	case exchange.FieldEmployeeID:
		return m.EmployeeID()
	case exchange.FieldUUID:
		return m.UUID()
	case exchange.FieldCabinetID:
		return m.CabinetID()
	case exchange.FieldSuccess:
		return m.Success()
	case exchange.FieldModel:
		return m.Model()
	case exchange.FieldAlternative:
		return m.Alternative()
	case exchange.FieldStartAt:
		return m.StartAt()
	case exchange.FieldFinishAt:
		return m.FinishAt()
	case exchange.FieldDuration:
		return m.Duration()
	case exchange.FieldRiderBattery:
		return m.RiderBattery()
	case exchange.FieldPutinBattery:
		return m.PutinBattery()
	case exchange.FieldPutoutBattery:
		return m.PutoutBattery()
	case exchange.FieldCabinetInfo:
		return m.CabinetInfo()
	case exchange.FieldEmpty:
		return m.Empty()
	case exchange.FieldFully:
		return m.Fully()
	case exchange.FieldSteps:
		return m.Steps()
	case exchange.FieldMessage:
		return m.Message()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExchangeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case exchange.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case exchange.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case exchange.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case exchange.FieldCreator:
		return m.OldCreator(ctx)
	case exchange.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case exchange.FieldRemark:
		return m.OldRemark(ctx)
	case exchange.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case exchange.FieldCityID:
		return m.OldCityID(ctx)
	case exchange.FieldStoreID:
		return m.OldStoreID(ctx)
	case exchange.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case exchange.FieldStationID:
		return m.OldStationID(ctx)
	case exchange.FieldRiderID:
		return m.OldRiderID(ctx)
	case exchange.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case exchange.FieldUUID:
		return m.OldUUID(ctx)
	case exchange.FieldCabinetID:
		return m.OldCabinetID(ctx)
	case exchange.FieldSuccess:
		return m.OldSuccess(ctx)
	case exchange.FieldModel:
		return m.OldModel(ctx)
	case exchange.FieldAlternative:
		return m.OldAlternative(ctx)
	case exchange.FieldStartAt:
		return m.OldStartAt(ctx)
	case exchange.FieldFinishAt:
		return m.OldFinishAt(ctx)
	case exchange.FieldDuration:
		return m.OldDuration(ctx)
	case exchange.FieldRiderBattery:
		return m.OldRiderBattery(ctx)
	case exchange.FieldPutinBattery:
		return m.OldPutinBattery(ctx)
	case exchange.FieldPutoutBattery:
		return m.OldPutoutBattery(ctx)
	case exchange.FieldCabinetInfo:
		return m.OldCabinetInfo(ctx)
	case exchange.FieldEmpty:
		return m.OldEmpty(ctx)
	case exchange.FieldFully:
		return m.OldFully(ctx)
	case exchange.FieldSteps:
		return m.OldSteps(ctx)
	case exchange.FieldMessage:
		return m.OldMessage(ctx)
	}
	return nil, fmt.Errorf("unknown Exchange field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case exchange.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case exchange.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case exchange.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case exchange.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case exchange.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case exchange.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case exchange.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case exchange.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case exchange.FieldStoreID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case exchange.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case exchange.FieldStationID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStationID(v)
		return nil
	case exchange.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case exchange.FieldEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case exchange.FieldUUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUUID(v)
		return nil
	case exchange.FieldCabinetID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCabinetID(v)
		return nil
	case exchange.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case exchange.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case exchange.FieldAlternative:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlternative(v)
		return nil
	case exchange.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case exchange.FieldFinishAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishAt(v)
		return nil
	case exchange.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case exchange.FieldRiderBattery:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderBattery(v)
		return nil
	case exchange.FieldPutinBattery:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPutinBattery(v)
		return nil
	case exchange.FieldPutoutBattery:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPutoutBattery(v)
		return nil
	case exchange.FieldCabinetInfo:
		v, ok := value.(*model.ExchangeCabinetInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCabinetInfo(v)
		return nil
	case exchange.FieldEmpty:
		v, ok := value.(*model.BinInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmpty(v)
		return nil
	case exchange.FieldFully:
		v, ok := value.(*model.BinInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFully(v)
		return nil
	case exchange.FieldSteps:
		v, ok := value.([]*model.ExchangeStepInfo)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSteps(v)
		return nil
	case exchange.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	}
	return fmt.Errorf("unknown Exchange field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExchangeMutation) AddedFields() []string {
	var fields []string
	if m.addduration != nil {
		fields = append(fields, exchange.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExchangeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case exchange.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExchangeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case exchange.FieldDuration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown Exchange numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExchangeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(exchange.FieldDeletedAt) {
		fields = append(fields, exchange.FieldDeletedAt)
	}
	if m.FieldCleared(exchange.FieldCreator) {
		fields = append(fields, exchange.FieldCreator)
	}
	if m.FieldCleared(exchange.FieldLastModifier) {
		fields = append(fields, exchange.FieldLastModifier)
	}
	if m.FieldCleared(exchange.FieldRemark) {
		fields = append(fields, exchange.FieldRemark)
	}
	if m.FieldCleared(exchange.FieldStoreID) {
		fields = append(fields, exchange.FieldStoreID)
	}
	if m.FieldCleared(exchange.FieldEnterpriseID) {
		fields = append(fields, exchange.FieldEnterpriseID)
	}
	if m.FieldCleared(exchange.FieldStationID) {
		fields = append(fields, exchange.FieldStationID)
	}
	if m.FieldCleared(exchange.FieldEmployeeID) {
		fields = append(fields, exchange.FieldEmployeeID)
	}
	if m.FieldCleared(exchange.FieldCabinetID) {
		fields = append(fields, exchange.FieldCabinetID)
	}
	if m.FieldCleared(exchange.FieldStartAt) {
		fields = append(fields, exchange.FieldStartAt)
	}
	if m.FieldCleared(exchange.FieldFinishAt) {
		fields = append(fields, exchange.FieldFinishAt)
	}
	if m.FieldCleared(exchange.FieldDuration) {
		fields = append(fields, exchange.FieldDuration)
	}
	if m.FieldCleared(exchange.FieldRiderBattery) {
		fields = append(fields, exchange.FieldRiderBattery)
	}
	if m.FieldCleared(exchange.FieldPutinBattery) {
		fields = append(fields, exchange.FieldPutinBattery)
	}
	if m.FieldCleared(exchange.FieldPutoutBattery) {
		fields = append(fields, exchange.FieldPutoutBattery)
	}
	if m.FieldCleared(exchange.FieldCabinetInfo) {
		fields = append(fields, exchange.FieldCabinetInfo)
	}
	if m.FieldCleared(exchange.FieldEmpty) {
		fields = append(fields, exchange.FieldEmpty)
	}
	if m.FieldCleared(exchange.FieldFully) {
		fields = append(fields, exchange.FieldFully)
	}
	if m.FieldCleared(exchange.FieldSteps) {
		fields = append(fields, exchange.FieldSteps)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExchangeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExchangeMutation) ClearField(name string) error {
	switch name {
	case exchange.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case exchange.FieldCreator:
		m.ClearCreator()
		return nil
	case exchange.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case exchange.FieldRemark:
		m.ClearRemark()
		return nil
	case exchange.FieldStoreID:
		m.ClearStoreID()
		return nil
	case exchange.FieldEnterpriseID:
		m.ClearEnterpriseID()
		return nil
	case exchange.FieldStationID:
		m.ClearStationID()
		return nil
	case exchange.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case exchange.FieldCabinetID:
		m.ClearCabinetID()
		return nil
	case exchange.FieldStartAt:
		m.ClearStartAt()
		return nil
	case exchange.FieldFinishAt:
		m.ClearFinishAt()
		return nil
	case exchange.FieldDuration:
		m.ClearDuration()
		return nil
	case exchange.FieldRiderBattery:
		m.ClearRiderBattery()
		return nil
	case exchange.FieldPutinBattery:
		m.ClearPutinBattery()
		return nil
	case exchange.FieldPutoutBattery:
		m.ClearPutoutBattery()
		return nil
	case exchange.FieldCabinetInfo:
		m.ClearCabinetInfo()
		return nil
	case exchange.FieldEmpty:
		m.ClearEmpty()
		return nil
	case exchange.FieldFully:
		m.ClearFully()
		return nil
	case exchange.FieldSteps:
		m.ClearSteps()
		return nil
	}
	return fmt.Errorf("unknown Exchange nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExchangeMutation) ResetField(name string) error {
	switch name {
	case exchange.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case exchange.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case exchange.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case exchange.FieldCreator:
		m.ResetCreator()
		return nil
	case exchange.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case exchange.FieldRemark:
		m.ResetRemark()
		return nil
	case exchange.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case exchange.FieldCityID:
		m.ResetCityID()
		return nil
	case exchange.FieldStoreID:
		m.ResetStoreID()
		return nil
	case exchange.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case exchange.FieldStationID:
		m.ResetStationID()
		return nil
	case exchange.FieldRiderID:
		m.ResetRiderID()
		return nil
	case exchange.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case exchange.FieldUUID:
		m.ResetUUID()
		return nil
	case exchange.FieldCabinetID:
		m.ResetCabinetID()
		return nil
	case exchange.FieldSuccess:
		m.ResetSuccess()
		return nil
	case exchange.FieldModel:
		m.ResetModel()
		return nil
	case exchange.FieldAlternative:
		m.ResetAlternative()
		return nil
	case exchange.FieldStartAt:
		m.ResetStartAt()
		return nil
	case exchange.FieldFinishAt:
		m.ResetFinishAt()
		return nil
	case exchange.FieldDuration:
		m.ResetDuration()
		return nil
	case exchange.FieldRiderBattery:
		m.ResetRiderBattery()
		return nil
	case exchange.FieldPutinBattery:
		m.ResetPutinBattery()
		return nil
	case exchange.FieldPutoutBattery:
		m.ResetPutoutBattery()
		return nil
	case exchange.FieldCabinetInfo:
		m.ResetCabinetInfo()
		return nil
	case exchange.FieldEmpty:
		m.ResetEmpty()
		return nil
	case exchange.FieldFully:
		m.ResetFully()
		return nil
	case exchange.FieldSteps:
		m.ResetSteps()
		return nil
	case exchange.FieldMessage:
		m.ResetMessage()
		return nil
	}
	return fmt.Errorf("unknown Exchange field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExchangeMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.subscribe != nil {
		edges = append(edges, exchange.EdgeSubscribe)
	}
	if m.city != nil {
		edges = append(edges, exchange.EdgeCity)
	}
	if m.store != nil {
		edges = append(edges, exchange.EdgeStore)
	}
	if m.enterprise != nil {
		edges = append(edges, exchange.EdgeEnterprise)
	}
	if m.station != nil {
		edges = append(edges, exchange.EdgeStation)
	}
	if m.cabinet != nil {
		edges = append(edges, exchange.EdgeCabinet)
	}
	if m.rider != nil {
		edges = append(edges, exchange.EdgeRider)
	}
	if m.employee != nil {
		edges = append(edges, exchange.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExchangeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case exchange.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	case exchange.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case exchange.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	case exchange.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	case exchange.EdgeStation:
		if id := m.station; id != nil {
			return []ent.Value{*id}
		}
	case exchange.EdgeCabinet:
		if id := m.cabinet; id != nil {
			return []ent.Value{*id}
		}
	case exchange.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case exchange.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExchangeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExchangeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExchangeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedsubscribe {
		edges = append(edges, exchange.EdgeSubscribe)
	}
	if m.clearedcity {
		edges = append(edges, exchange.EdgeCity)
	}
	if m.clearedstore {
		edges = append(edges, exchange.EdgeStore)
	}
	if m.clearedenterprise {
		edges = append(edges, exchange.EdgeEnterprise)
	}
	if m.clearedstation {
		edges = append(edges, exchange.EdgeStation)
	}
	if m.clearedcabinet {
		edges = append(edges, exchange.EdgeCabinet)
	}
	if m.clearedrider {
		edges = append(edges, exchange.EdgeRider)
	}
	if m.clearedemployee {
		edges = append(edges, exchange.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExchangeMutation) EdgeCleared(name string) bool {
	switch name {
	case exchange.EdgeSubscribe:
		return m.clearedsubscribe
	case exchange.EdgeCity:
		return m.clearedcity
	case exchange.EdgeStore:
		return m.clearedstore
	case exchange.EdgeEnterprise:
		return m.clearedenterprise
	case exchange.EdgeStation:
		return m.clearedstation
	case exchange.EdgeCabinet:
		return m.clearedcabinet
	case exchange.EdgeRider:
		return m.clearedrider
	case exchange.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExchangeMutation) ClearEdge(name string) error {
	switch name {
	case exchange.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	case exchange.EdgeCity:
		m.ClearCity()
		return nil
	case exchange.EdgeStore:
		m.ClearStore()
		return nil
	case exchange.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	case exchange.EdgeStation:
		m.ClearStation()
		return nil
	case exchange.EdgeCabinet:
		m.ClearCabinet()
		return nil
	case exchange.EdgeRider:
		m.ClearRider()
		return nil
	case exchange.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown Exchange unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExchangeMutation) ResetEdge(name string) error {
	switch name {
	case exchange.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	case exchange.EdgeCity:
		m.ResetCity()
		return nil
	case exchange.EdgeStore:
		m.ResetStore()
		return nil
	case exchange.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	case exchange.EdgeStation:
		m.ResetStation()
		return nil
	case exchange.EdgeCabinet:
		m.ResetCabinet()
		return nil
	case exchange.EdgeRider:
		m.ResetRider()
		return nil
	case exchange.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Exchange edge %s", name)
}

// ExportMutation represents an operation that mutates the Export nodes in the graph.
type ExportMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	taxonomy       *string
	sn             *string
	status         *uint8
	addstatus      *int8
	_path          *string
	message        *string
	finish_at      *time.Time
	duration       *int64
	addduration    *int64
	condition      *string
	info           *map[string]interface{}
	remark         *string
	clearedFields  map[string]struct{}
	manager        *uint64
	clearedmanager bool
	done           bool
	oldValue       func(context.Context) (*Export, error)
	predicates     []predicate.Export
}

var _ ent.Mutation = (*ExportMutation)(nil)

// exportOption allows management of the mutation configuration using functional options.
type exportOption func(*ExportMutation)

// newExportMutation creates new mutation for the Export entity.
func newExportMutation(c config, op Op, opts ...exportOption) *ExportMutation {
	m := &ExportMutation{
		config:        c,
		op:            op,
		typ:           TypeExport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExportID sets the ID field of the mutation.
func withExportID(id uint64) exportOption {
	return func(m *ExportMutation) {
		var (
			err   error
			once  sync.Once
			value *Export
		)
		m.oldValue = func(ctx context.Context) (*Export, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Export.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExport sets the old Export of the mutation.
func withExport(node *Export) exportOption {
	return func(m *ExportMutation) {
		m.oldValue = func(context.Context) (*Export, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExportMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExportMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Export.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ExportMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExportMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExportMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExportMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExportMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExportMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ExportMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ExportMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ExportMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[export.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ExportMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[export.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ExportMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, export.FieldDeletedAt)
}

// SetManagerID sets the "manager_id" field.
func (m *ExportMutation) SetManagerID(u uint64) {
	m.manager = &u
}

// ManagerID returns the value of the "manager_id" field in the mutation.
func (m *ExportMutation) ManagerID() (r uint64, exists bool) {
	v := m.manager
	if v == nil {
		return
	}
	return *v, true
}

// OldManagerID returns the old "manager_id" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldManagerID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagerID: %w", err)
	}
	return oldValue.ManagerID, nil
}

// ResetManagerID resets all changes to the "manager_id" field.
func (m *ExportMutation) ResetManagerID() {
	m.manager = nil
}

// SetTaxonomy sets the "taxonomy" field.
func (m *ExportMutation) SetTaxonomy(s string) {
	m.taxonomy = &s
}

// Taxonomy returns the value of the "taxonomy" field in the mutation.
func (m *ExportMutation) Taxonomy() (r string, exists bool) {
	v := m.taxonomy
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxonomy returns the old "taxonomy" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldTaxonomy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaxonomy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaxonomy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxonomy: %w", err)
	}
	return oldValue.Taxonomy, nil
}

// ResetTaxonomy resets all changes to the "taxonomy" field.
func (m *ExportMutation) ResetTaxonomy() {
	m.taxonomy = nil
}

// SetSn sets the "sn" field.
func (m *ExportMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *ExportMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *ExportMutation) ResetSn() {
	m.sn = nil
}

// SetStatus sets the "status" field.
func (m *ExportMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ExportMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *ExportMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ExportMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ExportMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetPath sets the "path" field.
func (m *ExportMutation) SetPath(s string) {
	m._path = &s
}

// Path returns the value of the "path" field in the mutation.
func (m *ExportMutation) Path() (r string, exists bool) {
	v := m._path
	if v == nil {
		return
	}
	return *v, true
}

// OldPath returns the old "path" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPath: %w", err)
	}
	return oldValue.Path, nil
}

// ClearPath clears the value of the "path" field.
func (m *ExportMutation) ClearPath() {
	m._path = nil
	m.clearedFields[export.FieldPath] = struct{}{}
}

// PathCleared returns if the "path" field was cleared in this mutation.
func (m *ExportMutation) PathCleared() bool {
	_, ok := m.clearedFields[export.FieldPath]
	return ok
}

// ResetPath resets all changes to the "path" field.
func (m *ExportMutation) ResetPath() {
	m._path = nil
	delete(m.clearedFields, export.FieldPath)
}

// SetMessage sets the "message" field.
func (m *ExportMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *ExportMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *ExportMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[export.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *ExportMutation) MessageCleared() bool {
	_, ok := m.clearedFields[export.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *ExportMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, export.FieldMessage)
}

// SetFinishAt sets the "finish_at" field.
func (m *ExportMutation) SetFinishAt(t time.Time) {
	m.finish_at = &t
}

// FinishAt returns the value of the "finish_at" field in the mutation.
func (m *ExportMutation) FinishAt() (r time.Time, exists bool) {
	v := m.finish_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishAt returns the old "finish_at" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldFinishAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFinishAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFinishAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishAt: %w", err)
	}
	return oldValue.FinishAt, nil
}

// ClearFinishAt clears the value of the "finish_at" field.
func (m *ExportMutation) ClearFinishAt() {
	m.finish_at = nil
	m.clearedFields[export.FieldFinishAt] = struct{}{}
}

// FinishAtCleared returns if the "finish_at" field was cleared in this mutation.
func (m *ExportMutation) FinishAtCleared() bool {
	_, ok := m.clearedFields[export.FieldFinishAt]
	return ok
}

// ResetFinishAt resets all changes to the "finish_at" field.
func (m *ExportMutation) ResetFinishAt() {
	m.finish_at = nil
	delete(m.clearedFields, export.FieldFinishAt)
}

// SetDuration sets the "duration" field.
func (m *ExportMutation) SetDuration(i int64) {
	m.duration = &i
	m.addduration = nil
}

// Duration returns the value of the "duration" field in the mutation.
func (m *ExportMutation) Duration() (r int64, exists bool) {
	v := m.duration
	if v == nil {
		return
	}
	return *v, true
}

// OldDuration returns the old "duration" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldDuration(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDuration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDuration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDuration: %w", err)
	}
	return oldValue.Duration, nil
}

// AddDuration adds i to the "duration" field.
func (m *ExportMutation) AddDuration(i int64) {
	if m.addduration != nil {
		*m.addduration += i
	} else {
		m.addduration = &i
	}
}

// AddedDuration returns the value that was added to the "duration" field in this mutation.
func (m *ExportMutation) AddedDuration() (r int64, exists bool) {
	v := m.addduration
	if v == nil {
		return
	}
	return *v, true
}

// ClearDuration clears the value of the "duration" field.
func (m *ExportMutation) ClearDuration() {
	m.duration = nil
	m.addduration = nil
	m.clearedFields[export.FieldDuration] = struct{}{}
}

// DurationCleared returns if the "duration" field was cleared in this mutation.
func (m *ExportMutation) DurationCleared() bool {
	_, ok := m.clearedFields[export.FieldDuration]
	return ok
}

// ResetDuration resets all changes to the "duration" field.
func (m *ExportMutation) ResetDuration() {
	m.duration = nil
	m.addduration = nil
	delete(m.clearedFields, export.FieldDuration)
}

// SetCondition sets the "condition" field.
func (m *ExportMutation) SetCondition(s string) {
	m.condition = &s
}

// Condition returns the value of the "condition" field in the mutation.
func (m *ExportMutation) Condition() (r string, exists bool) {
	v := m.condition
	if v == nil {
		return
	}
	return *v, true
}

// OldCondition returns the old "condition" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldCondition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondition: %w", err)
	}
	return oldValue.Condition, nil
}

// ResetCondition resets all changes to the "condition" field.
func (m *ExportMutation) ResetCondition() {
	m.condition = nil
}

// SetInfo sets the "info" field.
func (m *ExportMutation) SetInfo(value map[string]interface{}) {
	m.info = &value
}

// Info returns the value of the "info" field in the mutation.
func (m *ExportMutation) Info() (r map[string]interface{}, exists bool) {
	v := m.info
	if v == nil {
		return
	}
	return *v, true
}

// OldInfo returns the old "info" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldInfo(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInfo: %w", err)
	}
	return oldValue.Info, nil
}

// ClearInfo clears the value of the "info" field.
func (m *ExportMutation) ClearInfo() {
	m.info = nil
	m.clearedFields[export.FieldInfo] = struct{}{}
}

// InfoCleared returns if the "info" field was cleared in this mutation.
func (m *ExportMutation) InfoCleared() bool {
	_, ok := m.clearedFields[export.FieldInfo]
	return ok
}

// ResetInfo resets all changes to the "info" field.
func (m *ExportMutation) ResetInfo() {
	m.info = nil
	delete(m.clearedFields, export.FieldInfo)
}

// SetRemark sets the "remark" field.
func (m *ExportMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ExportMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Export entity.
// If the Export object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExportMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ResetRemark resets all changes to the "remark" field.
func (m *ExportMutation) ResetRemark() {
	m.remark = nil
}

// ClearManager clears the "manager" edge to the Manager entity.
func (m *ExportMutation) ClearManager() {
	m.clearedmanager = true
	m.clearedFields[export.FieldManagerID] = struct{}{}
}

// ManagerCleared reports if the "manager" edge to the Manager entity was cleared.
func (m *ExportMutation) ManagerCleared() bool {
	return m.clearedmanager
}

// ManagerIDs returns the "manager" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ManagerID instead. It exists only for internal usage by the builders.
func (m *ExportMutation) ManagerIDs() (ids []uint64) {
	if id := m.manager; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetManager resets all changes to the "manager" edge.
func (m *ExportMutation) ResetManager() {
	m.manager = nil
	m.clearedmanager = false
}

// Where appends a list predicates to the ExportMutation builder.
func (m *ExportMutation) Where(ps ...predicate.Export) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Export, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Export).
func (m *ExportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExportMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, export.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, export.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, export.FieldDeletedAt)
	}
	if m.manager != nil {
		fields = append(fields, export.FieldManagerID)
	}
	if m.taxonomy != nil {
		fields = append(fields, export.FieldTaxonomy)
	}
	if m.sn != nil {
		fields = append(fields, export.FieldSn)
	}
	if m.status != nil {
		fields = append(fields, export.FieldStatus)
	}
	if m._path != nil {
		fields = append(fields, export.FieldPath)
	}
	if m.message != nil {
		fields = append(fields, export.FieldMessage)
	}
	if m.finish_at != nil {
		fields = append(fields, export.FieldFinishAt)
	}
	if m.duration != nil {
		fields = append(fields, export.FieldDuration)
	}
	if m.condition != nil {
		fields = append(fields, export.FieldCondition)
	}
	if m.info != nil {
		fields = append(fields, export.FieldInfo)
	}
	if m.remark != nil {
		fields = append(fields, export.FieldRemark)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case export.FieldCreatedAt:
		return m.CreatedAt()
	case export.FieldUpdatedAt:
		return m.UpdatedAt()
	case export.FieldDeletedAt:
		return m.DeletedAt()
	case export.FieldManagerID:
		return m.ManagerID()
	case export.FieldTaxonomy:
		return m.Taxonomy()
	case export.FieldSn:
		return m.Sn()
	case export.FieldStatus:
		return m.Status()
	case export.FieldPath:
		return m.Path()
	case export.FieldMessage:
		return m.Message()
	case export.FieldFinishAt:
		return m.FinishAt()
	case export.FieldDuration:
		return m.Duration()
	case export.FieldCondition:
		return m.Condition()
	case export.FieldInfo:
		return m.Info()
	case export.FieldRemark:
		return m.Remark()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case export.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case export.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case export.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case export.FieldManagerID:
		return m.OldManagerID(ctx)
	case export.FieldTaxonomy:
		return m.OldTaxonomy(ctx)
	case export.FieldSn:
		return m.OldSn(ctx)
	case export.FieldStatus:
		return m.OldStatus(ctx)
	case export.FieldPath:
		return m.OldPath(ctx)
	case export.FieldMessage:
		return m.OldMessage(ctx)
	case export.FieldFinishAt:
		return m.OldFinishAt(ctx)
	case export.FieldDuration:
		return m.OldDuration(ctx)
	case export.FieldCondition:
		return m.OldCondition(ctx)
	case export.FieldInfo:
		return m.OldInfo(ctx)
	case export.FieldRemark:
		return m.OldRemark(ctx)
	}
	return nil, fmt.Errorf("unknown Export field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case export.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case export.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case export.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case export.FieldManagerID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagerID(v)
		return nil
	case export.FieldTaxonomy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxonomy(v)
		return nil
	case export.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case export.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case export.FieldPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPath(v)
		return nil
	case export.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case export.FieldFinishAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishAt(v)
		return nil
	case export.FieldDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDuration(v)
		return nil
	case export.FieldCondition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondition(v)
		return nil
	case export.FieldInfo:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInfo(v)
		return nil
	case export.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	}
	return fmt.Errorf("unknown Export field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExportMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, export.FieldStatus)
	}
	if m.addduration != nil {
		fields = append(fields, export.FieldDuration)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case export.FieldStatus:
		return m.AddedStatus()
	case export.FieldDuration:
		return m.AddedDuration()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case export.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case export.FieldDuration:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDuration(v)
		return nil
	}
	return fmt.Errorf("unknown Export numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(export.FieldDeletedAt) {
		fields = append(fields, export.FieldDeletedAt)
	}
	if m.FieldCleared(export.FieldPath) {
		fields = append(fields, export.FieldPath)
	}
	if m.FieldCleared(export.FieldMessage) {
		fields = append(fields, export.FieldMessage)
	}
	if m.FieldCleared(export.FieldFinishAt) {
		fields = append(fields, export.FieldFinishAt)
	}
	if m.FieldCleared(export.FieldDuration) {
		fields = append(fields, export.FieldDuration)
	}
	if m.FieldCleared(export.FieldInfo) {
		fields = append(fields, export.FieldInfo)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExportMutation) ClearField(name string) error {
	switch name {
	case export.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case export.FieldPath:
		m.ClearPath()
		return nil
	case export.FieldMessage:
		m.ClearMessage()
		return nil
	case export.FieldFinishAt:
		m.ClearFinishAt()
		return nil
	case export.FieldDuration:
		m.ClearDuration()
		return nil
	case export.FieldInfo:
		m.ClearInfo()
		return nil
	}
	return fmt.Errorf("unknown Export nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExportMutation) ResetField(name string) error {
	switch name {
	case export.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case export.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case export.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case export.FieldManagerID:
		m.ResetManagerID()
		return nil
	case export.FieldTaxonomy:
		m.ResetTaxonomy()
		return nil
	case export.FieldSn:
		m.ResetSn()
		return nil
	case export.FieldStatus:
		m.ResetStatus()
		return nil
	case export.FieldPath:
		m.ResetPath()
		return nil
	case export.FieldMessage:
		m.ResetMessage()
		return nil
	case export.FieldFinishAt:
		m.ResetFinishAt()
		return nil
	case export.FieldDuration:
		m.ResetDuration()
		return nil
	case export.FieldCondition:
		m.ResetCondition()
		return nil
	case export.FieldInfo:
		m.ResetInfo()
		return nil
	case export.FieldRemark:
		m.ResetRemark()
		return nil
	}
	return fmt.Errorf("unknown Export field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExportMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.manager != nil {
		edges = append(edges, export.EdgeManager)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case export.EdgeManager:
		if id := m.manager; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmanager {
		edges = append(edges, export.EdgeManager)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExportMutation) EdgeCleared(name string) bool {
	switch name {
	case export.EdgeManager:
		return m.clearedmanager
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExportMutation) ClearEdge(name string) error {
	switch name {
	case export.EdgeManager:
		m.ClearManager()
		return nil
	}
	return fmt.Errorf("unknown Export unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExportMutation) ResetEdge(name string) error {
	switch name {
	case export.EdgeManager:
		m.ResetManager()
		return nil
	}
	return fmt.Errorf("unknown Export edge %s", name)
}

// FeedbackMutation represents an operation that mutates the Feedback nodes in the graph.
type FeedbackMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	content           *string
	_type             *uint8
	add_type          *int8
	source            *uint8
	addsource         *int8
	url               *[]string
	appendurl         []string
	name              *string
	phone             *string
	clearedFields     map[string]struct{}
	enterprise        *uint64
	clearedenterprise bool
	agent             *uint64
	clearedagent      bool
	done              bool
	oldValue          func(context.Context) (*Feedback, error)
	predicates        []predicate.Feedback
}

var _ ent.Mutation = (*FeedbackMutation)(nil)

// feedbackOption allows management of the mutation configuration using functional options.
type feedbackOption func(*FeedbackMutation)

// newFeedbackMutation creates new mutation for the Feedback entity.
func newFeedbackMutation(c config, op Op, opts ...feedbackOption) *FeedbackMutation {
	m := &FeedbackMutation{
		config:        c,
		op:            op,
		typ:           TypeFeedback,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFeedbackID sets the ID field of the mutation.
func withFeedbackID(id uint64) feedbackOption {
	return func(m *FeedbackMutation) {
		var (
			err   error
			once  sync.Once
			value *Feedback
		)
		m.oldValue = func(ctx context.Context) (*Feedback, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Feedback.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFeedback sets the old Feedback of the mutation.
func withFeedback(node *Feedback) feedbackOption {
	return func(m *FeedbackMutation) {
		m.oldValue = func(context.Context) (*Feedback, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FeedbackMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FeedbackMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FeedbackMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FeedbackMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Feedback.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FeedbackMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FeedbackMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FeedbackMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FeedbackMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FeedbackMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FeedbackMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *FeedbackMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *FeedbackMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldEnterpriseID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ClearEnterpriseID clears the value of the "enterprise_id" field.
func (m *FeedbackMutation) ClearEnterpriseID() {
	m.enterprise = nil
	m.clearedFields[feedback.FieldEnterpriseID] = struct{}{}
}

// EnterpriseIDCleared returns if the "enterprise_id" field was cleared in this mutation.
func (m *FeedbackMutation) EnterpriseIDCleared() bool {
	_, ok := m.clearedFields[feedback.FieldEnterpriseID]
	return ok
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *FeedbackMutation) ResetEnterpriseID() {
	m.enterprise = nil
	delete(m.clearedFields, feedback.FieldEnterpriseID)
}

// SetAgentID sets the "agent_id" field.
func (m *FeedbackMutation) SetAgentID(u uint64) {
	m.agent = &u
}

// AgentID returns the value of the "agent_id" field in the mutation.
func (m *FeedbackMutation) AgentID() (r uint64, exists bool) {
	v := m.agent
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentID returns the old "agent_id" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldAgentID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentID: %w", err)
	}
	return oldValue.AgentID, nil
}

// ClearAgentID clears the value of the "agent_id" field.
func (m *FeedbackMutation) ClearAgentID() {
	m.agent = nil
	m.clearedFields[feedback.FieldAgentID] = struct{}{}
}

// AgentIDCleared returns if the "agent_id" field was cleared in this mutation.
func (m *FeedbackMutation) AgentIDCleared() bool {
	_, ok := m.clearedFields[feedback.FieldAgentID]
	return ok
}

// ResetAgentID resets all changes to the "agent_id" field.
func (m *FeedbackMutation) ResetAgentID() {
	m.agent = nil
	delete(m.clearedFields, feedback.FieldAgentID)
}

// SetContent sets the "content" field.
func (m *FeedbackMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *FeedbackMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *FeedbackMutation) ResetContent() {
	m.content = nil
}

// SetType sets the "type" field.
func (m *FeedbackMutation) SetType(u uint8) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *FeedbackMutation) GetType() (r uint8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *FeedbackMutation) AddType(u int8) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *FeedbackMutation) AddedType() (r int8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *FeedbackMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetSource sets the "source" field.
func (m *FeedbackMutation) SetSource(u uint8) {
	m.source = &u
	m.addsource = nil
}

// Source returns the value of the "source" field in the mutation.
func (m *FeedbackMutation) Source() (r uint8, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldSource(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// AddSource adds u to the "source" field.
func (m *FeedbackMutation) AddSource(u int8) {
	if m.addsource != nil {
		*m.addsource += u
	} else {
		m.addsource = &u
	}
}

// AddedSource returns the value that was added to the "source" field in this mutation.
func (m *FeedbackMutation) AddedSource() (r int8, exists bool) {
	v := m.addsource
	if v == nil {
		return
	}
	return *v, true
}

// ResetSource resets all changes to the "source" field.
func (m *FeedbackMutation) ResetSource() {
	m.source = nil
	m.addsource = nil
}

// SetURL sets the "url" field.
func (m *FeedbackMutation) SetURL(s []string) {
	m.url = &s
	m.appendurl = nil
}

// URL returns the value of the "url" field in the mutation.
func (m *FeedbackMutation) URL() (r []string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldURL(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// AppendURL adds s to the "url" field.
func (m *FeedbackMutation) AppendURL(s []string) {
	m.appendurl = append(m.appendurl, s...)
}

// AppendedURL returns the list of values that were appended to the "url" field in this mutation.
func (m *FeedbackMutation) AppendedURL() ([]string, bool) {
	if len(m.appendurl) == 0 {
		return nil, false
	}
	return m.appendurl, true
}

// ClearURL clears the value of the "url" field.
func (m *FeedbackMutation) ClearURL() {
	m.url = nil
	m.appendurl = nil
	m.clearedFields[feedback.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *FeedbackMutation) URLCleared() bool {
	_, ok := m.clearedFields[feedback.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *FeedbackMutation) ResetURL() {
	m.url = nil
	m.appendurl = nil
	delete(m.clearedFields, feedback.FieldURL)
}

// SetName sets the "name" field.
func (m *FeedbackMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FeedbackMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *FeedbackMutation) ClearName() {
	m.name = nil
	m.clearedFields[feedback.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *FeedbackMutation) NameCleared() bool {
	_, ok := m.clearedFields[feedback.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *FeedbackMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, feedback.FieldName)
}

// SetPhone sets the "phone" field.
func (m *FeedbackMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *FeedbackMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Feedback entity.
// If the Feedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FeedbackMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *FeedbackMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[feedback.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *FeedbackMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[feedback.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *FeedbackMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, feedback.FieldPhone)
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *FeedbackMutation) ClearEnterprise() {
	m.clearedenterprise = true
	m.clearedFields[feedback.FieldEnterpriseID] = struct{}{}
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *FeedbackMutation) EnterpriseCleared() bool {
	return m.EnterpriseIDCleared() || m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *FeedbackMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *FeedbackMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// ClearAgent clears the "agent" edge to the Agent entity.
func (m *FeedbackMutation) ClearAgent() {
	m.clearedagent = true
	m.clearedFields[feedback.FieldAgentID] = struct{}{}
}

// AgentCleared reports if the "agent" edge to the Agent entity was cleared.
func (m *FeedbackMutation) AgentCleared() bool {
	return m.AgentIDCleared() || m.clearedagent
}

// AgentIDs returns the "agent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentID instead. It exists only for internal usage by the builders.
func (m *FeedbackMutation) AgentIDs() (ids []uint64) {
	if id := m.agent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgent resets all changes to the "agent" edge.
func (m *FeedbackMutation) ResetAgent() {
	m.agent = nil
	m.clearedagent = false
}

// Where appends a list predicates to the FeedbackMutation builder.
func (m *FeedbackMutation) Where(ps ...predicate.Feedback) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FeedbackMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FeedbackMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Feedback, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FeedbackMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FeedbackMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Feedback).
func (m *FeedbackMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FeedbackMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, feedback.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, feedback.FieldUpdatedAt)
	}
	if m.enterprise != nil {
		fields = append(fields, feedback.FieldEnterpriseID)
	}
	if m.agent != nil {
		fields = append(fields, feedback.FieldAgentID)
	}
	if m.content != nil {
		fields = append(fields, feedback.FieldContent)
	}
	if m._type != nil {
		fields = append(fields, feedback.FieldType)
	}
	if m.source != nil {
		fields = append(fields, feedback.FieldSource)
	}
	if m.url != nil {
		fields = append(fields, feedback.FieldURL)
	}
	if m.name != nil {
		fields = append(fields, feedback.FieldName)
	}
	if m.phone != nil {
		fields = append(fields, feedback.FieldPhone)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FeedbackMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case feedback.FieldCreatedAt:
		return m.CreatedAt()
	case feedback.FieldUpdatedAt:
		return m.UpdatedAt()
	case feedback.FieldEnterpriseID:
		return m.EnterpriseID()
	case feedback.FieldAgentID:
		return m.AgentID()
	case feedback.FieldContent:
		return m.Content()
	case feedback.FieldType:
		return m.GetType()
	case feedback.FieldSource:
		return m.Source()
	case feedback.FieldURL:
		return m.URL()
	case feedback.FieldName:
		return m.Name()
	case feedback.FieldPhone:
		return m.Phone()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FeedbackMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case feedback.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case feedback.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case feedback.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case feedback.FieldAgentID:
		return m.OldAgentID(ctx)
	case feedback.FieldContent:
		return m.OldContent(ctx)
	case feedback.FieldType:
		return m.OldType(ctx)
	case feedback.FieldSource:
		return m.OldSource(ctx)
	case feedback.FieldURL:
		return m.OldURL(ctx)
	case feedback.FieldName:
		return m.OldName(ctx)
	case feedback.FieldPhone:
		return m.OldPhone(ctx)
	}
	return nil, fmt.Errorf("unknown Feedback field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedbackMutation) SetField(name string, value ent.Value) error {
	switch name {
	case feedback.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case feedback.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case feedback.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case feedback.FieldAgentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentID(v)
		return nil
	case feedback.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case feedback.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case feedback.FieldSource:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case feedback.FieldURL:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case feedback.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case feedback.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	}
	return fmt.Errorf("unknown Feedback field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FeedbackMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, feedback.FieldType)
	}
	if m.addsource != nil {
		fields = append(fields, feedback.FieldSource)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FeedbackMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case feedback.FieldType:
		return m.AddedType()
	case feedback.FieldSource:
		return m.AddedSource()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FeedbackMutation) AddField(name string, value ent.Value) error {
	switch name {
	case feedback.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case feedback.FieldSource:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSource(v)
		return nil
	}
	return fmt.Errorf("unknown Feedback numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FeedbackMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(feedback.FieldEnterpriseID) {
		fields = append(fields, feedback.FieldEnterpriseID)
	}
	if m.FieldCleared(feedback.FieldAgentID) {
		fields = append(fields, feedback.FieldAgentID)
	}
	if m.FieldCleared(feedback.FieldURL) {
		fields = append(fields, feedback.FieldURL)
	}
	if m.FieldCleared(feedback.FieldName) {
		fields = append(fields, feedback.FieldName)
	}
	if m.FieldCleared(feedback.FieldPhone) {
		fields = append(fields, feedback.FieldPhone)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FeedbackMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FeedbackMutation) ClearField(name string) error {
	switch name {
	case feedback.FieldEnterpriseID:
		m.ClearEnterpriseID()
		return nil
	case feedback.FieldAgentID:
		m.ClearAgentID()
		return nil
	case feedback.FieldURL:
		m.ClearURL()
		return nil
	case feedback.FieldName:
		m.ClearName()
		return nil
	case feedback.FieldPhone:
		m.ClearPhone()
		return nil
	}
	return fmt.Errorf("unknown Feedback nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FeedbackMutation) ResetField(name string) error {
	switch name {
	case feedback.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case feedback.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case feedback.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case feedback.FieldAgentID:
		m.ResetAgentID()
		return nil
	case feedback.FieldContent:
		m.ResetContent()
		return nil
	case feedback.FieldType:
		m.ResetType()
		return nil
	case feedback.FieldSource:
		m.ResetSource()
		return nil
	case feedback.FieldURL:
		m.ResetURL()
		return nil
	case feedback.FieldName:
		m.ResetName()
		return nil
	case feedback.FieldPhone:
		m.ResetPhone()
		return nil
	}
	return fmt.Errorf("unknown Feedback field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FeedbackMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.enterprise != nil {
		edges = append(edges, feedback.EdgeEnterprise)
	}
	if m.agent != nil {
		edges = append(edges, feedback.EdgeAgent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FeedbackMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case feedback.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	case feedback.EdgeAgent:
		if id := m.agent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FeedbackMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FeedbackMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FeedbackMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedenterprise {
		edges = append(edges, feedback.EdgeEnterprise)
	}
	if m.clearedagent {
		edges = append(edges, feedback.EdgeAgent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FeedbackMutation) EdgeCleared(name string) bool {
	switch name {
	case feedback.EdgeEnterprise:
		return m.clearedenterprise
	case feedback.EdgeAgent:
		return m.clearedagent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FeedbackMutation) ClearEdge(name string) error {
	switch name {
	case feedback.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	case feedback.EdgeAgent:
		m.ClearAgent()
		return nil
	}
	return fmt.Errorf("unknown Feedback unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FeedbackMutation) ResetEdge(name string) error {
	switch name {
	case feedback.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	case feedback.EdgeAgent:
		m.ResetAgent()
		return nil
	}
	return fmt.Errorf("unknown Feedback edge %s", name)
}

// GuideMutation represents an operation that mutates the Guide nodes in the graph.
type GuideMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	creator       **model.Modifier
	last_modifier **model.Modifier
	remark        *string
	name          *string
	sort          *uint8
	addsort       *int8
	answer        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Guide, error)
	predicates    []predicate.Guide
}

var _ ent.Mutation = (*GuideMutation)(nil)

// guideOption allows management of the mutation configuration using functional options.
type guideOption func(*GuideMutation)

// newGuideMutation creates new mutation for the Guide entity.
func newGuideMutation(c config, op Op, opts ...guideOption) *GuideMutation {
	m := &GuideMutation{
		config:        c,
		op:            op,
		typ:           TypeGuide,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGuideID sets the ID field of the mutation.
func withGuideID(id uint64) guideOption {
	return func(m *GuideMutation) {
		var (
			err   error
			once  sync.Once
			value *Guide
		)
		m.oldValue = func(ctx context.Context) (*Guide, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Guide.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGuide sets the old Guide of the mutation.
func withGuide(node *Guide) guideOption {
	return func(m *GuideMutation) {
		m.oldValue = func(context.Context) (*Guide, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GuideMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GuideMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GuideMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GuideMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Guide.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GuideMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GuideMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Guide entity.
// If the Guide object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuideMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GuideMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GuideMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GuideMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Guide entity.
// If the Guide object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuideMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GuideMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *GuideMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *GuideMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Guide entity.
// If the Guide object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuideMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *GuideMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[guide.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *GuideMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[guide.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *GuideMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, guide.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *GuideMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *GuideMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Guide entity.
// If the Guide object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuideMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *GuideMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[guide.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *GuideMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[guide.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *GuideMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, guide.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *GuideMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *GuideMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Guide entity.
// If the Guide object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuideMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *GuideMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[guide.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *GuideMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[guide.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *GuideMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, guide.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *GuideMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *GuideMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Guide entity.
// If the Guide object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuideMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *GuideMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[guide.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *GuideMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[guide.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *GuideMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, guide.FieldRemark)
}

// SetName sets the "name" field.
func (m *GuideMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *GuideMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Guide entity.
// If the Guide object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuideMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *GuideMutation) ResetName() {
	m.name = nil
}

// SetSort sets the "sort" field.
func (m *GuideMutation) SetSort(u uint8) {
	m.sort = &u
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *GuideMutation) Sort() (r uint8, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Guide entity.
// If the Guide object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuideMutation) OldSort(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds u to the "sort" field.
func (m *GuideMutation) AddSort(u int8) {
	if m.addsort != nil {
		*m.addsort += u
	} else {
		m.addsort = &u
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *GuideMutation) AddedSort() (r int8, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *GuideMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetAnswer sets the "answer" field.
func (m *GuideMutation) SetAnswer(s string) {
	m.answer = &s
}

// Answer returns the value of the "answer" field in the mutation.
func (m *GuideMutation) Answer() (r string, exists bool) {
	v := m.answer
	if v == nil {
		return
	}
	return *v, true
}

// OldAnswer returns the old "answer" field's value of the Guide entity.
// If the Guide object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GuideMutation) OldAnswer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAnswer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAnswer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAnswer: %w", err)
	}
	return oldValue.Answer, nil
}

// ResetAnswer resets all changes to the "answer" field.
func (m *GuideMutation) ResetAnswer() {
	m.answer = nil
}

// Where appends a list predicates to the GuideMutation builder.
func (m *GuideMutation) Where(ps ...predicate.Guide) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GuideMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GuideMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Guide, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GuideMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GuideMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Guide).
func (m *GuideMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GuideMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, guide.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, guide.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, guide.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, guide.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, guide.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, guide.FieldRemark)
	}
	if m.name != nil {
		fields = append(fields, guide.FieldName)
	}
	if m.sort != nil {
		fields = append(fields, guide.FieldSort)
	}
	if m.answer != nil {
		fields = append(fields, guide.FieldAnswer)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GuideMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case guide.FieldCreatedAt:
		return m.CreatedAt()
	case guide.FieldUpdatedAt:
		return m.UpdatedAt()
	case guide.FieldDeletedAt:
		return m.DeletedAt()
	case guide.FieldCreator:
		return m.Creator()
	case guide.FieldLastModifier:
		return m.LastModifier()
	case guide.FieldRemark:
		return m.Remark()
	case guide.FieldName:
		return m.Name()
	case guide.FieldSort:
		return m.Sort()
	case guide.FieldAnswer:
		return m.Answer()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GuideMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case guide.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case guide.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case guide.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case guide.FieldCreator:
		return m.OldCreator(ctx)
	case guide.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case guide.FieldRemark:
		return m.OldRemark(ctx)
	case guide.FieldName:
		return m.OldName(ctx)
	case guide.FieldSort:
		return m.OldSort(ctx)
	case guide.FieldAnswer:
		return m.OldAnswer(ctx)
	}
	return nil, fmt.Errorf("unknown Guide field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GuideMutation) SetField(name string, value ent.Value) error {
	switch name {
	case guide.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case guide.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case guide.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case guide.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case guide.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case guide.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case guide.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case guide.FieldSort:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case guide.FieldAnswer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAnswer(v)
		return nil
	}
	return fmt.Errorf("unknown Guide field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GuideMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, guide.FieldSort)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GuideMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case guide.FieldSort:
		return m.AddedSort()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GuideMutation) AddField(name string, value ent.Value) error {
	switch name {
	case guide.FieldSort:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	}
	return fmt.Errorf("unknown Guide numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GuideMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(guide.FieldDeletedAt) {
		fields = append(fields, guide.FieldDeletedAt)
	}
	if m.FieldCleared(guide.FieldCreator) {
		fields = append(fields, guide.FieldCreator)
	}
	if m.FieldCleared(guide.FieldLastModifier) {
		fields = append(fields, guide.FieldLastModifier)
	}
	if m.FieldCleared(guide.FieldRemark) {
		fields = append(fields, guide.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GuideMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GuideMutation) ClearField(name string) error {
	switch name {
	case guide.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case guide.FieldCreator:
		m.ClearCreator()
		return nil
	case guide.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case guide.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Guide nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GuideMutation) ResetField(name string) error {
	switch name {
	case guide.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case guide.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case guide.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case guide.FieldCreator:
		m.ResetCreator()
		return nil
	case guide.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case guide.FieldRemark:
		m.ResetRemark()
		return nil
	case guide.FieldName:
		m.ResetName()
		return nil
	case guide.FieldSort:
		m.ResetSort()
		return nil
	case guide.FieldAnswer:
		m.ResetAnswer()
		return nil
	}
	return fmt.Errorf("unknown Guide field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GuideMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GuideMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GuideMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GuideMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GuideMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GuideMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GuideMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Guide unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GuideMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Guide edge %s", name)
}

// InventoryMutation represents an operation that mutates the Inventory nodes in the graph.
type InventoryMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	creator       **model.Modifier
	last_modifier **model.Modifier
	remark        *string
	name          *string
	count         *bool
	transfer      *bool
	purchase      *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Inventory, error)
	predicates    []predicate.Inventory
}

var _ ent.Mutation = (*InventoryMutation)(nil)

// inventoryOption allows management of the mutation configuration using functional options.
type inventoryOption func(*InventoryMutation)

// newInventoryMutation creates new mutation for the Inventory entity.
func newInventoryMutation(c config, op Op, opts ...inventoryOption) *InventoryMutation {
	m := &InventoryMutation{
		config:        c,
		op:            op,
		typ:           TypeInventory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInventoryID sets the ID field of the mutation.
func withInventoryID(id uint64) inventoryOption {
	return func(m *InventoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Inventory
		)
		m.oldValue = func(ctx context.Context) (*Inventory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Inventory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInventory sets the old Inventory of the mutation.
func withInventory(node *Inventory) inventoryOption {
	return func(m *InventoryMutation) {
		m.oldValue = func(context.Context) (*Inventory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InventoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InventoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InventoryMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InventoryMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Inventory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InventoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InventoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InventoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InventoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InventoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InventoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *InventoryMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *InventoryMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *InventoryMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[inventory.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *InventoryMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[inventory.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *InventoryMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, inventory.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *InventoryMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *InventoryMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *InventoryMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[inventory.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *InventoryMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[inventory.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *InventoryMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, inventory.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *InventoryMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *InventoryMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *InventoryMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[inventory.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *InventoryMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[inventory.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *InventoryMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, inventory.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *InventoryMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *InventoryMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *InventoryMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[inventory.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *InventoryMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[inventory.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *InventoryMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, inventory.FieldRemark)
}

// SetName sets the "name" field.
func (m *InventoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InventoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *InventoryMutation) ResetName() {
	m.name = nil
}

// SetCount sets the "count" field.
func (m *InventoryMutation) SetCount(b bool) {
	m.count = &b
}

// Count returns the value of the "count" field in the mutation.
func (m *InventoryMutation) Count() (r bool, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldCount(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// ResetCount resets all changes to the "count" field.
func (m *InventoryMutation) ResetCount() {
	m.count = nil
}

// SetTransfer sets the "transfer" field.
func (m *InventoryMutation) SetTransfer(b bool) {
	m.transfer = &b
}

// Transfer returns the value of the "transfer" field in the mutation.
func (m *InventoryMutation) Transfer() (r bool, exists bool) {
	v := m.transfer
	if v == nil {
		return
	}
	return *v, true
}

// OldTransfer returns the old "transfer" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldTransfer(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransfer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransfer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransfer: %w", err)
	}
	return oldValue.Transfer, nil
}

// ResetTransfer resets all changes to the "transfer" field.
func (m *InventoryMutation) ResetTransfer() {
	m.transfer = nil
}

// SetPurchase sets the "purchase" field.
func (m *InventoryMutation) SetPurchase(b bool) {
	m.purchase = &b
}

// Purchase returns the value of the "purchase" field in the mutation.
func (m *InventoryMutation) Purchase() (r bool, exists bool) {
	v := m.purchase
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchase returns the old "purchase" field's value of the Inventory entity.
// If the Inventory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryMutation) OldPurchase(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchase is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchase requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchase: %w", err)
	}
	return oldValue.Purchase, nil
}

// ResetPurchase resets all changes to the "purchase" field.
func (m *InventoryMutation) ResetPurchase() {
	m.purchase = nil
}

// Where appends a list predicates to the InventoryMutation builder.
func (m *InventoryMutation) Where(ps ...predicate.Inventory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InventoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InventoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Inventory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InventoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InventoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Inventory).
func (m *InventoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InventoryMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, inventory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, inventory.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, inventory.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, inventory.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, inventory.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, inventory.FieldRemark)
	}
	if m.name != nil {
		fields = append(fields, inventory.FieldName)
	}
	if m.count != nil {
		fields = append(fields, inventory.FieldCount)
	}
	if m.transfer != nil {
		fields = append(fields, inventory.FieldTransfer)
	}
	if m.purchase != nil {
		fields = append(fields, inventory.FieldPurchase)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InventoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inventory.FieldCreatedAt:
		return m.CreatedAt()
	case inventory.FieldUpdatedAt:
		return m.UpdatedAt()
	case inventory.FieldDeletedAt:
		return m.DeletedAt()
	case inventory.FieldCreator:
		return m.Creator()
	case inventory.FieldLastModifier:
		return m.LastModifier()
	case inventory.FieldRemark:
		return m.Remark()
	case inventory.FieldName:
		return m.Name()
	case inventory.FieldCount:
		return m.Count()
	case inventory.FieldTransfer:
		return m.Transfer()
	case inventory.FieldPurchase:
		return m.Purchase()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InventoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inventory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case inventory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case inventory.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case inventory.FieldCreator:
		return m.OldCreator(ctx)
	case inventory.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case inventory.FieldRemark:
		return m.OldRemark(ctx)
	case inventory.FieldName:
		return m.OldName(ctx)
	case inventory.FieldCount:
		return m.OldCount(ctx)
	case inventory.FieldTransfer:
		return m.OldTransfer(ctx)
	case inventory.FieldPurchase:
		return m.OldPurchase(ctx)
	}
	return nil, fmt.Errorf("unknown Inventory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inventory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case inventory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case inventory.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case inventory.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case inventory.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case inventory.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case inventory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case inventory.FieldCount:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case inventory.FieldTransfer:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransfer(v)
		return nil
	case inventory.FieldPurchase:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchase(v)
		return nil
	}
	return fmt.Errorf("unknown Inventory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InventoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InventoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Inventory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InventoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inventory.FieldDeletedAt) {
		fields = append(fields, inventory.FieldDeletedAt)
	}
	if m.FieldCleared(inventory.FieldCreator) {
		fields = append(fields, inventory.FieldCreator)
	}
	if m.FieldCleared(inventory.FieldLastModifier) {
		fields = append(fields, inventory.FieldLastModifier)
	}
	if m.FieldCleared(inventory.FieldRemark) {
		fields = append(fields, inventory.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InventoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InventoryMutation) ClearField(name string) error {
	switch name {
	case inventory.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case inventory.FieldCreator:
		m.ClearCreator()
		return nil
	case inventory.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case inventory.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Inventory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InventoryMutation) ResetField(name string) error {
	switch name {
	case inventory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case inventory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case inventory.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case inventory.FieldCreator:
		m.ResetCreator()
		return nil
	case inventory.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case inventory.FieldRemark:
		m.ResetRemark()
		return nil
	case inventory.FieldName:
		m.ResetName()
		return nil
	case inventory.FieldCount:
		m.ResetCount()
		return nil
	case inventory.FieldTransfer:
		m.ResetTransfer()
		return nil
	case inventory.FieldPurchase:
		m.ResetPurchase()
		return nil
	}
	return fmt.Errorf("unknown Inventory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InventoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InventoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InventoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InventoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InventoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InventoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InventoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Inventory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InventoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Inventory edge %s", name)
}

// MaintainerMutation represents an operation that mutates the Maintainer nodes in the graph.
type MaintainerMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	enable        *bool
	name          *string
	phone         *string
	password      *string
	clearedFields map[string]struct{}
	cities        map[uint64]struct{}
	removedcities map[uint64]struct{}
	clearedcities bool
	done          bool
	oldValue      func(context.Context) (*Maintainer, error)
	predicates    []predicate.Maintainer
}

var _ ent.Mutation = (*MaintainerMutation)(nil)

// maintainerOption allows management of the mutation configuration using functional options.
type maintainerOption func(*MaintainerMutation)

// newMaintainerMutation creates new mutation for the Maintainer entity.
func newMaintainerMutation(c config, op Op, opts ...maintainerOption) *MaintainerMutation {
	m := &MaintainerMutation{
		config:        c,
		op:            op,
		typ:           TypeMaintainer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMaintainerID sets the ID field of the mutation.
func withMaintainerID(id uint64) maintainerOption {
	return func(m *MaintainerMutation) {
		var (
			err   error
			once  sync.Once
			value *Maintainer
		)
		m.oldValue = func(ctx context.Context) (*Maintainer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Maintainer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMaintainer sets the old Maintainer of the mutation.
func withMaintainer(node *Maintainer) maintainerOption {
	return func(m *MaintainerMutation) {
		m.oldValue = func(context.Context) (*Maintainer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MaintainerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MaintainerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MaintainerMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MaintainerMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Maintainer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnable sets the "enable" field.
func (m *MaintainerMutation) SetEnable(b bool) {
	m.enable = &b
}

// Enable returns the value of the "enable" field in the mutation.
func (m *MaintainerMutation) Enable() (r bool, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the Maintainer entity.
// If the Maintainer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintainerMutation) OldEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// ResetEnable resets all changes to the "enable" field.
func (m *MaintainerMutation) ResetEnable() {
	m.enable = nil
}

// SetName sets the "name" field.
func (m *MaintainerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MaintainerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Maintainer entity.
// If the Maintainer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintainerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MaintainerMutation) ResetName() {
	m.name = nil
}

// SetPhone sets the "phone" field.
func (m *MaintainerMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *MaintainerMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Maintainer entity.
// If the Maintainer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintainerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *MaintainerMutation) ResetPhone() {
	m.phone = nil
}

// SetPassword sets the "password" field.
func (m *MaintainerMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *MaintainerMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Maintainer entity.
// If the Maintainer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MaintainerMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *MaintainerMutation) ResetPassword() {
	m.password = nil
}

// AddCityIDs adds the "cities" edge to the City entity by ids.
func (m *MaintainerMutation) AddCityIDs(ids ...uint64) {
	if m.cities == nil {
		m.cities = make(map[uint64]struct{})
	}
	for i := range ids {
		m.cities[ids[i]] = struct{}{}
	}
}

// ClearCities clears the "cities" edge to the City entity.
func (m *MaintainerMutation) ClearCities() {
	m.clearedcities = true
}

// CitiesCleared reports if the "cities" edge to the City entity was cleared.
func (m *MaintainerMutation) CitiesCleared() bool {
	return m.clearedcities
}

// RemoveCityIDs removes the "cities" edge to the City entity by IDs.
func (m *MaintainerMutation) RemoveCityIDs(ids ...uint64) {
	if m.removedcities == nil {
		m.removedcities = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.cities, ids[i])
		m.removedcities[ids[i]] = struct{}{}
	}
}

// RemovedCities returns the removed IDs of the "cities" edge to the City entity.
func (m *MaintainerMutation) RemovedCitiesIDs() (ids []uint64) {
	for id := range m.removedcities {
		ids = append(ids, id)
	}
	return
}

// CitiesIDs returns the "cities" edge IDs in the mutation.
func (m *MaintainerMutation) CitiesIDs() (ids []uint64) {
	for id := range m.cities {
		ids = append(ids, id)
	}
	return
}

// ResetCities resets all changes to the "cities" edge.
func (m *MaintainerMutation) ResetCities() {
	m.cities = nil
	m.clearedcities = false
	m.removedcities = nil
}

// Where appends a list predicates to the MaintainerMutation builder.
func (m *MaintainerMutation) Where(ps ...predicate.Maintainer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MaintainerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MaintainerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Maintainer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MaintainerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MaintainerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Maintainer).
func (m *MaintainerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MaintainerMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.enable != nil {
		fields = append(fields, maintainer.FieldEnable)
	}
	if m.name != nil {
		fields = append(fields, maintainer.FieldName)
	}
	if m.phone != nil {
		fields = append(fields, maintainer.FieldPhone)
	}
	if m.password != nil {
		fields = append(fields, maintainer.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MaintainerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case maintainer.FieldEnable:
		return m.Enable()
	case maintainer.FieldName:
		return m.Name()
	case maintainer.FieldPhone:
		return m.Phone()
	case maintainer.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MaintainerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case maintainer.FieldEnable:
		return m.OldEnable(ctx)
	case maintainer.FieldName:
		return m.OldName(ctx)
	case maintainer.FieldPhone:
		return m.OldPhone(ctx)
	case maintainer.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown Maintainer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MaintainerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case maintainer.FieldEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case maintainer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case maintainer.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case maintainer.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown Maintainer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MaintainerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MaintainerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MaintainerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Maintainer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MaintainerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MaintainerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MaintainerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Maintainer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MaintainerMutation) ResetField(name string) error {
	switch name {
	case maintainer.FieldEnable:
		m.ResetEnable()
		return nil
	case maintainer.FieldName:
		m.ResetName()
		return nil
	case maintainer.FieldPhone:
		m.ResetPhone()
		return nil
	case maintainer.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown Maintainer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MaintainerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cities != nil {
		edges = append(edges, maintainer.EdgeCities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MaintainerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case maintainer.EdgeCities:
		ids := make([]ent.Value, 0, len(m.cities))
		for id := range m.cities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MaintainerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcities != nil {
		edges = append(edges, maintainer.EdgeCities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MaintainerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case maintainer.EdgeCities:
		ids := make([]ent.Value, 0, len(m.removedcities))
		for id := range m.removedcities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MaintainerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcities {
		edges = append(edges, maintainer.EdgeCities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MaintainerMutation) EdgeCleared(name string) bool {
	switch name {
	case maintainer.EdgeCities:
		return m.clearedcities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MaintainerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Maintainer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MaintainerMutation) ResetEdge(name string) error {
	switch name {
	case maintainer.EdgeCities:
		m.ResetCities()
		return nil
	}
	return fmt.Errorf("unknown Maintainer edge %s", name)
}

// ManagerMutation represents an operation that mutates the Manager nodes in the graph.
type ManagerMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	creator        **model.Modifier
	last_modifier  **model.Modifier
	remark         *string
	phone          *string
	name           *string
	password       *string
	last_signin_at *time.Time
	clearedFields  map[string]struct{}
	role           *uint64
	clearedrole    bool
	done           bool
	oldValue       func(context.Context) (*Manager, error)
	predicates     []predicate.Manager
}

var _ ent.Mutation = (*ManagerMutation)(nil)

// managerOption allows management of the mutation configuration using functional options.
type managerOption func(*ManagerMutation)

// newManagerMutation creates new mutation for the Manager entity.
func newManagerMutation(c config, op Op, opts ...managerOption) *ManagerMutation {
	m := &ManagerMutation{
		config:        c,
		op:            op,
		typ:           TypeManager,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withManagerID sets the ID field of the mutation.
func withManagerID(id uint64) managerOption {
	return func(m *ManagerMutation) {
		var (
			err   error
			once  sync.Once
			value *Manager
		)
		m.oldValue = func(ctx context.Context) (*Manager, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Manager.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withManager sets the old Manager of the mutation.
func withManager(node *Manager) managerOption {
	return func(m *ManagerMutation) {
		m.oldValue = func(context.Context) (*Manager, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ManagerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ManagerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ManagerMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ManagerMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Manager.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ManagerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ManagerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ManagerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ManagerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ManagerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ManagerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ManagerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ManagerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ManagerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[manager.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ManagerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[manager.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ManagerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, manager.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *ManagerMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *ManagerMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *ManagerMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[manager.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *ManagerMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[manager.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *ManagerMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, manager.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *ManagerMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *ManagerMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *ManagerMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[manager.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *ManagerMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[manager.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *ManagerMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, manager.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *ManagerMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ManagerMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ManagerMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[manager.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ManagerMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[manager.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ManagerMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, manager.FieldRemark)
}

// SetRoleID sets the "role_id" field.
func (m *ManagerMutation) SetRoleID(u uint64) {
	m.role = &u
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *ManagerMutation) RoleID() (r uint64, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldRoleID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ClearRoleID clears the value of the "role_id" field.
func (m *ManagerMutation) ClearRoleID() {
	m.role = nil
	m.clearedFields[manager.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *ManagerMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[manager.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *ManagerMutation) ResetRoleID() {
	m.role = nil
	delete(m.clearedFields, manager.FieldRoleID)
}

// SetPhone sets the "phone" field.
func (m *ManagerMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *ManagerMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *ManagerMutation) ResetPhone() {
	m.phone = nil
}

// SetName sets the "name" field.
func (m *ManagerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ManagerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ManagerMutation) ResetName() {
	m.name = nil
}

// SetPassword sets the "password" field.
func (m *ManagerMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *ManagerMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *ManagerMutation) ResetPassword() {
	m.password = nil
}

// SetLastSigninAt sets the "last_signin_at" field.
func (m *ManagerMutation) SetLastSigninAt(t time.Time) {
	m.last_signin_at = &t
}

// LastSigninAt returns the value of the "last_signin_at" field in the mutation.
func (m *ManagerMutation) LastSigninAt() (r time.Time, exists bool) {
	v := m.last_signin_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSigninAt returns the old "last_signin_at" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldLastSigninAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSigninAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSigninAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSigninAt: %w", err)
	}
	return oldValue.LastSigninAt, nil
}

// ClearLastSigninAt clears the value of the "last_signin_at" field.
func (m *ManagerMutation) ClearLastSigninAt() {
	m.last_signin_at = nil
	m.clearedFields[manager.FieldLastSigninAt] = struct{}{}
}

// LastSigninAtCleared returns if the "last_signin_at" field was cleared in this mutation.
func (m *ManagerMutation) LastSigninAtCleared() bool {
	_, ok := m.clearedFields[manager.FieldLastSigninAt]
	return ok
}

// ResetLastSigninAt resets all changes to the "last_signin_at" field.
func (m *ManagerMutation) ResetLastSigninAt() {
	m.last_signin_at = nil
	delete(m.clearedFields, manager.FieldLastSigninAt)
}

// ClearRole clears the "role" edge to the Role entity.
func (m *ManagerMutation) ClearRole() {
	m.clearedrole = true
	m.clearedFields[manager.FieldRoleID] = struct{}{}
}

// RoleCleared reports if the "role" edge to the Role entity was cleared.
func (m *ManagerMutation) RoleCleared() bool {
	return m.RoleIDCleared() || m.clearedrole
}

// RoleIDs returns the "role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoleID instead. It exists only for internal usage by the builders.
func (m *ManagerMutation) RoleIDs() (ids []uint64) {
	if id := m.role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRole resets all changes to the "role" edge.
func (m *ManagerMutation) ResetRole() {
	m.role = nil
	m.clearedrole = false
}

// Where appends a list predicates to the ManagerMutation builder.
func (m *ManagerMutation) Where(ps ...predicate.Manager) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ManagerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ManagerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Manager, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ManagerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ManagerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Manager).
func (m *ManagerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ManagerMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, manager.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, manager.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, manager.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, manager.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, manager.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, manager.FieldRemark)
	}
	if m.role != nil {
		fields = append(fields, manager.FieldRoleID)
	}
	if m.phone != nil {
		fields = append(fields, manager.FieldPhone)
	}
	if m.name != nil {
		fields = append(fields, manager.FieldName)
	}
	if m.password != nil {
		fields = append(fields, manager.FieldPassword)
	}
	if m.last_signin_at != nil {
		fields = append(fields, manager.FieldLastSigninAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ManagerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case manager.FieldCreatedAt:
		return m.CreatedAt()
	case manager.FieldUpdatedAt:
		return m.UpdatedAt()
	case manager.FieldDeletedAt:
		return m.DeletedAt()
	case manager.FieldCreator:
		return m.Creator()
	case manager.FieldLastModifier:
		return m.LastModifier()
	case manager.FieldRemark:
		return m.Remark()
	case manager.FieldRoleID:
		return m.RoleID()
	case manager.FieldPhone:
		return m.Phone()
	case manager.FieldName:
		return m.Name()
	case manager.FieldPassword:
		return m.Password()
	case manager.FieldLastSigninAt:
		return m.LastSigninAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ManagerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case manager.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case manager.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case manager.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case manager.FieldCreator:
		return m.OldCreator(ctx)
	case manager.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case manager.FieldRemark:
		return m.OldRemark(ctx)
	case manager.FieldRoleID:
		return m.OldRoleID(ctx)
	case manager.FieldPhone:
		return m.OldPhone(ctx)
	case manager.FieldName:
		return m.OldName(ctx)
	case manager.FieldPassword:
		return m.OldPassword(ctx)
	case manager.FieldLastSigninAt:
		return m.OldLastSigninAt(ctx)
	}
	return nil, fmt.Errorf("unknown Manager field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ManagerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case manager.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case manager.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case manager.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case manager.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case manager.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case manager.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case manager.FieldRoleID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case manager.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case manager.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case manager.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case manager.FieldLastSigninAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSigninAt(v)
		return nil
	}
	return fmt.Errorf("unknown Manager field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ManagerMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ManagerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ManagerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Manager numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ManagerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(manager.FieldDeletedAt) {
		fields = append(fields, manager.FieldDeletedAt)
	}
	if m.FieldCleared(manager.FieldCreator) {
		fields = append(fields, manager.FieldCreator)
	}
	if m.FieldCleared(manager.FieldLastModifier) {
		fields = append(fields, manager.FieldLastModifier)
	}
	if m.FieldCleared(manager.FieldRemark) {
		fields = append(fields, manager.FieldRemark)
	}
	if m.FieldCleared(manager.FieldRoleID) {
		fields = append(fields, manager.FieldRoleID)
	}
	if m.FieldCleared(manager.FieldLastSigninAt) {
		fields = append(fields, manager.FieldLastSigninAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ManagerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ManagerMutation) ClearField(name string) error {
	switch name {
	case manager.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case manager.FieldCreator:
		m.ClearCreator()
		return nil
	case manager.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case manager.FieldRemark:
		m.ClearRemark()
		return nil
	case manager.FieldRoleID:
		m.ClearRoleID()
		return nil
	case manager.FieldLastSigninAt:
		m.ClearLastSigninAt()
		return nil
	}
	return fmt.Errorf("unknown Manager nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ManagerMutation) ResetField(name string) error {
	switch name {
	case manager.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case manager.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case manager.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case manager.FieldCreator:
		m.ResetCreator()
		return nil
	case manager.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case manager.FieldRemark:
		m.ResetRemark()
		return nil
	case manager.FieldRoleID:
		m.ResetRoleID()
		return nil
	case manager.FieldPhone:
		m.ResetPhone()
		return nil
	case manager.FieldName:
		m.ResetName()
		return nil
	case manager.FieldPassword:
		m.ResetPassword()
		return nil
	case manager.FieldLastSigninAt:
		m.ResetLastSigninAt()
		return nil
	}
	return fmt.Errorf("unknown Manager field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ManagerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.role != nil {
		edges = append(edges, manager.EdgeRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ManagerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case manager.EdgeRole:
		if id := m.role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ManagerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ManagerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ManagerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrole {
		edges = append(edges, manager.EdgeRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ManagerMutation) EdgeCleared(name string) bool {
	switch name {
	case manager.EdgeRole:
		return m.clearedrole
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ManagerMutation) ClearEdge(name string) error {
	switch name {
	case manager.EdgeRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown Manager unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ManagerMutation) ResetEdge(name string) error {
	switch name {
	case manager.EdgeRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown Manager edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	status            *uint8
	addstatus         *int8
	payway            *uint8
	addpayway         *int8
	_type             *uint
	add_type          *int
	out_trade_no      *string
	trade_no          *string
	amount            *float64
	addamount         *float64
	total             *float64
	addtotal          *float64
	refund_at         *time.Time
	initial_days      *int
	addinitial_days   *int
	past_days         *int
	addpast_days      *int
	points            *int64
	addpoints         *int64
	point_ratio       *float64
	addpoint_ratio    *float64
	coupon_amount     *float64
	addcoupon_amount  *float64
	discount_newly    *float64
	adddiscount_newly *float64
	trade_pay_at      *time.Time
	clearedFields     map[string]struct{}
	plan              *uint64
	clearedplan       bool
	city              *uint64
	clearedcity       bool
	brand             *uint64
	clearedbrand      bool
	ebike             *uint64
	clearedebike      bool
	agent             *uint64
	clearedagent      bool
	rider             *uint64
	clearedrider      bool
	subscribe         *uint64
	clearedsubscribe  bool
	commission        *uint64
	clearedcommission bool
	parent            *uint64
	clearedparent     bool
	children          map[uint64]struct{}
	removedchildren   map[uint64]struct{}
	clearedchildren   bool
	refund            *uint64
	clearedrefund     bool
	assistance        *uint64
	clearedassistance bool
	coupons           map[uint64]struct{}
	removedcoupons    map[uint64]struct{}
	clearedcoupons    bool
	done              bool
	oldValue          func(context.Context) (*Order, error)
	predicates        []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id uint64) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrderMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[order.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrderMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[order.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, order.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *OrderMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *OrderMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *OrderMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[order.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *OrderMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[order.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *OrderMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, order.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *OrderMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *OrderMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *OrderMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[order.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *OrderMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[order.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *OrderMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, order.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *OrderMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *OrderMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *OrderMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[order.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *OrderMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[order.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *OrderMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, order.FieldRemark)
}

// SetPlanID sets the "plan_id" field.
func (m *OrderMutation) SetPlanID(u uint64) {
	m.plan = &u
}

// PlanID returns the value of the "plan_id" field in the mutation.
func (m *OrderMutation) PlanID() (r uint64, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanID returns the old "plan_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPlanID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanID: %w", err)
	}
	return oldValue.PlanID, nil
}

// ClearPlanID clears the value of the "plan_id" field.
func (m *OrderMutation) ClearPlanID() {
	m.plan = nil
	m.clearedFields[order.FieldPlanID] = struct{}{}
}

// PlanIDCleared returns if the "plan_id" field was cleared in this mutation.
func (m *OrderMutation) PlanIDCleared() bool {
	_, ok := m.clearedFields[order.FieldPlanID]
	return ok
}

// ResetPlanID resets all changes to the "plan_id" field.
func (m *OrderMutation) ResetPlanID() {
	m.plan = nil
	delete(m.clearedFields, order.FieldPlanID)
}

// SetCityID sets the "city_id" field.
func (m *OrderMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *OrderMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCityID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ClearCityID clears the value of the "city_id" field.
func (m *OrderMutation) ClearCityID() {
	m.city = nil
	m.clearedFields[order.FieldCityID] = struct{}{}
}

// CityIDCleared returns if the "city_id" field was cleared in this mutation.
func (m *OrderMutation) CityIDCleared() bool {
	_, ok := m.clearedFields[order.FieldCityID]
	return ok
}

// ResetCityID resets all changes to the "city_id" field.
func (m *OrderMutation) ResetCityID() {
	m.city = nil
	delete(m.clearedFields, order.FieldCityID)
}

// SetBrandID sets the "brand_id" field.
func (m *OrderMutation) SetBrandID(u uint64) {
	m.brand = &u
}

// BrandID returns the value of the "brand_id" field in the mutation.
func (m *OrderMutation) BrandID() (r uint64, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrandID returns the old "brand_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldBrandID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrandID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrandID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrandID: %w", err)
	}
	return oldValue.BrandID, nil
}

// ClearBrandID clears the value of the "brand_id" field.
func (m *OrderMutation) ClearBrandID() {
	m.brand = nil
	m.clearedFields[order.FieldBrandID] = struct{}{}
}

// BrandIDCleared returns if the "brand_id" field was cleared in this mutation.
func (m *OrderMutation) BrandIDCleared() bool {
	_, ok := m.clearedFields[order.FieldBrandID]
	return ok
}

// ResetBrandID resets all changes to the "brand_id" field.
func (m *OrderMutation) ResetBrandID() {
	m.brand = nil
	delete(m.clearedFields, order.FieldBrandID)
}

// SetEbikeID sets the "ebike_id" field.
func (m *OrderMutation) SetEbikeID(u uint64) {
	m.ebike = &u
}

// EbikeID returns the value of the "ebike_id" field in the mutation.
func (m *OrderMutation) EbikeID() (r uint64, exists bool) {
	v := m.ebike
	if v == nil {
		return
	}
	return *v, true
}

// OldEbikeID returns the old "ebike_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldEbikeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEbikeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEbikeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEbikeID: %w", err)
	}
	return oldValue.EbikeID, nil
}

// ClearEbikeID clears the value of the "ebike_id" field.
func (m *OrderMutation) ClearEbikeID() {
	m.ebike = nil
	m.clearedFields[order.FieldEbikeID] = struct{}{}
}

// EbikeIDCleared returns if the "ebike_id" field was cleared in this mutation.
func (m *OrderMutation) EbikeIDCleared() bool {
	_, ok := m.clearedFields[order.FieldEbikeID]
	return ok
}

// ResetEbikeID resets all changes to the "ebike_id" field.
func (m *OrderMutation) ResetEbikeID() {
	m.ebike = nil
	delete(m.clearedFields, order.FieldEbikeID)
}

// SetAgentID sets the "agent_id" field.
func (m *OrderMutation) SetAgentID(u uint64) {
	m.agent = &u
}

// AgentID returns the value of the "agent_id" field in the mutation.
func (m *OrderMutation) AgentID() (r uint64, exists bool) {
	v := m.agent
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentID returns the old "agent_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldAgentID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentID: %w", err)
	}
	return oldValue.AgentID, nil
}

// ClearAgentID clears the value of the "agent_id" field.
func (m *OrderMutation) ClearAgentID() {
	m.agent = nil
	m.clearedFields[order.FieldAgentID] = struct{}{}
}

// AgentIDCleared returns if the "agent_id" field was cleared in this mutation.
func (m *OrderMutation) AgentIDCleared() bool {
	_, ok := m.clearedFields[order.FieldAgentID]
	return ok
}

// ResetAgentID resets all changes to the "agent_id" field.
func (m *OrderMutation) ResetAgentID() {
	m.agent = nil
	delete(m.clearedFields, order.FieldAgentID)
}

// SetRiderID sets the "rider_id" field.
func (m *OrderMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *OrderMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ClearRiderID clears the value of the "rider_id" field.
func (m *OrderMutation) ClearRiderID() {
	m.rider = nil
	m.clearedFields[order.FieldRiderID] = struct{}{}
}

// RiderIDCleared returns if the "rider_id" field was cleared in this mutation.
func (m *OrderMutation) RiderIDCleared() bool {
	_, ok := m.clearedFields[order.FieldRiderID]
	return ok
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *OrderMutation) ResetRiderID() {
	m.rider = nil
	delete(m.clearedFields, order.FieldRiderID)
}

// SetParentID sets the "parent_id" field.
func (m *OrderMutation) SetParentID(u uint64) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *OrderMutation) ParentID() (r uint64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldParentID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *OrderMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[order.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *OrderMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[order.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *OrderMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, order.FieldParentID)
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *OrderMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *OrderMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldSubscribeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ClearSubscribeID clears the value of the "subscribe_id" field.
func (m *OrderMutation) ClearSubscribeID() {
	m.subscribe = nil
	m.clearedFields[order.FieldSubscribeID] = struct{}{}
}

// SubscribeIDCleared returns if the "subscribe_id" field was cleared in this mutation.
func (m *OrderMutation) SubscribeIDCleared() bool {
	_, ok := m.clearedFields[order.FieldSubscribeID]
	return ok
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *OrderMutation) ResetSubscribeID() {
	m.subscribe = nil
	delete(m.clearedFields, order.FieldSubscribeID)
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *OrderMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OrderMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetPayway sets the "payway" field.
func (m *OrderMutation) SetPayway(u uint8) {
	m.payway = &u
	m.addpayway = nil
}

// Payway returns the value of the "payway" field in the mutation.
func (m *OrderMutation) Payway() (r uint8, exists bool) {
	v := m.payway
	if v == nil {
		return
	}
	return *v, true
}

// OldPayway returns the old "payway" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPayway(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayway: %w", err)
	}
	return oldValue.Payway, nil
}

// AddPayway adds u to the "payway" field.
func (m *OrderMutation) AddPayway(u int8) {
	if m.addpayway != nil {
		*m.addpayway += u
	} else {
		m.addpayway = &u
	}
}

// AddedPayway returns the value that was added to the "payway" field in this mutation.
func (m *OrderMutation) AddedPayway() (r int8, exists bool) {
	v := m.addpayway
	if v == nil {
		return
	}
	return *v, true
}

// ResetPayway resets all changes to the "payway" field.
func (m *OrderMutation) ResetPayway() {
	m.payway = nil
	m.addpayway = nil
}

// SetType sets the "type" field.
func (m *OrderMutation) SetType(u uint) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *OrderMutation) GetType() (r uint, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldType(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *OrderMutation) AddType(u int) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *OrderMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *OrderMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetOutTradeNo sets the "out_trade_no" field.
func (m *OrderMutation) SetOutTradeNo(s string) {
	m.out_trade_no = &s
}

// OutTradeNo returns the value of the "out_trade_no" field in the mutation.
func (m *OrderMutation) OutTradeNo() (r string, exists bool) {
	v := m.out_trade_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOutTradeNo returns the old "out_trade_no" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOutTradeNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutTradeNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutTradeNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutTradeNo: %w", err)
	}
	return oldValue.OutTradeNo, nil
}

// ResetOutTradeNo resets all changes to the "out_trade_no" field.
func (m *OrderMutation) ResetOutTradeNo() {
	m.out_trade_no = nil
}

// SetTradeNo sets the "trade_no" field.
func (m *OrderMutation) SetTradeNo(s string) {
	m.trade_no = &s
}

// TradeNo returns the value of the "trade_no" field in the mutation.
func (m *OrderMutation) TradeNo() (r string, exists bool) {
	v := m.trade_no
	if v == nil {
		return
	}
	return *v, true
}

// OldTradeNo returns the old "trade_no" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTradeNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTradeNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTradeNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTradeNo: %w", err)
	}
	return oldValue.TradeNo, nil
}

// ResetTradeNo resets all changes to the "trade_no" field.
func (m *OrderMutation) ResetTradeNo() {
	m.trade_no = nil
}

// SetAmount sets the "amount" field.
func (m *OrderMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *OrderMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *OrderMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *OrderMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *OrderMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetTotal sets the "total" field.
func (m *OrderMutation) SetTotal(f float64) {
	m.total = &f
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *OrderMutation) Total() (r float64, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTotal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds f to the "total" field.
func (m *OrderMutation) AddTotal(f float64) {
	if m.addtotal != nil {
		*m.addtotal += f
	} else {
		m.addtotal = &f
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *OrderMutation) AddedTotal() (r float64, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotal resets all changes to the "total" field.
func (m *OrderMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
}

// SetRefundAt sets the "refund_at" field.
func (m *OrderMutation) SetRefundAt(t time.Time) {
	m.refund_at = &t
}

// RefundAt returns the value of the "refund_at" field in the mutation.
func (m *OrderMutation) RefundAt() (r time.Time, exists bool) {
	v := m.refund_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundAt returns the old "refund_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldRefundAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundAt: %w", err)
	}
	return oldValue.RefundAt, nil
}

// ClearRefundAt clears the value of the "refund_at" field.
func (m *OrderMutation) ClearRefundAt() {
	m.refund_at = nil
	m.clearedFields[order.FieldRefundAt] = struct{}{}
}

// RefundAtCleared returns if the "refund_at" field was cleared in this mutation.
func (m *OrderMutation) RefundAtCleared() bool {
	_, ok := m.clearedFields[order.FieldRefundAt]
	return ok
}

// ResetRefundAt resets all changes to the "refund_at" field.
func (m *OrderMutation) ResetRefundAt() {
	m.refund_at = nil
	delete(m.clearedFields, order.FieldRefundAt)
}

// SetInitialDays sets the "initial_days" field.
func (m *OrderMutation) SetInitialDays(i int) {
	m.initial_days = &i
	m.addinitial_days = nil
}

// InitialDays returns the value of the "initial_days" field in the mutation.
func (m *OrderMutation) InitialDays() (r int, exists bool) {
	v := m.initial_days
	if v == nil {
		return
	}
	return *v, true
}

// OldInitialDays returns the old "initial_days" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldInitialDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitialDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitialDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitialDays: %w", err)
	}
	return oldValue.InitialDays, nil
}

// AddInitialDays adds i to the "initial_days" field.
func (m *OrderMutation) AddInitialDays(i int) {
	if m.addinitial_days != nil {
		*m.addinitial_days += i
	} else {
		m.addinitial_days = &i
	}
}

// AddedInitialDays returns the value that was added to the "initial_days" field in this mutation.
func (m *OrderMutation) AddedInitialDays() (r int, exists bool) {
	v := m.addinitial_days
	if v == nil {
		return
	}
	return *v, true
}

// ClearInitialDays clears the value of the "initial_days" field.
func (m *OrderMutation) ClearInitialDays() {
	m.initial_days = nil
	m.addinitial_days = nil
	m.clearedFields[order.FieldInitialDays] = struct{}{}
}

// InitialDaysCleared returns if the "initial_days" field was cleared in this mutation.
func (m *OrderMutation) InitialDaysCleared() bool {
	_, ok := m.clearedFields[order.FieldInitialDays]
	return ok
}

// ResetInitialDays resets all changes to the "initial_days" field.
func (m *OrderMutation) ResetInitialDays() {
	m.initial_days = nil
	m.addinitial_days = nil
	delete(m.clearedFields, order.FieldInitialDays)
}

// SetPastDays sets the "past_days" field.
func (m *OrderMutation) SetPastDays(i int) {
	m.past_days = &i
	m.addpast_days = nil
}

// PastDays returns the value of the "past_days" field in the mutation.
func (m *OrderMutation) PastDays() (r int, exists bool) {
	v := m.past_days
	if v == nil {
		return
	}
	return *v, true
}

// OldPastDays returns the old "past_days" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPastDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPastDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPastDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPastDays: %w", err)
	}
	return oldValue.PastDays, nil
}

// AddPastDays adds i to the "past_days" field.
func (m *OrderMutation) AddPastDays(i int) {
	if m.addpast_days != nil {
		*m.addpast_days += i
	} else {
		m.addpast_days = &i
	}
}

// AddedPastDays returns the value that was added to the "past_days" field in this mutation.
func (m *OrderMutation) AddedPastDays() (r int, exists bool) {
	v := m.addpast_days
	if v == nil {
		return
	}
	return *v, true
}

// ClearPastDays clears the value of the "past_days" field.
func (m *OrderMutation) ClearPastDays() {
	m.past_days = nil
	m.addpast_days = nil
	m.clearedFields[order.FieldPastDays] = struct{}{}
}

// PastDaysCleared returns if the "past_days" field was cleared in this mutation.
func (m *OrderMutation) PastDaysCleared() bool {
	_, ok := m.clearedFields[order.FieldPastDays]
	return ok
}

// ResetPastDays resets all changes to the "past_days" field.
func (m *OrderMutation) ResetPastDays() {
	m.past_days = nil
	m.addpast_days = nil
	delete(m.clearedFields, order.FieldPastDays)
}

// SetPoints sets the "points" field.
func (m *OrderMutation) SetPoints(i int64) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *OrderMutation) Points() (r int64, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPoints(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *OrderMutation) AddPoints(i int64) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *OrderMutation) AddedPoints() (r int64, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints resets all changes to the "points" field.
func (m *OrderMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetPointRatio sets the "point_ratio" field.
func (m *OrderMutation) SetPointRatio(f float64) {
	m.point_ratio = &f
	m.addpoint_ratio = nil
}

// PointRatio returns the value of the "point_ratio" field in the mutation.
func (m *OrderMutation) PointRatio() (r float64, exists bool) {
	v := m.point_ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldPointRatio returns the old "point_ratio" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldPointRatio(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPointRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPointRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointRatio: %w", err)
	}
	return oldValue.PointRatio, nil
}

// AddPointRatio adds f to the "point_ratio" field.
func (m *OrderMutation) AddPointRatio(f float64) {
	if m.addpoint_ratio != nil {
		*m.addpoint_ratio += f
	} else {
		m.addpoint_ratio = &f
	}
}

// AddedPointRatio returns the value that was added to the "point_ratio" field in this mutation.
func (m *OrderMutation) AddedPointRatio() (r float64, exists bool) {
	v := m.addpoint_ratio
	if v == nil {
		return
	}
	return *v, true
}

// ResetPointRatio resets all changes to the "point_ratio" field.
func (m *OrderMutation) ResetPointRatio() {
	m.point_ratio = nil
	m.addpoint_ratio = nil
}

// SetCouponAmount sets the "coupon_amount" field.
func (m *OrderMutation) SetCouponAmount(f float64) {
	m.coupon_amount = &f
	m.addcoupon_amount = nil
}

// CouponAmount returns the value of the "coupon_amount" field in the mutation.
func (m *OrderMutation) CouponAmount() (r float64, exists bool) {
	v := m.coupon_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldCouponAmount returns the old "coupon_amount" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCouponAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCouponAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCouponAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCouponAmount: %w", err)
	}
	return oldValue.CouponAmount, nil
}

// AddCouponAmount adds f to the "coupon_amount" field.
func (m *OrderMutation) AddCouponAmount(f float64) {
	if m.addcoupon_amount != nil {
		*m.addcoupon_amount += f
	} else {
		m.addcoupon_amount = &f
	}
}

// AddedCouponAmount returns the value that was added to the "coupon_amount" field in this mutation.
func (m *OrderMutation) AddedCouponAmount() (r float64, exists bool) {
	v := m.addcoupon_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCouponAmount resets all changes to the "coupon_amount" field.
func (m *OrderMutation) ResetCouponAmount() {
	m.coupon_amount = nil
	m.addcoupon_amount = nil
}

// SetDiscountNewly sets the "discount_newly" field.
func (m *OrderMutation) SetDiscountNewly(f float64) {
	m.discount_newly = &f
	m.adddiscount_newly = nil
}

// DiscountNewly returns the value of the "discount_newly" field in the mutation.
func (m *OrderMutation) DiscountNewly() (r float64, exists bool) {
	v := m.discount_newly
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountNewly returns the old "discount_newly" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldDiscountNewly(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscountNewly is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscountNewly requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountNewly: %w", err)
	}
	return oldValue.DiscountNewly, nil
}

// AddDiscountNewly adds f to the "discount_newly" field.
func (m *OrderMutation) AddDiscountNewly(f float64) {
	if m.adddiscount_newly != nil {
		*m.adddiscount_newly += f
	} else {
		m.adddiscount_newly = &f
	}
}

// AddedDiscountNewly returns the value that was added to the "discount_newly" field in this mutation.
func (m *OrderMutation) AddedDiscountNewly() (r float64, exists bool) {
	v := m.adddiscount_newly
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiscountNewly resets all changes to the "discount_newly" field.
func (m *OrderMutation) ResetDiscountNewly() {
	m.discount_newly = nil
	m.adddiscount_newly = nil
}

// SetTradePayAt sets the "trade_pay_at" field.
func (m *OrderMutation) SetTradePayAt(t time.Time) {
	m.trade_pay_at = &t
}

// TradePayAt returns the value of the "trade_pay_at" field in the mutation.
func (m *OrderMutation) TradePayAt() (r time.Time, exists bool) {
	v := m.trade_pay_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTradePayAt returns the old "trade_pay_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTradePayAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTradePayAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTradePayAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTradePayAt: %w", err)
	}
	return oldValue.TradePayAt, nil
}

// ClearTradePayAt clears the value of the "trade_pay_at" field.
func (m *OrderMutation) ClearTradePayAt() {
	m.trade_pay_at = nil
	m.clearedFields[order.FieldTradePayAt] = struct{}{}
}

// TradePayAtCleared returns if the "trade_pay_at" field was cleared in this mutation.
func (m *OrderMutation) TradePayAtCleared() bool {
	_, ok := m.clearedFields[order.FieldTradePayAt]
	return ok
}

// ResetTradePayAt resets all changes to the "trade_pay_at" field.
func (m *OrderMutation) ResetTradePayAt() {
	m.trade_pay_at = nil
	delete(m.clearedFields, order.FieldTradePayAt)
}

// ClearPlan clears the "plan" edge to the Plan entity.
func (m *OrderMutation) ClearPlan() {
	m.clearedplan = true
	m.clearedFields[order.FieldPlanID] = struct{}{}
}

// PlanCleared reports if the "plan" edge to the Plan entity was cleared.
func (m *OrderMutation) PlanCleared() bool {
	return m.PlanIDCleared() || m.clearedplan
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) PlanIDs() (ids []uint64) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *OrderMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *OrderMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[order.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *OrderMutation) CityCleared() bool {
	return m.CityIDCleared() || m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *OrderMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearBrand clears the "brand" edge to the EbikeBrand entity.
func (m *OrderMutation) ClearBrand() {
	m.clearedbrand = true
	m.clearedFields[order.FieldBrandID] = struct{}{}
}

// BrandCleared reports if the "brand" edge to the EbikeBrand entity was cleared.
func (m *OrderMutation) BrandCleared() bool {
	return m.BrandIDCleared() || m.clearedbrand
}

// BrandIDs returns the "brand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BrandID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) BrandIDs() (ids []uint64) {
	if id := m.brand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBrand resets all changes to the "brand" edge.
func (m *OrderMutation) ResetBrand() {
	m.brand = nil
	m.clearedbrand = false
}

// ClearEbike clears the "ebike" edge to the Ebike entity.
func (m *OrderMutation) ClearEbike() {
	m.clearedebike = true
	m.clearedFields[order.FieldEbikeID] = struct{}{}
}

// EbikeCleared reports if the "ebike" edge to the Ebike entity was cleared.
func (m *OrderMutation) EbikeCleared() bool {
	return m.EbikeIDCleared() || m.clearedebike
}

// EbikeIDs returns the "ebike" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EbikeID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) EbikeIDs() (ids []uint64) {
	if id := m.ebike; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEbike resets all changes to the "ebike" edge.
func (m *OrderMutation) ResetEbike() {
	m.ebike = nil
	m.clearedebike = false
}

// ClearAgent clears the "agent" edge to the Agent entity.
func (m *OrderMutation) ClearAgent() {
	m.clearedagent = true
	m.clearedFields[order.FieldAgentID] = struct{}{}
}

// AgentCleared reports if the "agent" edge to the Agent entity was cleared.
func (m *OrderMutation) AgentCleared() bool {
	return m.AgentIDCleared() || m.clearedagent
}

// AgentIDs returns the "agent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) AgentIDs() (ids []uint64) {
	if id := m.agent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgent resets all changes to the "agent" edge.
func (m *OrderMutation) ResetAgent() {
	m.agent = nil
	m.clearedagent = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *OrderMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[order.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *OrderMutation) RiderCleared() bool {
	return m.RiderIDCleared() || m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *OrderMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *OrderMutation) ClearSubscribe() {
	m.clearedsubscribe = true
	m.clearedFields[order.FieldSubscribeID] = struct{}{}
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *OrderMutation) SubscribeCleared() bool {
	return m.SubscribeIDCleared() || m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *OrderMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// SetCommissionID sets the "commission" edge to the Commission entity by id.
func (m *OrderMutation) SetCommissionID(id uint64) {
	m.commission = &id
}

// ClearCommission clears the "commission" edge to the Commission entity.
func (m *OrderMutation) ClearCommission() {
	m.clearedcommission = true
}

// CommissionCleared reports if the "commission" edge to the Commission entity was cleared.
func (m *OrderMutation) CommissionCleared() bool {
	return m.clearedcommission
}

// CommissionID returns the "commission" edge ID in the mutation.
func (m *OrderMutation) CommissionID() (id uint64, exists bool) {
	if m.commission != nil {
		return *m.commission, true
	}
	return
}

// CommissionIDs returns the "commission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommissionID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) CommissionIDs() (ids []uint64) {
	if id := m.commission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCommission resets all changes to the "commission" edge.
func (m *OrderMutation) ResetCommission() {
	m.commission = nil
	m.clearedcommission = false
}

// ClearParent clears the "parent" edge to the Order entity.
func (m *OrderMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[order.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Order entity was cleared.
func (m *OrderMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) ParentIDs() (ids []uint64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OrderMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Order entity by ids.
func (m *OrderMutation) AddChildIDs(ids ...uint64) {
	if m.children == nil {
		m.children = make(map[uint64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Order entity.
func (m *OrderMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Order entity was cleared.
func (m *OrderMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Order entity by IDs.
func (m *OrderMutation) RemoveChildIDs(ids ...uint64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Order entity.
func (m *OrderMutation) RemovedChildrenIDs() (ids []uint64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *OrderMutation) ChildrenIDs() (ids []uint64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *OrderMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// SetRefundID sets the "refund" edge to the OrderRefund entity by id.
func (m *OrderMutation) SetRefundID(id uint64) {
	m.refund = &id
}

// ClearRefund clears the "refund" edge to the OrderRefund entity.
func (m *OrderMutation) ClearRefund() {
	m.clearedrefund = true
}

// RefundCleared reports if the "refund" edge to the OrderRefund entity was cleared.
func (m *OrderMutation) RefundCleared() bool {
	return m.clearedrefund
}

// RefundID returns the "refund" edge ID in the mutation.
func (m *OrderMutation) RefundID() (id uint64, exists bool) {
	if m.refund != nil {
		return *m.refund, true
	}
	return
}

// RefundIDs returns the "refund" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RefundID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) RefundIDs() (ids []uint64) {
	if id := m.refund; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRefund resets all changes to the "refund" edge.
func (m *OrderMutation) ResetRefund() {
	m.refund = nil
	m.clearedrefund = false
}

// SetAssistanceID sets the "assistance" edge to the Assistance entity by id.
func (m *OrderMutation) SetAssistanceID(id uint64) {
	m.assistance = &id
}

// ClearAssistance clears the "assistance" edge to the Assistance entity.
func (m *OrderMutation) ClearAssistance() {
	m.clearedassistance = true
}

// AssistanceCleared reports if the "assistance" edge to the Assistance entity was cleared.
func (m *OrderMutation) AssistanceCleared() bool {
	return m.clearedassistance
}

// AssistanceID returns the "assistance" edge ID in the mutation.
func (m *OrderMutation) AssistanceID() (id uint64, exists bool) {
	if m.assistance != nil {
		return *m.assistance, true
	}
	return
}

// AssistanceIDs returns the "assistance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssistanceID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) AssistanceIDs() (ids []uint64) {
	if id := m.assistance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssistance resets all changes to the "assistance" edge.
func (m *OrderMutation) ResetAssistance() {
	m.assistance = nil
	m.clearedassistance = false
}

// AddCouponIDs adds the "coupons" edge to the Coupon entity by ids.
func (m *OrderMutation) AddCouponIDs(ids ...uint64) {
	if m.coupons == nil {
		m.coupons = make(map[uint64]struct{})
	}
	for i := range ids {
		m.coupons[ids[i]] = struct{}{}
	}
}

// ClearCoupons clears the "coupons" edge to the Coupon entity.
func (m *OrderMutation) ClearCoupons() {
	m.clearedcoupons = true
}

// CouponsCleared reports if the "coupons" edge to the Coupon entity was cleared.
func (m *OrderMutation) CouponsCleared() bool {
	return m.clearedcoupons
}

// RemoveCouponIDs removes the "coupons" edge to the Coupon entity by IDs.
func (m *OrderMutation) RemoveCouponIDs(ids ...uint64) {
	if m.removedcoupons == nil {
		m.removedcoupons = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.coupons, ids[i])
		m.removedcoupons[ids[i]] = struct{}{}
	}
}

// RemovedCoupons returns the removed IDs of the "coupons" edge to the Coupon entity.
func (m *OrderMutation) RemovedCouponsIDs() (ids []uint64) {
	for id := range m.removedcoupons {
		ids = append(ids, id)
	}
	return
}

// CouponsIDs returns the "coupons" edge IDs in the mutation.
func (m *OrderMutation) CouponsIDs() (ids []uint64) {
	for id := range m.coupons {
		ids = append(ids, id)
	}
	return
}

// ResetCoupons resets all changes to the "coupons" edge.
func (m *OrderMutation) ResetCoupons() {
	m.coupons = nil
	m.clearedcoupons = false
	m.removedcoupons = nil
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 29)
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, order.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, order.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, order.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, order.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, order.FieldRemark)
	}
	if m.plan != nil {
		fields = append(fields, order.FieldPlanID)
	}
	if m.city != nil {
		fields = append(fields, order.FieldCityID)
	}
	if m.brand != nil {
		fields = append(fields, order.FieldBrandID)
	}
	if m.ebike != nil {
		fields = append(fields, order.FieldEbikeID)
	}
	if m.agent != nil {
		fields = append(fields, order.FieldAgentID)
	}
	if m.rider != nil {
		fields = append(fields, order.FieldRiderID)
	}
	if m.parent != nil {
		fields = append(fields, order.FieldParentID)
	}
	if m.subscribe != nil {
		fields = append(fields, order.FieldSubscribeID)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.payway != nil {
		fields = append(fields, order.FieldPayway)
	}
	if m._type != nil {
		fields = append(fields, order.FieldType)
	}
	if m.out_trade_no != nil {
		fields = append(fields, order.FieldOutTradeNo)
	}
	if m.trade_no != nil {
		fields = append(fields, order.FieldTradeNo)
	}
	if m.amount != nil {
		fields = append(fields, order.FieldAmount)
	}
	if m.total != nil {
		fields = append(fields, order.FieldTotal)
	}
	if m.refund_at != nil {
		fields = append(fields, order.FieldRefundAt)
	}
	if m.initial_days != nil {
		fields = append(fields, order.FieldInitialDays)
	}
	if m.past_days != nil {
		fields = append(fields, order.FieldPastDays)
	}
	if m.points != nil {
		fields = append(fields, order.FieldPoints)
	}
	if m.point_ratio != nil {
		fields = append(fields, order.FieldPointRatio)
	}
	if m.coupon_amount != nil {
		fields = append(fields, order.FieldCouponAmount)
	}
	if m.discount_newly != nil {
		fields = append(fields, order.FieldDiscountNewly)
	}
	if m.trade_pay_at != nil {
		fields = append(fields, order.FieldTradePayAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldUpdatedAt:
		return m.UpdatedAt()
	case order.FieldDeletedAt:
		return m.DeletedAt()
	case order.FieldCreator:
		return m.Creator()
	case order.FieldLastModifier:
		return m.LastModifier()
	case order.FieldRemark:
		return m.Remark()
	case order.FieldPlanID:
		return m.PlanID()
	case order.FieldCityID:
		return m.CityID()
	case order.FieldBrandID:
		return m.BrandID()
	case order.FieldEbikeID:
		return m.EbikeID()
	case order.FieldAgentID:
		return m.AgentID()
	case order.FieldRiderID:
		return m.RiderID()
	case order.FieldParentID:
		return m.ParentID()
	case order.FieldSubscribeID:
		return m.SubscribeID()
	case order.FieldStatus:
		return m.Status()
	case order.FieldPayway:
		return m.Payway()
	case order.FieldType:
		return m.GetType()
	case order.FieldOutTradeNo:
		return m.OutTradeNo()
	case order.FieldTradeNo:
		return m.TradeNo()
	case order.FieldAmount:
		return m.Amount()
	case order.FieldTotal:
		return m.Total()
	case order.FieldRefundAt:
		return m.RefundAt()
	case order.FieldInitialDays:
		return m.InitialDays()
	case order.FieldPastDays:
		return m.PastDays()
	case order.FieldPoints:
		return m.Points()
	case order.FieldPointRatio:
		return m.PointRatio()
	case order.FieldCouponAmount:
		return m.CouponAmount()
	case order.FieldDiscountNewly:
		return m.DiscountNewly()
	case order.FieldTradePayAt:
		return m.TradePayAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case order.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case order.FieldCreator:
		return m.OldCreator(ctx)
	case order.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case order.FieldRemark:
		return m.OldRemark(ctx)
	case order.FieldPlanID:
		return m.OldPlanID(ctx)
	case order.FieldCityID:
		return m.OldCityID(ctx)
	case order.FieldBrandID:
		return m.OldBrandID(ctx)
	case order.FieldEbikeID:
		return m.OldEbikeID(ctx)
	case order.FieldAgentID:
		return m.OldAgentID(ctx)
	case order.FieldRiderID:
		return m.OldRiderID(ctx)
	case order.FieldParentID:
		return m.OldParentID(ctx)
	case order.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	case order.FieldPayway:
		return m.OldPayway(ctx)
	case order.FieldType:
		return m.OldType(ctx)
	case order.FieldOutTradeNo:
		return m.OldOutTradeNo(ctx)
	case order.FieldTradeNo:
		return m.OldTradeNo(ctx)
	case order.FieldAmount:
		return m.OldAmount(ctx)
	case order.FieldTotal:
		return m.OldTotal(ctx)
	case order.FieldRefundAt:
		return m.OldRefundAt(ctx)
	case order.FieldInitialDays:
		return m.OldInitialDays(ctx)
	case order.FieldPastDays:
		return m.OldPastDays(ctx)
	case order.FieldPoints:
		return m.OldPoints(ctx)
	case order.FieldPointRatio:
		return m.OldPointRatio(ctx)
	case order.FieldCouponAmount:
		return m.OldCouponAmount(ctx)
	case order.FieldDiscountNewly:
		return m.OldDiscountNewly(ctx)
	case order.FieldTradePayAt:
		return m.OldTradePayAt(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case order.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case order.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case order.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case order.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case order.FieldPlanID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanID(v)
		return nil
	case order.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case order.FieldBrandID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrandID(v)
		return nil
	case order.FieldEbikeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEbikeID(v)
		return nil
	case order.FieldAgentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentID(v)
		return nil
	case order.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case order.FieldParentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case order.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case order.FieldPayway:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayway(v)
		return nil
	case order.FieldType:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case order.FieldOutTradeNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutTradeNo(v)
		return nil
	case order.FieldTradeNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTradeNo(v)
		return nil
	case order.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case order.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case order.FieldRefundAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundAt(v)
		return nil
	case order.FieldInitialDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitialDays(v)
		return nil
	case order.FieldPastDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPastDays(v)
		return nil
	case order.FieldPoints:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case order.FieldPointRatio:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointRatio(v)
		return nil
	case order.FieldCouponAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCouponAmount(v)
		return nil
	case order.FieldDiscountNewly:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountNewly(v)
		return nil
	case order.FieldTradePayAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTradePayAt(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.addpayway != nil {
		fields = append(fields, order.FieldPayway)
	}
	if m.add_type != nil {
		fields = append(fields, order.FieldType)
	}
	if m.addamount != nil {
		fields = append(fields, order.FieldAmount)
	}
	if m.addtotal != nil {
		fields = append(fields, order.FieldTotal)
	}
	if m.addinitial_days != nil {
		fields = append(fields, order.FieldInitialDays)
	}
	if m.addpast_days != nil {
		fields = append(fields, order.FieldPastDays)
	}
	if m.addpoints != nil {
		fields = append(fields, order.FieldPoints)
	}
	if m.addpoint_ratio != nil {
		fields = append(fields, order.FieldPointRatio)
	}
	if m.addcoupon_amount != nil {
		fields = append(fields, order.FieldCouponAmount)
	}
	if m.adddiscount_newly != nil {
		fields = append(fields, order.FieldDiscountNewly)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case order.FieldStatus:
		return m.AddedStatus()
	case order.FieldPayway:
		return m.AddedPayway()
	case order.FieldType:
		return m.AddedType()
	case order.FieldAmount:
		return m.AddedAmount()
	case order.FieldTotal:
		return m.AddedTotal()
	case order.FieldInitialDays:
		return m.AddedInitialDays()
	case order.FieldPastDays:
		return m.AddedPastDays()
	case order.FieldPoints:
		return m.AddedPoints()
	case order.FieldPointRatio:
		return m.AddedPointRatio()
	case order.FieldCouponAmount:
		return m.AddedCouponAmount()
	case order.FieldDiscountNewly:
		return m.AddedDiscountNewly()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case order.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case order.FieldPayway:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayway(v)
		return nil
	case order.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case order.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case order.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	case order.FieldInitialDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInitialDays(v)
		return nil
	case order.FieldPastDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPastDays(v)
		return nil
	case order.FieldPoints:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	case order.FieldPointRatio:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPointRatio(v)
		return nil
	case order.FieldCouponAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCouponAmount(v)
		return nil
	case order.FieldDiscountNewly:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscountNewly(v)
		return nil
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldDeletedAt) {
		fields = append(fields, order.FieldDeletedAt)
	}
	if m.FieldCleared(order.FieldCreator) {
		fields = append(fields, order.FieldCreator)
	}
	if m.FieldCleared(order.FieldLastModifier) {
		fields = append(fields, order.FieldLastModifier)
	}
	if m.FieldCleared(order.FieldRemark) {
		fields = append(fields, order.FieldRemark)
	}
	if m.FieldCleared(order.FieldPlanID) {
		fields = append(fields, order.FieldPlanID)
	}
	if m.FieldCleared(order.FieldCityID) {
		fields = append(fields, order.FieldCityID)
	}
	if m.FieldCleared(order.FieldBrandID) {
		fields = append(fields, order.FieldBrandID)
	}
	if m.FieldCleared(order.FieldEbikeID) {
		fields = append(fields, order.FieldEbikeID)
	}
	if m.FieldCleared(order.FieldAgentID) {
		fields = append(fields, order.FieldAgentID)
	}
	if m.FieldCleared(order.FieldRiderID) {
		fields = append(fields, order.FieldRiderID)
	}
	if m.FieldCleared(order.FieldParentID) {
		fields = append(fields, order.FieldParentID)
	}
	if m.FieldCleared(order.FieldSubscribeID) {
		fields = append(fields, order.FieldSubscribeID)
	}
	if m.FieldCleared(order.FieldRefundAt) {
		fields = append(fields, order.FieldRefundAt)
	}
	if m.FieldCleared(order.FieldInitialDays) {
		fields = append(fields, order.FieldInitialDays)
	}
	if m.FieldCleared(order.FieldPastDays) {
		fields = append(fields, order.FieldPastDays)
	}
	if m.FieldCleared(order.FieldTradePayAt) {
		fields = append(fields, order.FieldTradePayAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case order.FieldCreator:
		m.ClearCreator()
		return nil
	case order.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case order.FieldRemark:
		m.ClearRemark()
		return nil
	case order.FieldPlanID:
		m.ClearPlanID()
		return nil
	case order.FieldCityID:
		m.ClearCityID()
		return nil
	case order.FieldBrandID:
		m.ClearBrandID()
		return nil
	case order.FieldEbikeID:
		m.ClearEbikeID()
		return nil
	case order.FieldAgentID:
		m.ClearAgentID()
		return nil
	case order.FieldRiderID:
		m.ClearRiderID()
		return nil
	case order.FieldParentID:
		m.ClearParentID()
		return nil
	case order.FieldSubscribeID:
		m.ClearSubscribeID()
		return nil
	case order.FieldRefundAt:
		m.ClearRefundAt()
		return nil
	case order.FieldInitialDays:
		m.ClearInitialDays()
		return nil
	case order.FieldPastDays:
		m.ClearPastDays()
		return nil
	case order.FieldTradePayAt:
		m.ClearTradePayAt()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case order.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case order.FieldCreator:
		m.ResetCreator()
		return nil
	case order.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case order.FieldRemark:
		m.ResetRemark()
		return nil
	case order.FieldPlanID:
		m.ResetPlanID()
		return nil
	case order.FieldCityID:
		m.ResetCityID()
		return nil
	case order.FieldBrandID:
		m.ResetBrandID()
		return nil
	case order.FieldEbikeID:
		m.ResetEbikeID()
		return nil
	case order.FieldAgentID:
		m.ResetAgentID()
		return nil
	case order.FieldRiderID:
		m.ResetRiderID()
		return nil
	case order.FieldParentID:
		m.ResetParentID()
		return nil
	case order.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	case order.FieldPayway:
		m.ResetPayway()
		return nil
	case order.FieldType:
		m.ResetType()
		return nil
	case order.FieldOutTradeNo:
		m.ResetOutTradeNo()
		return nil
	case order.FieldTradeNo:
		m.ResetTradeNo()
		return nil
	case order.FieldAmount:
		m.ResetAmount()
		return nil
	case order.FieldTotal:
		m.ResetTotal()
		return nil
	case order.FieldRefundAt:
		m.ResetRefundAt()
		return nil
	case order.FieldInitialDays:
		m.ResetInitialDays()
		return nil
	case order.FieldPastDays:
		m.ResetPastDays()
		return nil
	case order.FieldPoints:
		m.ResetPoints()
		return nil
	case order.FieldPointRatio:
		m.ResetPointRatio()
		return nil
	case order.FieldCouponAmount:
		m.ResetCouponAmount()
		return nil
	case order.FieldDiscountNewly:
		m.ResetDiscountNewly()
		return nil
	case order.FieldTradePayAt:
		m.ResetTradePayAt()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 13)
	if m.plan != nil {
		edges = append(edges, order.EdgePlan)
	}
	if m.city != nil {
		edges = append(edges, order.EdgeCity)
	}
	if m.brand != nil {
		edges = append(edges, order.EdgeBrand)
	}
	if m.ebike != nil {
		edges = append(edges, order.EdgeEbike)
	}
	if m.agent != nil {
		edges = append(edges, order.EdgeAgent)
	}
	if m.rider != nil {
		edges = append(edges, order.EdgeRider)
	}
	if m.subscribe != nil {
		edges = append(edges, order.EdgeSubscribe)
	}
	if m.commission != nil {
		edges = append(edges, order.EdgeCommission)
	}
	if m.parent != nil {
		edges = append(edges, order.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, order.EdgeChildren)
	}
	if m.refund != nil {
		edges = append(edges, order.EdgeRefund)
	}
	if m.assistance != nil {
		edges = append(edges, order.EdgeAssistance)
	}
	if m.coupons != nil {
		edges = append(edges, order.EdgeCoupons)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeBrand:
		if id := m.brand; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeEbike:
		if id := m.ebike; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeAgent:
		if id := m.agent; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeCommission:
		if id := m.commission; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeRefund:
		if id := m.refund; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeAssistance:
		if id := m.assistance; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeCoupons:
		ids := make([]ent.Value, 0, len(m.coupons))
		for id := range m.coupons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 13)
	if m.removedchildren != nil {
		edges = append(edges, order.EdgeChildren)
	}
	if m.removedcoupons != nil {
		edges = append(edges, order.EdgeCoupons)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeCoupons:
		ids := make([]ent.Value, 0, len(m.removedcoupons))
		for id := range m.removedcoupons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 13)
	if m.clearedplan {
		edges = append(edges, order.EdgePlan)
	}
	if m.clearedcity {
		edges = append(edges, order.EdgeCity)
	}
	if m.clearedbrand {
		edges = append(edges, order.EdgeBrand)
	}
	if m.clearedebike {
		edges = append(edges, order.EdgeEbike)
	}
	if m.clearedagent {
		edges = append(edges, order.EdgeAgent)
	}
	if m.clearedrider {
		edges = append(edges, order.EdgeRider)
	}
	if m.clearedsubscribe {
		edges = append(edges, order.EdgeSubscribe)
	}
	if m.clearedcommission {
		edges = append(edges, order.EdgeCommission)
	}
	if m.clearedparent {
		edges = append(edges, order.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, order.EdgeChildren)
	}
	if m.clearedrefund {
		edges = append(edges, order.EdgeRefund)
	}
	if m.clearedassistance {
		edges = append(edges, order.EdgeAssistance)
	}
	if m.clearedcoupons {
		edges = append(edges, order.EdgeCoupons)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgePlan:
		return m.clearedplan
	case order.EdgeCity:
		return m.clearedcity
	case order.EdgeBrand:
		return m.clearedbrand
	case order.EdgeEbike:
		return m.clearedebike
	case order.EdgeAgent:
		return m.clearedagent
	case order.EdgeRider:
		return m.clearedrider
	case order.EdgeSubscribe:
		return m.clearedsubscribe
	case order.EdgeCommission:
		return m.clearedcommission
	case order.EdgeParent:
		return m.clearedparent
	case order.EdgeChildren:
		return m.clearedchildren
	case order.EdgeRefund:
		return m.clearedrefund
	case order.EdgeAssistance:
		return m.clearedassistance
	case order.EdgeCoupons:
		return m.clearedcoupons
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgePlan:
		m.ClearPlan()
		return nil
	case order.EdgeCity:
		m.ClearCity()
		return nil
	case order.EdgeBrand:
		m.ClearBrand()
		return nil
	case order.EdgeEbike:
		m.ClearEbike()
		return nil
	case order.EdgeAgent:
		m.ClearAgent()
		return nil
	case order.EdgeRider:
		m.ClearRider()
		return nil
	case order.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	case order.EdgeCommission:
		m.ClearCommission()
		return nil
	case order.EdgeParent:
		m.ClearParent()
		return nil
	case order.EdgeRefund:
		m.ClearRefund()
		return nil
	case order.EdgeAssistance:
		m.ClearAssistance()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgePlan:
		m.ResetPlan()
		return nil
	case order.EdgeCity:
		m.ResetCity()
		return nil
	case order.EdgeBrand:
		m.ResetBrand()
		return nil
	case order.EdgeEbike:
		m.ResetEbike()
		return nil
	case order.EdgeAgent:
		m.ResetAgent()
		return nil
	case order.EdgeRider:
		m.ResetRider()
		return nil
	case order.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	case order.EdgeCommission:
		m.ResetCommission()
		return nil
	case order.EdgeParent:
		m.ResetParent()
		return nil
	case order.EdgeChildren:
		m.ResetChildren()
		return nil
	case order.EdgeRefund:
		m.ResetRefund()
		return nil
	case order.EdgeAssistance:
		m.ResetAssistance()
		return nil
	case order.EdgeCoupons:
		m.ResetCoupons()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderRefundMutation represents an operation that mutates the OrderRefund nodes in the graph.
type OrderRefundMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	creator       **model.Modifier
	last_modifier **model.Modifier
	remark        *string
	status        *uint8
	addstatus     *int8
	amount        *float64
	addamount     *float64
	out_refund_no *string
	reason        *string
	refund_at     *time.Time
	clearedFields map[string]struct{}
	_order        *uint64
	cleared_order bool
	done          bool
	oldValue      func(context.Context) (*OrderRefund, error)
	predicates    []predicate.OrderRefund
}

var _ ent.Mutation = (*OrderRefundMutation)(nil)

// orderrefundOption allows management of the mutation configuration using functional options.
type orderrefundOption func(*OrderRefundMutation)

// newOrderRefundMutation creates new mutation for the OrderRefund entity.
func newOrderRefundMutation(c config, op Op, opts ...orderrefundOption) *OrderRefundMutation {
	m := &OrderRefundMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderRefund,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderRefundID sets the ID field of the mutation.
func withOrderRefundID(id uint64) orderrefundOption {
	return func(m *OrderRefundMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderRefund
		)
		m.oldValue = func(ctx context.Context) (*OrderRefund, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderRefund.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderRefund sets the old OrderRefund of the mutation.
func withOrderRefund(node *OrderRefund) orderrefundOption {
	return func(m *OrderRefundMutation) {
		m.oldValue = func(context.Context) (*OrderRefund, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderRefundMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderRefundMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderRefundMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderRefundMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderRefund.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderRefundMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderRefundMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderRefundMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderRefundMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderRefundMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderRefundMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *OrderRefundMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *OrderRefundMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *OrderRefundMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[orderrefund.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *OrderRefundMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[orderrefund.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *OrderRefundMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, orderrefund.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *OrderRefundMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *OrderRefundMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *OrderRefundMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[orderrefund.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *OrderRefundMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[orderrefund.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *OrderRefundMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, orderrefund.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *OrderRefundMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *OrderRefundMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *OrderRefundMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[orderrefund.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *OrderRefundMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[orderrefund.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *OrderRefundMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, orderrefund.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *OrderRefundMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *OrderRefundMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *OrderRefundMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[orderrefund.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *OrderRefundMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[orderrefund.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *OrderRefundMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, orderrefund.FieldRemark)
}

// SetOrderID sets the "order_id" field.
func (m *OrderRefundMutation) SetOrderID(u uint64) {
	m._order = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderRefundMutation) OrderID() (r uint64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldOrderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderRefundMutation) ResetOrderID() {
	m._order = nil
}

// SetStatus sets the "status" field.
func (m *OrderRefundMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderRefundMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *OrderRefundMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *OrderRefundMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderRefundMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetAmount sets the "amount" field.
func (m *OrderRefundMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *OrderRefundMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *OrderRefundMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *OrderRefundMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *OrderRefundMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetOutRefundNo sets the "out_refund_no" field.
func (m *OrderRefundMutation) SetOutRefundNo(s string) {
	m.out_refund_no = &s
}

// OutRefundNo returns the value of the "out_refund_no" field in the mutation.
func (m *OrderRefundMutation) OutRefundNo() (r string, exists bool) {
	v := m.out_refund_no
	if v == nil {
		return
	}
	return *v, true
}

// OldOutRefundNo returns the old "out_refund_no" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldOutRefundNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutRefundNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutRefundNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutRefundNo: %w", err)
	}
	return oldValue.OutRefundNo, nil
}

// ResetOutRefundNo resets all changes to the "out_refund_no" field.
func (m *OrderRefundMutation) ResetOutRefundNo() {
	m.out_refund_no = nil
}

// SetReason sets the "reason" field.
func (m *OrderRefundMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *OrderRefundMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *OrderRefundMutation) ResetReason() {
	m.reason = nil
}

// SetRefundAt sets the "refund_at" field.
func (m *OrderRefundMutation) SetRefundAt(t time.Time) {
	m.refund_at = &t
}

// RefundAt returns the value of the "refund_at" field in the mutation.
func (m *OrderRefundMutation) RefundAt() (r time.Time, exists bool) {
	v := m.refund_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundAt returns the old "refund_at" field's value of the OrderRefund entity.
// If the OrderRefund object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderRefundMutation) OldRefundAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundAt: %w", err)
	}
	return oldValue.RefundAt, nil
}

// ClearRefundAt clears the value of the "refund_at" field.
func (m *OrderRefundMutation) ClearRefundAt() {
	m.refund_at = nil
	m.clearedFields[orderrefund.FieldRefundAt] = struct{}{}
}

// RefundAtCleared returns if the "refund_at" field was cleared in this mutation.
func (m *OrderRefundMutation) RefundAtCleared() bool {
	_, ok := m.clearedFields[orderrefund.FieldRefundAt]
	return ok
}

// ResetRefundAt resets all changes to the "refund_at" field.
func (m *OrderRefundMutation) ResetRefundAt() {
	m.refund_at = nil
	delete(m.clearedFields, orderrefund.FieldRefundAt)
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderRefundMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[orderrefund.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderRefundMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderRefundMutation) OrderIDs() (ids []uint64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderRefundMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderRefundMutation builder.
func (m *OrderRefundMutation) Where(ps ...predicate.OrderRefund) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderRefundMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderRefundMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderRefund, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderRefundMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderRefundMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderRefund).
func (m *OrderRefundMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderRefundMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, orderrefund.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderrefund.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, orderrefund.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, orderrefund.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, orderrefund.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, orderrefund.FieldRemark)
	}
	if m._order != nil {
		fields = append(fields, orderrefund.FieldOrderID)
	}
	if m.status != nil {
		fields = append(fields, orderrefund.FieldStatus)
	}
	if m.amount != nil {
		fields = append(fields, orderrefund.FieldAmount)
	}
	if m.out_refund_no != nil {
		fields = append(fields, orderrefund.FieldOutRefundNo)
	}
	if m.reason != nil {
		fields = append(fields, orderrefund.FieldReason)
	}
	if m.refund_at != nil {
		fields = append(fields, orderrefund.FieldRefundAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderRefundMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderrefund.FieldCreatedAt:
		return m.CreatedAt()
	case orderrefund.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderrefund.FieldDeletedAt:
		return m.DeletedAt()
	case orderrefund.FieldCreator:
		return m.Creator()
	case orderrefund.FieldLastModifier:
		return m.LastModifier()
	case orderrefund.FieldRemark:
		return m.Remark()
	case orderrefund.FieldOrderID:
		return m.OrderID()
	case orderrefund.FieldStatus:
		return m.Status()
	case orderrefund.FieldAmount:
		return m.Amount()
	case orderrefund.FieldOutRefundNo:
		return m.OutRefundNo()
	case orderrefund.FieldReason:
		return m.Reason()
	case orderrefund.FieldRefundAt:
		return m.RefundAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderRefundMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderrefund.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderrefund.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderrefund.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case orderrefund.FieldCreator:
		return m.OldCreator(ctx)
	case orderrefund.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case orderrefund.FieldRemark:
		return m.OldRemark(ctx)
	case orderrefund.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderrefund.FieldStatus:
		return m.OldStatus(ctx)
	case orderrefund.FieldAmount:
		return m.OldAmount(ctx)
	case orderrefund.FieldOutRefundNo:
		return m.OldOutRefundNo(ctx)
	case orderrefund.FieldReason:
		return m.OldReason(ctx)
	case orderrefund.FieldRefundAt:
		return m.OldRefundAt(ctx)
	}
	return nil, fmt.Errorf("unknown OrderRefund field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderRefundMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderrefund.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderrefund.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderrefund.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case orderrefund.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case orderrefund.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case orderrefund.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case orderrefund.FieldOrderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderrefund.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case orderrefund.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case orderrefund.FieldOutRefundNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutRefundNo(v)
		return nil
	case orderrefund.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case orderrefund.FieldRefundAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundAt(v)
		return nil
	}
	return fmt.Errorf("unknown OrderRefund field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderRefundMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, orderrefund.FieldStatus)
	}
	if m.addamount != nil {
		fields = append(fields, orderrefund.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderRefundMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderrefund.FieldStatus:
		return m.AddedStatus()
	case orderrefund.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderRefundMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderrefund.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case orderrefund.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown OrderRefund numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderRefundMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderrefund.FieldDeletedAt) {
		fields = append(fields, orderrefund.FieldDeletedAt)
	}
	if m.FieldCleared(orderrefund.FieldCreator) {
		fields = append(fields, orderrefund.FieldCreator)
	}
	if m.FieldCleared(orderrefund.FieldLastModifier) {
		fields = append(fields, orderrefund.FieldLastModifier)
	}
	if m.FieldCleared(orderrefund.FieldRemark) {
		fields = append(fields, orderrefund.FieldRemark)
	}
	if m.FieldCleared(orderrefund.FieldRefundAt) {
		fields = append(fields, orderrefund.FieldRefundAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderRefundMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderRefundMutation) ClearField(name string) error {
	switch name {
	case orderrefund.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case orderrefund.FieldCreator:
		m.ClearCreator()
		return nil
	case orderrefund.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case orderrefund.FieldRemark:
		m.ClearRemark()
		return nil
	case orderrefund.FieldRefundAt:
		m.ClearRefundAt()
		return nil
	}
	return fmt.Errorf("unknown OrderRefund nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderRefundMutation) ResetField(name string) error {
	switch name {
	case orderrefund.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderrefund.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderrefund.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case orderrefund.FieldCreator:
		m.ResetCreator()
		return nil
	case orderrefund.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case orderrefund.FieldRemark:
		m.ResetRemark()
		return nil
	case orderrefund.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderrefund.FieldStatus:
		m.ResetStatus()
		return nil
	case orderrefund.FieldAmount:
		m.ResetAmount()
		return nil
	case orderrefund.FieldOutRefundNo:
		m.ResetOutRefundNo()
		return nil
	case orderrefund.FieldReason:
		m.ResetReason()
		return nil
	case orderrefund.FieldRefundAt:
		m.ResetRefundAt()
		return nil
	}
	return fmt.Errorf("unknown OrderRefund field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderRefundMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._order != nil {
		edges = append(edges, orderrefund.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderRefundMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderrefund.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderRefundMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderRefundMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderRefundMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_order {
		edges = append(edges, orderrefund.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderRefundMutation) EdgeCleared(name string) bool {
	switch name {
	case orderrefund.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderRefundMutation) ClearEdge(name string) error {
	switch name {
	case orderrefund.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderRefund unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderRefundMutation) ResetEdge(name string) error {
	switch name {
	case orderrefund.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderRefund edge %s", name)
}

// PersonMutation represents an operation that mutates the Person nodes in the graph.
type PersonMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint64
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	creator            **model.Modifier
	last_modifier      **model.Modifier
	remark             *string
	status             *uint8
	addstatus          *int8
	banned             *bool
	name               *string
	id_card_number     *string
	id_card_type       *uint8
	addid_card_type    *int8
	id_card_portrait   *string
	id_card_national   *string
	auth_face          *string
	auth_result        **model.BaiduFaceVerifyResult
	auth_at            *time.Time
	esign_account_id   *string
	baidu_verify_token *string
	baidu_log_id       *string
	face_verify_result **model.PersonFaceVerifyResult
	clearedFields      map[string]struct{}
	riders             map[uint64]struct{}
	removedriders      map[uint64]struct{}
	clearedriders      bool
	done               bool
	oldValue           func(context.Context) (*Person, error)
	predicates         []predicate.Person
}

var _ ent.Mutation = (*PersonMutation)(nil)

// personOption allows management of the mutation configuration using functional options.
type personOption func(*PersonMutation)

// newPersonMutation creates new mutation for the Person entity.
func newPersonMutation(c config, op Op, opts ...personOption) *PersonMutation {
	m := &PersonMutation{
		config:        c,
		op:            op,
		typ:           TypePerson,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonID sets the ID field of the mutation.
func withPersonID(id uint64) personOption {
	return func(m *PersonMutation) {
		var (
			err   error
			once  sync.Once
			value *Person
		)
		m.oldValue = func(ctx context.Context) (*Person, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Person.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPerson sets the old Person of the mutation.
func withPerson(node *Person) personOption {
	return func(m *PersonMutation) {
		m.oldValue = func(context.Context) (*Person, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PersonMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Person.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PersonMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PersonMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PersonMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PersonMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PersonMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PersonMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PersonMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PersonMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PersonMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[person.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PersonMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[person.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PersonMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, person.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *PersonMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *PersonMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *PersonMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[person.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *PersonMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[person.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *PersonMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, person.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *PersonMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *PersonMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *PersonMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[person.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *PersonMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[person.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *PersonMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, person.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *PersonMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PersonMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PersonMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[person.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PersonMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[person.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PersonMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, person.FieldRemark)
}

// SetStatus sets the "status" field.
func (m *PersonMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *PersonMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *PersonMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *PersonMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *PersonMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetBanned sets the "banned" field.
func (m *PersonMutation) SetBanned(b bool) {
	m.banned = &b
}

// Banned returns the value of the "banned" field in the mutation.
func (m *PersonMutation) Banned() (r bool, exists bool) {
	v := m.banned
	if v == nil {
		return
	}
	return *v, true
}

// OldBanned returns the old "banned" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldBanned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBanned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBanned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBanned: %w", err)
	}
	return oldValue.Banned, nil
}

// ResetBanned resets all changes to the "banned" field.
func (m *PersonMutation) ResetBanned() {
	m.banned = nil
}

// SetName sets the "name" field.
func (m *PersonMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PersonMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PersonMutation) ResetName() {
	m.name = nil
}

// SetIDCardNumber sets the "id_card_number" field.
func (m *PersonMutation) SetIDCardNumber(s string) {
	m.id_card_number = &s
}

// IDCardNumber returns the value of the "id_card_number" field in the mutation.
func (m *PersonMutation) IDCardNumber() (r string, exists bool) {
	v := m.id_card_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCardNumber returns the old "id_card_number" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldIDCardNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCardNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCardNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCardNumber: %w", err)
	}
	return oldValue.IDCardNumber, nil
}

// ClearIDCardNumber clears the value of the "id_card_number" field.
func (m *PersonMutation) ClearIDCardNumber() {
	m.id_card_number = nil
	m.clearedFields[person.FieldIDCardNumber] = struct{}{}
}

// IDCardNumberCleared returns if the "id_card_number" field was cleared in this mutation.
func (m *PersonMutation) IDCardNumberCleared() bool {
	_, ok := m.clearedFields[person.FieldIDCardNumber]
	return ok
}

// ResetIDCardNumber resets all changes to the "id_card_number" field.
func (m *PersonMutation) ResetIDCardNumber() {
	m.id_card_number = nil
	delete(m.clearedFields, person.FieldIDCardNumber)
}

// SetIDCardType sets the "id_card_type" field.
func (m *PersonMutation) SetIDCardType(u uint8) {
	m.id_card_type = &u
	m.addid_card_type = nil
}

// IDCardType returns the value of the "id_card_type" field in the mutation.
func (m *PersonMutation) IDCardType() (r uint8, exists bool) {
	v := m.id_card_type
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCardType returns the old "id_card_type" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldIDCardType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCardType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCardType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCardType: %w", err)
	}
	return oldValue.IDCardType, nil
}

// AddIDCardType adds u to the "id_card_type" field.
func (m *PersonMutation) AddIDCardType(u int8) {
	if m.addid_card_type != nil {
		*m.addid_card_type += u
	} else {
		m.addid_card_type = &u
	}
}

// AddedIDCardType returns the value that was added to the "id_card_type" field in this mutation.
func (m *PersonMutation) AddedIDCardType() (r int8, exists bool) {
	v := m.addid_card_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetIDCardType resets all changes to the "id_card_type" field.
func (m *PersonMutation) ResetIDCardType() {
	m.id_card_type = nil
	m.addid_card_type = nil
}

// SetIDCardPortrait sets the "id_card_portrait" field.
func (m *PersonMutation) SetIDCardPortrait(s string) {
	m.id_card_portrait = &s
}

// IDCardPortrait returns the value of the "id_card_portrait" field in the mutation.
func (m *PersonMutation) IDCardPortrait() (r string, exists bool) {
	v := m.id_card_portrait
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCardPortrait returns the old "id_card_portrait" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldIDCardPortrait(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCardPortrait is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCardPortrait requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCardPortrait: %w", err)
	}
	return oldValue.IDCardPortrait, nil
}

// ClearIDCardPortrait clears the value of the "id_card_portrait" field.
func (m *PersonMutation) ClearIDCardPortrait() {
	m.id_card_portrait = nil
	m.clearedFields[person.FieldIDCardPortrait] = struct{}{}
}

// IDCardPortraitCleared returns if the "id_card_portrait" field was cleared in this mutation.
func (m *PersonMutation) IDCardPortraitCleared() bool {
	_, ok := m.clearedFields[person.FieldIDCardPortrait]
	return ok
}

// ResetIDCardPortrait resets all changes to the "id_card_portrait" field.
func (m *PersonMutation) ResetIDCardPortrait() {
	m.id_card_portrait = nil
	delete(m.clearedFields, person.FieldIDCardPortrait)
}

// SetIDCardNational sets the "id_card_national" field.
func (m *PersonMutation) SetIDCardNational(s string) {
	m.id_card_national = &s
}

// IDCardNational returns the value of the "id_card_national" field in the mutation.
func (m *PersonMutation) IDCardNational() (r string, exists bool) {
	v := m.id_card_national
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCardNational returns the old "id_card_national" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldIDCardNational(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCardNational is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCardNational requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCardNational: %w", err)
	}
	return oldValue.IDCardNational, nil
}

// ClearIDCardNational clears the value of the "id_card_national" field.
func (m *PersonMutation) ClearIDCardNational() {
	m.id_card_national = nil
	m.clearedFields[person.FieldIDCardNational] = struct{}{}
}

// IDCardNationalCleared returns if the "id_card_national" field was cleared in this mutation.
func (m *PersonMutation) IDCardNationalCleared() bool {
	_, ok := m.clearedFields[person.FieldIDCardNational]
	return ok
}

// ResetIDCardNational resets all changes to the "id_card_national" field.
func (m *PersonMutation) ResetIDCardNational() {
	m.id_card_national = nil
	delete(m.clearedFields, person.FieldIDCardNational)
}

// SetAuthFace sets the "auth_face" field.
func (m *PersonMutation) SetAuthFace(s string) {
	m.auth_face = &s
}

// AuthFace returns the value of the "auth_face" field in the mutation.
func (m *PersonMutation) AuthFace() (r string, exists bool) {
	v := m.auth_face
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthFace returns the old "auth_face" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldAuthFace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthFace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthFace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthFace: %w", err)
	}
	return oldValue.AuthFace, nil
}

// ClearAuthFace clears the value of the "auth_face" field.
func (m *PersonMutation) ClearAuthFace() {
	m.auth_face = nil
	m.clearedFields[person.FieldAuthFace] = struct{}{}
}

// AuthFaceCleared returns if the "auth_face" field was cleared in this mutation.
func (m *PersonMutation) AuthFaceCleared() bool {
	_, ok := m.clearedFields[person.FieldAuthFace]
	return ok
}

// ResetAuthFace resets all changes to the "auth_face" field.
func (m *PersonMutation) ResetAuthFace() {
	m.auth_face = nil
	delete(m.clearedFields, person.FieldAuthFace)
}

// SetAuthResult sets the "auth_result" field.
func (m *PersonMutation) SetAuthResult(mfvr *model.BaiduFaceVerifyResult) {
	m.auth_result = &mfvr
}

// AuthResult returns the value of the "auth_result" field in the mutation.
func (m *PersonMutation) AuthResult() (r *model.BaiduFaceVerifyResult, exists bool) {
	v := m.auth_result
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthResult returns the old "auth_result" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldAuthResult(ctx context.Context) (v *model.BaiduFaceVerifyResult, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthResult: %w", err)
	}
	return oldValue.AuthResult, nil
}

// ClearAuthResult clears the value of the "auth_result" field.
func (m *PersonMutation) ClearAuthResult() {
	m.auth_result = nil
	m.clearedFields[person.FieldAuthResult] = struct{}{}
}

// AuthResultCleared returns if the "auth_result" field was cleared in this mutation.
func (m *PersonMutation) AuthResultCleared() bool {
	_, ok := m.clearedFields[person.FieldAuthResult]
	return ok
}

// ResetAuthResult resets all changes to the "auth_result" field.
func (m *PersonMutation) ResetAuthResult() {
	m.auth_result = nil
	delete(m.clearedFields, person.FieldAuthResult)
}

// SetAuthAt sets the "auth_at" field.
func (m *PersonMutation) SetAuthAt(t time.Time) {
	m.auth_at = &t
}

// AuthAt returns the value of the "auth_at" field in the mutation.
func (m *PersonMutation) AuthAt() (r time.Time, exists bool) {
	v := m.auth_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthAt returns the old "auth_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldAuthAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthAt: %w", err)
	}
	return oldValue.AuthAt, nil
}

// ClearAuthAt clears the value of the "auth_at" field.
func (m *PersonMutation) ClearAuthAt() {
	m.auth_at = nil
	m.clearedFields[person.FieldAuthAt] = struct{}{}
}

// AuthAtCleared returns if the "auth_at" field was cleared in this mutation.
func (m *PersonMutation) AuthAtCleared() bool {
	_, ok := m.clearedFields[person.FieldAuthAt]
	return ok
}

// ResetAuthAt resets all changes to the "auth_at" field.
func (m *PersonMutation) ResetAuthAt() {
	m.auth_at = nil
	delete(m.clearedFields, person.FieldAuthAt)
}

// SetEsignAccountID sets the "esign_account_id" field.
func (m *PersonMutation) SetEsignAccountID(s string) {
	m.esign_account_id = &s
}

// EsignAccountID returns the value of the "esign_account_id" field in the mutation.
func (m *PersonMutation) EsignAccountID() (r string, exists bool) {
	v := m.esign_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEsignAccountID returns the old "esign_account_id" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldEsignAccountID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEsignAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEsignAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEsignAccountID: %w", err)
	}
	return oldValue.EsignAccountID, nil
}

// ClearEsignAccountID clears the value of the "esign_account_id" field.
func (m *PersonMutation) ClearEsignAccountID() {
	m.esign_account_id = nil
	m.clearedFields[person.FieldEsignAccountID] = struct{}{}
}

// EsignAccountIDCleared returns if the "esign_account_id" field was cleared in this mutation.
func (m *PersonMutation) EsignAccountIDCleared() bool {
	_, ok := m.clearedFields[person.FieldEsignAccountID]
	return ok
}

// ResetEsignAccountID resets all changes to the "esign_account_id" field.
func (m *PersonMutation) ResetEsignAccountID() {
	m.esign_account_id = nil
	delete(m.clearedFields, person.FieldEsignAccountID)
}

// SetBaiduVerifyToken sets the "baidu_verify_token" field.
func (m *PersonMutation) SetBaiduVerifyToken(s string) {
	m.baidu_verify_token = &s
}

// BaiduVerifyToken returns the value of the "baidu_verify_token" field in the mutation.
func (m *PersonMutation) BaiduVerifyToken() (r string, exists bool) {
	v := m.baidu_verify_token
	if v == nil {
		return
	}
	return *v, true
}

// OldBaiduVerifyToken returns the old "baidu_verify_token" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldBaiduVerifyToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaiduVerifyToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaiduVerifyToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaiduVerifyToken: %w", err)
	}
	return oldValue.BaiduVerifyToken, nil
}

// ClearBaiduVerifyToken clears the value of the "baidu_verify_token" field.
func (m *PersonMutation) ClearBaiduVerifyToken() {
	m.baidu_verify_token = nil
	m.clearedFields[person.FieldBaiduVerifyToken] = struct{}{}
}

// BaiduVerifyTokenCleared returns if the "baidu_verify_token" field was cleared in this mutation.
func (m *PersonMutation) BaiduVerifyTokenCleared() bool {
	_, ok := m.clearedFields[person.FieldBaiduVerifyToken]
	return ok
}

// ResetBaiduVerifyToken resets all changes to the "baidu_verify_token" field.
func (m *PersonMutation) ResetBaiduVerifyToken() {
	m.baidu_verify_token = nil
	delete(m.clearedFields, person.FieldBaiduVerifyToken)
}

// SetBaiduLogID sets the "baidu_log_id" field.
func (m *PersonMutation) SetBaiduLogID(s string) {
	m.baidu_log_id = &s
}

// BaiduLogID returns the value of the "baidu_log_id" field in the mutation.
func (m *PersonMutation) BaiduLogID() (r string, exists bool) {
	v := m.baidu_log_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBaiduLogID returns the old "baidu_log_id" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldBaiduLogID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaiduLogID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaiduLogID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaiduLogID: %w", err)
	}
	return oldValue.BaiduLogID, nil
}

// ClearBaiduLogID clears the value of the "baidu_log_id" field.
func (m *PersonMutation) ClearBaiduLogID() {
	m.baidu_log_id = nil
	m.clearedFields[person.FieldBaiduLogID] = struct{}{}
}

// BaiduLogIDCleared returns if the "baidu_log_id" field was cleared in this mutation.
func (m *PersonMutation) BaiduLogIDCleared() bool {
	_, ok := m.clearedFields[person.FieldBaiduLogID]
	return ok
}

// ResetBaiduLogID resets all changes to the "baidu_log_id" field.
func (m *PersonMutation) ResetBaiduLogID() {
	m.baidu_log_id = nil
	delete(m.clearedFields, person.FieldBaiduLogID)
}

// SetFaceVerifyResult sets the "face_verify_result" field.
func (m *PersonMutation) SetFaceVerifyResult(mfvr *model.PersonFaceVerifyResult) {
	m.face_verify_result = &mfvr
}

// FaceVerifyResult returns the value of the "face_verify_result" field in the mutation.
func (m *PersonMutation) FaceVerifyResult() (r *model.PersonFaceVerifyResult, exists bool) {
	v := m.face_verify_result
	if v == nil {
		return
	}
	return *v, true
}

// OldFaceVerifyResult returns the old "face_verify_result" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldFaceVerifyResult(ctx context.Context) (v *model.PersonFaceVerifyResult, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFaceVerifyResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFaceVerifyResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFaceVerifyResult: %w", err)
	}
	return oldValue.FaceVerifyResult, nil
}

// ClearFaceVerifyResult clears the value of the "face_verify_result" field.
func (m *PersonMutation) ClearFaceVerifyResult() {
	m.face_verify_result = nil
	m.clearedFields[person.FieldFaceVerifyResult] = struct{}{}
}

// FaceVerifyResultCleared returns if the "face_verify_result" field was cleared in this mutation.
func (m *PersonMutation) FaceVerifyResultCleared() bool {
	_, ok := m.clearedFields[person.FieldFaceVerifyResult]
	return ok
}

// ResetFaceVerifyResult resets all changes to the "face_verify_result" field.
func (m *PersonMutation) ResetFaceVerifyResult() {
	m.face_verify_result = nil
	delete(m.clearedFields, person.FieldFaceVerifyResult)
}

// AddRiderIDs adds the "riders" edge to the Rider entity by ids.
func (m *PersonMutation) AddRiderIDs(ids ...uint64) {
	if m.riders == nil {
		m.riders = make(map[uint64]struct{})
	}
	for i := range ids {
		m.riders[ids[i]] = struct{}{}
	}
}

// ClearRiders clears the "riders" edge to the Rider entity.
func (m *PersonMutation) ClearRiders() {
	m.clearedriders = true
}

// RidersCleared reports if the "riders" edge to the Rider entity was cleared.
func (m *PersonMutation) RidersCleared() bool {
	return m.clearedriders
}

// RemoveRiderIDs removes the "riders" edge to the Rider entity by IDs.
func (m *PersonMutation) RemoveRiderIDs(ids ...uint64) {
	if m.removedriders == nil {
		m.removedriders = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.riders, ids[i])
		m.removedriders[ids[i]] = struct{}{}
	}
}

// RemovedRiders returns the removed IDs of the "riders" edge to the Rider entity.
func (m *PersonMutation) RemovedRidersIDs() (ids []uint64) {
	for id := range m.removedriders {
		ids = append(ids, id)
	}
	return
}

// RidersIDs returns the "riders" edge IDs in the mutation.
func (m *PersonMutation) RidersIDs() (ids []uint64) {
	for id := range m.riders {
		ids = append(ids, id)
	}
	return
}

// ResetRiders resets all changes to the "riders" edge.
func (m *PersonMutation) ResetRiders() {
	m.riders = nil
	m.clearedriders = false
	m.removedriders = nil
}

// Where appends a list predicates to the PersonMutation builder.
func (m *PersonMutation) Where(ps ...predicate.Person) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PersonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PersonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Person, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PersonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PersonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Person).
func (m *PersonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, person.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, person.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, person.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, person.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, person.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, person.FieldRemark)
	}
	if m.status != nil {
		fields = append(fields, person.FieldStatus)
	}
	if m.banned != nil {
		fields = append(fields, person.FieldBanned)
	}
	if m.name != nil {
		fields = append(fields, person.FieldName)
	}
	if m.id_card_number != nil {
		fields = append(fields, person.FieldIDCardNumber)
	}
	if m.id_card_type != nil {
		fields = append(fields, person.FieldIDCardType)
	}
	if m.id_card_portrait != nil {
		fields = append(fields, person.FieldIDCardPortrait)
	}
	if m.id_card_national != nil {
		fields = append(fields, person.FieldIDCardNational)
	}
	if m.auth_face != nil {
		fields = append(fields, person.FieldAuthFace)
	}
	if m.auth_result != nil {
		fields = append(fields, person.FieldAuthResult)
	}
	if m.auth_at != nil {
		fields = append(fields, person.FieldAuthAt)
	}
	if m.esign_account_id != nil {
		fields = append(fields, person.FieldEsignAccountID)
	}
	if m.baidu_verify_token != nil {
		fields = append(fields, person.FieldBaiduVerifyToken)
	}
	if m.baidu_log_id != nil {
		fields = append(fields, person.FieldBaiduLogID)
	}
	if m.face_verify_result != nil {
		fields = append(fields, person.FieldFaceVerifyResult)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case person.FieldCreatedAt:
		return m.CreatedAt()
	case person.FieldUpdatedAt:
		return m.UpdatedAt()
	case person.FieldDeletedAt:
		return m.DeletedAt()
	case person.FieldCreator:
		return m.Creator()
	case person.FieldLastModifier:
		return m.LastModifier()
	case person.FieldRemark:
		return m.Remark()
	case person.FieldStatus:
		return m.Status()
	case person.FieldBanned:
		return m.Banned()
	case person.FieldName:
		return m.Name()
	case person.FieldIDCardNumber:
		return m.IDCardNumber()
	case person.FieldIDCardType:
		return m.IDCardType()
	case person.FieldIDCardPortrait:
		return m.IDCardPortrait()
	case person.FieldIDCardNational:
		return m.IDCardNational()
	case person.FieldAuthFace:
		return m.AuthFace()
	case person.FieldAuthResult:
		return m.AuthResult()
	case person.FieldAuthAt:
		return m.AuthAt()
	case person.FieldEsignAccountID:
		return m.EsignAccountID()
	case person.FieldBaiduVerifyToken:
		return m.BaiduVerifyToken()
	case person.FieldBaiduLogID:
		return m.BaiduLogID()
	case person.FieldFaceVerifyResult:
		return m.FaceVerifyResult()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case person.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case person.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case person.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case person.FieldCreator:
		return m.OldCreator(ctx)
	case person.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case person.FieldRemark:
		return m.OldRemark(ctx)
	case person.FieldStatus:
		return m.OldStatus(ctx)
	case person.FieldBanned:
		return m.OldBanned(ctx)
	case person.FieldName:
		return m.OldName(ctx)
	case person.FieldIDCardNumber:
		return m.OldIDCardNumber(ctx)
	case person.FieldIDCardType:
		return m.OldIDCardType(ctx)
	case person.FieldIDCardPortrait:
		return m.OldIDCardPortrait(ctx)
	case person.FieldIDCardNational:
		return m.OldIDCardNational(ctx)
	case person.FieldAuthFace:
		return m.OldAuthFace(ctx)
	case person.FieldAuthResult:
		return m.OldAuthResult(ctx)
	case person.FieldAuthAt:
		return m.OldAuthAt(ctx)
	case person.FieldEsignAccountID:
		return m.OldEsignAccountID(ctx)
	case person.FieldBaiduVerifyToken:
		return m.OldBaiduVerifyToken(ctx)
	case person.FieldBaiduLogID:
		return m.OldBaiduLogID(ctx)
	case person.FieldFaceVerifyResult:
		return m.OldFaceVerifyResult(ctx)
	}
	return nil, fmt.Errorf("unknown Person field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case person.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case person.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case person.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case person.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case person.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case person.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case person.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case person.FieldBanned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBanned(v)
		return nil
	case person.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case person.FieldIDCardNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCardNumber(v)
		return nil
	case person.FieldIDCardType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCardType(v)
		return nil
	case person.FieldIDCardPortrait:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCardPortrait(v)
		return nil
	case person.FieldIDCardNational:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCardNational(v)
		return nil
	case person.FieldAuthFace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthFace(v)
		return nil
	case person.FieldAuthResult:
		v, ok := value.(*model.BaiduFaceVerifyResult)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthResult(v)
		return nil
	case person.FieldAuthAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthAt(v)
		return nil
	case person.FieldEsignAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEsignAccountID(v)
		return nil
	case person.FieldBaiduVerifyToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaiduVerifyToken(v)
		return nil
	case person.FieldBaiduLogID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaiduLogID(v)
		return nil
	case person.FieldFaceVerifyResult:
		v, ok := value.(*model.PersonFaceVerifyResult)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFaceVerifyResult(v)
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, person.FieldStatus)
	}
	if m.addid_card_type != nil {
		fields = append(fields, person.FieldIDCardType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case person.FieldStatus:
		return m.AddedStatus()
	case person.FieldIDCardType:
		return m.AddedIDCardType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case person.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case person.FieldIDCardType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIDCardType(v)
		return nil
	}
	return fmt.Errorf("unknown Person numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(person.FieldDeletedAt) {
		fields = append(fields, person.FieldDeletedAt)
	}
	if m.FieldCleared(person.FieldCreator) {
		fields = append(fields, person.FieldCreator)
	}
	if m.FieldCleared(person.FieldLastModifier) {
		fields = append(fields, person.FieldLastModifier)
	}
	if m.FieldCleared(person.FieldRemark) {
		fields = append(fields, person.FieldRemark)
	}
	if m.FieldCleared(person.FieldIDCardNumber) {
		fields = append(fields, person.FieldIDCardNumber)
	}
	if m.FieldCleared(person.FieldIDCardPortrait) {
		fields = append(fields, person.FieldIDCardPortrait)
	}
	if m.FieldCleared(person.FieldIDCardNational) {
		fields = append(fields, person.FieldIDCardNational)
	}
	if m.FieldCleared(person.FieldAuthFace) {
		fields = append(fields, person.FieldAuthFace)
	}
	if m.FieldCleared(person.FieldAuthResult) {
		fields = append(fields, person.FieldAuthResult)
	}
	if m.FieldCleared(person.FieldAuthAt) {
		fields = append(fields, person.FieldAuthAt)
	}
	if m.FieldCleared(person.FieldEsignAccountID) {
		fields = append(fields, person.FieldEsignAccountID)
	}
	if m.FieldCleared(person.FieldBaiduVerifyToken) {
		fields = append(fields, person.FieldBaiduVerifyToken)
	}
	if m.FieldCleared(person.FieldBaiduLogID) {
		fields = append(fields, person.FieldBaiduLogID)
	}
	if m.FieldCleared(person.FieldFaceVerifyResult) {
		fields = append(fields, person.FieldFaceVerifyResult)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonMutation) ClearField(name string) error {
	switch name {
	case person.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case person.FieldCreator:
		m.ClearCreator()
		return nil
	case person.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case person.FieldRemark:
		m.ClearRemark()
		return nil
	case person.FieldIDCardNumber:
		m.ClearIDCardNumber()
		return nil
	case person.FieldIDCardPortrait:
		m.ClearIDCardPortrait()
		return nil
	case person.FieldIDCardNational:
		m.ClearIDCardNational()
		return nil
	case person.FieldAuthFace:
		m.ClearAuthFace()
		return nil
	case person.FieldAuthResult:
		m.ClearAuthResult()
		return nil
	case person.FieldAuthAt:
		m.ClearAuthAt()
		return nil
	case person.FieldEsignAccountID:
		m.ClearEsignAccountID()
		return nil
	case person.FieldBaiduVerifyToken:
		m.ClearBaiduVerifyToken()
		return nil
	case person.FieldBaiduLogID:
		m.ClearBaiduLogID()
		return nil
	case person.FieldFaceVerifyResult:
		m.ClearFaceVerifyResult()
		return nil
	}
	return fmt.Errorf("unknown Person nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonMutation) ResetField(name string) error {
	switch name {
	case person.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case person.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case person.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case person.FieldCreator:
		m.ResetCreator()
		return nil
	case person.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case person.FieldRemark:
		m.ResetRemark()
		return nil
	case person.FieldStatus:
		m.ResetStatus()
		return nil
	case person.FieldBanned:
		m.ResetBanned()
		return nil
	case person.FieldName:
		m.ResetName()
		return nil
	case person.FieldIDCardNumber:
		m.ResetIDCardNumber()
		return nil
	case person.FieldIDCardType:
		m.ResetIDCardType()
		return nil
	case person.FieldIDCardPortrait:
		m.ResetIDCardPortrait()
		return nil
	case person.FieldIDCardNational:
		m.ResetIDCardNational()
		return nil
	case person.FieldAuthFace:
		m.ResetAuthFace()
		return nil
	case person.FieldAuthResult:
		m.ResetAuthResult()
		return nil
	case person.FieldAuthAt:
		m.ResetAuthAt()
		return nil
	case person.FieldEsignAccountID:
		m.ResetEsignAccountID()
		return nil
	case person.FieldBaiduVerifyToken:
		m.ResetBaiduVerifyToken()
		return nil
	case person.FieldBaiduLogID:
		m.ResetBaiduLogID()
		return nil
	case person.FieldFaceVerifyResult:
		m.ResetFaceVerifyResult()
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.riders != nil {
		edges = append(edges, person.EdgeRiders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeRiders:
		ids := make([]ent.Value, 0, len(m.riders))
		for id := range m.riders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedriders != nil {
		edges = append(edges, person.EdgeRiders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeRiders:
		ids := make([]ent.Value, 0, len(m.removedriders))
		for id := range m.removedriders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedriders {
		edges = append(edges, person.EdgeRiders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonMutation) EdgeCleared(name string) bool {
	switch name {
	case person.EdgeRiders:
		return m.clearedriders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Person unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonMutation) ResetEdge(name string) error {
	switch name {
	case person.EdgeRiders:
		m.ResetRiders()
		return nil
	}
	return fmt.Errorf("unknown Person edge %s", name)
}

// PlanMutation represents an operation that mutates the Plan nodes in the graph.
type PlanMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint64
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	creator              **model.Modifier
	last_modifier        **model.Modifier
	remark               *string
	model                *string
	enable               *bool
	_type                *uint8
	add_type             *int8
	name                 *string
	start                *time.Time
	end                  *time.Time
	price                *float64
	addprice             *float64
	days                 *uint
	adddays              *int
	commission           *float64
	addcommission        *float64
	original             *float64
	addoriginal          *float64
	desc                 *string
	discount_newly       *float64
	adddiscount_newly    *float64
	notes                *[]string
	appendnotes          []string
	intelligent          *bool
	deposit              *bool
	deposit_amount       *float64
	adddeposit_amount    *float64
	deposit_payway       *[]uint8
	appenddeposit_payway []uint8
	clearedFields        map[string]struct{}
	brand                *uint64
	clearedbrand         bool
	cities               map[uint64]struct{}
	removedcities        map[uint64]struct{}
	clearedcities        bool
	parent               *uint64
	clearedparent        bool
	complexes            map[uint64]struct{}
	removedcomplexes     map[uint64]struct{}
	clearedcomplexes     bool
	commissions          map[uint64]struct{}
	removedcommissions   map[uint64]struct{}
	clearedcommissions   bool
	done                 bool
	oldValue             func(context.Context) (*Plan, error)
	predicates           []predicate.Plan
}

var _ ent.Mutation = (*PlanMutation)(nil)

// planOption allows management of the mutation configuration using functional options.
type planOption func(*PlanMutation)

// newPlanMutation creates new mutation for the Plan entity.
func newPlanMutation(c config, op Op, opts ...planOption) *PlanMutation {
	m := &PlanMutation{
		config:        c,
		op:            op,
		typ:           TypePlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanID sets the ID field of the mutation.
func withPlanID(id uint64) planOption {
	return func(m *PlanMutation) {
		var (
			err   error
			once  sync.Once
			value *Plan
		)
		m.oldValue = func(ctx context.Context) (*Plan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Plan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlan sets the old Plan of the mutation.
func withPlan(node *Plan) planOption {
	return func(m *PlanMutation) {
		m.oldValue = func(context.Context) (*Plan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Plan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PlanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlanMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlanMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlanMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlanMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PlanMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PlanMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PlanMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[plan.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PlanMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[plan.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PlanMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, plan.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *PlanMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *PlanMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *PlanMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[plan.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *PlanMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[plan.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *PlanMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, plan.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *PlanMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *PlanMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *PlanMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[plan.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *PlanMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[plan.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *PlanMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, plan.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *PlanMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PlanMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PlanMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[plan.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PlanMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[plan.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PlanMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, plan.FieldRemark)
}

// SetBrandID sets the "brand_id" field.
func (m *PlanMutation) SetBrandID(u uint64) {
	m.brand = &u
}

// BrandID returns the value of the "brand_id" field in the mutation.
func (m *PlanMutation) BrandID() (r uint64, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrandID returns the old "brand_id" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldBrandID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrandID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrandID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrandID: %w", err)
	}
	return oldValue.BrandID, nil
}

// ClearBrandID clears the value of the "brand_id" field.
func (m *PlanMutation) ClearBrandID() {
	m.brand = nil
	m.clearedFields[plan.FieldBrandID] = struct{}{}
}

// BrandIDCleared returns if the "brand_id" field was cleared in this mutation.
func (m *PlanMutation) BrandIDCleared() bool {
	_, ok := m.clearedFields[plan.FieldBrandID]
	return ok
}

// ResetBrandID resets all changes to the "brand_id" field.
func (m *PlanMutation) ResetBrandID() {
	m.brand = nil
	delete(m.clearedFields, plan.FieldBrandID)
}

// SetModel sets the "model" field.
func (m *PlanMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *PlanMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *PlanMutation) ClearModel() {
	m.model = nil
	m.clearedFields[plan.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *PlanMutation) ModelCleared() bool {
	_, ok := m.clearedFields[plan.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *PlanMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, plan.FieldModel)
}

// SetEnable sets the "enable" field.
func (m *PlanMutation) SetEnable(b bool) {
	m.enable = &b
}

// Enable returns the value of the "enable" field in the mutation.
func (m *PlanMutation) Enable() (r bool, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// ResetEnable resets all changes to the "enable" field.
func (m *PlanMutation) ResetEnable() {
	m.enable = nil
}

// SetType sets the "type" field.
func (m *PlanMutation) SetType(u uint8) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *PlanMutation) GetType() (r uint8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *PlanMutation) AddType(u int8) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *PlanMutation) AddedType() (r int8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *PlanMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetName sets the "name" field.
func (m *PlanMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlanMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlanMutation) ResetName() {
	m.name = nil
}

// SetStart sets the "start" field.
func (m *PlanMutation) SetStart(t time.Time) {
	m.start = &t
}

// Start returns the value of the "start" field in the mutation.
func (m *PlanMutation) Start() (r time.Time, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// ResetStart resets all changes to the "start" field.
func (m *PlanMutation) ResetStart() {
	m.start = nil
}

// SetEnd sets the "end" field.
func (m *PlanMutation) SetEnd(t time.Time) {
	m.end = &t
}

// End returns the value of the "end" field in the mutation.
func (m *PlanMutation) End() (r time.Time, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// ResetEnd resets all changes to the "end" field.
func (m *PlanMutation) ResetEnd() {
	m.end = nil
}

// SetPrice sets the "price" field.
func (m *PlanMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *PlanMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *PlanMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *PlanMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *PlanMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetDays sets the "days" field.
func (m *PlanMutation) SetDays(u uint) {
	m.days = &u
	m.adddays = nil
}

// Days returns the value of the "days" field in the mutation.
func (m *PlanMutation) Days() (r uint, exists bool) {
	v := m.days
	if v == nil {
		return
	}
	return *v, true
}

// OldDays returns the old "days" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldDays(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDays: %w", err)
	}
	return oldValue.Days, nil
}

// AddDays adds u to the "days" field.
func (m *PlanMutation) AddDays(u int) {
	if m.adddays != nil {
		*m.adddays += u
	} else {
		m.adddays = &u
	}
}

// AddedDays returns the value that was added to the "days" field in this mutation.
func (m *PlanMutation) AddedDays() (r int, exists bool) {
	v := m.adddays
	if v == nil {
		return
	}
	return *v, true
}

// ResetDays resets all changes to the "days" field.
func (m *PlanMutation) ResetDays() {
	m.days = nil
	m.adddays = nil
}

// SetCommission sets the "commission" field.
func (m *PlanMutation) SetCommission(f float64) {
	m.commission = &f
	m.addcommission = nil
}

// Commission returns the value of the "commission" field in the mutation.
func (m *PlanMutation) Commission() (r float64, exists bool) {
	v := m.commission
	if v == nil {
		return
	}
	return *v, true
}

// OldCommission returns the old "commission" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldCommission(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommission: %w", err)
	}
	return oldValue.Commission, nil
}

// AddCommission adds f to the "commission" field.
func (m *PlanMutation) AddCommission(f float64) {
	if m.addcommission != nil {
		*m.addcommission += f
	} else {
		m.addcommission = &f
	}
}

// AddedCommission returns the value that was added to the "commission" field in this mutation.
func (m *PlanMutation) AddedCommission() (r float64, exists bool) {
	v := m.addcommission
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommission resets all changes to the "commission" field.
func (m *PlanMutation) ResetCommission() {
	m.commission = nil
	m.addcommission = nil
}

// SetOriginal sets the "original" field.
func (m *PlanMutation) SetOriginal(f float64) {
	m.original = &f
	m.addoriginal = nil
}

// Original returns the value of the "original" field in the mutation.
func (m *PlanMutation) Original() (r float64, exists bool) {
	v := m.original
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginal returns the old "original" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldOriginal(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginal: %w", err)
	}
	return oldValue.Original, nil
}

// AddOriginal adds f to the "original" field.
func (m *PlanMutation) AddOriginal(f float64) {
	if m.addoriginal != nil {
		*m.addoriginal += f
	} else {
		m.addoriginal = &f
	}
}

// AddedOriginal returns the value that was added to the "original" field in this mutation.
func (m *PlanMutation) AddedOriginal() (r float64, exists bool) {
	v := m.addoriginal
	if v == nil {
		return
	}
	return *v, true
}

// ClearOriginal clears the value of the "original" field.
func (m *PlanMutation) ClearOriginal() {
	m.original = nil
	m.addoriginal = nil
	m.clearedFields[plan.FieldOriginal] = struct{}{}
}

// OriginalCleared returns if the "original" field was cleared in this mutation.
func (m *PlanMutation) OriginalCleared() bool {
	_, ok := m.clearedFields[plan.FieldOriginal]
	return ok
}

// ResetOriginal resets all changes to the "original" field.
func (m *PlanMutation) ResetOriginal() {
	m.original = nil
	m.addoriginal = nil
	delete(m.clearedFields, plan.FieldOriginal)
}

// SetDesc sets the "desc" field.
func (m *PlanMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *PlanMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ClearDesc clears the value of the "desc" field.
func (m *PlanMutation) ClearDesc() {
	m.desc = nil
	m.clearedFields[plan.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *PlanMutation) DescCleared() bool {
	_, ok := m.clearedFields[plan.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *PlanMutation) ResetDesc() {
	m.desc = nil
	delete(m.clearedFields, plan.FieldDesc)
}

// SetParentID sets the "parent_id" field.
func (m *PlanMutation) SetParentID(u uint64) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *PlanMutation) ParentID() (r uint64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldParentID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *PlanMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[plan.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *PlanMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[plan.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *PlanMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, plan.FieldParentID)
}

// SetDiscountNewly sets the "discount_newly" field.
func (m *PlanMutation) SetDiscountNewly(f float64) {
	m.discount_newly = &f
	m.adddiscount_newly = nil
}

// DiscountNewly returns the value of the "discount_newly" field in the mutation.
func (m *PlanMutation) DiscountNewly() (r float64, exists bool) {
	v := m.discount_newly
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountNewly returns the old "discount_newly" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldDiscountNewly(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscountNewly is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscountNewly requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountNewly: %w", err)
	}
	return oldValue.DiscountNewly, nil
}

// AddDiscountNewly adds f to the "discount_newly" field.
func (m *PlanMutation) AddDiscountNewly(f float64) {
	if m.adddiscount_newly != nil {
		*m.adddiscount_newly += f
	} else {
		m.adddiscount_newly = &f
	}
}

// AddedDiscountNewly returns the value that was added to the "discount_newly" field in this mutation.
func (m *PlanMutation) AddedDiscountNewly() (r float64, exists bool) {
	v := m.adddiscount_newly
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiscountNewly resets all changes to the "discount_newly" field.
func (m *PlanMutation) ResetDiscountNewly() {
	m.discount_newly = nil
	m.adddiscount_newly = nil
}

// SetNotes sets the "notes" field.
func (m *PlanMutation) SetNotes(s []string) {
	m.notes = &s
	m.appendnotes = nil
}

// Notes returns the value of the "notes" field in the mutation.
func (m *PlanMutation) Notes() (r []string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldNotes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// AppendNotes adds s to the "notes" field.
func (m *PlanMutation) AppendNotes(s []string) {
	m.appendnotes = append(m.appendnotes, s...)
}

// AppendedNotes returns the list of values that were appended to the "notes" field in this mutation.
func (m *PlanMutation) AppendedNotes() ([]string, bool) {
	if len(m.appendnotes) == 0 {
		return nil, false
	}
	return m.appendnotes, true
}

// ClearNotes clears the value of the "notes" field.
func (m *PlanMutation) ClearNotes() {
	m.notes = nil
	m.appendnotes = nil
	m.clearedFields[plan.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *PlanMutation) NotesCleared() bool {
	_, ok := m.clearedFields[plan.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *PlanMutation) ResetNotes() {
	m.notes = nil
	m.appendnotes = nil
	delete(m.clearedFields, plan.FieldNotes)
}

// SetIntelligent sets the "intelligent" field.
func (m *PlanMutation) SetIntelligent(b bool) {
	m.intelligent = &b
}

// Intelligent returns the value of the "intelligent" field in the mutation.
func (m *PlanMutation) Intelligent() (r bool, exists bool) {
	v := m.intelligent
	if v == nil {
		return
	}
	return *v, true
}

// OldIntelligent returns the old "intelligent" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldIntelligent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntelligent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntelligent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntelligent: %w", err)
	}
	return oldValue.Intelligent, nil
}

// ResetIntelligent resets all changes to the "intelligent" field.
func (m *PlanMutation) ResetIntelligent() {
	m.intelligent = nil
}

// SetDeposit sets the "deposit" field.
func (m *PlanMutation) SetDeposit(b bool) {
	m.deposit = &b
}

// Deposit returns the value of the "deposit" field in the mutation.
func (m *PlanMutation) Deposit() (r bool, exists bool) {
	v := m.deposit
	if v == nil {
		return
	}
	return *v, true
}

// OldDeposit returns the old "deposit" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldDeposit(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeposit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeposit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeposit: %w", err)
	}
	return oldValue.Deposit, nil
}

// ResetDeposit resets all changes to the "deposit" field.
func (m *PlanMutation) ResetDeposit() {
	m.deposit = nil
}

// SetDepositAmount sets the "deposit_amount" field.
func (m *PlanMutation) SetDepositAmount(f float64) {
	m.deposit_amount = &f
	m.adddeposit_amount = nil
}

// DepositAmount returns the value of the "deposit_amount" field in the mutation.
func (m *PlanMutation) DepositAmount() (r float64, exists bool) {
	v := m.deposit_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldDepositAmount returns the old "deposit_amount" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldDepositAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepositAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepositAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepositAmount: %w", err)
	}
	return oldValue.DepositAmount, nil
}

// AddDepositAmount adds f to the "deposit_amount" field.
func (m *PlanMutation) AddDepositAmount(f float64) {
	if m.adddeposit_amount != nil {
		*m.adddeposit_amount += f
	} else {
		m.adddeposit_amount = &f
	}
}

// AddedDepositAmount returns the value that was added to the "deposit_amount" field in this mutation.
func (m *PlanMutation) AddedDepositAmount() (r float64, exists bool) {
	v := m.adddeposit_amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearDepositAmount clears the value of the "deposit_amount" field.
func (m *PlanMutation) ClearDepositAmount() {
	m.deposit_amount = nil
	m.adddeposit_amount = nil
	m.clearedFields[plan.FieldDepositAmount] = struct{}{}
}

// DepositAmountCleared returns if the "deposit_amount" field was cleared in this mutation.
func (m *PlanMutation) DepositAmountCleared() bool {
	_, ok := m.clearedFields[plan.FieldDepositAmount]
	return ok
}

// ResetDepositAmount resets all changes to the "deposit_amount" field.
func (m *PlanMutation) ResetDepositAmount() {
	m.deposit_amount = nil
	m.adddeposit_amount = nil
	delete(m.clearedFields, plan.FieldDepositAmount)
}

// SetDepositPayway sets the "deposit_payway" field.
func (m *PlanMutation) SetDepositPayway(u []uint8) {
	m.deposit_payway = &u
	m.appenddeposit_payway = nil
}

// DepositPayway returns the value of the "deposit_payway" field in the mutation.
func (m *PlanMutation) DepositPayway() (r []uint8, exists bool) {
	v := m.deposit_payway
	if v == nil {
		return
	}
	return *v, true
}

// OldDepositPayway returns the old "deposit_payway" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldDepositPayway(ctx context.Context) (v []uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepositPayway is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepositPayway requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepositPayway: %w", err)
	}
	return oldValue.DepositPayway, nil
}

// AppendDepositPayway adds u to the "deposit_payway" field.
func (m *PlanMutation) AppendDepositPayway(u []uint8) {
	m.appenddeposit_payway = append(m.appenddeposit_payway, u...)
}

// AppendedDepositPayway returns the list of values that were appended to the "deposit_payway" field in this mutation.
func (m *PlanMutation) AppendedDepositPayway() ([]uint8, bool) {
	if len(m.appenddeposit_payway) == 0 {
		return nil, false
	}
	return m.appenddeposit_payway, true
}

// ClearDepositPayway clears the value of the "deposit_payway" field.
func (m *PlanMutation) ClearDepositPayway() {
	m.deposit_payway = nil
	m.appenddeposit_payway = nil
	m.clearedFields[plan.FieldDepositPayway] = struct{}{}
}

// DepositPaywayCleared returns if the "deposit_payway" field was cleared in this mutation.
func (m *PlanMutation) DepositPaywayCleared() bool {
	_, ok := m.clearedFields[plan.FieldDepositPayway]
	return ok
}

// ResetDepositPayway resets all changes to the "deposit_payway" field.
func (m *PlanMutation) ResetDepositPayway() {
	m.deposit_payway = nil
	m.appenddeposit_payway = nil
	delete(m.clearedFields, plan.FieldDepositPayway)
}

// ClearBrand clears the "brand" edge to the EbikeBrand entity.
func (m *PlanMutation) ClearBrand() {
	m.clearedbrand = true
	m.clearedFields[plan.FieldBrandID] = struct{}{}
}

// BrandCleared reports if the "brand" edge to the EbikeBrand entity was cleared.
func (m *PlanMutation) BrandCleared() bool {
	return m.BrandIDCleared() || m.clearedbrand
}

// BrandIDs returns the "brand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BrandID instead. It exists only for internal usage by the builders.
func (m *PlanMutation) BrandIDs() (ids []uint64) {
	if id := m.brand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBrand resets all changes to the "brand" edge.
func (m *PlanMutation) ResetBrand() {
	m.brand = nil
	m.clearedbrand = false
}

// AddCityIDs adds the "cities" edge to the City entity by ids.
func (m *PlanMutation) AddCityIDs(ids ...uint64) {
	if m.cities == nil {
		m.cities = make(map[uint64]struct{})
	}
	for i := range ids {
		m.cities[ids[i]] = struct{}{}
	}
}

// ClearCities clears the "cities" edge to the City entity.
func (m *PlanMutation) ClearCities() {
	m.clearedcities = true
}

// CitiesCleared reports if the "cities" edge to the City entity was cleared.
func (m *PlanMutation) CitiesCleared() bool {
	return m.clearedcities
}

// RemoveCityIDs removes the "cities" edge to the City entity by IDs.
func (m *PlanMutation) RemoveCityIDs(ids ...uint64) {
	if m.removedcities == nil {
		m.removedcities = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.cities, ids[i])
		m.removedcities[ids[i]] = struct{}{}
	}
}

// RemovedCities returns the removed IDs of the "cities" edge to the City entity.
func (m *PlanMutation) RemovedCitiesIDs() (ids []uint64) {
	for id := range m.removedcities {
		ids = append(ids, id)
	}
	return
}

// CitiesIDs returns the "cities" edge IDs in the mutation.
func (m *PlanMutation) CitiesIDs() (ids []uint64) {
	for id := range m.cities {
		ids = append(ids, id)
	}
	return
}

// ResetCities resets all changes to the "cities" edge.
func (m *PlanMutation) ResetCities() {
	m.cities = nil
	m.clearedcities = false
	m.removedcities = nil
}

// ClearParent clears the "parent" edge to the Plan entity.
func (m *PlanMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[plan.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Plan entity was cleared.
func (m *PlanMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *PlanMutation) ParentIDs() (ids []uint64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *PlanMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddComplexIDs adds the "complexes" edge to the Plan entity by ids.
func (m *PlanMutation) AddComplexIDs(ids ...uint64) {
	if m.complexes == nil {
		m.complexes = make(map[uint64]struct{})
	}
	for i := range ids {
		m.complexes[ids[i]] = struct{}{}
	}
}

// ClearComplexes clears the "complexes" edge to the Plan entity.
func (m *PlanMutation) ClearComplexes() {
	m.clearedcomplexes = true
}

// ComplexesCleared reports if the "complexes" edge to the Plan entity was cleared.
func (m *PlanMutation) ComplexesCleared() bool {
	return m.clearedcomplexes
}

// RemoveComplexIDs removes the "complexes" edge to the Plan entity by IDs.
func (m *PlanMutation) RemoveComplexIDs(ids ...uint64) {
	if m.removedcomplexes == nil {
		m.removedcomplexes = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.complexes, ids[i])
		m.removedcomplexes[ids[i]] = struct{}{}
	}
}

// RemovedComplexes returns the removed IDs of the "complexes" edge to the Plan entity.
func (m *PlanMutation) RemovedComplexesIDs() (ids []uint64) {
	for id := range m.removedcomplexes {
		ids = append(ids, id)
	}
	return
}

// ComplexesIDs returns the "complexes" edge IDs in the mutation.
func (m *PlanMutation) ComplexesIDs() (ids []uint64) {
	for id := range m.complexes {
		ids = append(ids, id)
	}
	return
}

// ResetComplexes resets all changes to the "complexes" edge.
func (m *PlanMutation) ResetComplexes() {
	m.complexes = nil
	m.clearedcomplexes = false
	m.removedcomplexes = nil
}

// AddCommissionIDs adds the "commissions" edge to the PromotionCommissionPlan entity by ids.
func (m *PlanMutation) AddCommissionIDs(ids ...uint64) {
	if m.commissions == nil {
		m.commissions = make(map[uint64]struct{})
	}
	for i := range ids {
		m.commissions[ids[i]] = struct{}{}
	}
}

// ClearCommissions clears the "commissions" edge to the PromotionCommissionPlan entity.
func (m *PlanMutation) ClearCommissions() {
	m.clearedcommissions = true
}

// CommissionsCleared reports if the "commissions" edge to the PromotionCommissionPlan entity was cleared.
func (m *PlanMutation) CommissionsCleared() bool {
	return m.clearedcommissions
}

// RemoveCommissionIDs removes the "commissions" edge to the PromotionCommissionPlan entity by IDs.
func (m *PlanMutation) RemoveCommissionIDs(ids ...uint64) {
	if m.removedcommissions == nil {
		m.removedcommissions = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.commissions, ids[i])
		m.removedcommissions[ids[i]] = struct{}{}
	}
}

// RemovedCommissions returns the removed IDs of the "commissions" edge to the PromotionCommissionPlan entity.
func (m *PlanMutation) RemovedCommissionsIDs() (ids []uint64) {
	for id := range m.removedcommissions {
		ids = append(ids, id)
	}
	return
}

// CommissionsIDs returns the "commissions" edge IDs in the mutation.
func (m *PlanMutation) CommissionsIDs() (ids []uint64) {
	for id := range m.commissions {
		ids = append(ids, id)
	}
	return
}

// ResetCommissions resets all changes to the "commissions" edge.
func (m *PlanMutation) ResetCommissions() {
	m.commissions = nil
	m.clearedcommissions = false
	m.removedcommissions = nil
}

// Where appends a list predicates to the PlanMutation builder.
func (m *PlanMutation) Where(ps ...predicate.Plan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Plan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Plan).
func (m *PlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanMutation) Fields() []string {
	fields := make([]string, 0, 25)
	if m.created_at != nil {
		fields = append(fields, plan.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, plan.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, plan.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, plan.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, plan.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, plan.FieldRemark)
	}
	if m.brand != nil {
		fields = append(fields, plan.FieldBrandID)
	}
	if m.model != nil {
		fields = append(fields, plan.FieldModel)
	}
	if m.enable != nil {
		fields = append(fields, plan.FieldEnable)
	}
	if m._type != nil {
		fields = append(fields, plan.FieldType)
	}
	if m.name != nil {
		fields = append(fields, plan.FieldName)
	}
	if m.start != nil {
		fields = append(fields, plan.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, plan.FieldEnd)
	}
	if m.price != nil {
		fields = append(fields, plan.FieldPrice)
	}
	if m.days != nil {
		fields = append(fields, plan.FieldDays)
	}
	if m.commission != nil {
		fields = append(fields, plan.FieldCommission)
	}
	if m.original != nil {
		fields = append(fields, plan.FieldOriginal)
	}
	if m.desc != nil {
		fields = append(fields, plan.FieldDesc)
	}
	if m.parent != nil {
		fields = append(fields, plan.FieldParentID)
	}
	if m.discount_newly != nil {
		fields = append(fields, plan.FieldDiscountNewly)
	}
	if m.notes != nil {
		fields = append(fields, plan.FieldNotes)
	}
	if m.intelligent != nil {
		fields = append(fields, plan.FieldIntelligent)
	}
	if m.deposit != nil {
		fields = append(fields, plan.FieldDeposit)
	}
	if m.deposit_amount != nil {
		fields = append(fields, plan.FieldDepositAmount)
	}
	if m.deposit_payway != nil {
		fields = append(fields, plan.FieldDepositPayway)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plan.FieldCreatedAt:
		return m.CreatedAt()
	case plan.FieldUpdatedAt:
		return m.UpdatedAt()
	case plan.FieldDeletedAt:
		return m.DeletedAt()
	case plan.FieldCreator:
		return m.Creator()
	case plan.FieldLastModifier:
		return m.LastModifier()
	case plan.FieldRemark:
		return m.Remark()
	case plan.FieldBrandID:
		return m.BrandID()
	case plan.FieldModel:
		return m.Model()
	case plan.FieldEnable:
		return m.Enable()
	case plan.FieldType:
		return m.GetType()
	case plan.FieldName:
		return m.Name()
	case plan.FieldStart:
		return m.Start()
	case plan.FieldEnd:
		return m.End()
	case plan.FieldPrice:
		return m.Price()
	case plan.FieldDays:
		return m.Days()
	case plan.FieldCommission:
		return m.Commission()
	case plan.FieldOriginal:
		return m.Original()
	case plan.FieldDesc:
		return m.Desc()
	case plan.FieldParentID:
		return m.ParentID()
	case plan.FieldDiscountNewly:
		return m.DiscountNewly()
	case plan.FieldNotes:
		return m.Notes()
	case plan.FieldIntelligent:
		return m.Intelligent()
	case plan.FieldDeposit:
		return m.Deposit()
	case plan.FieldDepositAmount:
		return m.DepositAmount()
	case plan.FieldDepositPayway:
		return m.DepositPayway()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case plan.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case plan.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case plan.FieldCreator:
		return m.OldCreator(ctx)
	case plan.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case plan.FieldRemark:
		return m.OldRemark(ctx)
	case plan.FieldBrandID:
		return m.OldBrandID(ctx)
	case plan.FieldModel:
		return m.OldModel(ctx)
	case plan.FieldEnable:
		return m.OldEnable(ctx)
	case plan.FieldType:
		return m.OldType(ctx)
	case plan.FieldName:
		return m.OldName(ctx)
	case plan.FieldStart:
		return m.OldStart(ctx)
	case plan.FieldEnd:
		return m.OldEnd(ctx)
	case plan.FieldPrice:
		return m.OldPrice(ctx)
	case plan.FieldDays:
		return m.OldDays(ctx)
	case plan.FieldCommission:
		return m.OldCommission(ctx)
	case plan.FieldOriginal:
		return m.OldOriginal(ctx)
	case plan.FieldDesc:
		return m.OldDesc(ctx)
	case plan.FieldParentID:
		return m.OldParentID(ctx)
	case plan.FieldDiscountNewly:
		return m.OldDiscountNewly(ctx)
	case plan.FieldNotes:
		return m.OldNotes(ctx)
	case plan.FieldIntelligent:
		return m.OldIntelligent(ctx)
	case plan.FieldDeposit:
		return m.OldDeposit(ctx)
	case plan.FieldDepositAmount:
		return m.OldDepositAmount(ctx)
	case plan.FieldDepositPayway:
		return m.OldDepositPayway(ctx)
	}
	return nil, fmt.Errorf("unknown Plan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plan.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case plan.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case plan.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case plan.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case plan.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case plan.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case plan.FieldBrandID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrandID(v)
		return nil
	case plan.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case plan.FieldEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case plan.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case plan.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case plan.FieldStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case plan.FieldEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case plan.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case plan.FieldDays:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDays(v)
		return nil
	case plan.FieldCommission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommission(v)
		return nil
	case plan.FieldOriginal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginal(v)
		return nil
	case plan.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case plan.FieldParentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case plan.FieldDiscountNewly:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountNewly(v)
		return nil
	case plan.FieldNotes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case plan.FieldIntelligent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntelligent(v)
		return nil
	case plan.FieldDeposit:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeposit(v)
		return nil
	case plan.FieldDepositAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepositAmount(v)
		return nil
	case plan.FieldDepositPayway:
		v, ok := value.([]uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepositPayway(v)
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, plan.FieldType)
	}
	if m.addprice != nil {
		fields = append(fields, plan.FieldPrice)
	}
	if m.adddays != nil {
		fields = append(fields, plan.FieldDays)
	}
	if m.addcommission != nil {
		fields = append(fields, plan.FieldCommission)
	}
	if m.addoriginal != nil {
		fields = append(fields, plan.FieldOriginal)
	}
	if m.adddiscount_newly != nil {
		fields = append(fields, plan.FieldDiscountNewly)
	}
	if m.adddeposit_amount != nil {
		fields = append(fields, plan.FieldDepositAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case plan.FieldType:
		return m.AddedType()
	case plan.FieldPrice:
		return m.AddedPrice()
	case plan.FieldDays:
		return m.AddedDays()
	case plan.FieldCommission:
		return m.AddedCommission()
	case plan.FieldOriginal:
		return m.AddedOriginal()
	case plan.FieldDiscountNewly:
		return m.AddedDiscountNewly()
	case plan.FieldDepositAmount:
		return m.AddedDepositAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case plan.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case plan.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case plan.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDays(v)
		return nil
	case plan.FieldCommission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommission(v)
		return nil
	case plan.FieldOriginal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOriginal(v)
		return nil
	case plan.FieldDiscountNewly:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscountNewly(v)
		return nil
	case plan.FieldDepositAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDepositAmount(v)
		return nil
	}
	return fmt.Errorf("unknown Plan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(plan.FieldDeletedAt) {
		fields = append(fields, plan.FieldDeletedAt)
	}
	if m.FieldCleared(plan.FieldCreator) {
		fields = append(fields, plan.FieldCreator)
	}
	if m.FieldCleared(plan.FieldLastModifier) {
		fields = append(fields, plan.FieldLastModifier)
	}
	if m.FieldCleared(plan.FieldRemark) {
		fields = append(fields, plan.FieldRemark)
	}
	if m.FieldCleared(plan.FieldBrandID) {
		fields = append(fields, plan.FieldBrandID)
	}
	if m.FieldCleared(plan.FieldModel) {
		fields = append(fields, plan.FieldModel)
	}
	if m.FieldCleared(plan.FieldOriginal) {
		fields = append(fields, plan.FieldOriginal)
	}
	if m.FieldCleared(plan.FieldDesc) {
		fields = append(fields, plan.FieldDesc)
	}
	if m.FieldCleared(plan.FieldParentID) {
		fields = append(fields, plan.FieldParentID)
	}
	if m.FieldCleared(plan.FieldNotes) {
		fields = append(fields, plan.FieldNotes)
	}
	if m.FieldCleared(plan.FieldDepositAmount) {
		fields = append(fields, plan.FieldDepositAmount)
	}
	if m.FieldCleared(plan.FieldDepositPayway) {
		fields = append(fields, plan.FieldDepositPayway)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanMutation) ClearField(name string) error {
	switch name {
	case plan.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case plan.FieldCreator:
		m.ClearCreator()
		return nil
	case plan.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case plan.FieldRemark:
		m.ClearRemark()
		return nil
	case plan.FieldBrandID:
		m.ClearBrandID()
		return nil
	case plan.FieldModel:
		m.ClearModel()
		return nil
	case plan.FieldOriginal:
		m.ClearOriginal()
		return nil
	case plan.FieldDesc:
		m.ClearDesc()
		return nil
	case plan.FieldParentID:
		m.ClearParentID()
		return nil
	case plan.FieldNotes:
		m.ClearNotes()
		return nil
	case plan.FieldDepositAmount:
		m.ClearDepositAmount()
		return nil
	case plan.FieldDepositPayway:
		m.ClearDepositPayway()
		return nil
	}
	return fmt.Errorf("unknown Plan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanMutation) ResetField(name string) error {
	switch name {
	case plan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case plan.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case plan.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case plan.FieldCreator:
		m.ResetCreator()
		return nil
	case plan.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case plan.FieldRemark:
		m.ResetRemark()
		return nil
	case plan.FieldBrandID:
		m.ResetBrandID()
		return nil
	case plan.FieldModel:
		m.ResetModel()
		return nil
	case plan.FieldEnable:
		m.ResetEnable()
		return nil
	case plan.FieldType:
		m.ResetType()
		return nil
	case plan.FieldName:
		m.ResetName()
		return nil
	case plan.FieldStart:
		m.ResetStart()
		return nil
	case plan.FieldEnd:
		m.ResetEnd()
		return nil
	case plan.FieldPrice:
		m.ResetPrice()
		return nil
	case plan.FieldDays:
		m.ResetDays()
		return nil
	case plan.FieldCommission:
		m.ResetCommission()
		return nil
	case plan.FieldOriginal:
		m.ResetOriginal()
		return nil
	case plan.FieldDesc:
		m.ResetDesc()
		return nil
	case plan.FieldParentID:
		m.ResetParentID()
		return nil
	case plan.FieldDiscountNewly:
		m.ResetDiscountNewly()
		return nil
	case plan.FieldNotes:
		m.ResetNotes()
		return nil
	case plan.FieldIntelligent:
		m.ResetIntelligent()
		return nil
	case plan.FieldDeposit:
		m.ResetDeposit()
		return nil
	case plan.FieldDepositAmount:
		m.ResetDepositAmount()
		return nil
	case plan.FieldDepositPayway:
		m.ResetDepositPayway()
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.brand != nil {
		edges = append(edges, plan.EdgeBrand)
	}
	if m.cities != nil {
		edges = append(edges, plan.EdgeCities)
	}
	if m.parent != nil {
		edges = append(edges, plan.EdgeParent)
	}
	if m.complexes != nil {
		edges = append(edges, plan.EdgeComplexes)
	}
	if m.commissions != nil {
		edges = append(edges, plan.EdgeCommissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case plan.EdgeBrand:
		if id := m.brand; id != nil {
			return []ent.Value{*id}
		}
	case plan.EdgeCities:
		ids := make([]ent.Value, 0, len(m.cities))
		for id := range m.cities {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case plan.EdgeComplexes:
		ids := make([]ent.Value, 0, len(m.complexes))
		for id := range m.complexes {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeCommissions:
		ids := make([]ent.Value, 0, len(m.commissions))
		for id := range m.commissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcities != nil {
		edges = append(edges, plan.EdgeCities)
	}
	if m.removedcomplexes != nil {
		edges = append(edges, plan.EdgeComplexes)
	}
	if m.removedcommissions != nil {
		edges = append(edges, plan.EdgeCommissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case plan.EdgeCities:
		ids := make([]ent.Value, 0, len(m.removedcities))
		for id := range m.removedcities {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeComplexes:
		ids := make([]ent.Value, 0, len(m.removedcomplexes))
		for id := range m.removedcomplexes {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeCommissions:
		ids := make([]ent.Value, 0, len(m.removedcommissions))
		for id := range m.removedcommissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedbrand {
		edges = append(edges, plan.EdgeBrand)
	}
	if m.clearedcities {
		edges = append(edges, plan.EdgeCities)
	}
	if m.clearedparent {
		edges = append(edges, plan.EdgeParent)
	}
	if m.clearedcomplexes {
		edges = append(edges, plan.EdgeComplexes)
	}
	if m.clearedcommissions {
		edges = append(edges, plan.EdgeCommissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanMutation) EdgeCleared(name string) bool {
	switch name {
	case plan.EdgeBrand:
		return m.clearedbrand
	case plan.EdgeCities:
		return m.clearedcities
	case plan.EdgeParent:
		return m.clearedparent
	case plan.EdgeComplexes:
		return m.clearedcomplexes
	case plan.EdgeCommissions:
		return m.clearedcommissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanMutation) ClearEdge(name string) error {
	switch name {
	case plan.EdgeBrand:
		m.ClearBrand()
		return nil
	case plan.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Plan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanMutation) ResetEdge(name string) error {
	switch name {
	case plan.EdgeBrand:
		m.ResetBrand()
		return nil
	case plan.EdgeCities:
		m.ResetCities()
		return nil
	case plan.EdgeParent:
		m.ResetParent()
		return nil
	case plan.EdgeComplexes:
		m.ResetComplexes()
		return nil
	case plan.EdgeCommissions:
		m.ResetCommissions()
		return nil
	}
	return fmt.Errorf("unknown Plan edge %s", name)
}

// PlanIntroduceMutation represents an operation that mutates the PlanIntroduce nodes in the graph.
type PlanIntroduceMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	model         *string
	image         *string
	clearedFields map[string]struct{}
	brand         *uint64
	clearedbrand  bool
	done          bool
	oldValue      func(context.Context) (*PlanIntroduce, error)
	predicates    []predicate.PlanIntroduce
}

var _ ent.Mutation = (*PlanIntroduceMutation)(nil)

// planintroduceOption allows management of the mutation configuration using functional options.
type planintroduceOption func(*PlanIntroduceMutation)

// newPlanIntroduceMutation creates new mutation for the PlanIntroduce entity.
func newPlanIntroduceMutation(c config, op Op, opts ...planintroduceOption) *PlanIntroduceMutation {
	m := &PlanIntroduceMutation{
		config:        c,
		op:            op,
		typ:           TypePlanIntroduce,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanIntroduceID sets the ID field of the mutation.
func withPlanIntroduceID(id uint64) planintroduceOption {
	return func(m *PlanIntroduceMutation) {
		var (
			err   error
			once  sync.Once
			value *PlanIntroduce
		)
		m.oldValue = func(ctx context.Context) (*PlanIntroduce, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlanIntroduce.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlanIntroduce sets the old PlanIntroduce of the mutation.
func withPlanIntroduce(node *PlanIntroduce) planintroduceOption {
	return func(m *PlanIntroduceMutation) {
		m.oldValue = func(context.Context) (*PlanIntroduce, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanIntroduceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanIntroduceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanIntroduceMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanIntroduceMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlanIntroduce.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PlanIntroduceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlanIntroduceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PlanIntroduce entity.
// If the PlanIntroduce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanIntroduceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlanIntroduceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlanIntroduceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlanIntroduceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PlanIntroduce entity.
// If the PlanIntroduce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanIntroduceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlanIntroduceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetBrandID sets the "brand_id" field.
func (m *PlanIntroduceMutation) SetBrandID(u uint64) {
	m.brand = &u
}

// BrandID returns the value of the "brand_id" field in the mutation.
func (m *PlanIntroduceMutation) BrandID() (r uint64, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrandID returns the old "brand_id" field's value of the PlanIntroduce entity.
// If the PlanIntroduce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanIntroduceMutation) OldBrandID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrandID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrandID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrandID: %w", err)
	}
	return oldValue.BrandID, nil
}

// ClearBrandID clears the value of the "brand_id" field.
func (m *PlanIntroduceMutation) ClearBrandID() {
	m.brand = nil
	m.clearedFields[planintroduce.FieldBrandID] = struct{}{}
}

// BrandIDCleared returns if the "brand_id" field was cleared in this mutation.
func (m *PlanIntroduceMutation) BrandIDCleared() bool {
	_, ok := m.clearedFields[planintroduce.FieldBrandID]
	return ok
}

// ResetBrandID resets all changes to the "brand_id" field.
func (m *PlanIntroduceMutation) ResetBrandID() {
	m.brand = nil
	delete(m.clearedFields, planintroduce.FieldBrandID)
}

// SetModel sets the "model" field.
func (m *PlanIntroduceMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *PlanIntroduceMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the PlanIntroduce entity.
// If the PlanIntroduce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanIntroduceMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *PlanIntroduceMutation) ResetModel() {
	m.model = nil
}

// SetImage sets the "image" field.
func (m *PlanIntroduceMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *PlanIntroduceMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the PlanIntroduce entity.
// If the PlanIntroduce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanIntroduceMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *PlanIntroduceMutation) ResetImage() {
	m.image = nil
}

// ClearBrand clears the "brand" edge to the EbikeBrand entity.
func (m *PlanIntroduceMutation) ClearBrand() {
	m.clearedbrand = true
	m.clearedFields[planintroduce.FieldBrandID] = struct{}{}
}

// BrandCleared reports if the "brand" edge to the EbikeBrand entity was cleared.
func (m *PlanIntroduceMutation) BrandCleared() bool {
	return m.BrandIDCleared() || m.clearedbrand
}

// BrandIDs returns the "brand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BrandID instead. It exists only for internal usage by the builders.
func (m *PlanIntroduceMutation) BrandIDs() (ids []uint64) {
	if id := m.brand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBrand resets all changes to the "brand" edge.
func (m *PlanIntroduceMutation) ResetBrand() {
	m.brand = nil
	m.clearedbrand = false
}

// Where appends a list predicates to the PlanIntroduceMutation builder.
func (m *PlanIntroduceMutation) Where(ps ...predicate.PlanIntroduce) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlanIntroduceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlanIntroduceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlanIntroduce, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlanIntroduceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlanIntroduceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlanIntroduce).
func (m *PlanIntroduceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanIntroduceMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, planintroduce.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, planintroduce.FieldUpdatedAt)
	}
	if m.brand != nil {
		fields = append(fields, planintroduce.FieldBrandID)
	}
	if m.model != nil {
		fields = append(fields, planintroduce.FieldModel)
	}
	if m.image != nil {
		fields = append(fields, planintroduce.FieldImage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanIntroduceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case planintroduce.FieldCreatedAt:
		return m.CreatedAt()
	case planintroduce.FieldUpdatedAt:
		return m.UpdatedAt()
	case planintroduce.FieldBrandID:
		return m.BrandID()
	case planintroduce.FieldModel:
		return m.Model()
	case planintroduce.FieldImage:
		return m.Image()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanIntroduceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case planintroduce.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case planintroduce.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case planintroduce.FieldBrandID:
		return m.OldBrandID(ctx)
	case planintroduce.FieldModel:
		return m.OldModel(ctx)
	case planintroduce.FieldImage:
		return m.OldImage(ctx)
	}
	return nil, fmt.Errorf("unknown PlanIntroduce field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanIntroduceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case planintroduce.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case planintroduce.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case planintroduce.FieldBrandID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrandID(v)
		return nil
	case planintroduce.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case planintroduce.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	}
	return fmt.Errorf("unknown PlanIntroduce field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanIntroduceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanIntroduceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanIntroduceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PlanIntroduce numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanIntroduceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(planintroduce.FieldBrandID) {
		fields = append(fields, planintroduce.FieldBrandID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanIntroduceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanIntroduceMutation) ClearField(name string) error {
	switch name {
	case planintroduce.FieldBrandID:
		m.ClearBrandID()
		return nil
	}
	return fmt.Errorf("unknown PlanIntroduce nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanIntroduceMutation) ResetField(name string) error {
	switch name {
	case planintroduce.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case planintroduce.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case planintroduce.FieldBrandID:
		m.ResetBrandID()
		return nil
	case planintroduce.FieldModel:
		m.ResetModel()
		return nil
	case planintroduce.FieldImage:
		m.ResetImage()
		return nil
	}
	return fmt.Errorf("unknown PlanIntroduce field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanIntroduceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.brand != nil {
		edges = append(edges, planintroduce.EdgeBrand)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanIntroduceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case planintroduce.EdgeBrand:
		if id := m.brand; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanIntroduceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanIntroduceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanIntroduceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbrand {
		edges = append(edges, planintroduce.EdgeBrand)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanIntroduceMutation) EdgeCleared(name string) bool {
	switch name {
	case planintroduce.EdgeBrand:
		return m.clearedbrand
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanIntroduceMutation) ClearEdge(name string) error {
	switch name {
	case planintroduce.EdgeBrand:
		m.ClearBrand()
		return nil
	}
	return fmt.Errorf("unknown PlanIntroduce unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanIntroduceMutation) ResetEdge(name string) error {
	switch name {
	case planintroduce.EdgeBrand:
		m.ResetBrand()
		return nil
	}
	return fmt.Errorf("unknown PlanIntroduce edge %s", name)
}

// PointLogMutation represents an operation that mutates the PointLog nodes in the graph.
type PointLogMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	modifier      **model.Modifier
	employee_info **model.Employee
	_type         *uint8
	add_type      *int8
	points        *int64
	addpoints     *int64
	after         *int64
	addafter      *int64
	reason        *string
	attach        **model.PointLogAttach
	clearedFields map[string]struct{}
	rider         *uint64
	clearedrider  bool
	_order        *uint64
	cleared_order bool
	done          bool
	oldValue      func(context.Context) (*PointLog, error)
	predicates    []predicate.PointLog
}

var _ ent.Mutation = (*PointLogMutation)(nil)

// pointlogOption allows management of the mutation configuration using functional options.
type pointlogOption func(*PointLogMutation)

// newPointLogMutation creates new mutation for the PointLog entity.
func newPointLogMutation(c config, op Op, opts ...pointlogOption) *PointLogMutation {
	m := &PointLogMutation{
		config:        c,
		op:            op,
		typ:           TypePointLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPointLogID sets the ID field of the mutation.
func withPointLogID(id uint64) pointlogOption {
	return func(m *PointLogMutation) {
		var (
			err   error
			once  sync.Once
			value *PointLog
		)
		m.oldValue = func(ctx context.Context) (*PointLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PointLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPointLog sets the old PointLog of the mutation.
func withPointLog(node *PointLog) pointlogOption {
	return func(m *PointLogMutation) {
		m.oldValue = func(context.Context) (*PointLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PointLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PointLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PointLogMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PointLogMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PointLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PointLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PointLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PointLog entity.
// If the PointLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PointLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PointLogMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PointLogMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PointLog entity.
// If the PointLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointLogMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PointLogMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRiderID sets the "rider_id" field.
func (m *PointLogMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *PointLogMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the PointLog entity.
// If the PointLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointLogMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *PointLogMutation) ResetRiderID() {
	m.rider = nil
}

// SetOrderID sets the "order_id" field.
func (m *PointLogMutation) SetOrderID(u uint64) {
	m._order = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *PointLogMutation) OrderID() (r uint64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the PointLog entity.
// If the PointLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointLogMutation) OldOrderID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *PointLogMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[pointlog.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *PointLogMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[pointlog.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *PointLogMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, pointlog.FieldOrderID)
}

// SetModifier sets the "modifier" field.
func (m *PointLogMutation) SetModifier(value *model.Modifier) {
	m.modifier = &value
}

// Modifier returns the value of the "modifier" field in the mutation.
func (m *PointLogMutation) Modifier() (r *model.Modifier, exists bool) {
	v := m.modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldModifier returns the old "modifier" field's value of the PointLog entity.
// If the PointLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointLogMutation) OldModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifier: %w", err)
	}
	return oldValue.Modifier, nil
}

// ClearModifier clears the value of the "modifier" field.
func (m *PointLogMutation) ClearModifier() {
	m.modifier = nil
	m.clearedFields[pointlog.FieldModifier] = struct{}{}
}

// ModifierCleared returns if the "modifier" field was cleared in this mutation.
func (m *PointLogMutation) ModifierCleared() bool {
	_, ok := m.clearedFields[pointlog.FieldModifier]
	return ok
}

// ResetModifier resets all changes to the "modifier" field.
func (m *PointLogMutation) ResetModifier() {
	m.modifier = nil
	delete(m.clearedFields, pointlog.FieldModifier)
}

// SetEmployeeInfo sets the "employee_info" field.
func (m *PointLogMutation) SetEmployeeInfo(value *model.Employee) {
	m.employee_info = &value
}

// EmployeeInfo returns the value of the "employee_info" field in the mutation.
func (m *PointLogMutation) EmployeeInfo() (r *model.Employee, exists bool) {
	v := m.employee_info
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeInfo returns the old "employee_info" field's value of the PointLog entity.
// If the PointLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointLogMutation) OldEmployeeInfo(ctx context.Context) (v *model.Employee, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeInfo: %w", err)
	}
	return oldValue.EmployeeInfo, nil
}

// ClearEmployeeInfo clears the value of the "employee_info" field.
func (m *PointLogMutation) ClearEmployeeInfo() {
	m.employee_info = nil
	m.clearedFields[pointlog.FieldEmployeeInfo] = struct{}{}
}

// EmployeeInfoCleared returns if the "employee_info" field was cleared in this mutation.
func (m *PointLogMutation) EmployeeInfoCleared() bool {
	_, ok := m.clearedFields[pointlog.FieldEmployeeInfo]
	return ok
}

// ResetEmployeeInfo resets all changes to the "employee_info" field.
func (m *PointLogMutation) ResetEmployeeInfo() {
	m.employee_info = nil
	delete(m.clearedFields, pointlog.FieldEmployeeInfo)
}

// SetType sets the "type" field.
func (m *PointLogMutation) SetType(u uint8) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *PointLogMutation) GetType() (r uint8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PointLog entity.
// If the PointLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointLogMutation) OldType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *PointLogMutation) AddType(u int8) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *PointLogMutation) AddedType() (r int8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *PointLogMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetPoints sets the "points" field.
func (m *PointLogMutation) SetPoints(i int64) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *PointLogMutation) Points() (r int64, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the PointLog entity.
// If the PointLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointLogMutation) OldPoints(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *PointLogMutation) AddPoints(i int64) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *PointLogMutation) AddedPoints() (r int64, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints resets all changes to the "points" field.
func (m *PointLogMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetAfter sets the "after" field.
func (m *PointLogMutation) SetAfter(i int64) {
	m.after = &i
	m.addafter = nil
}

// After returns the value of the "after" field in the mutation.
func (m *PointLogMutation) After() (r int64, exists bool) {
	v := m.after
	if v == nil {
		return
	}
	return *v, true
}

// OldAfter returns the old "after" field's value of the PointLog entity.
// If the PointLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointLogMutation) OldAfter(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAfter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAfter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAfter: %w", err)
	}
	return oldValue.After, nil
}

// AddAfter adds i to the "after" field.
func (m *PointLogMutation) AddAfter(i int64) {
	if m.addafter != nil {
		*m.addafter += i
	} else {
		m.addafter = &i
	}
}

// AddedAfter returns the value that was added to the "after" field in this mutation.
func (m *PointLogMutation) AddedAfter() (r int64, exists bool) {
	v := m.addafter
	if v == nil {
		return
	}
	return *v, true
}

// ResetAfter resets all changes to the "after" field.
func (m *PointLogMutation) ResetAfter() {
	m.after = nil
	m.addafter = nil
}

// SetReason sets the "reason" field.
func (m *PointLogMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *PointLogMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the PointLog entity.
// If the PointLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointLogMutation) OldReason(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ClearReason clears the value of the "reason" field.
func (m *PointLogMutation) ClearReason() {
	m.reason = nil
	m.clearedFields[pointlog.FieldReason] = struct{}{}
}

// ReasonCleared returns if the "reason" field was cleared in this mutation.
func (m *PointLogMutation) ReasonCleared() bool {
	_, ok := m.clearedFields[pointlog.FieldReason]
	return ok
}

// ResetReason resets all changes to the "reason" field.
func (m *PointLogMutation) ResetReason() {
	m.reason = nil
	delete(m.clearedFields, pointlog.FieldReason)
}

// SetAttach sets the "attach" field.
func (m *PointLogMutation) SetAttach(mla *model.PointLogAttach) {
	m.attach = &mla
}

// Attach returns the value of the "attach" field in the mutation.
func (m *PointLogMutation) Attach() (r *model.PointLogAttach, exists bool) {
	v := m.attach
	if v == nil {
		return
	}
	return *v, true
}

// OldAttach returns the old "attach" field's value of the PointLog entity.
// If the PointLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointLogMutation) OldAttach(ctx context.Context) (v *model.PointLogAttach, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttach is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttach requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttach: %w", err)
	}
	return oldValue.Attach, nil
}

// ClearAttach clears the value of the "attach" field.
func (m *PointLogMutation) ClearAttach() {
	m.attach = nil
	m.clearedFields[pointlog.FieldAttach] = struct{}{}
}

// AttachCleared returns if the "attach" field was cleared in this mutation.
func (m *PointLogMutation) AttachCleared() bool {
	_, ok := m.clearedFields[pointlog.FieldAttach]
	return ok
}

// ResetAttach resets all changes to the "attach" field.
func (m *PointLogMutation) ResetAttach() {
	m.attach = nil
	delete(m.clearedFields, pointlog.FieldAttach)
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *PointLogMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[pointlog.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *PointLogMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *PointLogMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *PointLogMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *PointLogMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[pointlog.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *PointLogMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *PointLogMutation) OrderIDs() (ids []uint64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *PointLogMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the PointLogMutation builder.
func (m *PointLogMutation) Where(ps ...predicate.PointLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PointLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PointLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PointLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PointLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PointLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PointLog).
func (m *PointLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PointLogMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, pointlog.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pointlog.FieldUpdatedAt)
	}
	if m.rider != nil {
		fields = append(fields, pointlog.FieldRiderID)
	}
	if m._order != nil {
		fields = append(fields, pointlog.FieldOrderID)
	}
	if m.modifier != nil {
		fields = append(fields, pointlog.FieldModifier)
	}
	if m.employee_info != nil {
		fields = append(fields, pointlog.FieldEmployeeInfo)
	}
	if m._type != nil {
		fields = append(fields, pointlog.FieldType)
	}
	if m.points != nil {
		fields = append(fields, pointlog.FieldPoints)
	}
	if m.after != nil {
		fields = append(fields, pointlog.FieldAfter)
	}
	if m.reason != nil {
		fields = append(fields, pointlog.FieldReason)
	}
	if m.attach != nil {
		fields = append(fields, pointlog.FieldAttach)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PointLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pointlog.FieldCreatedAt:
		return m.CreatedAt()
	case pointlog.FieldUpdatedAt:
		return m.UpdatedAt()
	case pointlog.FieldRiderID:
		return m.RiderID()
	case pointlog.FieldOrderID:
		return m.OrderID()
	case pointlog.FieldModifier:
		return m.Modifier()
	case pointlog.FieldEmployeeInfo:
		return m.EmployeeInfo()
	case pointlog.FieldType:
		return m.GetType()
	case pointlog.FieldPoints:
		return m.Points()
	case pointlog.FieldAfter:
		return m.After()
	case pointlog.FieldReason:
		return m.Reason()
	case pointlog.FieldAttach:
		return m.Attach()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PointLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pointlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pointlog.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pointlog.FieldRiderID:
		return m.OldRiderID(ctx)
	case pointlog.FieldOrderID:
		return m.OldOrderID(ctx)
	case pointlog.FieldModifier:
		return m.OldModifier(ctx)
	case pointlog.FieldEmployeeInfo:
		return m.OldEmployeeInfo(ctx)
	case pointlog.FieldType:
		return m.OldType(ctx)
	case pointlog.FieldPoints:
		return m.OldPoints(ctx)
	case pointlog.FieldAfter:
		return m.OldAfter(ctx)
	case pointlog.FieldReason:
		return m.OldReason(ctx)
	case pointlog.FieldAttach:
		return m.OldAttach(ctx)
	}
	return nil, fmt.Errorf("unknown PointLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PointLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pointlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pointlog.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pointlog.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case pointlog.FieldOrderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case pointlog.FieldModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifier(v)
		return nil
	case pointlog.FieldEmployeeInfo:
		v, ok := value.(*model.Employee)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeInfo(v)
		return nil
	case pointlog.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case pointlog.FieldPoints:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case pointlog.FieldAfter:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAfter(v)
		return nil
	case pointlog.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	case pointlog.FieldAttach:
		v, ok := value.(*model.PointLogAttach)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttach(v)
		return nil
	}
	return fmt.Errorf("unknown PointLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PointLogMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, pointlog.FieldType)
	}
	if m.addpoints != nil {
		fields = append(fields, pointlog.FieldPoints)
	}
	if m.addafter != nil {
		fields = append(fields, pointlog.FieldAfter)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PointLogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pointlog.FieldType:
		return m.AddedType()
	case pointlog.FieldPoints:
		return m.AddedPoints()
	case pointlog.FieldAfter:
		return m.AddedAfter()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PointLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pointlog.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case pointlog.FieldPoints:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	case pointlog.FieldAfter:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAfter(v)
		return nil
	}
	return fmt.Errorf("unknown PointLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PointLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pointlog.FieldOrderID) {
		fields = append(fields, pointlog.FieldOrderID)
	}
	if m.FieldCleared(pointlog.FieldModifier) {
		fields = append(fields, pointlog.FieldModifier)
	}
	if m.FieldCleared(pointlog.FieldEmployeeInfo) {
		fields = append(fields, pointlog.FieldEmployeeInfo)
	}
	if m.FieldCleared(pointlog.FieldReason) {
		fields = append(fields, pointlog.FieldReason)
	}
	if m.FieldCleared(pointlog.FieldAttach) {
		fields = append(fields, pointlog.FieldAttach)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PointLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PointLogMutation) ClearField(name string) error {
	switch name {
	case pointlog.FieldOrderID:
		m.ClearOrderID()
		return nil
	case pointlog.FieldModifier:
		m.ClearModifier()
		return nil
	case pointlog.FieldEmployeeInfo:
		m.ClearEmployeeInfo()
		return nil
	case pointlog.FieldReason:
		m.ClearReason()
		return nil
	case pointlog.FieldAttach:
		m.ClearAttach()
		return nil
	}
	return fmt.Errorf("unknown PointLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PointLogMutation) ResetField(name string) error {
	switch name {
	case pointlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pointlog.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pointlog.FieldRiderID:
		m.ResetRiderID()
		return nil
	case pointlog.FieldOrderID:
		m.ResetOrderID()
		return nil
	case pointlog.FieldModifier:
		m.ResetModifier()
		return nil
	case pointlog.FieldEmployeeInfo:
		m.ResetEmployeeInfo()
		return nil
	case pointlog.FieldType:
		m.ResetType()
		return nil
	case pointlog.FieldPoints:
		m.ResetPoints()
		return nil
	case pointlog.FieldAfter:
		m.ResetAfter()
		return nil
	case pointlog.FieldReason:
		m.ResetReason()
		return nil
	case pointlog.FieldAttach:
		m.ResetAttach()
		return nil
	}
	return fmt.Errorf("unknown PointLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PointLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.rider != nil {
		edges = append(edges, pointlog.EdgeRider)
	}
	if m._order != nil {
		edges = append(edges, pointlog.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PointLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pointlog.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case pointlog.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PointLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PointLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PointLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrider {
		edges = append(edges, pointlog.EdgeRider)
	}
	if m.cleared_order {
		edges = append(edges, pointlog.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PointLogMutation) EdgeCleared(name string) bool {
	switch name {
	case pointlog.EdgeRider:
		return m.clearedrider
	case pointlog.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PointLogMutation) ClearEdge(name string) error {
	switch name {
	case pointlog.EdgeRider:
		m.ClearRider()
		return nil
	case pointlog.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown PointLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PointLogMutation) ResetEdge(name string) error {
	switch name {
	case pointlog.EdgeRider:
		m.ResetRider()
		return nil
	case pointlog.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown PointLog edge %s", name)
}

// PromotionAchievementMutation represents an operation that mutates the PromotionAchievement nodes in the graph.
type PromotionAchievementMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	creator       **model.Modifier
	last_modifier **model.Modifier
	remark        *string
	name          *string
	_type         *uint8
	add_type      *int8
	icon          *string
	condition     *uint64
	addcondition  *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PromotionAchievement, error)
	predicates    []predicate.PromotionAchievement
}

var _ ent.Mutation = (*PromotionAchievementMutation)(nil)

// promotionachievementOption allows management of the mutation configuration using functional options.
type promotionachievementOption func(*PromotionAchievementMutation)

// newPromotionAchievementMutation creates new mutation for the PromotionAchievement entity.
func newPromotionAchievementMutation(c config, op Op, opts ...promotionachievementOption) *PromotionAchievementMutation {
	m := &PromotionAchievementMutation{
		config:        c,
		op:            op,
		typ:           TypePromotionAchievement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionAchievementID sets the ID field of the mutation.
func withPromotionAchievementID(id uint64) promotionachievementOption {
	return func(m *PromotionAchievementMutation) {
		var (
			err   error
			once  sync.Once
			value *PromotionAchievement
		)
		m.oldValue = func(ctx context.Context) (*PromotionAchievement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromotionAchievement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotionAchievement sets the old PromotionAchievement of the mutation.
func withPromotionAchievement(node *PromotionAchievement) promotionachievementOption {
	return func(m *PromotionAchievementMutation) {
		m.oldValue = func(context.Context) (*PromotionAchievement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionAchievementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionAchievementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromotionAchievementMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromotionAchievementMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromotionAchievement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromotionAchievementMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromotionAchievementMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromotionAchievement entity.
// If the PromotionAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionAchievementMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromotionAchievementMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromotionAchievementMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromotionAchievementMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PromotionAchievement entity.
// If the PromotionAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionAchievementMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromotionAchievementMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PromotionAchievementMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PromotionAchievementMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PromotionAchievement entity.
// If the PromotionAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionAchievementMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PromotionAchievementMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[promotionachievement.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PromotionAchievementMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[promotionachievement.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PromotionAchievementMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, promotionachievement.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *PromotionAchievementMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *PromotionAchievementMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the PromotionAchievement entity.
// If the PromotionAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionAchievementMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *PromotionAchievementMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[promotionachievement.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *PromotionAchievementMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[promotionachievement.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *PromotionAchievementMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, promotionachievement.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *PromotionAchievementMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *PromotionAchievementMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the PromotionAchievement entity.
// If the PromotionAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionAchievementMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *PromotionAchievementMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[promotionachievement.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *PromotionAchievementMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[promotionachievement.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *PromotionAchievementMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, promotionachievement.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *PromotionAchievementMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PromotionAchievementMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the PromotionAchievement entity.
// If the PromotionAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionAchievementMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PromotionAchievementMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[promotionachievement.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PromotionAchievementMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[promotionachievement.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PromotionAchievementMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, promotionachievement.FieldRemark)
}

// SetName sets the "name" field.
func (m *PromotionAchievementMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PromotionAchievementMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PromotionAchievement entity.
// If the PromotionAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionAchievementMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PromotionAchievementMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *PromotionAchievementMutation) SetType(u uint8) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *PromotionAchievementMutation) GetType() (r uint8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PromotionAchievement entity.
// If the PromotionAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionAchievementMutation) OldType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *PromotionAchievementMutation) AddType(u int8) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *PromotionAchievementMutation) AddedType() (r int8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *PromotionAchievementMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetIcon sets the "icon" field.
func (m *PromotionAchievementMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *PromotionAchievementMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the PromotionAchievement entity.
// If the PromotionAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionAchievementMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ResetIcon resets all changes to the "icon" field.
func (m *PromotionAchievementMutation) ResetIcon() {
	m.icon = nil
}

// SetCondition sets the "condition" field.
func (m *PromotionAchievementMutation) SetCondition(u uint64) {
	m.condition = &u
	m.addcondition = nil
}

// Condition returns the value of the "condition" field in the mutation.
func (m *PromotionAchievementMutation) Condition() (r uint64, exists bool) {
	v := m.condition
	if v == nil {
		return
	}
	return *v, true
}

// OldCondition returns the old "condition" field's value of the PromotionAchievement entity.
// If the PromotionAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionAchievementMutation) OldCondition(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCondition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCondition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCondition: %w", err)
	}
	return oldValue.Condition, nil
}

// AddCondition adds u to the "condition" field.
func (m *PromotionAchievementMutation) AddCondition(u int64) {
	if m.addcondition != nil {
		*m.addcondition += u
	} else {
		m.addcondition = &u
	}
}

// AddedCondition returns the value that was added to the "condition" field in this mutation.
func (m *PromotionAchievementMutation) AddedCondition() (r int64, exists bool) {
	v := m.addcondition
	if v == nil {
		return
	}
	return *v, true
}

// ResetCondition resets all changes to the "condition" field.
func (m *PromotionAchievementMutation) ResetCondition() {
	m.condition = nil
	m.addcondition = nil
}

// Where appends a list predicates to the PromotionAchievementMutation builder.
func (m *PromotionAchievementMutation) Where(ps ...predicate.PromotionAchievement) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromotionAchievementMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromotionAchievementMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromotionAchievement, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromotionAchievementMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromotionAchievementMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromotionAchievement).
func (m *PromotionAchievementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromotionAchievementMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, promotionachievement.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, promotionachievement.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, promotionachievement.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, promotionachievement.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, promotionachievement.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, promotionachievement.FieldRemark)
	}
	if m.name != nil {
		fields = append(fields, promotionachievement.FieldName)
	}
	if m._type != nil {
		fields = append(fields, promotionachievement.FieldType)
	}
	if m.icon != nil {
		fields = append(fields, promotionachievement.FieldIcon)
	}
	if m.condition != nil {
		fields = append(fields, promotionachievement.FieldCondition)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromotionAchievementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotionachievement.FieldCreatedAt:
		return m.CreatedAt()
	case promotionachievement.FieldUpdatedAt:
		return m.UpdatedAt()
	case promotionachievement.FieldDeletedAt:
		return m.DeletedAt()
	case promotionachievement.FieldCreator:
		return m.Creator()
	case promotionachievement.FieldLastModifier:
		return m.LastModifier()
	case promotionachievement.FieldRemark:
		return m.Remark()
	case promotionachievement.FieldName:
		return m.Name()
	case promotionachievement.FieldType:
		return m.GetType()
	case promotionachievement.FieldIcon:
		return m.Icon()
	case promotionachievement.FieldCondition:
		return m.Condition()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromotionAchievementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotionachievement.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case promotionachievement.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case promotionachievement.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case promotionachievement.FieldCreator:
		return m.OldCreator(ctx)
	case promotionachievement.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case promotionachievement.FieldRemark:
		return m.OldRemark(ctx)
	case promotionachievement.FieldName:
		return m.OldName(ctx)
	case promotionachievement.FieldType:
		return m.OldType(ctx)
	case promotionachievement.FieldIcon:
		return m.OldIcon(ctx)
	case promotionachievement.FieldCondition:
		return m.OldCondition(ctx)
	}
	return nil, fmt.Errorf("unknown PromotionAchievement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionAchievementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotionachievement.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case promotionachievement.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case promotionachievement.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case promotionachievement.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case promotionachievement.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case promotionachievement.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case promotionachievement.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case promotionachievement.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case promotionachievement.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case promotionachievement.FieldCondition:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCondition(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionAchievement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromotionAchievementMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, promotionachievement.FieldType)
	}
	if m.addcondition != nil {
		fields = append(fields, promotionachievement.FieldCondition)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromotionAchievementMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case promotionachievement.FieldType:
		return m.AddedType()
	case promotionachievement.FieldCondition:
		return m.AddedCondition()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionAchievementMutation) AddField(name string, value ent.Value) error {
	switch name {
	case promotionachievement.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case promotionachievement.FieldCondition:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCondition(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionAchievement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromotionAchievementMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promotionachievement.FieldDeletedAt) {
		fields = append(fields, promotionachievement.FieldDeletedAt)
	}
	if m.FieldCleared(promotionachievement.FieldCreator) {
		fields = append(fields, promotionachievement.FieldCreator)
	}
	if m.FieldCleared(promotionachievement.FieldLastModifier) {
		fields = append(fields, promotionachievement.FieldLastModifier)
	}
	if m.FieldCleared(promotionachievement.FieldRemark) {
		fields = append(fields, promotionachievement.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromotionAchievementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionAchievementMutation) ClearField(name string) error {
	switch name {
	case promotionachievement.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case promotionachievement.FieldCreator:
		m.ClearCreator()
		return nil
	case promotionachievement.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case promotionachievement.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown PromotionAchievement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromotionAchievementMutation) ResetField(name string) error {
	switch name {
	case promotionachievement.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case promotionachievement.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case promotionachievement.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case promotionachievement.FieldCreator:
		m.ResetCreator()
		return nil
	case promotionachievement.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case promotionachievement.FieldRemark:
		m.ResetRemark()
		return nil
	case promotionachievement.FieldName:
		m.ResetName()
		return nil
	case promotionachievement.FieldType:
		m.ResetType()
		return nil
	case promotionachievement.FieldIcon:
		m.ResetIcon()
		return nil
	case promotionachievement.FieldCondition:
		m.ResetCondition()
		return nil
	}
	return fmt.Errorf("unknown PromotionAchievement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromotionAchievementMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromotionAchievementMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromotionAchievementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromotionAchievementMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromotionAchievementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromotionAchievementMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromotionAchievementMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PromotionAchievement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromotionAchievementMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PromotionAchievement edge %s", name)
}

// PromotionBankCardMutation represents an operation that mutates the PromotionBankCard nodes in the graph.
type PromotionBankCardMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint64
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	creator            **model.Modifier
	last_modifier      **model.Modifier
	remark             *string
	card_no            *string
	bank               *string
	is_default         *bool
	bank_logo_url      *string
	province           *string
	city               *string
	clearedFields      map[string]struct{}
	member             *uint64
	clearedmember      bool
	withdrawals        map[uint64]struct{}
	removedwithdrawals map[uint64]struct{}
	clearedwithdrawals bool
	done               bool
	oldValue           func(context.Context) (*PromotionBankCard, error)
	predicates         []predicate.PromotionBankCard
}

var _ ent.Mutation = (*PromotionBankCardMutation)(nil)

// promotionbankcardOption allows management of the mutation configuration using functional options.
type promotionbankcardOption func(*PromotionBankCardMutation)

// newPromotionBankCardMutation creates new mutation for the PromotionBankCard entity.
func newPromotionBankCardMutation(c config, op Op, opts ...promotionbankcardOption) *PromotionBankCardMutation {
	m := &PromotionBankCardMutation{
		config:        c,
		op:            op,
		typ:           TypePromotionBankCard,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionBankCardID sets the ID field of the mutation.
func withPromotionBankCardID(id uint64) promotionbankcardOption {
	return func(m *PromotionBankCardMutation) {
		var (
			err   error
			once  sync.Once
			value *PromotionBankCard
		)
		m.oldValue = func(ctx context.Context) (*PromotionBankCard, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromotionBankCard.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotionBankCard sets the old PromotionBankCard of the mutation.
func withPromotionBankCard(node *PromotionBankCard) promotionbankcardOption {
	return func(m *PromotionBankCardMutation) {
		m.oldValue = func(context.Context) (*PromotionBankCard, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionBankCardMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionBankCardMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromotionBankCardMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromotionBankCardMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromotionBankCard.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromotionBankCardMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromotionBankCardMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromotionBankCard entity.
// If the PromotionBankCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionBankCardMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromotionBankCardMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromotionBankCardMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromotionBankCardMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PromotionBankCard entity.
// If the PromotionBankCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionBankCardMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromotionBankCardMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PromotionBankCardMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PromotionBankCardMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PromotionBankCard entity.
// If the PromotionBankCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionBankCardMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PromotionBankCardMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[promotionbankcard.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PromotionBankCardMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[promotionbankcard.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PromotionBankCardMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, promotionbankcard.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *PromotionBankCardMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *PromotionBankCardMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the PromotionBankCard entity.
// If the PromotionBankCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionBankCardMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *PromotionBankCardMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[promotionbankcard.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *PromotionBankCardMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[promotionbankcard.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *PromotionBankCardMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, promotionbankcard.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *PromotionBankCardMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *PromotionBankCardMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the PromotionBankCard entity.
// If the PromotionBankCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionBankCardMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *PromotionBankCardMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[promotionbankcard.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *PromotionBankCardMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[promotionbankcard.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *PromotionBankCardMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, promotionbankcard.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *PromotionBankCardMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PromotionBankCardMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the PromotionBankCard entity.
// If the PromotionBankCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionBankCardMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PromotionBankCardMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[promotionbankcard.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PromotionBankCardMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[promotionbankcard.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PromotionBankCardMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, promotionbankcard.FieldRemark)
}

// SetMemberID sets the "member_id" field.
func (m *PromotionBankCardMutation) SetMemberID(u uint64) {
	m.member = &u
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *PromotionBankCardMutation) MemberID() (r uint64, exists bool) {
	v := m.member
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the PromotionBankCard entity.
// If the PromotionBankCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionBankCardMutation) OldMemberID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *PromotionBankCardMutation) ClearMemberID() {
	m.member = nil
	m.clearedFields[promotionbankcard.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *PromotionBankCardMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[promotionbankcard.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *PromotionBankCardMutation) ResetMemberID() {
	m.member = nil
	delete(m.clearedFields, promotionbankcard.FieldMemberID)
}

// SetCardNo sets the "card_no" field.
func (m *PromotionBankCardMutation) SetCardNo(s string) {
	m.card_no = &s
}

// CardNo returns the value of the "card_no" field in the mutation.
func (m *PromotionBankCardMutation) CardNo() (r string, exists bool) {
	v := m.card_no
	if v == nil {
		return
	}
	return *v, true
}

// OldCardNo returns the old "card_no" field's value of the PromotionBankCard entity.
// If the PromotionBankCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionBankCardMutation) OldCardNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCardNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCardNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCardNo: %w", err)
	}
	return oldValue.CardNo, nil
}

// ResetCardNo resets all changes to the "card_no" field.
func (m *PromotionBankCardMutation) ResetCardNo() {
	m.card_no = nil
}

// SetBank sets the "bank" field.
func (m *PromotionBankCardMutation) SetBank(s string) {
	m.bank = &s
}

// Bank returns the value of the "bank" field in the mutation.
func (m *PromotionBankCardMutation) Bank() (r string, exists bool) {
	v := m.bank
	if v == nil {
		return
	}
	return *v, true
}

// OldBank returns the old "bank" field's value of the PromotionBankCard entity.
// If the PromotionBankCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionBankCardMutation) OldBank(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBank: %w", err)
	}
	return oldValue.Bank, nil
}

// ClearBank clears the value of the "bank" field.
func (m *PromotionBankCardMutation) ClearBank() {
	m.bank = nil
	m.clearedFields[promotionbankcard.FieldBank] = struct{}{}
}

// BankCleared returns if the "bank" field was cleared in this mutation.
func (m *PromotionBankCardMutation) BankCleared() bool {
	_, ok := m.clearedFields[promotionbankcard.FieldBank]
	return ok
}

// ResetBank resets all changes to the "bank" field.
func (m *PromotionBankCardMutation) ResetBank() {
	m.bank = nil
	delete(m.clearedFields, promotionbankcard.FieldBank)
}

// SetIsDefault sets the "is_default" field.
func (m *PromotionBankCardMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *PromotionBankCardMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the PromotionBankCard entity.
// If the PromotionBankCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionBankCardMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *PromotionBankCardMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetBankLogoURL sets the "bank_logo_url" field.
func (m *PromotionBankCardMutation) SetBankLogoURL(s string) {
	m.bank_logo_url = &s
}

// BankLogoURL returns the value of the "bank_logo_url" field in the mutation.
func (m *PromotionBankCardMutation) BankLogoURL() (r string, exists bool) {
	v := m.bank_logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldBankLogoURL returns the old "bank_logo_url" field's value of the PromotionBankCard entity.
// If the PromotionBankCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionBankCardMutation) OldBankLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankLogoURL: %w", err)
	}
	return oldValue.BankLogoURL, nil
}

// ClearBankLogoURL clears the value of the "bank_logo_url" field.
func (m *PromotionBankCardMutation) ClearBankLogoURL() {
	m.bank_logo_url = nil
	m.clearedFields[promotionbankcard.FieldBankLogoURL] = struct{}{}
}

// BankLogoURLCleared returns if the "bank_logo_url" field was cleared in this mutation.
func (m *PromotionBankCardMutation) BankLogoURLCleared() bool {
	_, ok := m.clearedFields[promotionbankcard.FieldBankLogoURL]
	return ok
}

// ResetBankLogoURL resets all changes to the "bank_logo_url" field.
func (m *PromotionBankCardMutation) ResetBankLogoURL() {
	m.bank_logo_url = nil
	delete(m.clearedFields, promotionbankcard.FieldBankLogoURL)
}

// SetProvince sets the "province" field.
func (m *PromotionBankCardMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *PromotionBankCardMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the PromotionBankCard entity.
// If the PromotionBankCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionBankCardMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ClearProvince clears the value of the "province" field.
func (m *PromotionBankCardMutation) ClearProvince() {
	m.province = nil
	m.clearedFields[promotionbankcard.FieldProvince] = struct{}{}
}

// ProvinceCleared returns if the "province" field was cleared in this mutation.
func (m *PromotionBankCardMutation) ProvinceCleared() bool {
	_, ok := m.clearedFields[promotionbankcard.FieldProvince]
	return ok
}

// ResetProvince resets all changes to the "province" field.
func (m *PromotionBankCardMutation) ResetProvince() {
	m.province = nil
	delete(m.clearedFields, promotionbankcard.FieldProvince)
}

// SetCity sets the "city" field.
func (m *PromotionBankCardMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *PromotionBankCardMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the PromotionBankCard entity.
// If the PromotionBankCard object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionBankCardMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ClearCity clears the value of the "city" field.
func (m *PromotionBankCardMutation) ClearCity() {
	m.city = nil
	m.clearedFields[promotionbankcard.FieldCity] = struct{}{}
}

// CityCleared returns if the "city" field was cleared in this mutation.
func (m *PromotionBankCardMutation) CityCleared() bool {
	_, ok := m.clearedFields[promotionbankcard.FieldCity]
	return ok
}

// ResetCity resets all changes to the "city" field.
func (m *PromotionBankCardMutation) ResetCity() {
	m.city = nil
	delete(m.clearedFields, promotionbankcard.FieldCity)
}

// ClearMember clears the "member" edge to the PromotionMember entity.
func (m *PromotionBankCardMutation) ClearMember() {
	m.clearedmember = true
	m.clearedFields[promotionbankcard.FieldMemberID] = struct{}{}
}

// MemberCleared reports if the "member" edge to the PromotionMember entity was cleared.
func (m *PromotionBankCardMutation) MemberCleared() bool {
	return m.MemberIDCleared() || m.clearedmember
}

// MemberIDs returns the "member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberID instead. It exists only for internal usage by the builders.
func (m *PromotionBankCardMutation) MemberIDs() (ids []uint64) {
	if id := m.member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMember resets all changes to the "member" edge.
func (m *PromotionBankCardMutation) ResetMember() {
	m.member = nil
	m.clearedmember = false
}

// AddWithdrawalIDs adds the "withdrawals" edge to the PromotionWithdrawal entity by ids.
func (m *PromotionBankCardMutation) AddWithdrawalIDs(ids ...uint64) {
	if m.withdrawals == nil {
		m.withdrawals = make(map[uint64]struct{})
	}
	for i := range ids {
		m.withdrawals[ids[i]] = struct{}{}
	}
}

// ClearWithdrawals clears the "withdrawals" edge to the PromotionWithdrawal entity.
func (m *PromotionBankCardMutation) ClearWithdrawals() {
	m.clearedwithdrawals = true
}

// WithdrawalsCleared reports if the "withdrawals" edge to the PromotionWithdrawal entity was cleared.
func (m *PromotionBankCardMutation) WithdrawalsCleared() bool {
	return m.clearedwithdrawals
}

// RemoveWithdrawalIDs removes the "withdrawals" edge to the PromotionWithdrawal entity by IDs.
func (m *PromotionBankCardMutation) RemoveWithdrawalIDs(ids ...uint64) {
	if m.removedwithdrawals == nil {
		m.removedwithdrawals = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.withdrawals, ids[i])
		m.removedwithdrawals[ids[i]] = struct{}{}
	}
}

// RemovedWithdrawals returns the removed IDs of the "withdrawals" edge to the PromotionWithdrawal entity.
func (m *PromotionBankCardMutation) RemovedWithdrawalsIDs() (ids []uint64) {
	for id := range m.removedwithdrawals {
		ids = append(ids, id)
	}
	return
}

// WithdrawalsIDs returns the "withdrawals" edge IDs in the mutation.
func (m *PromotionBankCardMutation) WithdrawalsIDs() (ids []uint64) {
	for id := range m.withdrawals {
		ids = append(ids, id)
	}
	return
}

// ResetWithdrawals resets all changes to the "withdrawals" edge.
func (m *PromotionBankCardMutation) ResetWithdrawals() {
	m.withdrawals = nil
	m.clearedwithdrawals = false
	m.removedwithdrawals = nil
}

// Where appends a list predicates to the PromotionBankCardMutation builder.
func (m *PromotionBankCardMutation) Where(ps ...predicate.PromotionBankCard) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromotionBankCardMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromotionBankCardMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromotionBankCard, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromotionBankCardMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromotionBankCardMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromotionBankCard).
func (m *PromotionBankCardMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromotionBankCardMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, promotionbankcard.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, promotionbankcard.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, promotionbankcard.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, promotionbankcard.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, promotionbankcard.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, promotionbankcard.FieldRemark)
	}
	if m.member != nil {
		fields = append(fields, promotionbankcard.FieldMemberID)
	}
	if m.card_no != nil {
		fields = append(fields, promotionbankcard.FieldCardNo)
	}
	if m.bank != nil {
		fields = append(fields, promotionbankcard.FieldBank)
	}
	if m.is_default != nil {
		fields = append(fields, promotionbankcard.FieldIsDefault)
	}
	if m.bank_logo_url != nil {
		fields = append(fields, promotionbankcard.FieldBankLogoURL)
	}
	if m.province != nil {
		fields = append(fields, promotionbankcard.FieldProvince)
	}
	if m.city != nil {
		fields = append(fields, promotionbankcard.FieldCity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromotionBankCardMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotionbankcard.FieldCreatedAt:
		return m.CreatedAt()
	case promotionbankcard.FieldUpdatedAt:
		return m.UpdatedAt()
	case promotionbankcard.FieldDeletedAt:
		return m.DeletedAt()
	case promotionbankcard.FieldCreator:
		return m.Creator()
	case promotionbankcard.FieldLastModifier:
		return m.LastModifier()
	case promotionbankcard.FieldRemark:
		return m.Remark()
	case promotionbankcard.FieldMemberID:
		return m.MemberID()
	case promotionbankcard.FieldCardNo:
		return m.CardNo()
	case promotionbankcard.FieldBank:
		return m.Bank()
	case promotionbankcard.FieldIsDefault:
		return m.IsDefault()
	case promotionbankcard.FieldBankLogoURL:
		return m.BankLogoURL()
	case promotionbankcard.FieldProvince:
		return m.Province()
	case promotionbankcard.FieldCity:
		return m.City()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromotionBankCardMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotionbankcard.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case promotionbankcard.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case promotionbankcard.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case promotionbankcard.FieldCreator:
		return m.OldCreator(ctx)
	case promotionbankcard.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case promotionbankcard.FieldRemark:
		return m.OldRemark(ctx)
	case promotionbankcard.FieldMemberID:
		return m.OldMemberID(ctx)
	case promotionbankcard.FieldCardNo:
		return m.OldCardNo(ctx)
	case promotionbankcard.FieldBank:
		return m.OldBank(ctx)
	case promotionbankcard.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case promotionbankcard.FieldBankLogoURL:
		return m.OldBankLogoURL(ctx)
	case promotionbankcard.FieldProvince:
		return m.OldProvince(ctx)
	case promotionbankcard.FieldCity:
		return m.OldCity(ctx)
	}
	return nil, fmt.Errorf("unknown PromotionBankCard field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionBankCardMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotionbankcard.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case promotionbankcard.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case promotionbankcard.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case promotionbankcard.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case promotionbankcard.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case promotionbankcard.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case promotionbankcard.FieldMemberID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case promotionbankcard.FieldCardNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCardNo(v)
		return nil
	case promotionbankcard.FieldBank:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBank(v)
		return nil
	case promotionbankcard.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case promotionbankcard.FieldBankLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankLogoURL(v)
		return nil
	case promotionbankcard.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case promotionbankcard.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionBankCard field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromotionBankCardMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromotionBankCardMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionBankCardMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PromotionBankCard numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromotionBankCardMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promotionbankcard.FieldDeletedAt) {
		fields = append(fields, promotionbankcard.FieldDeletedAt)
	}
	if m.FieldCleared(promotionbankcard.FieldCreator) {
		fields = append(fields, promotionbankcard.FieldCreator)
	}
	if m.FieldCleared(promotionbankcard.FieldLastModifier) {
		fields = append(fields, promotionbankcard.FieldLastModifier)
	}
	if m.FieldCleared(promotionbankcard.FieldRemark) {
		fields = append(fields, promotionbankcard.FieldRemark)
	}
	if m.FieldCleared(promotionbankcard.FieldMemberID) {
		fields = append(fields, promotionbankcard.FieldMemberID)
	}
	if m.FieldCleared(promotionbankcard.FieldBank) {
		fields = append(fields, promotionbankcard.FieldBank)
	}
	if m.FieldCleared(promotionbankcard.FieldBankLogoURL) {
		fields = append(fields, promotionbankcard.FieldBankLogoURL)
	}
	if m.FieldCleared(promotionbankcard.FieldProvince) {
		fields = append(fields, promotionbankcard.FieldProvince)
	}
	if m.FieldCleared(promotionbankcard.FieldCity) {
		fields = append(fields, promotionbankcard.FieldCity)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromotionBankCardMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionBankCardMutation) ClearField(name string) error {
	switch name {
	case promotionbankcard.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case promotionbankcard.FieldCreator:
		m.ClearCreator()
		return nil
	case promotionbankcard.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case promotionbankcard.FieldRemark:
		m.ClearRemark()
		return nil
	case promotionbankcard.FieldMemberID:
		m.ClearMemberID()
		return nil
	case promotionbankcard.FieldBank:
		m.ClearBank()
		return nil
	case promotionbankcard.FieldBankLogoURL:
		m.ClearBankLogoURL()
		return nil
	case promotionbankcard.FieldProvince:
		m.ClearProvince()
		return nil
	case promotionbankcard.FieldCity:
		m.ClearCity()
		return nil
	}
	return fmt.Errorf("unknown PromotionBankCard nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromotionBankCardMutation) ResetField(name string) error {
	switch name {
	case promotionbankcard.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case promotionbankcard.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case promotionbankcard.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case promotionbankcard.FieldCreator:
		m.ResetCreator()
		return nil
	case promotionbankcard.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case promotionbankcard.FieldRemark:
		m.ResetRemark()
		return nil
	case promotionbankcard.FieldMemberID:
		m.ResetMemberID()
		return nil
	case promotionbankcard.FieldCardNo:
		m.ResetCardNo()
		return nil
	case promotionbankcard.FieldBank:
		m.ResetBank()
		return nil
	case promotionbankcard.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case promotionbankcard.FieldBankLogoURL:
		m.ResetBankLogoURL()
		return nil
	case promotionbankcard.FieldProvince:
		m.ResetProvince()
		return nil
	case promotionbankcard.FieldCity:
		m.ResetCity()
		return nil
	}
	return fmt.Errorf("unknown PromotionBankCard field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromotionBankCardMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.member != nil {
		edges = append(edges, promotionbankcard.EdgeMember)
	}
	if m.withdrawals != nil {
		edges = append(edges, promotionbankcard.EdgeWithdrawals)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromotionBankCardMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promotionbankcard.EdgeMember:
		if id := m.member; id != nil {
			return []ent.Value{*id}
		}
	case promotionbankcard.EdgeWithdrawals:
		ids := make([]ent.Value, 0, len(m.withdrawals))
		for id := range m.withdrawals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromotionBankCardMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedwithdrawals != nil {
		edges = append(edges, promotionbankcard.EdgeWithdrawals)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromotionBankCardMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case promotionbankcard.EdgeWithdrawals:
		ids := make([]ent.Value, 0, len(m.removedwithdrawals))
		for id := range m.removedwithdrawals {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromotionBankCardMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmember {
		edges = append(edges, promotionbankcard.EdgeMember)
	}
	if m.clearedwithdrawals {
		edges = append(edges, promotionbankcard.EdgeWithdrawals)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromotionBankCardMutation) EdgeCleared(name string) bool {
	switch name {
	case promotionbankcard.EdgeMember:
		return m.clearedmember
	case promotionbankcard.EdgeWithdrawals:
		return m.clearedwithdrawals
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromotionBankCardMutation) ClearEdge(name string) error {
	switch name {
	case promotionbankcard.EdgeMember:
		m.ClearMember()
		return nil
	}
	return fmt.Errorf("unknown PromotionBankCard unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromotionBankCardMutation) ResetEdge(name string) error {
	switch name {
	case promotionbankcard.EdgeMember:
		m.ResetMember()
		return nil
	case promotionbankcard.EdgeWithdrawals:
		m.ResetWithdrawals()
		return nil
	}
	return fmt.Errorf("unknown PromotionBankCard edge %s", name)
}

// PromotionCommissionMutation represents an operation that mutates the PromotionCommission nodes in the graph.
type PromotionCommissionMutation struct {
	config
	op                         Op
	typ                        string
	id                         *uint64
	created_at                 *time.Time
	updated_at                 *time.Time
	deleted_at                 *time.Time
	creator                    **model.Modifier
	last_modifier              **model.Modifier
	remark                     *string
	_type                      *uint8
	add_type                   *int8
	name                       *string
	rule                       **promotion.CommissionRule
	enable                     *bool
	amount_sum                 *float64
	addamount_sum              *float64
	first_new_num              *uint64
	addfirst_new_num           *int64
	second_new_num             *uint64
	addsecond_new_num          *int64
	first_renew_num            *uint64
	addfirst_renew_num         *int64
	second_renew_num           *uint64
	addsecond_renew_num        *int64
	first_new_amount_sum       *float64
	addfirst_new_amount_sum    *float64
	second_new_amount_sum      *float64
	addsecond_new_amount_sum   *float64
	first_renew_amount_sum     *float64
	addfirst_renew_amount_sum  *float64
	second_renew_amount_sum    *float64
	addsecond_renew_amount_sum *float64
	desc                       *string
	history_id                 *[]uint64
	appendhistory_id           []uint64
	start_at                   *time.Time
	end_at                     *time.Time
	clearedFields              map[string]struct{}
	member                     *uint64
	clearedmember              bool
	plans                      map[uint64]struct{}
	removedplans               map[uint64]struct{}
	clearedplans               bool
	done                       bool
	oldValue                   func(context.Context) (*PromotionCommission, error)
	predicates                 []predicate.PromotionCommission
}

var _ ent.Mutation = (*PromotionCommissionMutation)(nil)

// promotioncommissionOption allows management of the mutation configuration using functional options.
type promotioncommissionOption func(*PromotionCommissionMutation)

// newPromotionCommissionMutation creates new mutation for the PromotionCommission entity.
func newPromotionCommissionMutation(c config, op Op, opts ...promotioncommissionOption) *PromotionCommissionMutation {
	m := &PromotionCommissionMutation{
		config:        c,
		op:            op,
		typ:           TypePromotionCommission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionCommissionID sets the ID field of the mutation.
func withPromotionCommissionID(id uint64) promotioncommissionOption {
	return func(m *PromotionCommissionMutation) {
		var (
			err   error
			once  sync.Once
			value *PromotionCommission
		)
		m.oldValue = func(ctx context.Context) (*PromotionCommission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromotionCommission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotionCommission sets the old PromotionCommission of the mutation.
func withPromotionCommission(node *PromotionCommission) promotioncommissionOption {
	return func(m *PromotionCommissionMutation) {
		m.oldValue = func(context.Context) (*PromotionCommission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionCommissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionCommissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromotionCommissionMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromotionCommissionMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromotionCommission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromotionCommissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromotionCommissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromotionCommissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromotionCommissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromotionCommissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromotionCommissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PromotionCommissionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PromotionCommissionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PromotionCommissionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[promotioncommission.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PromotionCommissionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[promotioncommission.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PromotionCommissionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, promotioncommission.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *PromotionCommissionMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *PromotionCommissionMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *PromotionCommissionMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[promotioncommission.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *PromotionCommissionMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[promotioncommission.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *PromotionCommissionMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, promotioncommission.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *PromotionCommissionMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *PromotionCommissionMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *PromotionCommissionMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[promotioncommission.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *PromotionCommissionMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[promotioncommission.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *PromotionCommissionMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, promotioncommission.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *PromotionCommissionMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PromotionCommissionMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PromotionCommissionMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[promotioncommission.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PromotionCommissionMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[promotioncommission.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PromotionCommissionMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, promotioncommission.FieldRemark)
}

// SetMemberID sets the "member_id" field.
func (m *PromotionCommissionMutation) SetMemberID(u uint64) {
	m.member = &u
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *PromotionCommissionMutation) MemberID() (r uint64, exists bool) {
	v := m.member
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldMemberID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *PromotionCommissionMutation) ClearMemberID() {
	m.member = nil
	m.clearedFields[promotioncommission.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *PromotionCommissionMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[promotioncommission.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *PromotionCommissionMutation) ResetMemberID() {
	m.member = nil
	delete(m.clearedFields, promotioncommission.FieldMemberID)
}

// SetType sets the "type" field.
func (m *PromotionCommissionMutation) SetType(u uint8) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *PromotionCommissionMutation) GetType() (r uint8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldType(ctx context.Context) (v *uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *PromotionCommissionMutation) AddType(u int8) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *PromotionCommissionMutation) AddedType() (r int8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *PromotionCommissionMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetName sets the "name" field.
func (m *PromotionCommissionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PromotionCommissionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PromotionCommissionMutation) ResetName() {
	m.name = nil
}

// SetRule sets the "rule" field.
func (m *PromotionCommissionMutation) SetRule(pr *promotion.CommissionRule) {
	m.rule = &pr
}

// Rule returns the value of the "rule" field in the mutation.
func (m *PromotionCommissionMutation) Rule() (r *promotion.CommissionRule, exists bool) {
	v := m.rule
	if v == nil {
		return
	}
	return *v, true
}

// OldRule returns the old "rule" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldRule(ctx context.Context) (v *promotion.CommissionRule, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRule: %w", err)
	}
	return oldValue.Rule, nil
}

// ResetRule resets all changes to the "rule" field.
func (m *PromotionCommissionMutation) ResetRule() {
	m.rule = nil
}

// SetEnable sets the "enable" field.
func (m *PromotionCommissionMutation) SetEnable(b bool) {
	m.enable = &b
}

// Enable returns the value of the "enable" field in the mutation.
func (m *PromotionCommissionMutation) Enable() (r bool, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// ResetEnable resets all changes to the "enable" field.
func (m *PromotionCommissionMutation) ResetEnable() {
	m.enable = nil
}

// SetAmountSum sets the "amount_sum" field.
func (m *PromotionCommissionMutation) SetAmountSum(f float64) {
	m.amount_sum = &f
	m.addamount_sum = nil
}

// AmountSum returns the value of the "amount_sum" field in the mutation.
func (m *PromotionCommissionMutation) AmountSum() (r float64, exists bool) {
	v := m.amount_sum
	if v == nil {
		return
	}
	return *v, true
}

// OldAmountSum returns the old "amount_sum" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldAmountSum(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmountSum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmountSum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmountSum: %w", err)
	}
	return oldValue.AmountSum, nil
}

// AddAmountSum adds f to the "amount_sum" field.
func (m *PromotionCommissionMutation) AddAmountSum(f float64) {
	if m.addamount_sum != nil {
		*m.addamount_sum += f
	} else {
		m.addamount_sum = &f
	}
}

// AddedAmountSum returns the value that was added to the "amount_sum" field in this mutation.
func (m *PromotionCommissionMutation) AddedAmountSum() (r float64, exists bool) {
	v := m.addamount_sum
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmountSum resets all changes to the "amount_sum" field.
func (m *PromotionCommissionMutation) ResetAmountSum() {
	m.amount_sum = nil
	m.addamount_sum = nil
}

// SetFirstNewNum sets the "first_new_num" field.
func (m *PromotionCommissionMutation) SetFirstNewNum(u uint64) {
	m.first_new_num = &u
	m.addfirst_new_num = nil
}

// FirstNewNum returns the value of the "first_new_num" field in the mutation.
func (m *PromotionCommissionMutation) FirstNewNum() (r uint64, exists bool) {
	v := m.first_new_num
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstNewNum returns the old "first_new_num" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldFirstNewNum(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstNewNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstNewNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstNewNum: %w", err)
	}
	return oldValue.FirstNewNum, nil
}

// AddFirstNewNum adds u to the "first_new_num" field.
func (m *PromotionCommissionMutation) AddFirstNewNum(u int64) {
	if m.addfirst_new_num != nil {
		*m.addfirst_new_num += u
	} else {
		m.addfirst_new_num = &u
	}
}

// AddedFirstNewNum returns the value that was added to the "first_new_num" field in this mutation.
func (m *PromotionCommissionMutation) AddedFirstNewNum() (r int64, exists bool) {
	v := m.addfirst_new_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetFirstNewNum resets all changes to the "first_new_num" field.
func (m *PromotionCommissionMutation) ResetFirstNewNum() {
	m.first_new_num = nil
	m.addfirst_new_num = nil
}

// SetSecondNewNum sets the "second_new_num" field.
func (m *PromotionCommissionMutation) SetSecondNewNum(u uint64) {
	m.second_new_num = &u
	m.addsecond_new_num = nil
}

// SecondNewNum returns the value of the "second_new_num" field in the mutation.
func (m *PromotionCommissionMutation) SecondNewNum() (r uint64, exists bool) {
	v := m.second_new_num
	if v == nil {
		return
	}
	return *v, true
}

// OldSecondNewNum returns the old "second_new_num" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldSecondNewNum(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecondNewNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecondNewNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecondNewNum: %w", err)
	}
	return oldValue.SecondNewNum, nil
}

// AddSecondNewNum adds u to the "second_new_num" field.
func (m *PromotionCommissionMutation) AddSecondNewNum(u int64) {
	if m.addsecond_new_num != nil {
		*m.addsecond_new_num += u
	} else {
		m.addsecond_new_num = &u
	}
}

// AddedSecondNewNum returns the value that was added to the "second_new_num" field in this mutation.
func (m *PromotionCommissionMutation) AddedSecondNewNum() (r int64, exists bool) {
	v := m.addsecond_new_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetSecondNewNum resets all changes to the "second_new_num" field.
func (m *PromotionCommissionMutation) ResetSecondNewNum() {
	m.second_new_num = nil
	m.addsecond_new_num = nil
}

// SetFirstRenewNum sets the "first_renew_num" field.
func (m *PromotionCommissionMutation) SetFirstRenewNum(u uint64) {
	m.first_renew_num = &u
	m.addfirst_renew_num = nil
}

// FirstRenewNum returns the value of the "first_renew_num" field in the mutation.
func (m *PromotionCommissionMutation) FirstRenewNum() (r uint64, exists bool) {
	v := m.first_renew_num
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstRenewNum returns the old "first_renew_num" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldFirstRenewNum(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstRenewNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstRenewNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstRenewNum: %w", err)
	}
	return oldValue.FirstRenewNum, nil
}

// AddFirstRenewNum adds u to the "first_renew_num" field.
func (m *PromotionCommissionMutation) AddFirstRenewNum(u int64) {
	if m.addfirst_renew_num != nil {
		*m.addfirst_renew_num += u
	} else {
		m.addfirst_renew_num = &u
	}
}

// AddedFirstRenewNum returns the value that was added to the "first_renew_num" field in this mutation.
func (m *PromotionCommissionMutation) AddedFirstRenewNum() (r int64, exists bool) {
	v := m.addfirst_renew_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetFirstRenewNum resets all changes to the "first_renew_num" field.
func (m *PromotionCommissionMutation) ResetFirstRenewNum() {
	m.first_renew_num = nil
	m.addfirst_renew_num = nil
}

// SetSecondRenewNum sets the "second_renew_num" field.
func (m *PromotionCommissionMutation) SetSecondRenewNum(u uint64) {
	m.second_renew_num = &u
	m.addsecond_renew_num = nil
}

// SecondRenewNum returns the value of the "second_renew_num" field in the mutation.
func (m *PromotionCommissionMutation) SecondRenewNum() (r uint64, exists bool) {
	v := m.second_renew_num
	if v == nil {
		return
	}
	return *v, true
}

// OldSecondRenewNum returns the old "second_renew_num" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldSecondRenewNum(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecondRenewNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecondRenewNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecondRenewNum: %w", err)
	}
	return oldValue.SecondRenewNum, nil
}

// AddSecondRenewNum adds u to the "second_renew_num" field.
func (m *PromotionCommissionMutation) AddSecondRenewNum(u int64) {
	if m.addsecond_renew_num != nil {
		*m.addsecond_renew_num += u
	} else {
		m.addsecond_renew_num = &u
	}
}

// AddedSecondRenewNum returns the value that was added to the "second_renew_num" field in this mutation.
func (m *PromotionCommissionMutation) AddedSecondRenewNum() (r int64, exists bool) {
	v := m.addsecond_renew_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetSecondRenewNum resets all changes to the "second_renew_num" field.
func (m *PromotionCommissionMutation) ResetSecondRenewNum() {
	m.second_renew_num = nil
	m.addsecond_renew_num = nil
}

// SetFirstNewAmountSum sets the "first_new_amount_sum" field.
func (m *PromotionCommissionMutation) SetFirstNewAmountSum(f float64) {
	m.first_new_amount_sum = &f
	m.addfirst_new_amount_sum = nil
}

// FirstNewAmountSum returns the value of the "first_new_amount_sum" field in the mutation.
func (m *PromotionCommissionMutation) FirstNewAmountSum() (r float64, exists bool) {
	v := m.first_new_amount_sum
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstNewAmountSum returns the old "first_new_amount_sum" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldFirstNewAmountSum(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstNewAmountSum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstNewAmountSum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstNewAmountSum: %w", err)
	}
	return oldValue.FirstNewAmountSum, nil
}

// AddFirstNewAmountSum adds f to the "first_new_amount_sum" field.
func (m *PromotionCommissionMutation) AddFirstNewAmountSum(f float64) {
	if m.addfirst_new_amount_sum != nil {
		*m.addfirst_new_amount_sum += f
	} else {
		m.addfirst_new_amount_sum = &f
	}
}

// AddedFirstNewAmountSum returns the value that was added to the "first_new_amount_sum" field in this mutation.
func (m *PromotionCommissionMutation) AddedFirstNewAmountSum() (r float64, exists bool) {
	v := m.addfirst_new_amount_sum
	if v == nil {
		return
	}
	return *v, true
}

// ResetFirstNewAmountSum resets all changes to the "first_new_amount_sum" field.
func (m *PromotionCommissionMutation) ResetFirstNewAmountSum() {
	m.first_new_amount_sum = nil
	m.addfirst_new_amount_sum = nil
}

// SetSecondNewAmountSum sets the "second_new_amount_sum" field.
func (m *PromotionCommissionMutation) SetSecondNewAmountSum(f float64) {
	m.second_new_amount_sum = &f
	m.addsecond_new_amount_sum = nil
}

// SecondNewAmountSum returns the value of the "second_new_amount_sum" field in the mutation.
func (m *PromotionCommissionMutation) SecondNewAmountSum() (r float64, exists bool) {
	v := m.second_new_amount_sum
	if v == nil {
		return
	}
	return *v, true
}

// OldSecondNewAmountSum returns the old "second_new_amount_sum" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldSecondNewAmountSum(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecondNewAmountSum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecondNewAmountSum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecondNewAmountSum: %w", err)
	}
	return oldValue.SecondNewAmountSum, nil
}

// AddSecondNewAmountSum adds f to the "second_new_amount_sum" field.
func (m *PromotionCommissionMutation) AddSecondNewAmountSum(f float64) {
	if m.addsecond_new_amount_sum != nil {
		*m.addsecond_new_amount_sum += f
	} else {
		m.addsecond_new_amount_sum = &f
	}
}

// AddedSecondNewAmountSum returns the value that was added to the "second_new_amount_sum" field in this mutation.
func (m *PromotionCommissionMutation) AddedSecondNewAmountSum() (r float64, exists bool) {
	v := m.addsecond_new_amount_sum
	if v == nil {
		return
	}
	return *v, true
}

// ResetSecondNewAmountSum resets all changes to the "second_new_amount_sum" field.
func (m *PromotionCommissionMutation) ResetSecondNewAmountSum() {
	m.second_new_amount_sum = nil
	m.addsecond_new_amount_sum = nil
}

// SetFirstRenewAmountSum sets the "first_renew_amount_sum" field.
func (m *PromotionCommissionMutation) SetFirstRenewAmountSum(f float64) {
	m.first_renew_amount_sum = &f
	m.addfirst_renew_amount_sum = nil
}

// FirstRenewAmountSum returns the value of the "first_renew_amount_sum" field in the mutation.
func (m *PromotionCommissionMutation) FirstRenewAmountSum() (r float64, exists bool) {
	v := m.first_renew_amount_sum
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstRenewAmountSum returns the old "first_renew_amount_sum" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldFirstRenewAmountSum(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstRenewAmountSum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstRenewAmountSum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstRenewAmountSum: %w", err)
	}
	return oldValue.FirstRenewAmountSum, nil
}

// AddFirstRenewAmountSum adds f to the "first_renew_amount_sum" field.
func (m *PromotionCommissionMutation) AddFirstRenewAmountSum(f float64) {
	if m.addfirst_renew_amount_sum != nil {
		*m.addfirst_renew_amount_sum += f
	} else {
		m.addfirst_renew_amount_sum = &f
	}
}

// AddedFirstRenewAmountSum returns the value that was added to the "first_renew_amount_sum" field in this mutation.
func (m *PromotionCommissionMutation) AddedFirstRenewAmountSum() (r float64, exists bool) {
	v := m.addfirst_renew_amount_sum
	if v == nil {
		return
	}
	return *v, true
}

// ResetFirstRenewAmountSum resets all changes to the "first_renew_amount_sum" field.
func (m *PromotionCommissionMutation) ResetFirstRenewAmountSum() {
	m.first_renew_amount_sum = nil
	m.addfirst_renew_amount_sum = nil
}

// SetSecondRenewAmountSum sets the "second_renew_amount_sum" field.
func (m *PromotionCommissionMutation) SetSecondRenewAmountSum(f float64) {
	m.second_renew_amount_sum = &f
	m.addsecond_renew_amount_sum = nil
}

// SecondRenewAmountSum returns the value of the "second_renew_amount_sum" field in the mutation.
func (m *PromotionCommissionMutation) SecondRenewAmountSum() (r float64, exists bool) {
	v := m.second_renew_amount_sum
	if v == nil {
		return
	}
	return *v, true
}

// OldSecondRenewAmountSum returns the old "second_renew_amount_sum" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldSecondRenewAmountSum(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecondRenewAmountSum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecondRenewAmountSum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecondRenewAmountSum: %w", err)
	}
	return oldValue.SecondRenewAmountSum, nil
}

// AddSecondRenewAmountSum adds f to the "second_renew_amount_sum" field.
func (m *PromotionCommissionMutation) AddSecondRenewAmountSum(f float64) {
	if m.addsecond_renew_amount_sum != nil {
		*m.addsecond_renew_amount_sum += f
	} else {
		m.addsecond_renew_amount_sum = &f
	}
}

// AddedSecondRenewAmountSum returns the value that was added to the "second_renew_amount_sum" field in this mutation.
func (m *PromotionCommissionMutation) AddedSecondRenewAmountSum() (r float64, exists bool) {
	v := m.addsecond_renew_amount_sum
	if v == nil {
		return
	}
	return *v, true
}

// ResetSecondRenewAmountSum resets all changes to the "second_renew_amount_sum" field.
func (m *PromotionCommissionMutation) ResetSecondRenewAmountSum() {
	m.second_renew_amount_sum = nil
	m.addsecond_renew_amount_sum = nil
}

// SetDesc sets the "desc" field.
func (m *PromotionCommissionMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *PromotionCommissionMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldDesc(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ClearDesc clears the value of the "desc" field.
func (m *PromotionCommissionMutation) ClearDesc() {
	m.desc = nil
	m.clearedFields[promotioncommission.FieldDesc] = struct{}{}
}

// DescCleared returns if the "desc" field was cleared in this mutation.
func (m *PromotionCommissionMutation) DescCleared() bool {
	_, ok := m.clearedFields[promotioncommission.FieldDesc]
	return ok
}

// ResetDesc resets all changes to the "desc" field.
func (m *PromotionCommissionMutation) ResetDesc() {
	m.desc = nil
	delete(m.clearedFields, promotioncommission.FieldDesc)
}

// SetHistoryID sets the "history_id" field.
func (m *PromotionCommissionMutation) SetHistoryID(u []uint64) {
	m.history_id = &u
	m.appendhistory_id = nil
}

// HistoryID returns the value of the "history_id" field in the mutation.
func (m *PromotionCommissionMutation) HistoryID() (r []uint64, exists bool) {
	v := m.history_id
	if v == nil {
		return
	}
	return *v, true
}

// OldHistoryID returns the old "history_id" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldHistoryID(ctx context.Context) (v []uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHistoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHistoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHistoryID: %w", err)
	}
	return oldValue.HistoryID, nil
}

// AppendHistoryID adds u to the "history_id" field.
func (m *PromotionCommissionMutation) AppendHistoryID(u []uint64) {
	m.appendhistory_id = append(m.appendhistory_id, u...)
}

// AppendedHistoryID returns the list of values that were appended to the "history_id" field in this mutation.
func (m *PromotionCommissionMutation) AppendedHistoryID() ([]uint64, bool) {
	if len(m.appendhistory_id) == 0 {
		return nil, false
	}
	return m.appendhistory_id, true
}

// ClearHistoryID clears the value of the "history_id" field.
func (m *PromotionCommissionMutation) ClearHistoryID() {
	m.history_id = nil
	m.appendhistory_id = nil
	m.clearedFields[promotioncommission.FieldHistoryID] = struct{}{}
}

// HistoryIDCleared returns if the "history_id" field was cleared in this mutation.
func (m *PromotionCommissionMutation) HistoryIDCleared() bool {
	_, ok := m.clearedFields[promotioncommission.FieldHistoryID]
	return ok
}

// ResetHistoryID resets all changes to the "history_id" field.
func (m *PromotionCommissionMutation) ResetHistoryID() {
	m.history_id = nil
	m.appendhistory_id = nil
	delete(m.clearedFields, promotioncommission.FieldHistoryID)
}

// SetStartAt sets the "start_at" field.
func (m *PromotionCommissionMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *PromotionCommissionMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldStartAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *PromotionCommissionMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[promotioncommission.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *PromotionCommissionMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[promotioncommission.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *PromotionCommissionMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, promotioncommission.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *PromotionCommissionMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *PromotionCommissionMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the PromotionCommission entity.
// If the PromotionCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionMutation) OldEndAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *PromotionCommissionMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[promotioncommission.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *PromotionCommissionMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[promotioncommission.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *PromotionCommissionMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, promotioncommission.FieldEndAt)
}

// ClearMember clears the "member" edge to the PromotionMember entity.
func (m *PromotionCommissionMutation) ClearMember() {
	m.clearedmember = true
	m.clearedFields[promotioncommission.FieldMemberID] = struct{}{}
}

// MemberCleared reports if the "member" edge to the PromotionMember entity was cleared.
func (m *PromotionCommissionMutation) MemberCleared() bool {
	return m.MemberIDCleared() || m.clearedmember
}

// MemberIDs returns the "member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberID instead. It exists only for internal usage by the builders.
func (m *PromotionCommissionMutation) MemberIDs() (ids []uint64) {
	if id := m.member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMember resets all changes to the "member" edge.
func (m *PromotionCommissionMutation) ResetMember() {
	m.member = nil
	m.clearedmember = false
}

// AddPlanIDs adds the "plans" edge to the PromotionCommissionPlan entity by ids.
func (m *PromotionCommissionMutation) AddPlanIDs(ids ...uint64) {
	if m.plans == nil {
		m.plans = make(map[uint64]struct{})
	}
	for i := range ids {
		m.plans[ids[i]] = struct{}{}
	}
}

// ClearPlans clears the "plans" edge to the PromotionCommissionPlan entity.
func (m *PromotionCommissionMutation) ClearPlans() {
	m.clearedplans = true
}

// PlansCleared reports if the "plans" edge to the PromotionCommissionPlan entity was cleared.
func (m *PromotionCommissionMutation) PlansCleared() bool {
	return m.clearedplans
}

// RemovePlanIDs removes the "plans" edge to the PromotionCommissionPlan entity by IDs.
func (m *PromotionCommissionMutation) RemovePlanIDs(ids ...uint64) {
	if m.removedplans == nil {
		m.removedplans = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.plans, ids[i])
		m.removedplans[ids[i]] = struct{}{}
	}
}

// RemovedPlans returns the removed IDs of the "plans" edge to the PromotionCommissionPlan entity.
func (m *PromotionCommissionMutation) RemovedPlansIDs() (ids []uint64) {
	for id := range m.removedplans {
		ids = append(ids, id)
	}
	return
}

// PlansIDs returns the "plans" edge IDs in the mutation.
func (m *PromotionCommissionMutation) PlansIDs() (ids []uint64) {
	for id := range m.plans {
		ids = append(ids, id)
	}
	return
}

// ResetPlans resets all changes to the "plans" edge.
func (m *PromotionCommissionMutation) ResetPlans() {
	m.plans = nil
	m.clearedplans = false
	m.removedplans = nil
}

// Where appends a list predicates to the PromotionCommissionMutation builder.
func (m *PromotionCommissionMutation) Where(ps ...predicate.PromotionCommission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromotionCommissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromotionCommissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromotionCommission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromotionCommissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromotionCommissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromotionCommission).
func (m *PromotionCommissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromotionCommissionMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.created_at != nil {
		fields = append(fields, promotioncommission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, promotioncommission.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, promotioncommission.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, promotioncommission.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, promotioncommission.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, promotioncommission.FieldRemark)
	}
	if m.member != nil {
		fields = append(fields, promotioncommission.FieldMemberID)
	}
	if m._type != nil {
		fields = append(fields, promotioncommission.FieldType)
	}
	if m.name != nil {
		fields = append(fields, promotioncommission.FieldName)
	}
	if m.rule != nil {
		fields = append(fields, promotioncommission.FieldRule)
	}
	if m.enable != nil {
		fields = append(fields, promotioncommission.FieldEnable)
	}
	if m.amount_sum != nil {
		fields = append(fields, promotioncommission.FieldAmountSum)
	}
	if m.first_new_num != nil {
		fields = append(fields, promotioncommission.FieldFirstNewNum)
	}
	if m.second_new_num != nil {
		fields = append(fields, promotioncommission.FieldSecondNewNum)
	}
	if m.first_renew_num != nil {
		fields = append(fields, promotioncommission.FieldFirstRenewNum)
	}
	if m.second_renew_num != nil {
		fields = append(fields, promotioncommission.FieldSecondRenewNum)
	}
	if m.first_new_amount_sum != nil {
		fields = append(fields, promotioncommission.FieldFirstNewAmountSum)
	}
	if m.second_new_amount_sum != nil {
		fields = append(fields, promotioncommission.FieldSecondNewAmountSum)
	}
	if m.first_renew_amount_sum != nil {
		fields = append(fields, promotioncommission.FieldFirstRenewAmountSum)
	}
	if m.second_renew_amount_sum != nil {
		fields = append(fields, promotioncommission.FieldSecondRenewAmountSum)
	}
	if m.desc != nil {
		fields = append(fields, promotioncommission.FieldDesc)
	}
	if m.history_id != nil {
		fields = append(fields, promotioncommission.FieldHistoryID)
	}
	if m.start_at != nil {
		fields = append(fields, promotioncommission.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, promotioncommission.FieldEndAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromotionCommissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotioncommission.FieldCreatedAt:
		return m.CreatedAt()
	case promotioncommission.FieldUpdatedAt:
		return m.UpdatedAt()
	case promotioncommission.FieldDeletedAt:
		return m.DeletedAt()
	case promotioncommission.FieldCreator:
		return m.Creator()
	case promotioncommission.FieldLastModifier:
		return m.LastModifier()
	case promotioncommission.FieldRemark:
		return m.Remark()
	case promotioncommission.FieldMemberID:
		return m.MemberID()
	case promotioncommission.FieldType:
		return m.GetType()
	case promotioncommission.FieldName:
		return m.Name()
	case promotioncommission.FieldRule:
		return m.Rule()
	case promotioncommission.FieldEnable:
		return m.Enable()
	case promotioncommission.FieldAmountSum:
		return m.AmountSum()
	case promotioncommission.FieldFirstNewNum:
		return m.FirstNewNum()
	case promotioncommission.FieldSecondNewNum:
		return m.SecondNewNum()
	case promotioncommission.FieldFirstRenewNum:
		return m.FirstRenewNum()
	case promotioncommission.FieldSecondRenewNum:
		return m.SecondRenewNum()
	case promotioncommission.FieldFirstNewAmountSum:
		return m.FirstNewAmountSum()
	case promotioncommission.FieldSecondNewAmountSum:
		return m.SecondNewAmountSum()
	case promotioncommission.FieldFirstRenewAmountSum:
		return m.FirstRenewAmountSum()
	case promotioncommission.FieldSecondRenewAmountSum:
		return m.SecondRenewAmountSum()
	case promotioncommission.FieldDesc:
		return m.Desc()
	case promotioncommission.FieldHistoryID:
		return m.HistoryID()
	case promotioncommission.FieldStartAt:
		return m.StartAt()
	case promotioncommission.FieldEndAt:
		return m.EndAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromotionCommissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotioncommission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case promotioncommission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case promotioncommission.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case promotioncommission.FieldCreator:
		return m.OldCreator(ctx)
	case promotioncommission.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case promotioncommission.FieldRemark:
		return m.OldRemark(ctx)
	case promotioncommission.FieldMemberID:
		return m.OldMemberID(ctx)
	case promotioncommission.FieldType:
		return m.OldType(ctx)
	case promotioncommission.FieldName:
		return m.OldName(ctx)
	case promotioncommission.FieldRule:
		return m.OldRule(ctx)
	case promotioncommission.FieldEnable:
		return m.OldEnable(ctx)
	case promotioncommission.FieldAmountSum:
		return m.OldAmountSum(ctx)
	case promotioncommission.FieldFirstNewNum:
		return m.OldFirstNewNum(ctx)
	case promotioncommission.FieldSecondNewNum:
		return m.OldSecondNewNum(ctx)
	case promotioncommission.FieldFirstRenewNum:
		return m.OldFirstRenewNum(ctx)
	case promotioncommission.FieldSecondRenewNum:
		return m.OldSecondRenewNum(ctx)
	case promotioncommission.FieldFirstNewAmountSum:
		return m.OldFirstNewAmountSum(ctx)
	case promotioncommission.FieldSecondNewAmountSum:
		return m.OldSecondNewAmountSum(ctx)
	case promotioncommission.FieldFirstRenewAmountSum:
		return m.OldFirstRenewAmountSum(ctx)
	case promotioncommission.FieldSecondRenewAmountSum:
		return m.OldSecondRenewAmountSum(ctx)
	case promotioncommission.FieldDesc:
		return m.OldDesc(ctx)
	case promotioncommission.FieldHistoryID:
		return m.OldHistoryID(ctx)
	case promotioncommission.FieldStartAt:
		return m.OldStartAt(ctx)
	case promotioncommission.FieldEndAt:
		return m.OldEndAt(ctx)
	}
	return nil, fmt.Errorf("unknown PromotionCommission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionCommissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotioncommission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case promotioncommission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case promotioncommission.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case promotioncommission.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case promotioncommission.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case promotioncommission.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case promotioncommission.FieldMemberID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case promotioncommission.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case promotioncommission.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case promotioncommission.FieldRule:
		v, ok := value.(*promotion.CommissionRule)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRule(v)
		return nil
	case promotioncommission.FieldEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case promotioncommission.FieldAmountSum:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmountSum(v)
		return nil
	case promotioncommission.FieldFirstNewNum:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstNewNum(v)
		return nil
	case promotioncommission.FieldSecondNewNum:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecondNewNum(v)
		return nil
	case promotioncommission.FieldFirstRenewNum:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstRenewNum(v)
		return nil
	case promotioncommission.FieldSecondRenewNum:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecondRenewNum(v)
		return nil
	case promotioncommission.FieldFirstNewAmountSum:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstNewAmountSum(v)
		return nil
	case promotioncommission.FieldSecondNewAmountSum:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecondNewAmountSum(v)
		return nil
	case promotioncommission.FieldFirstRenewAmountSum:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstRenewAmountSum(v)
		return nil
	case promotioncommission.FieldSecondRenewAmountSum:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecondRenewAmountSum(v)
		return nil
	case promotioncommission.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case promotioncommission.FieldHistoryID:
		v, ok := value.([]uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHistoryID(v)
		return nil
	case promotioncommission.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case promotioncommission.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionCommission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromotionCommissionMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, promotioncommission.FieldType)
	}
	if m.addamount_sum != nil {
		fields = append(fields, promotioncommission.FieldAmountSum)
	}
	if m.addfirst_new_num != nil {
		fields = append(fields, promotioncommission.FieldFirstNewNum)
	}
	if m.addsecond_new_num != nil {
		fields = append(fields, promotioncommission.FieldSecondNewNum)
	}
	if m.addfirst_renew_num != nil {
		fields = append(fields, promotioncommission.FieldFirstRenewNum)
	}
	if m.addsecond_renew_num != nil {
		fields = append(fields, promotioncommission.FieldSecondRenewNum)
	}
	if m.addfirst_new_amount_sum != nil {
		fields = append(fields, promotioncommission.FieldFirstNewAmountSum)
	}
	if m.addsecond_new_amount_sum != nil {
		fields = append(fields, promotioncommission.FieldSecondNewAmountSum)
	}
	if m.addfirst_renew_amount_sum != nil {
		fields = append(fields, promotioncommission.FieldFirstRenewAmountSum)
	}
	if m.addsecond_renew_amount_sum != nil {
		fields = append(fields, promotioncommission.FieldSecondRenewAmountSum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromotionCommissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case promotioncommission.FieldType:
		return m.AddedType()
	case promotioncommission.FieldAmountSum:
		return m.AddedAmountSum()
	case promotioncommission.FieldFirstNewNum:
		return m.AddedFirstNewNum()
	case promotioncommission.FieldSecondNewNum:
		return m.AddedSecondNewNum()
	case promotioncommission.FieldFirstRenewNum:
		return m.AddedFirstRenewNum()
	case promotioncommission.FieldSecondRenewNum:
		return m.AddedSecondRenewNum()
	case promotioncommission.FieldFirstNewAmountSum:
		return m.AddedFirstNewAmountSum()
	case promotioncommission.FieldSecondNewAmountSum:
		return m.AddedSecondNewAmountSum()
	case promotioncommission.FieldFirstRenewAmountSum:
		return m.AddedFirstRenewAmountSum()
	case promotioncommission.FieldSecondRenewAmountSum:
		return m.AddedSecondRenewAmountSum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionCommissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case promotioncommission.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case promotioncommission.FieldAmountSum:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmountSum(v)
		return nil
	case promotioncommission.FieldFirstNewNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstNewNum(v)
		return nil
	case promotioncommission.FieldSecondNewNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSecondNewNum(v)
		return nil
	case promotioncommission.FieldFirstRenewNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstRenewNum(v)
		return nil
	case promotioncommission.FieldSecondRenewNum:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSecondRenewNum(v)
		return nil
	case promotioncommission.FieldFirstNewAmountSum:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstNewAmountSum(v)
		return nil
	case promotioncommission.FieldSecondNewAmountSum:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSecondNewAmountSum(v)
		return nil
	case promotioncommission.FieldFirstRenewAmountSum:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFirstRenewAmountSum(v)
		return nil
	case promotioncommission.FieldSecondRenewAmountSum:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSecondRenewAmountSum(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionCommission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromotionCommissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promotioncommission.FieldDeletedAt) {
		fields = append(fields, promotioncommission.FieldDeletedAt)
	}
	if m.FieldCleared(promotioncommission.FieldCreator) {
		fields = append(fields, promotioncommission.FieldCreator)
	}
	if m.FieldCleared(promotioncommission.FieldLastModifier) {
		fields = append(fields, promotioncommission.FieldLastModifier)
	}
	if m.FieldCleared(promotioncommission.FieldRemark) {
		fields = append(fields, promotioncommission.FieldRemark)
	}
	if m.FieldCleared(promotioncommission.FieldMemberID) {
		fields = append(fields, promotioncommission.FieldMemberID)
	}
	if m.FieldCleared(promotioncommission.FieldDesc) {
		fields = append(fields, promotioncommission.FieldDesc)
	}
	if m.FieldCleared(promotioncommission.FieldHistoryID) {
		fields = append(fields, promotioncommission.FieldHistoryID)
	}
	if m.FieldCleared(promotioncommission.FieldStartAt) {
		fields = append(fields, promotioncommission.FieldStartAt)
	}
	if m.FieldCleared(promotioncommission.FieldEndAt) {
		fields = append(fields, promotioncommission.FieldEndAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromotionCommissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionCommissionMutation) ClearField(name string) error {
	switch name {
	case promotioncommission.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case promotioncommission.FieldCreator:
		m.ClearCreator()
		return nil
	case promotioncommission.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case promotioncommission.FieldRemark:
		m.ClearRemark()
		return nil
	case promotioncommission.FieldMemberID:
		m.ClearMemberID()
		return nil
	case promotioncommission.FieldDesc:
		m.ClearDesc()
		return nil
	case promotioncommission.FieldHistoryID:
		m.ClearHistoryID()
		return nil
	case promotioncommission.FieldStartAt:
		m.ClearStartAt()
		return nil
	case promotioncommission.FieldEndAt:
		m.ClearEndAt()
		return nil
	}
	return fmt.Errorf("unknown PromotionCommission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromotionCommissionMutation) ResetField(name string) error {
	switch name {
	case promotioncommission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case promotioncommission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case promotioncommission.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case promotioncommission.FieldCreator:
		m.ResetCreator()
		return nil
	case promotioncommission.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case promotioncommission.FieldRemark:
		m.ResetRemark()
		return nil
	case promotioncommission.FieldMemberID:
		m.ResetMemberID()
		return nil
	case promotioncommission.FieldType:
		m.ResetType()
		return nil
	case promotioncommission.FieldName:
		m.ResetName()
		return nil
	case promotioncommission.FieldRule:
		m.ResetRule()
		return nil
	case promotioncommission.FieldEnable:
		m.ResetEnable()
		return nil
	case promotioncommission.FieldAmountSum:
		m.ResetAmountSum()
		return nil
	case promotioncommission.FieldFirstNewNum:
		m.ResetFirstNewNum()
		return nil
	case promotioncommission.FieldSecondNewNum:
		m.ResetSecondNewNum()
		return nil
	case promotioncommission.FieldFirstRenewNum:
		m.ResetFirstRenewNum()
		return nil
	case promotioncommission.FieldSecondRenewNum:
		m.ResetSecondRenewNum()
		return nil
	case promotioncommission.FieldFirstNewAmountSum:
		m.ResetFirstNewAmountSum()
		return nil
	case promotioncommission.FieldSecondNewAmountSum:
		m.ResetSecondNewAmountSum()
		return nil
	case promotioncommission.FieldFirstRenewAmountSum:
		m.ResetFirstRenewAmountSum()
		return nil
	case promotioncommission.FieldSecondRenewAmountSum:
		m.ResetSecondRenewAmountSum()
		return nil
	case promotioncommission.FieldDesc:
		m.ResetDesc()
		return nil
	case promotioncommission.FieldHistoryID:
		m.ResetHistoryID()
		return nil
	case promotioncommission.FieldStartAt:
		m.ResetStartAt()
		return nil
	case promotioncommission.FieldEndAt:
		m.ResetEndAt()
		return nil
	}
	return fmt.Errorf("unknown PromotionCommission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromotionCommissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.member != nil {
		edges = append(edges, promotioncommission.EdgeMember)
	}
	if m.plans != nil {
		edges = append(edges, promotioncommission.EdgePlans)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromotionCommissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promotioncommission.EdgeMember:
		if id := m.member; id != nil {
			return []ent.Value{*id}
		}
	case promotioncommission.EdgePlans:
		ids := make([]ent.Value, 0, len(m.plans))
		for id := range m.plans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromotionCommissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedplans != nil {
		edges = append(edges, promotioncommission.EdgePlans)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromotionCommissionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case promotioncommission.EdgePlans:
		ids := make([]ent.Value, 0, len(m.removedplans))
		for id := range m.removedplans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromotionCommissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmember {
		edges = append(edges, promotioncommission.EdgeMember)
	}
	if m.clearedplans {
		edges = append(edges, promotioncommission.EdgePlans)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromotionCommissionMutation) EdgeCleared(name string) bool {
	switch name {
	case promotioncommission.EdgeMember:
		return m.clearedmember
	case promotioncommission.EdgePlans:
		return m.clearedplans
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromotionCommissionMutation) ClearEdge(name string) error {
	switch name {
	case promotioncommission.EdgeMember:
		m.ClearMember()
		return nil
	}
	return fmt.Errorf("unknown PromotionCommission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromotionCommissionMutation) ResetEdge(name string) error {
	switch name {
	case promotioncommission.EdgeMember:
		m.ResetMember()
		return nil
	case promotioncommission.EdgePlans:
		m.ResetPlans()
		return nil
	}
	return fmt.Errorf("unknown PromotionCommission edge %s", name)
}

// PromotionCommissionPlanMutation represents an operation that mutates the PromotionCommissionPlan nodes in the graph.
type PromotionCommissionPlanMutation struct {
	config
	op                          Op
	typ                         string
	id                          *uint64
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	clearedFields               map[string]struct{}
	member                      *uint64
	clearedmember               bool
	promotion_commission        *uint64
	clearedpromotion_commission bool
	plan                        *uint64
	clearedplan                 bool
	done                        bool
	oldValue                    func(context.Context) (*PromotionCommissionPlan, error)
	predicates                  []predicate.PromotionCommissionPlan
}

var _ ent.Mutation = (*PromotionCommissionPlanMutation)(nil)

// promotioncommissionplanOption allows management of the mutation configuration using functional options.
type promotioncommissionplanOption func(*PromotionCommissionPlanMutation)

// newPromotionCommissionPlanMutation creates new mutation for the PromotionCommissionPlan entity.
func newPromotionCommissionPlanMutation(c config, op Op, opts ...promotioncommissionplanOption) *PromotionCommissionPlanMutation {
	m := &PromotionCommissionPlanMutation{
		config:        c,
		op:            op,
		typ:           TypePromotionCommissionPlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionCommissionPlanID sets the ID field of the mutation.
func withPromotionCommissionPlanID(id uint64) promotioncommissionplanOption {
	return func(m *PromotionCommissionPlanMutation) {
		var (
			err   error
			once  sync.Once
			value *PromotionCommissionPlan
		)
		m.oldValue = func(ctx context.Context) (*PromotionCommissionPlan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromotionCommissionPlan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotionCommissionPlan sets the old PromotionCommissionPlan of the mutation.
func withPromotionCommissionPlan(node *PromotionCommissionPlan) promotioncommissionplanOption {
	return func(m *PromotionCommissionPlanMutation) {
		m.oldValue = func(context.Context) (*PromotionCommissionPlan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionCommissionPlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionCommissionPlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromotionCommissionPlanMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromotionCommissionPlanMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromotionCommissionPlan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromotionCommissionPlanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromotionCommissionPlanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromotionCommissionPlan entity.
// If the PromotionCommissionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionPlanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromotionCommissionPlanMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromotionCommissionPlanMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromotionCommissionPlanMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PromotionCommissionPlan entity.
// If the PromotionCommissionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionPlanMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromotionCommissionPlanMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PromotionCommissionPlanMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PromotionCommissionPlanMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PromotionCommissionPlan entity.
// If the PromotionCommissionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionPlanMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PromotionCommissionPlanMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[promotioncommissionplan.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PromotionCommissionPlanMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[promotioncommissionplan.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PromotionCommissionPlanMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, promotioncommissionplan.FieldDeletedAt)
}

// SetMemberID sets the "member_id" field.
func (m *PromotionCommissionPlanMutation) SetMemberID(u uint64) {
	m.member = &u
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *PromotionCommissionPlanMutation) MemberID() (r uint64, exists bool) {
	v := m.member
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the PromotionCommissionPlan entity.
// If the PromotionCommissionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionPlanMutation) OldMemberID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *PromotionCommissionPlanMutation) ClearMemberID() {
	m.member = nil
	m.clearedFields[promotioncommissionplan.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *PromotionCommissionPlanMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[promotioncommissionplan.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *PromotionCommissionPlanMutation) ResetMemberID() {
	m.member = nil
	delete(m.clearedFields, promotioncommissionplan.FieldMemberID)
}

// SetCommissionID sets the "commission_id" field.
func (m *PromotionCommissionPlanMutation) SetCommissionID(u uint64) {
	m.promotion_commission = &u
}

// CommissionID returns the value of the "commission_id" field in the mutation.
func (m *PromotionCommissionPlanMutation) CommissionID() (r uint64, exists bool) {
	v := m.promotion_commission
	if v == nil {
		return
	}
	return *v, true
}

// OldCommissionID returns the old "commission_id" field's value of the PromotionCommissionPlan entity.
// If the PromotionCommissionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionPlanMutation) OldCommissionID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommissionID: %w", err)
	}
	return oldValue.CommissionID, nil
}

// ClearCommissionID clears the value of the "commission_id" field.
func (m *PromotionCommissionPlanMutation) ClearCommissionID() {
	m.promotion_commission = nil
	m.clearedFields[promotioncommissionplan.FieldCommissionID] = struct{}{}
}

// CommissionIDCleared returns if the "commission_id" field was cleared in this mutation.
func (m *PromotionCommissionPlanMutation) CommissionIDCleared() bool {
	_, ok := m.clearedFields[promotioncommissionplan.FieldCommissionID]
	return ok
}

// ResetCommissionID resets all changes to the "commission_id" field.
func (m *PromotionCommissionPlanMutation) ResetCommissionID() {
	m.promotion_commission = nil
	delete(m.clearedFields, promotioncommissionplan.FieldCommissionID)
}

// SetPlanID sets the "plan_id" field.
func (m *PromotionCommissionPlanMutation) SetPlanID(u uint64) {
	m.plan = &u
}

// PlanID returns the value of the "plan_id" field in the mutation.
func (m *PromotionCommissionPlanMutation) PlanID() (r uint64, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanID returns the old "plan_id" field's value of the PromotionCommissionPlan entity.
// If the PromotionCommissionPlan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionCommissionPlanMutation) OldPlanID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanID: %w", err)
	}
	return oldValue.PlanID, nil
}

// ClearPlanID clears the value of the "plan_id" field.
func (m *PromotionCommissionPlanMutation) ClearPlanID() {
	m.plan = nil
	m.clearedFields[promotioncommissionplan.FieldPlanID] = struct{}{}
}

// PlanIDCleared returns if the "plan_id" field was cleared in this mutation.
func (m *PromotionCommissionPlanMutation) PlanIDCleared() bool {
	_, ok := m.clearedFields[promotioncommissionplan.FieldPlanID]
	return ok
}

// ResetPlanID resets all changes to the "plan_id" field.
func (m *PromotionCommissionPlanMutation) ResetPlanID() {
	m.plan = nil
	delete(m.clearedFields, promotioncommissionplan.FieldPlanID)
}

// ClearMember clears the "member" edge to the PromotionMember entity.
func (m *PromotionCommissionPlanMutation) ClearMember() {
	m.clearedmember = true
	m.clearedFields[promotioncommissionplan.FieldMemberID] = struct{}{}
}

// MemberCleared reports if the "member" edge to the PromotionMember entity was cleared.
func (m *PromotionCommissionPlanMutation) MemberCleared() bool {
	return m.MemberIDCleared() || m.clearedmember
}

// MemberIDs returns the "member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberID instead. It exists only for internal usage by the builders.
func (m *PromotionCommissionPlanMutation) MemberIDs() (ids []uint64) {
	if id := m.member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMember resets all changes to the "member" edge.
func (m *PromotionCommissionPlanMutation) ResetMember() {
	m.member = nil
	m.clearedmember = false
}

// SetPromotionCommissionID sets the "promotion_commission" edge to the PromotionCommission entity by id.
func (m *PromotionCommissionPlanMutation) SetPromotionCommissionID(id uint64) {
	m.promotion_commission = &id
}

// ClearPromotionCommission clears the "promotion_commission" edge to the PromotionCommission entity.
func (m *PromotionCommissionPlanMutation) ClearPromotionCommission() {
	m.clearedpromotion_commission = true
	m.clearedFields[promotioncommissionplan.FieldCommissionID] = struct{}{}
}

// PromotionCommissionCleared reports if the "promotion_commission" edge to the PromotionCommission entity was cleared.
func (m *PromotionCommissionPlanMutation) PromotionCommissionCleared() bool {
	return m.CommissionIDCleared() || m.clearedpromotion_commission
}

// PromotionCommissionID returns the "promotion_commission" edge ID in the mutation.
func (m *PromotionCommissionPlanMutation) PromotionCommissionID() (id uint64, exists bool) {
	if m.promotion_commission != nil {
		return *m.promotion_commission, true
	}
	return
}

// PromotionCommissionIDs returns the "promotion_commission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PromotionCommissionID instead. It exists only for internal usage by the builders.
func (m *PromotionCommissionPlanMutation) PromotionCommissionIDs() (ids []uint64) {
	if id := m.promotion_commission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPromotionCommission resets all changes to the "promotion_commission" edge.
func (m *PromotionCommissionPlanMutation) ResetPromotionCommission() {
	m.promotion_commission = nil
	m.clearedpromotion_commission = false
}

// ClearPlan clears the "plan" edge to the Plan entity.
func (m *PromotionCommissionPlanMutation) ClearPlan() {
	m.clearedplan = true
	m.clearedFields[promotioncommissionplan.FieldPlanID] = struct{}{}
}

// PlanCleared reports if the "plan" edge to the Plan entity was cleared.
func (m *PromotionCommissionPlanMutation) PlanCleared() bool {
	return m.PlanIDCleared() || m.clearedplan
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *PromotionCommissionPlanMutation) PlanIDs() (ids []uint64) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *PromotionCommissionPlanMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// Where appends a list predicates to the PromotionCommissionPlanMutation builder.
func (m *PromotionCommissionPlanMutation) Where(ps ...predicate.PromotionCommissionPlan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromotionCommissionPlanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromotionCommissionPlanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromotionCommissionPlan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromotionCommissionPlanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromotionCommissionPlanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromotionCommissionPlan).
func (m *PromotionCommissionPlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromotionCommissionPlanMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, promotioncommissionplan.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, promotioncommissionplan.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, promotioncommissionplan.FieldDeletedAt)
	}
	if m.member != nil {
		fields = append(fields, promotioncommissionplan.FieldMemberID)
	}
	if m.promotion_commission != nil {
		fields = append(fields, promotioncommissionplan.FieldCommissionID)
	}
	if m.plan != nil {
		fields = append(fields, promotioncommissionplan.FieldPlanID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromotionCommissionPlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotioncommissionplan.FieldCreatedAt:
		return m.CreatedAt()
	case promotioncommissionplan.FieldUpdatedAt:
		return m.UpdatedAt()
	case promotioncommissionplan.FieldDeletedAt:
		return m.DeletedAt()
	case promotioncommissionplan.FieldMemberID:
		return m.MemberID()
	case promotioncommissionplan.FieldCommissionID:
		return m.CommissionID()
	case promotioncommissionplan.FieldPlanID:
		return m.PlanID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromotionCommissionPlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotioncommissionplan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case promotioncommissionplan.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case promotioncommissionplan.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case promotioncommissionplan.FieldMemberID:
		return m.OldMemberID(ctx)
	case promotioncommissionplan.FieldCommissionID:
		return m.OldCommissionID(ctx)
	case promotioncommissionplan.FieldPlanID:
		return m.OldPlanID(ctx)
	}
	return nil, fmt.Errorf("unknown PromotionCommissionPlan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionCommissionPlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotioncommissionplan.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case promotioncommissionplan.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case promotioncommissionplan.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case promotioncommissionplan.FieldMemberID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case promotioncommissionplan.FieldCommissionID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommissionID(v)
		return nil
	case promotioncommissionplan.FieldPlanID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanID(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionCommissionPlan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromotionCommissionPlanMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromotionCommissionPlanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionCommissionPlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PromotionCommissionPlan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromotionCommissionPlanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promotioncommissionplan.FieldDeletedAt) {
		fields = append(fields, promotioncommissionplan.FieldDeletedAt)
	}
	if m.FieldCleared(promotioncommissionplan.FieldMemberID) {
		fields = append(fields, promotioncommissionplan.FieldMemberID)
	}
	if m.FieldCleared(promotioncommissionplan.FieldCommissionID) {
		fields = append(fields, promotioncommissionplan.FieldCommissionID)
	}
	if m.FieldCleared(promotioncommissionplan.FieldPlanID) {
		fields = append(fields, promotioncommissionplan.FieldPlanID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromotionCommissionPlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionCommissionPlanMutation) ClearField(name string) error {
	switch name {
	case promotioncommissionplan.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case promotioncommissionplan.FieldMemberID:
		m.ClearMemberID()
		return nil
	case promotioncommissionplan.FieldCommissionID:
		m.ClearCommissionID()
		return nil
	case promotioncommissionplan.FieldPlanID:
		m.ClearPlanID()
		return nil
	}
	return fmt.Errorf("unknown PromotionCommissionPlan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromotionCommissionPlanMutation) ResetField(name string) error {
	switch name {
	case promotioncommissionplan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case promotioncommissionplan.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case promotioncommissionplan.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case promotioncommissionplan.FieldMemberID:
		m.ResetMemberID()
		return nil
	case promotioncommissionplan.FieldCommissionID:
		m.ResetCommissionID()
		return nil
	case promotioncommissionplan.FieldPlanID:
		m.ResetPlanID()
		return nil
	}
	return fmt.Errorf("unknown PromotionCommissionPlan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromotionCommissionPlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.member != nil {
		edges = append(edges, promotioncommissionplan.EdgeMember)
	}
	if m.promotion_commission != nil {
		edges = append(edges, promotioncommissionplan.EdgePromotionCommission)
	}
	if m.plan != nil {
		edges = append(edges, promotioncommissionplan.EdgePlan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromotionCommissionPlanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promotioncommissionplan.EdgeMember:
		if id := m.member; id != nil {
			return []ent.Value{*id}
		}
	case promotioncommissionplan.EdgePromotionCommission:
		if id := m.promotion_commission; id != nil {
			return []ent.Value{*id}
		}
	case promotioncommissionplan.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromotionCommissionPlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromotionCommissionPlanMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromotionCommissionPlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmember {
		edges = append(edges, promotioncommissionplan.EdgeMember)
	}
	if m.clearedpromotion_commission {
		edges = append(edges, promotioncommissionplan.EdgePromotionCommission)
	}
	if m.clearedplan {
		edges = append(edges, promotioncommissionplan.EdgePlan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromotionCommissionPlanMutation) EdgeCleared(name string) bool {
	switch name {
	case promotioncommissionplan.EdgeMember:
		return m.clearedmember
	case promotioncommissionplan.EdgePromotionCommission:
		return m.clearedpromotion_commission
	case promotioncommissionplan.EdgePlan:
		return m.clearedplan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromotionCommissionPlanMutation) ClearEdge(name string) error {
	switch name {
	case promotioncommissionplan.EdgeMember:
		m.ClearMember()
		return nil
	case promotioncommissionplan.EdgePromotionCommission:
		m.ClearPromotionCommission()
		return nil
	case promotioncommissionplan.EdgePlan:
		m.ClearPlan()
		return nil
	}
	return fmt.Errorf("unknown PromotionCommissionPlan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromotionCommissionPlanMutation) ResetEdge(name string) error {
	switch name {
	case promotioncommissionplan.EdgeMember:
		m.ResetMember()
		return nil
	case promotioncommissionplan.EdgePromotionCommission:
		m.ResetPromotionCommission()
		return nil
	case promotioncommissionplan.EdgePlan:
		m.ResetPlan()
		return nil
	}
	return fmt.Errorf("unknown PromotionCommissionPlan edge %s", name)
}

// PromotionEarningsMutation represents an operation that mutates the PromotionEarnings nodes in the graph.
type PromotionEarningsMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uint64
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	creator             **model.Modifier
	last_modifier       **model.Modifier
	remark              *string
	status              *uint8
	addstatus           *int8
	amount              *float64
	addamount           *float64
	commission_rule_key *string
	clearedFields       map[string]struct{}
	commission          *uint64
	clearedcommission   bool
	member              *uint64
	clearedmember       bool
	rider               *uint64
	clearedrider        bool
	_order              *uint64
	cleared_order       bool
	plan                *uint64
	clearedplan         bool
	done                bool
	oldValue            func(context.Context) (*PromotionEarnings, error)
	predicates          []predicate.PromotionEarnings
}

var _ ent.Mutation = (*PromotionEarningsMutation)(nil)

// promotionearningsOption allows management of the mutation configuration using functional options.
type promotionearningsOption func(*PromotionEarningsMutation)

// newPromotionEarningsMutation creates new mutation for the PromotionEarnings entity.
func newPromotionEarningsMutation(c config, op Op, opts ...promotionearningsOption) *PromotionEarningsMutation {
	m := &PromotionEarningsMutation{
		config:        c,
		op:            op,
		typ:           TypePromotionEarnings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionEarningsID sets the ID field of the mutation.
func withPromotionEarningsID(id uint64) promotionearningsOption {
	return func(m *PromotionEarningsMutation) {
		var (
			err   error
			once  sync.Once
			value *PromotionEarnings
		)
		m.oldValue = func(ctx context.Context) (*PromotionEarnings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromotionEarnings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotionEarnings sets the old PromotionEarnings of the mutation.
func withPromotionEarnings(node *PromotionEarnings) promotionearningsOption {
	return func(m *PromotionEarningsMutation) {
		m.oldValue = func(context.Context) (*PromotionEarnings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionEarningsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionEarningsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromotionEarningsMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromotionEarningsMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromotionEarnings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromotionEarningsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromotionEarningsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromotionEarnings entity.
// If the PromotionEarnings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionEarningsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromotionEarningsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromotionEarningsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromotionEarningsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PromotionEarnings entity.
// If the PromotionEarnings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionEarningsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromotionEarningsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PromotionEarningsMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PromotionEarningsMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PromotionEarnings entity.
// If the PromotionEarnings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionEarningsMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PromotionEarningsMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[promotionearnings.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PromotionEarningsMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[promotionearnings.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PromotionEarningsMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, promotionearnings.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *PromotionEarningsMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *PromotionEarningsMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the PromotionEarnings entity.
// If the PromotionEarnings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionEarningsMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *PromotionEarningsMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[promotionearnings.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *PromotionEarningsMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[promotionearnings.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *PromotionEarningsMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, promotionearnings.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *PromotionEarningsMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *PromotionEarningsMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the PromotionEarnings entity.
// If the PromotionEarnings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionEarningsMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *PromotionEarningsMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[promotionearnings.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *PromotionEarningsMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[promotionearnings.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *PromotionEarningsMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, promotionearnings.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *PromotionEarningsMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PromotionEarningsMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the PromotionEarnings entity.
// If the PromotionEarnings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionEarningsMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PromotionEarningsMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[promotionearnings.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PromotionEarningsMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[promotionearnings.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PromotionEarningsMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, promotionearnings.FieldRemark)
}

// SetCommissionID sets the "commission_id" field.
func (m *PromotionEarningsMutation) SetCommissionID(u uint64) {
	m.commission = &u
}

// CommissionID returns the value of the "commission_id" field in the mutation.
func (m *PromotionEarningsMutation) CommissionID() (r uint64, exists bool) {
	v := m.commission
	if v == nil {
		return
	}
	return *v, true
}

// OldCommissionID returns the old "commission_id" field's value of the PromotionEarnings entity.
// If the PromotionEarnings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionEarningsMutation) OldCommissionID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommissionID: %w", err)
	}
	return oldValue.CommissionID, nil
}

// ResetCommissionID resets all changes to the "commission_id" field.
func (m *PromotionEarningsMutation) ResetCommissionID() {
	m.commission = nil
}

// SetMemberID sets the "member_id" field.
func (m *PromotionEarningsMutation) SetMemberID(u uint64) {
	m.member = &u
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *PromotionEarningsMutation) MemberID() (r uint64, exists bool) {
	v := m.member
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the PromotionEarnings entity.
// If the PromotionEarnings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionEarningsMutation) OldMemberID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *PromotionEarningsMutation) ResetMemberID() {
	m.member = nil
}

// SetRiderID sets the "rider_id" field.
func (m *PromotionEarningsMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *PromotionEarningsMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the PromotionEarnings entity.
// If the PromotionEarnings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionEarningsMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *PromotionEarningsMutation) ResetRiderID() {
	m.rider = nil
}

// SetOrderID sets the "order_id" field.
func (m *PromotionEarningsMutation) SetOrderID(u uint64) {
	m._order = &u
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *PromotionEarningsMutation) OrderID() (r uint64, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the PromotionEarnings entity.
// If the PromotionEarnings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionEarningsMutation) OldOrderID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// ClearOrderID clears the value of the "order_id" field.
func (m *PromotionEarningsMutation) ClearOrderID() {
	m._order = nil
	m.clearedFields[promotionearnings.FieldOrderID] = struct{}{}
}

// OrderIDCleared returns if the "order_id" field was cleared in this mutation.
func (m *PromotionEarningsMutation) OrderIDCleared() bool {
	_, ok := m.clearedFields[promotionearnings.FieldOrderID]
	return ok
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *PromotionEarningsMutation) ResetOrderID() {
	m._order = nil
	delete(m.clearedFields, promotionearnings.FieldOrderID)
}

// SetPlanID sets the "plan_id" field.
func (m *PromotionEarningsMutation) SetPlanID(u uint64) {
	m.plan = &u
}

// PlanID returns the value of the "plan_id" field in the mutation.
func (m *PromotionEarningsMutation) PlanID() (r uint64, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanID returns the old "plan_id" field's value of the PromotionEarnings entity.
// If the PromotionEarnings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionEarningsMutation) OldPlanID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanID: %w", err)
	}
	return oldValue.PlanID, nil
}

// ClearPlanID clears the value of the "plan_id" field.
func (m *PromotionEarningsMutation) ClearPlanID() {
	m.plan = nil
	m.clearedFields[promotionearnings.FieldPlanID] = struct{}{}
}

// PlanIDCleared returns if the "plan_id" field was cleared in this mutation.
func (m *PromotionEarningsMutation) PlanIDCleared() bool {
	_, ok := m.clearedFields[promotionearnings.FieldPlanID]
	return ok
}

// ResetPlanID resets all changes to the "plan_id" field.
func (m *PromotionEarningsMutation) ResetPlanID() {
	m.plan = nil
	delete(m.clearedFields, promotionearnings.FieldPlanID)
}

// SetStatus sets the "status" field.
func (m *PromotionEarningsMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *PromotionEarningsMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PromotionEarnings entity.
// If the PromotionEarnings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionEarningsMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *PromotionEarningsMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *PromotionEarningsMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *PromotionEarningsMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetAmount sets the "amount" field.
func (m *PromotionEarningsMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PromotionEarningsMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the PromotionEarnings entity.
// If the PromotionEarnings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionEarningsMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *PromotionEarningsMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PromotionEarningsMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PromotionEarningsMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetCommissionRuleKey sets the "commission_rule_key" field.
func (m *PromotionEarningsMutation) SetCommissionRuleKey(s string) {
	m.commission_rule_key = &s
}

// CommissionRuleKey returns the value of the "commission_rule_key" field in the mutation.
func (m *PromotionEarningsMutation) CommissionRuleKey() (r string, exists bool) {
	v := m.commission_rule_key
	if v == nil {
		return
	}
	return *v, true
}

// OldCommissionRuleKey returns the old "commission_rule_key" field's value of the PromotionEarnings entity.
// If the PromotionEarnings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionEarningsMutation) OldCommissionRuleKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommissionRuleKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommissionRuleKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommissionRuleKey: %w", err)
	}
	return oldValue.CommissionRuleKey, nil
}

// ClearCommissionRuleKey clears the value of the "commission_rule_key" field.
func (m *PromotionEarningsMutation) ClearCommissionRuleKey() {
	m.commission_rule_key = nil
	m.clearedFields[promotionearnings.FieldCommissionRuleKey] = struct{}{}
}

// CommissionRuleKeyCleared returns if the "commission_rule_key" field was cleared in this mutation.
func (m *PromotionEarningsMutation) CommissionRuleKeyCleared() bool {
	_, ok := m.clearedFields[promotionearnings.FieldCommissionRuleKey]
	return ok
}

// ResetCommissionRuleKey resets all changes to the "commission_rule_key" field.
func (m *PromotionEarningsMutation) ResetCommissionRuleKey() {
	m.commission_rule_key = nil
	delete(m.clearedFields, promotionearnings.FieldCommissionRuleKey)
}

// ClearCommission clears the "commission" edge to the PromotionCommission entity.
func (m *PromotionEarningsMutation) ClearCommission() {
	m.clearedcommission = true
	m.clearedFields[promotionearnings.FieldCommissionID] = struct{}{}
}

// CommissionCleared reports if the "commission" edge to the PromotionCommission entity was cleared.
func (m *PromotionEarningsMutation) CommissionCleared() bool {
	return m.clearedcommission
}

// CommissionIDs returns the "commission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommissionID instead. It exists only for internal usage by the builders.
func (m *PromotionEarningsMutation) CommissionIDs() (ids []uint64) {
	if id := m.commission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCommission resets all changes to the "commission" edge.
func (m *PromotionEarningsMutation) ResetCommission() {
	m.commission = nil
	m.clearedcommission = false
}

// ClearMember clears the "member" edge to the PromotionMember entity.
func (m *PromotionEarningsMutation) ClearMember() {
	m.clearedmember = true
	m.clearedFields[promotionearnings.FieldMemberID] = struct{}{}
}

// MemberCleared reports if the "member" edge to the PromotionMember entity was cleared.
func (m *PromotionEarningsMutation) MemberCleared() bool {
	return m.clearedmember
}

// MemberIDs returns the "member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberID instead. It exists only for internal usage by the builders.
func (m *PromotionEarningsMutation) MemberIDs() (ids []uint64) {
	if id := m.member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMember resets all changes to the "member" edge.
func (m *PromotionEarningsMutation) ResetMember() {
	m.member = nil
	m.clearedmember = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *PromotionEarningsMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[promotionearnings.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *PromotionEarningsMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *PromotionEarningsMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *PromotionEarningsMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *PromotionEarningsMutation) ClearOrder() {
	m.cleared_order = true
	m.clearedFields[promotionearnings.FieldOrderID] = struct{}{}
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *PromotionEarningsMutation) OrderCleared() bool {
	return m.OrderIDCleared() || m.cleared_order
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *PromotionEarningsMutation) OrderIDs() (ids []uint64) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *PromotionEarningsMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// ClearPlan clears the "plan" edge to the Plan entity.
func (m *PromotionEarningsMutation) ClearPlan() {
	m.clearedplan = true
	m.clearedFields[promotionearnings.FieldPlanID] = struct{}{}
}

// PlanCleared reports if the "plan" edge to the Plan entity was cleared.
func (m *PromotionEarningsMutation) PlanCleared() bool {
	return m.PlanIDCleared() || m.clearedplan
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *PromotionEarningsMutation) PlanIDs() (ids []uint64) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *PromotionEarningsMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// Where appends a list predicates to the PromotionEarningsMutation builder.
func (m *PromotionEarningsMutation) Where(ps ...predicate.PromotionEarnings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromotionEarningsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromotionEarningsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromotionEarnings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromotionEarningsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromotionEarningsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromotionEarnings).
func (m *PromotionEarningsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromotionEarningsMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, promotionearnings.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, promotionearnings.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, promotionearnings.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, promotionearnings.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, promotionearnings.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, promotionearnings.FieldRemark)
	}
	if m.commission != nil {
		fields = append(fields, promotionearnings.FieldCommissionID)
	}
	if m.member != nil {
		fields = append(fields, promotionearnings.FieldMemberID)
	}
	if m.rider != nil {
		fields = append(fields, promotionearnings.FieldRiderID)
	}
	if m._order != nil {
		fields = append(fields, promotionearnings.FieldOrderID)
	}
	if m.plan != nil {
		fields = append(fields, promotionearnings.FieldPlanID)
	}
	if m.status != nil {
		fields = append(fields, promotionearnings.FieldStatus)
	}
	if m.amount != nil {
		fields = append(fields, promotionearnings.FieldAmount)
	}
	if m.commission_rule_key != nil {
		fields = append(fields, promotionearnings.FieldCommissionRuleKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromotionEarningsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotionearnings.FieldCreatedAt:
		return m.CreatedAt()
	case promotionearnings.FieldUpdatedAt:
		return m.UpdatedAt()
	case promotionearnings.FieldDeletedAt:
		return m.DeletedAt()
	case promotionearnings.FieldCreator:
		return m.Creator()
	case promotionearnings.FieldLastModifier:
		return m.LastModifier()
	case promotionearnings.FieldRemark:
		return m.Remark()
	case promotionearnings.FieldCommissionID:
		return m.CommissionID()
	case promotionearnings.FieldMemberID:
		return m.MemberID()
	case promotionearnings.FieldRiderID:
		return m.RiderID()
	case promotionearnings.FieldOrderID:
		return m.OrderID()
	case promotionearnings.FieldPlanID:
		return m.PlanID()
	case promotionearnings.FieldStatus:
		return m.Status()
	case promotionearnings.FieldAmount:
		return m.Amount()
	case promotionearnings.FieldCommissionRuleKey:
		return m.CommissionRuleKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromotionEarningsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotionearnings.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case promotionearnings.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case promotionearnings.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case promotionearnings.FieldCreator:
		return m.OldCreator(ctx)
	case promotionearnings.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case promotionearnings.FieldRemark:
		return m.OldRemark(ctx)
	case promotionearnings.FieldCommissionID:
		return m.OldCommissionID(ctx)
	case promotionearnings.FieldMemberID:
		return m.OldMemberID(ctx)
	case promotionearnings.FieldRiderID:
		return m.OldRiderID(ctx)
	case promotionearnings.FieldOrderID:
		return m.OldOrderID(ctx)
	case promotionearnings.FieldPlanID:
		return m.OldPlanID(ctx)
	case promotionearnings.FieldStatus:
		return m.OldStatus(ctx)
	case promotionearnings.FieldAmount:
		return m.OldAmount(ctx)
	case promotionearnings.FieldCommissionRuleKey:
		return m.OldCommissionRuleKey(ctx)
	}
	return nil, fmt.Errorf("unknown PromotionEarnings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionEarningsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotionearnings.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case promotionearnings.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case promotionearnings.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case promotionearnings.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case promotionearnings.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case promotionearnings.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case promotionearnings.FieldCommissionID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommissionID(v)
		return nil
	case promotionearnings.FieldMemberID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case promotionearnings.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case promotionearnings.FieldOrderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case promotionearnings.FieldPlanID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanID(v)
		return nil
	case promotionearnings.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case promotionearnings.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case promotionearnings.FieldCommissionRuleKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommissionRuleKey(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionEarnings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromotionEarningsMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, promotionearnings.FieldStatus)
	}
	if m.addamount != nil {
		fields = append(fields, promotionearnings.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromotionEarningsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case promotionearnings.FieldStatus:
		return m.AddedStatus()
	case promotionearnings.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionEarningsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case promotionearnings.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case promotionearnings.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionEarnings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromotionEarningsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promotionearnings.FieldDeletedAt) {
		fields = append(fields, promotionearnings.FieldDeletedAt)
	}
	if m.FieldCleared(promotionearnings.FieldCreator) {
		fields = append(fields, promotionearnings.FieldCreator)
	}
	if m.FieldCleared(promotionearnings.FieldLastModifier) {
		fields = append(fields, promotionearnings.FieldLastModifier)
	}
	if m.FieldCleared(promotionearnings.FieldRemark) {
		fields = append(fields, promotionearnings.FieldRemark)
	}
	if m.FieldCleared(promotionearnings.FieldOrderID) {
		fields = append(fields, promotionearnings.FieldOrderID)
	}
	if m.FieldCleared(promotionearnings.FieldPlanID) {
		fields = append(fields, promotionearnings.FieldPlanID)
	}
	if m.FieldCleared(promotionearnings.FieldCommissionRuleKey) {
		fields = append(fields, promotionearnings.FieldCommissionRuleKey)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromotionEarningsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionEarningsMutation) ClearField(name string) error {
	switch name {
	case promotionearnings.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case promotionearnings.FieldCreator:
		m.ClearCreator()
		return nil
	case promotionearnings.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case promotionearnings.FieldRemark:
		m.ClearRemark()
		return nil
	case promotionearnings.FieldOrderID:
		m.ClearOrderID()
		return nil
	case promotionearnings.FieldPlanID:
		m.ClearPlanID()
		return nil
	case promotionearnings.FieldCommissionRuleKey:
		m.ClearCommissionRuleKey()
		return nil
	}
	return fmt.Errorf("unknown PromotionEarnings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromotionEarningsMutation) ResetField(name string) error {
	switch name {
	case promotionearnings.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case promotionearnings.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case promotionearnings.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case promotionearnings.FieldCreator:
		m.ResetCreator()
		return nil
	case promotionearnings.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case promotionearnings.FieldRemark:
		m.ResetRemark()
		return nil
	case promotionearnings.FieldCommissionID:
		m.ResetCommissionID()
		return nil
	case promotionearnings.FieldMemberID:
		m.ResetMemberID()
		return nil
	case promotionearnings.FieldRiderID:
		m.ResetRiderID()
		return nil
	case promotionearnings.FieldOrderID:
		m.ResetOrderID()
		return nil
	case promotionearnings.FieldPlanID:
		m.ResetPlanID()
		return nil
	case promotionearnings.FieldStatus:
		m.ResetStatus()
		return nil
	case promotionearnings.FieldAmount:
		m.ResetAmount()
		return nil
	case promotionearnings.FieldCommissionRuleKey:
		m.ResetCommissionRuleKey()
		return nil
	}
	return fmt.Errorf("unknown PromotionEarnings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromotionEarningsMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.commission != nil {
		edges = append(edges, promotionearnings.EdgeCommission)
	}
	if m.member != nil {
		edges = append(edges, promotionearnings.EdgeMember)
	}
	if m.rider != nil {
		edges = append(edges, promotionearnings.EdgeRider)
	}
	if m._order != nil {
		edges = append(edges, promotionearnings.EdgeOrder)
	}
	if m.plan != nil {
		edges = append(edges, promotionearnings.EdgePlan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromotionEarningsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promotionearnings.EdgeCommission:
		if id := m.commission; id != nil {
			return []ent.Value{*id}
		}
	case promotionearnings.EdgeMember:
		if id := m.member; id != nil {
			return []ent.Value{*id}
		}
	case promotionearnings.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case promotionearnings.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	case promotionearnings.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromotionEarningsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromotionEarningsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromotionEarningsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcommission {
		edges = append(edges, promotionearnings.EdgeCommission)
	}
	if m.clearedmember {
		edges = append(edges, promotionearnings.EdgeMember)
	}
	if m.clearedrider {
		edges = append(edges, promotionearnings.EdgeRider)
	}
	if m.cleared_order {
		edges = append(edges, promotionearnings.EdgeOrder)
	}
	if m.clearedplan {
		edges = append(edges, promotionearnings.EdgePlan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromotionEarningsMutation) EdgeCleared(name string) bool {
	switch name {
	case promotionearnings.EdgeCommission:
		return m.clearedcommission
	case promotionearnings.EdgeMember:
		return m.clearedmember
	case promotionearnings.EdgeRider:
		return m.clearedrider
	case promotionearnings.EdgeOrder:
		return m.cleared_order
	case promotionearnings.EdgePlan:
		return m.clearedplan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromotionEarningsMutation) ClearEdge(name string) error {
	switch name {
	case promotionearnings.EdgeCommission:
		m.ClearCommission()
		return nil
	case promotionearnings.EdgeMember:
		m.ClearMember()
		return nil
	case promotionearnings.EdgeRider:
		m.ClearRider()
		return nil
	case promotionearnings.EdgeOrder:
		m.ClearOrder()
		return nil
	case promotionearnings.EdgePlan:
		m.ClearPlan()
		return nil
	}
	return fmt.Errorf("unknown PromotionEarnings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromotionEarningsMutation) ResetEdge(name string) error {
	switch name {
	case promotionearnings.EdgeCommission:
		m.ResetCommission()
		return nil
	case promotionearnings.EdgeMember:
		m.ResetMember()
		return nil
	case promotionearnings.EdgeRider:
		m.ResetRider()
		return nil
	case promotionearnings.EdgeOrder:
		m.ResetOrder()
		return nil
	case promotionearnings.EdgePlan:
		m.ResetPlan()
		return nil
	}
	return fmt.Errorf("unknown PromotionEarnings edge %s", name)
}

// PromotionGrowthMutation represents an operation that mutates the PromotionGrowth nodes in the graph.
type PromotionGrowthMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	growth_value    *uint64
	addgrowth_value *int64
	clearedFields   map[string]struct{}
	member          *uint64
	clearedmember   bool
	task            *uint64
	clearedtask     bool
	rider           *uint64
	clearedrider    bool
	done            bool
	oldValue        func(context.Context) (*PromotionGrowth, error)
	predicates      []predicate.PromotionGrowth
}

var _ ent.Mutation = (*PromotionGrowthMutation)(nil)

// promotiongrowthOption allows management of the mutation configuration using functional options.
type promotiongrowthOption func(*PromotionGrowthMutation)

// newPromotionGrowthMutation creates new mutation for the PromotionGrowth entity.
func newPromotionGrowthMutation(c config, op Op, opts ...promotiongrowthOption) *PromotionGrowthMutation {
	m := &PromotionGrowthMutation{
		config:        c,
		op:            op,
		typ:           TypePromotionGrowth,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionGrowthID sets the ID field of the mutation.
func withPromotionGrowthID(id uint64) promotiongrowthOption {
	return func(m *PromotionGrowthMutation) {
		var (
			err   error
			once  sync.Once
			value *PromotionGrowth
		)
		m.oldValue = func(ctx context.Context) (*PromotionGrowth, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromotionGrowth.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotionGrowth sets the old PromotionGrowth of the mutation.
func withPromotionGrowth(node *PromotionGrowth) promotiongrowthOption {
	return func(m *PromotionGrowthMutation) {
		m.oldValue = func(context.Context) (*PromotionGrowth, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionGrowthMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionGrowthMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromotionGrowthMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromotionGrowthMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromotionGrowth.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromotionGrowthMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromotionGrowthMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromotionGrowth entity.
// If the PromotionGrowth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionGrowthMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromotionGrowthMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromotionGrowthMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromotionGrowthMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PromotionGrowth entity.
// If the PromotionGrowth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionGrowthMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromotionGrowthMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PromotionGrowthMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PromotionGrowthMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PromotionGrowth entity.
// If the PromotionGrowth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionGrowthMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PromotionGrowthMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[promotiongrowth.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PromotionGrowthMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[promotiongrowth.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PromotionGrowthMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, promotiongrowth.FieldDeletedAt)
}

// SetMemberID sets the "member_id" field.
func (m *PromotionGrowthMutation) SetMemberID(u uint64) {
	m.member = &u
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *PromotionGrowthMutation) MemberID() (r uint64, exists bool) {
	v := m.member
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the PromotionGrowth entity.
// If the PromotionGrowth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionGrowthMutation) OldMemberID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *PromotionGrowthMutation) ClearMemberID() {
	m.member = nil
	m.clearedFields[promotiongrowth.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *PromotionGrowthMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[promotiongrowth.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *PromotionGrowthMutation) ResetMemberID() {
	m.member = nil
	delete(m.clearedFields, promotiongrowth.FieldMemberID)
}

// SetTaskID sets the "task_id" field.
func (m *PromotionGrowthMutation) SetTaskID(u uint64) {
	m.task = &u
}

// TaskID returns the value of the "task_id" field in the mutation.
func (m *PromotionGrowthMutation) TaskID() (r uint64, exists bool) {
	v := m.task
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskID returns the old "task_id" field's value of the PromotionGrowth entity.
// If the PromotionGrowth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionGrowthMutation) OldTaskID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskID: %w", err)
	}
	return oldValue.TaskID, nil
}

// ClearTaskID clears the value of the "task_id" field.
func (m *PromotionGrowthMutation) ClearTaskID() {
	m.task = nil
	m.clearedFields[promotiongrowth.FieldTaskID] = struct{}{}
}

// TaskIDCleared returns if the "task_id" field was cleared in this mutation.
func (m *PromotionGrowthMutation) TaskIDCleared() bool {
	_, ok := m.clearedFields[promotiongrowth.FieldTaskID]
	return ok
}

// ResetTaskID resets all changes to the "task_id" field.
func (m *PromotionGrowthMutation) ResetTaskID() {
	m.task = nil
	delete(m.clearedFields, promotiongrowth.FieldTaskID)
}

// SetRiderID sets the "rider_id" field.
func (m *PromotionGrowthMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *PromotionGrowthMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the PromotionGrowth entity.
// If the PromotionGrowth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionGrowthMutation) OldRiderID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ClearRiderID clears the value of the "rider_id" field.
func (m *PromotionGrowthMutation) ClearRiderID() {
	m.rider = nil
	m.clearedFields[promotiongrowth.FieldRiderID] = struct{}{}
}

// RiderIDCleared returns if the "rider_id" field was cleared in this mutation.
func (m *PromotionGrowthMutation) RiderIDCleared() bool {
	_, ok := m.clearedFields[promotiongrowth.FieldRiderID]
	return ok
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *PromotionGrowthMutation) ResetRiderID() {
	m.rider = nil
	delete(m.clearedFields, promotiongrowth.FieldRiderID)
}

// SetGrowthValue sets the "growth_value" field.
func (m *PromotionGrowthMutation) SetGrowthValue(u uint64) {
	m.growth_value = &u
	m.addgrowth_value = nil
}

// GrowthValue returns the value of the "growth_value" field in the mutation.
func (m *PromotionGrowthMutation) GrowthValue() (r uint64, exists bool) {
	v := m.growth_value
	if v == nil {
		return
	}
	return *v, true
}

// OldGrowthValue returns the old "growth_value" field's value of the PromotionGrowth entity.
// If the PromotionGrowth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionGrowthMutation) OldGrowthValue(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrowthValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrowthValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrowthValue: %w", err)
	}
	return oldValue.GrowthValue, nil
}

// AddGrowthValue adds u to the "growth_value" field.
func (m *PromotionGrowthMutation) AddGrowthValue(u int64) {
	if m.addgrowth_value != nil {
		*m.addgrowth_value += u
	} else {
		m.addgrowth_value = &u
	}
}

// AddedGrowthValue returns the value that was added to the "growth_value" field in this mutation.
func (m *PromotionGrowthMutation) AddedGrowthValue() (r int64, exists bool) {
	v := m.addgrowth_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetGrowthValue resets all changes to the "growth_value" field.
func (m *PromotionGrowthMutation) ResetGrowthValue() {
	m.growth_value = nil
	m.addgrowth_value = nil
}

// ClearMember clears the "member" edge to the PromotionMember entity.
func (m *PromotionGrowthMutation) ClearMember() {
	m.clearedmember = true
	m.clearedFields[promotiongrowth.FieldMemberID] = struct{}{}
}

// MemberCleared reports if the "member" edge to the PromotionMember entity was cleared.
func (m *PromotionGrowthMutation) MemberCleared() bool {
	return m.MemberIDCleared() || m.clearedmember
}

// MemberIDs returns the "member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberID instead. It exists only for internal usage by the builders.
func (m *PromotionGrowthMutation) MemberIDs() (ids []uint64) {
	if id := m.member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMember resets all changes to the "member" edge.
func (m *PromotionGrowthMutation) ResetMember() {
	m.member = nil
	m.clearedmember = false
}

// ClearTask clears the "task" edge to the PromotionLevelTask entity.
func (m *PromotionGrowthMutation) ClearTask() {
	m.clearedtask = true
	m.clearedFields[promotiongrowth.FieldTaskID] = struct{}{}
}

// TaskCleared reports if the "task" edge to the PromotionLevelTask entity was cleared.
func (m *PromotionGrowthMutation) TaskCleared() bool {
	return m.TaskIDCleared() || m.clearedtask
}

// TaskIDs returns the "task" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TaskID instead. It exists only for internal usage by the builders.
func (m *PromotionGrowthMutation) TaskIDs() (ids []uint64) {
	if id := m.task; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTask resets all changes to the "task" edge.
func (m *PromotionGrowthMutation) ResetTask() {
	m.task = nil
	m.clearedtask = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *PromotionGrowthMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[promotiongrowth.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *PromotionGrowthMutation) RiderCleared() bool {
	return m.RiderIDCleared() || m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *PromotionGrowthMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *PromotionGrowthMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// Where appends a list predicates to the PromotionGrowthMutation builder.
func (m *PromotionGrowthMutation) Where(ps ...predicate.PromotionGrowth) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromotionGrowthMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromotionGrowthMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromotionGrowth, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromotionGrowthMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromotionGrowthMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromotionGrowth).
func (m *PromotionGrowthMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromotionGrowthMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, promotiongrowth.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, promotiongrowth.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, promotiongrowth.FieldDeletedAt)
	}
	if m.member != nil {
		fields = append(fields, promotiongrowth.FieldMemberID)
	}
	if m.task != nil {
		fields = append(fields, promotiongrowth.FieldTaskID)
	}
	if m.rider != nil {
		fields = append(fields, promotiongrowth.FieldRiderID)
	}
	if m.growth_value != nil {
		fields = append(fields, promotiongrowth.FieldGrowthValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromotionGrowthMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotiongrowth.FieldCreatedAt:
		return m.CreatedAt()
	case promotiongrowth.FieldUpdatedAt:
		return m.UpdatedAt()
	case promotiongrowth.FieldDeletedAt:
		return m.DeletedAt()
	case promotiongrowth.FieldMemberID:
		return m.MemberID()
	case promotiongrowth.FieldTaskID:
		return m.TaskID()
	case promotiongrowth.FieldRiderID:
		return m.RiderID()
	case promotiongrowth.FieldGrowthValue:
		return m.GrowthValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromotionGrowthMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotiongrowth.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case promotiongrowth.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case promotiongrowth.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case promotiongrowth.FieldMemberID:
		return m.OldMemberID(ctx)
	case promotiongrowth.FieldTaskID:
		return m.OldTaskID(ctx)
	case promotiongrowth.FieldRiderID:
		return m.OldRiderID(ctx)
	case promotiongrowth.FieldGrowthValue:
		return m.OldGrowthValue(ctx)
	}
	return nil, fmt.Errorf("unknown PromotionGrowth field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionGrowthMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotiongrowth.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case promotiongrowth.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case promotiongrowth.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case promotiongrowth.FieldMemberID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case promotiongrowth.FieldTaskID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskID(v)
		return nil
	case promotiongrowth.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case promotiongrowth.FieldGrowthValue:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrowthValue(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionGrowth field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromotionGrowthMutation) AddedFields() []string {
	var fields []string
	if m.addgrowth_value != nil {
		fields = append(fields, promotiongrowth.FieldGrowthValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromotionGrowthMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case promotiongrowth.FieldGrowthValue:
		return m.AddedGrowthValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionGrowthMutation) AddField(name string, value ent.Value) error {
	switch name {
	case promotiongrowth.FieldGrowthValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGrowthValue(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionGrowth numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromotionGrowthMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promotiongrowth.FieldDeletedAt) {
		fields = append(fields, promotiongrowth.FieldDeletedAt)
	}
	if m.FieldCleared(promotiongrowth.FieldMemberID) {
		fields = append(fields, promotiongrowth.FieldMemberID)
	}
	if m.FieldCleared(promotiongrowth.FieldTaskID) {
		fields = append(fields, promotiongrowth.FieldTaskID)
	}
	if m.FieldCleared(promotiongrowth.FieldRiderID) {
		fields = append(fields, promotiongrowth.FieldRiderID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromotionGrowthMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionGrowthMutation) ClearField(name string) error {
	switch name {
	case promotiongrowth.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case promotiongrowth.FieldMemberID:
		m.ClearMemberID()
		return nil
	case promotiongrowth.FieldTaskID:
		m.ClearTaskID()
		return nil
	case promotiongrowth.FieldRiderID:
		m.ClearRiderID()
		return nil
	}
	return fmt.Errorf("unknown PromotionGrowth nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromotionGrowthMutation) ResetField(name string) error {
	switch name {
	case promotiongrowth.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case promotiongrowth.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case promotiongrowth.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case promotiongrowth.FieldMemberID:
		m.ResetMemberID()
		return nil
	case promotiongrowth.FieldTaskID:
		m.ResetTaskID()
		return nil
	case promotiongrowth.FieldRiderID:
		m.ResetRiderID()
		return nil
	case promotiongrowth.FieldGrowthValue:
		m.ResetGrowthValue()
		return nil
	}
	return fmt.Errorf("unknown PromotionGrowth field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromotionGrowthMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.member != nil {
		edges = append(edges, promotiongrowth.EdgeMember)
	}
	if m.task != nil {
		edges = append(edges, promotiongrowth.EdgeTask)
	}
	if m.rider != nil {
		edges = append(edges, promotiongrowth.EdgeRider)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromotionGrowthMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promotiongrowth.EdgeMember:
		if id := m.member; id != nil {
			return []ent.Value{*id}
		}
	case promotiongrowth.EdgeTask:
		if id := m.task; id != nil {
			return []ent.Value{*id}
		}
	case promotiongrowth.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromotionGrowthMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromotionGrowthMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromotionGrowthMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmember {
		edges = append(edges, promotiongrowth.EdgeMember)
	}
	if m.clearedtask {
		edges = append(edges, promotiongrowth.EdgeTask)
	}
	if m.clearedrider {
		edges = append(edges, promotiongrowth.EdgeRider)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromotionGrowthMutation) EdgeCleared(name string) bool {
	switch name {
	case promotiongrowth.EdgeMember:
		return m.clearedmember
	case promotiongrowth.EdgeTask:
		return m.clearedtask
	case promotiongrowth.EdgeRider:
		return m.clearedrider
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromotionGrowthMutation) ClearEdge(name string) error {
	switch name {
	case promotiongrowth.EdgeMember:
		m.ClearMember()
		return nil
	case promotiongrowth.EdgeTask:
		m.ClearTask()
		return nil
	case promotiongrowth.EdgeRider:
		m.ClearRider()
		return nil
	}
	return fmt.Errorf("unknown PromotionGrowth unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromotionGrowthMutation) ResetEdge(name string) error {
	switch name {
	case promotiongrowth.EdgeMember:
		m.ResetMember()
		return nil
	case promotiongrowth.EdgeTask:
		m.ResetTask()
		return nil
	case promotiongrowth.EdgeRider:
		m.ResetRider()
		return nil
	}
	return fmt.Errorf("unknown PromotionGrowth edge %s", name)
}

// PromotionLevelMutation represents an operation that mutates the PromotionLevel nodes in the graph.
type PromotionLevelMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uint64
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	creator             **model.Modifier
	last_modifier       **model.Modifier
	remark              *string
	level               *uint64
	addlevel            *int64
	growth_value        *uint64
	addgrowth_value     *int64
	commission_ratio    *float64
	addcommission_ratio *float64
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*PromotionLevel, error)
	predicates          []predicate.PromotionLevel
}

var _ ent.Mutation = (*PromotionLevelMutation)(nil)

// promotionlevelOption allows management of the mutation configuration using functional options.
type promotionlevelOption func(*PromotionLevelMutation)

// newPromotionLevelMutation creates new mutation for the PromotionLevel entity.
func newPromotionLevelMutation(c config, op Op, opts ...promotionlevelOption) *PromotionLevelMutation {
	m := &PromotionLevelMutation{
		config:        c,
		op:            op,
		typ:           TypePromotionLevel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionLevelID sets the ID field of the mutation.
func withPromotionLevelID(id uint64) promotionlevelOption {
	return func(m *PromotionLevelMutation) {
		var (
			err   error
			once  sync.Once
			value *PromotionLevel
		)
		m.oldValue = func(ctx context.Context) (*PromotionLevel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromotionLevel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotionLevel sets the old PromotionLevel of the mutation.
func withPromotionLevel(node *PromotionLevel) promotionlevelOption {
	return func(m *PromotionLevelMutation) {
		m.oldValue = func(context.Context) (*PromotionLevel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionLevelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionLevelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromotionLevelMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromotionLevelMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromotionLevel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromotionLevelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromotionLevelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromotionLevel entity.
// If the PromotionLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionLevelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromotionLevelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromotionLevelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromotionLevelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PromotionLevel entity.
// If the PromotionLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionLevelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromotionLevelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PromotionLevelMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PromotionLevelMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PromotionLevel entity.
// If the PromotionLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionLevelMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PromotionLevelMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[promotionlevel.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PromotionLevelMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[promotionlevel.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PromotionLevelMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, promotionlevel.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *PromotionLevelMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *PromotionLevelMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the PromotionLevel entity.
// If the PromotionLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionLevelMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *PromotionLevelMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[promotionlevel.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *PromotionLevelMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[promotionlevel.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *PromotionLevelMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, promotionlevel.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *PromotionLevelMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *PromotionLevelMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the PromotionLevel entity.
// If the PromotionLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionLevelMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *PromotionLevelMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[promotionlevel.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *PromotionLevelMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[promotionlevel.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *PromotionLevelMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, promotionlevel.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *PromotionLevelMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PromotionLevelMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the PromotionLevel entity.
// If the PromotionLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionLevelMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PromotionLevelMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[promotionlevel.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PromotionLevelMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[promotionlevel.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PromotionLevelMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, promotionlevel.FieldRemark)
}

// SetLevel sets the "level" field.
func (m *PromotionLevelMutation) SetLevel(u uint64) {
	m.level = &u
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *PromotionLevelMutation) Level() (r uint64, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the PromotionLevel entity.
// If the PromotionLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionLevelMutation) OldLevel(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds u to the "level" field.
func (m *PromotionLevelMutation) AddLevel(u int64) {
	if m.addlevel != nil {
		*m.addlevel += u
	} else {
		m.addlevel = &u
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *PromotionLevelMutation) AddedLevel() (r int64, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *PromotionLevelMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetGrowthValue sets the "growth_value" field.
func (m *PromotionLevelMutation) SetGrowthValue(u uint64) {
	m.growth_value = &u
	m.addgrowth_value = nil
}

// GrowthValue returns the value of the "growth_value" field in the mutation.
func (m *PromotionLevelMutation) GrowthValue() (r uint64, exists bool) {
	v := m.growth_value
	if v == nil {
		return
	}
	return *v, true
}

// OldGrowthValue returns the old "growth_value" field's value of the PromotionLevel entity.
// If the PromotionLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionLevelMutation) OldGrowthValue(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrowthValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrowthValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrowthValue: %w", err)
	}
	return oldValue.GrowthValue, nil
}

// AddGrowthValue adds u to the "growth_value" field.
func (m *PromotionLevelMutation) AddGrowthValue(u int64) {
	if m.addgrowth_value != nil {
		*m.addgrowth_value += u
	} else {
		m.addgrowth_value = &u
	}
}

// AddedGrowthValue returns the value that was added to the "growth_value" field in this mutation.
func (m *PromotionLevelMutation) AddedGrowthValue() (r int64, exists bool) {
	v := m.addgrowth_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetGrowthValue resets all changes to the "growth_value" field.
func (m *PromotionLevelMutation) ResetGrowthValue() {
	m.growth_value = nil
	m.addgrowth_value = nil
}

// SetCommissionRatio sets the "commission_ratio" field.
func (m *PromotionLevelMutation) SetCommissionRatio(f float64) {
	m.commission_ratio = &f
	m.addcommission_ratio = nil
}

// CommissionRatio returns the value of the "commission_ratio" field in the mutation.
func (m *PromotionLevelMutation) CommissionRatio() (r float64, exists bool) {
	v := m.commission_ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldCommissionRatio returns the old "commission_ratio" field's value of the PromotionLevel entity.
// If the PromotionLevel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionLevelMutation) OldCommissionRatio(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommissionRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommissionRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommissionRatio: %w", err)
	}
	return oldValue.CommissionRatio, nil
}

// AddCommissionRatio adds f to the "commission_ratio" field.
func (m *PromotionLevelMutation) AddCommissionRatio(f float64) {
	if m.addcommission_ratio != nil {
		*m.addcommission_ratio += f
	} else {
		m.addcommission_ratio = &f
	}
}

// AddedCommissionRatio returns the value that was added to the "commission_ratio" field in this mutation.
func (m *PromotionLevelMutation) AddedCommissionRatio() (r float64, exists bool) {
	v := m.addcommission_ratio
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommissionRatio resets all changes to the "commission_ratio" field.
func (m *PromotionLevelMutation) ResetCommissionRatio() {
	m.commission_ratio = nil
	m.addcommission_ratio = nil
}

// Where appends a list predicates to the PromotionLevelMutation builder.
func (m *PromotionLevelMutation) Where(ps ...predicate.PromotionLevel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromotionLevelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromotionLevelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromotionLevel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromotionLevelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromotionLevelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromotionLevel).
func (m *PromotionLevelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromotionLevelMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, promotionlevel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, promotionlevel.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, promotionlevel.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, promotionlevel.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, promotionlevel.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, promotionlevel.FieldRemark)
	}
	if m.level != nil {
		fields = append(fields, promotionlevel.FieldLevel)
	}
	if m.growth_value != nil {
		fields = append(fields, promotionlevel.FieldGrowthValue)
	}
	if m.commission_ratio != nil {
		fields = append(fields, promotionlevel.FieldCommissionRatio)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromotionLevelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotionlevel.FieldCreatedAt:
		return m.CreatedAt()
	case promotionlevel.FieldUpdatedAt:
		return m.UpdatedAt()
	case promotionlevel.FieldDeletedAt:
		return m.DeletedAt()
	case promotionlevel.FieldCreator:
		return m.Creator()
	case promotionlevel.FieldLastModifier:
		return m.LastModifier()
	case promotionlevel.FieldRemark:
		return m.Remark()
	case promotionlevel.FieldLevel:
		return m.Level()
	case promotionlevel.FieldGrowthValue:
		return m.GrowthValue()
	case promotionlevel.FieldCommissionRatio:
		return m.CommissionRatio()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromotionLevelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotionlevel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case promotionlevel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case promotionlevel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case promotionlevel.FieldCreator:
		return m.OldCreator(ctx)
	case promotionlevel.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case promotionlevel.FieldRemark:
		return m.OldRemark(ctx)
	case promotionlevel.FieldLevel:
		return m.OldLevel(ctx)
	case promotionlevel.FieldGrowthValue:
		return m.OldGrowthValue(ctx)
	case promotionlevel.FieldCommissionRatio:
		return m.OldCommissionRatio(ctx)
	}
	return nil, fmt.Errorf("unknown PromotionLevel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionLevelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotionlevel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case promotionlevel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case promotionlevel.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case promotionlevel.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case promotionlevel.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case promotionlevel.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case promotionlevel.FieldLevel:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case promotionlevel.FieldGrowthValue:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrowthValue(v)
		return nil
	case promotionlevel.FieldCommissionRatio:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommissionRatio(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionLevel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromotionLevelMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, promotionlevel.FieldLevel)
	}
	if m.addgrowth_value != nil {
		fields = append(fields, promotionlevel.FieldGrowthValue)
	}
	if m.addcommission_ratio != nil {
		fields = append(fields, promotionlevel.FieldCommissionRatio)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromotionLevelMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case promotionlevel.FieldLevel:
		return m.AddedLevel()
	case promotionlevel.FieldGrowthValue:
		return m.AddedGrowthValue()
	case promotionlevel.FieldCommissionRatio:
		return m.AddedCommissionRatio()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionLevelMutation) AddField(name string, value ent.Value) error {
	switch name {
	case promotionlevel.FieldLevel:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case promotionlevel.FieldGrowthValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGrowthValue(v)
		return nil
	case promotionlevel.FieldCommissionRatio:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommissionRatio(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionLevel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromotionLevelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promotionlevel.FieldDeletedAt) {
		fields = append(fields, promotionlevel.FieldDeletedAt)
	}
	if m.FieldCleared(promotionlevel.FieldCreator) {
		fields = append(fields, promotionlevel.FieldCreator)
	}
	if m.FieldCleared(promotionlevel.FieldLastModifier) {
		fields = append(fields, promotionlevel.FieldLastModifier)
	}
	if m.FieldCleared(promotionlevel.FieldRemark) {
		fields = append(fields, promotionlevel.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromotionLevelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionLevelMutation) ClearField(name string) error {
	switch name {
	case promotionlevel.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case promotionlevel.FieldCreator:
		m.ClearCreator()
		return nil
	case promotionlevel.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case promotionlevel.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown PromotionLevel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromotionLevelMutation) ResetField(name string) error {
	switch name {
	case promotionlevel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case promotionlevel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case promotionlevel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case promotionlevel.FieldCreator:
		m.ResetCreator()
		return nil
	case promotionlevel.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case promotionlevel.FieldRemark:
		m.ResetRemark()
		return nil
	case promotionlevel.FieldLevel:
		m.ResetLevel()
		return nil
	case promotionlevel.FieldGrowthValue:
		m.ResetGrowthValue()
		return nil
	case promotionlevel.FieldCommissionRatio:
		m.ResetCommissionRatio()
		return nil
	}
	return fmt.Errorf("unknown PromotionLevel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromotionLevelMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromotionLevelMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromotionLevelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromotionLevelMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromotionLevelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromotionLevelMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromotionLevelMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PromotionLevel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromotionLevelMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PromotionLevel edge %s", name)
}

// PromotionLevelTaskMutation represents an operation that mutates the PromotionLevelTask nodes in the graph.
type PromotionLevelTaskMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	creator         **model.Modifier
	last_modifier   **model.Modifier
	remark          *string
	name            *string
	description     *string
	_type           *uint8
	add_type        *int8
	growth_value    *uint64
	addgrowth_value *int64
	key             *string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*PromotionLevelTask, error)
	predicates      []predicate.PromotionLevelTask
}

var _ ent.Mutation = (*PromotionLevelTaskMutation)(nil)

// promotionleveltaskOption allows management of the mutation configuration using functional options.
type promotionleveltaskOption func(*PromotionLevelTaskMutation)

// newPromotionLevelTaskMutation creates new mutation for the PromotionLevelTask entity.
func newPromotionLevelTaskMutation(c config, op Op, opts ...promotionleveltaskOption) *PromotionLevelTaskMutation {
	m := &PromotionLevelTaskMutation{
		config:        c,
		op:            op,
		typ:           TypePromotionLevelTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionLevelTaskID sets the ID field of the mutation.
func withPromotionLevelTaskID(id uint64) promotionleveltaskOption {
	return func(m *PromotionLevelTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *PromotionLevelTask
		)
		m.oldValue = func(ctx context.Context) (*PromotionLevelTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromotionLevelTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotionLevelTask sets the old PromotionLevelTask of the mutation.
func withPromotionLevelTask(node *PromotionLevelTask) promotionleveltaskOption {
	return func(m *PromotionLevelTaskMutation) {
		m.oldValue = func(context.Context) (*PromotionLevelTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionLevelTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionLevelTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromotionLevelTaskMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromotionLevelTaskMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromotionLevelTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromotionLevelTaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromotionLevelTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromotionLevelTask entity.
// If the PromotionLevelTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionLevelTaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromotionLevelTaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromotionLevelTaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromotionLevelTaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PromotionLevelTask entity.
// If the PromotionLevelTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionLevelTaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromotionLevelTaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreator sets the "creator" field.
func (m *PromotionLevelTaskMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *PromotionLevelTaskMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the PromotionLevelTask entity.
// If the PromotionLevelTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionLevelTaskMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *PromotionLevelTaskMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[promotionleveltask.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *PromotionLevelTaskMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[promotionleveltask.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *PromotionLevelTaskMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, promotionleveltask.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *PromotionLevelTaskMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *PromotionLevelTaskMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the PromotionLevelTask entity.
// If the PromotionLevelTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionLevelTaskMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *PromotionLevelTaskMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[promotionleveltask.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *PromotionLevelTaskMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[promotionleveltask.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *PromotionLevelTaskMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, promotionleveltask.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *PromotionLevelTaskMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PromotionLevelTaskMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the PromotionLevelTask entity.
// If the PromotionLevelTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionLevelTaskMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PromotionLevelTaskMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[promotionleveltask.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PromotionLevelTaskMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[promotionleveltask.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PromotionLevelTaskMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, promotionleveltask.FieldRemark)
}

// SetName sets the "name" field.
func (m *PromotionLevelTaskMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PromotionLevelTaskMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PromotionLevelTask entity.
// If the PromotionLevelTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionLevelTaskMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PromotionLevelTaskMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PromotionLevelTaskMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PromotionLevelTaskMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PromotionLevelTask entity.
// If the PromotionLevelTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionLevelTaskMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PromotionLevelTaskMutation) ResetDescription() {
	m.description = nil
}

// SetType sets the "type" field.
func (m *PromotionLevelTaskMutation) SetType(u uint8) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *PromotionLevelTaskMutation) GetType() (r uint8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PromotionLevelTask entity.
// If the PromotionLevelTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionLevelTaskMutation) OldType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *PromotionLevelTaskMutation) AddType(u int8) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *PromotionLevelTaskMutation) AddedType() (r int8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *PromotionLevelTaskMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetGrowthValue sets the "growth_value" field.
func (m *PromotionLevelTaskMutation) SetGrowthValue(u uint64) {
	m.growth_value = &u
	m.addgrowth_value = nil
}

// GrowthValue returns the value of the "growth_value" field in the mutation.
func (m *PromotionLevelTaskMutation) GrowthValue() (r uint64, exists bool) {
	v := m.growth_value
	if v == nil {
		return
	}
	return *v, true
}

// OldGrowthValue returns the old "growth_value" field's value of the PromotionLevelTask entity.
// If the PromotionLevelTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionLevelTaskMutation) OldGrowthValue(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGrowthValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGrowthValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGrowthValue: %w", err)
	}
	return oldValue.GrowthValue, nil
}

// AddGrowthValue adds u to the "growth_value" field.
func (m *PromotionLevelTaskMutation) AddGrowthValue(u int64) {
	if m.addgrowth_value != nil {
		*m.addgrowth_value += u
	} else {
		m.addgrowth_value = &u
	}
}

// AddedGrowthValue returns the value that was added to the "growth_value" field in this mutation.
func (m *PromotionLevelTaskMutation) AddedGrowthValue() (r int64, exists bool) {
	v := m.addgrowth_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetGrowthValue resets all changes to the "growth_value" field.
func (m *PromotionLevelTaskMutation) ResetGrowthValue() {
	m.growth_value = nil
	m.addgrowth_value = nil
}

// SetKey sets the "key" field.
func (m *PromotionLevelTaskMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *PromotionLevelTaskMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the PromotionLevelTask entity.
// If the PromotionLevelTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionLevelTaskMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ClearKey clears the value of the "key" field.
func (m *PromotionLevelTaskMutation) ClearKey() {
	m.key = nil
	m.clearedFields[promotionleveltask.FieldKey] = struct{}{}
}

// KeyCleared returns if the "key" field was cleared in this mutation.
func (m *PromotionLevelTaskMutation) KeyCleared() bool {
	_, ok := m.clearedFields[promotionleveltask.FieldKey]
	return ok
}

// ResetKey resets all changes to the "key" field.
func (m *PromotionLevelTaskMutation) ResetKey() {
	m.key = nil
	delete(m.clearedFields, promotionleveltask.FieldKey)
}

// Where appends a list predicates to the PromotionLevelTaskMutation builder.
func (m *PromotionLevelTaskMutation) Where(ps ...predicate.PromotionLevelTask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromotionLevelTaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromotionLevelTaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromotionLevelTask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromotionLevelTaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromotionLevelTaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromotionLevelTask).
func (m *PromotionLevelTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromotionLevelTaskMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, promotionleveltask.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, promotionleveltask.FieldUpdatedAt)
	}
	if m.creator != nil {
		fields = append(fields, promotionleveltask.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, promotionleveltask.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, promotionleveltask.FieldRemark)
	}
	if m.name != nil {
		fields = append(fields, promotionleveltask.FieldName)
	}
	if m.description != nil {
		fields = append(fields, promotionleveltask.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, promotionleveltask.FieldType)
	}
	if m.growth_value != nil {
		fields = append(fields, promotionleveltask.FieldGrowthValue)
	}
	if m.key != nil {
		fields = append(fields, promotionleveltask.FieldKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromotionLevelTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotionleveltask.FieldCreatedAt:
		return m.CreatedAt()
	case promotionleveltask.FieldUpdatedAt:
		return m.UpdatedAt()
	case promotionleveltask.FieldCreator:
		return m.Creator()
	case promotionleveltask.FieldLastModifier:
		return m.LastModifier()
	case promotionleveltask.FieldRemark:
		return m.Remark()
	case promotionleveltask.FieldName:
		return m.Name()
	case promotionleveltask.FieldDescription:
		return m.Description()
	case promotionleveltask.FieldType:
		return m.GetType()
	case promotionleveltask.FieldGrowthValue:
		return m.GrowthValue()
	case promotionleveltask.FieldKey:
		return m.Key()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromotionLevelTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotionleveltask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case promotionleveltask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case promotionleveltask.FieldCreator:
		return m.OldCreator(ctx)
	case promotionleveltask.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case promotionleveltask.FieldRemark:
		return m.OldRemark(ctx)
	case promotionleveltask.FieldName:
		return m.OldName(ctx)
	case promotionleveltask.FieldDescription:
		return m.OldDescription(ctx)
	case promotionleveltask.FieldType:
		return m.OldType(ctx)
	case promotionleveltask.FieldGrowthValue:
		return m.OldGrowthValue(ctx)
	case promotionleveltask.FieldKey:
		return m.OldKey(ctx)
	}
	return nil, fmt.Errorf("unknown PromotionLevelTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionLevelTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotionleveltask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case promotionleveltask.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case promotionleveltask.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case promotionleveltask.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case promotionleveltask.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case promotionleveltask.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case promotionleveltask.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case promotionleveltask.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case promotionleveltask.FieldGrowthValue:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGrowthValue(v)
		return nil
	case promotionleveltask.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionLevelTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromotionLevelTaskMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, promotionleveltask.FieldType)
	}
	if m.addgrowth_value != nil {
		fields = append(fields, promotionleveltask.FieldGrowthValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromotionLevelTaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case promotionleveltask.FieldType:
		return m.AddedType()
	case promotionleveltask.FieldGrowthValue:
		return m.AddedGrowthValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionLevelTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case promotionleveltask.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case promotionleveltask.FieldGrowthValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGrowthValue(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionLevelTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromotionLevelTaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promotionleveltask.FieldCreator) {
		fields = append(fields, promotionleveltask.FieldCreator)
	}
	if m.FieldCleared(promotionleveltask.FieldLastModifier) {
		fields = append(fields, promotionleveltask.FieldLastModifier)
	}
	if m.FieldCleared(promotionleveltask.FieldRemark) {
		fields = append(fields, promotionleveltask.FieldRemark)
	}
	if m.FieldCleared(promotionleveltask.FieldKey) {
		fields = append(fields, promotionleveltask.FieldKey)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromotionLevelTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionLevelTaskMutation) ClearField(name string) error {
	switch name {
	case promotionleveltask.FieldCreator:
		m.ClearCreator()
		return nil
	case promotionleveltask.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case promotionleveltask.FieldRemark:
		m.ClearRemark()
		return nil
	case promotionleveltask.FieldKey:
		m.ClearKey()
		return nil
	}
	return fmt.Errorf("unknown PromotionLevelTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromotionLevelTaskMutation) ResetField(name string) error {
	switch name {
	case promotionleveltask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case promotionleveltask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case promotionleveltask.FieldCreator:
		m.ResetCreator()
		return nil
	case promotionleveltask.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case promotionleveltask.FieldRemark:
		m.ResetRemark()
		return nil
	case promotionleveltask.FieldName:
		m.ResetName()
		return nil
	case promotionleveltask.FieldDescription:
		m.ResetDescription()
		return nil
	case promotionleveltask.FieldType:
		m.ResetType()
		return nil
	case promotionleveltask.FieldGrowthValue:
		m.ResetGrowthValue()
		return nil
	case promotionleveltask.FieldKey:
		m.ResetKey()
		return nil
	}
	return fmt.Errorf("unknown PromotionLevelTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromotionLevelTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromotionLevelTaskMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromotionLevelTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromotionLevelTaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromotionLevelTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromotionLevelTaskMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromotionLevelTaskMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PromotionLevelTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromotionLevelTaskMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PromotionLevelTask edge %s", name)
}

// PromotionMemberMutation represents an operation that mutates the PromotionMember nodes in the graph.
type PromotionMemberMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uint64
	created_at              *time.Time
	updated_at              *time.Time
	deleted_at              *time.Time
	creator                 **model.Modifier
	last_modifier           **model.Modifier
	remark                  *string
	phone                   *string
	name                    *string
	balance                 *float64
	addbalance              *float64
	frozen                  *float64
	addfrozen               *float64
	total_growth_value      *uint64
	addtotal_growth_value   *int64
	current_growth_value    *uint64
	addcurrent_growth_value *int64
	enable                  *bool
	avatar_url              *string
	new_sign_count          *uint64
	addnew_sign_count       *int64
	renew_count             *uint64
	addrenew_count          *int64
	clearedFields           map[string]struct{}
	rider                   *uint64
	clearedrider            bool
	subscribe               *uint64
	clearedsubscribe        bool
	level                   *uint64
	clearedlevel            bool
	referrals               map[uint64]struct{}
	removedreferrals        map[uint64]struct{}
	clearedreferrals        bool
	referred                *uint64
	clearedreferred         bool
	person                  *uint64
	clearedperson           bool
	cards                   map[uint64]struct{}
	removedcards            map[uint64]struct{}
	clearedcards            bool
	commissions             map[uint64]struct{}
	removedcommissions      map[uint64]struct{}
	clearedcommissions      bool
	done                    bool
	oldValue                func(context.Context) (*PromotionMember, error)
	predicates              []predicate.PromotionMember
}

var _ ent.Mutation = (*PromotionMemberMutation)(nil)

// promotionmemberOption allows management of the mutation configuration using functional options.
type promotionmemberOption func(*PromotionMemberMutation)

// newPromotionMemberMutation creates new mutation for the PromotionMember entity.
func newPromotionMemberMutation(c config, op Op, opts ...promotionmemberOption) *PromotionMemberMutation {
	m := &PromotionMemberMutation{
		config:        c,
		op:            op,
		typ:           TypePromotionMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionMemberID sets the ID field of the mutation.
func withPromotionMemberID(id uint64) promotionmemberOption {
	return func(m *PromotionMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *PromotionMember
		)
		m.oldValue = func(ctx context.Context) (*PromotionMember, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromotionMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotionMember sets the old PromotionMember of the mutation.
func withPromotionMember(node *PromotionMember) promotionmemberOption {
	return func(m *PromotionMemberMutation) {
		m.oldValue = func(context.Context) (*PromotionMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromotionMemberMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromotionMemberMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromotionMember.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromotionMemberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromotionMemberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromotionMember entity.
// If the PromotionMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromotionMemberMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromotionMemberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromotionMemberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PromotionMember entity.
// If the PromotionMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromotionMemberMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PromotionMemberMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PromotionMemberMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PromotionMember entity.
// If the PromotionMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PromotionMemberMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[promotionmember.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PromotionMemberMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[promotionmember.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PromotionMemberMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, promotionmember.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *PromotionMemberMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *PromotionMemberMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the PromotionMember entity.
// If the PromotionMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *PromotionMemberMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[promotionmember.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *PromotionMemberMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[promotionmember.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *PromotionMemberMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, promotionmember.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *PromotionMemberMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *PromotionMemberMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the PromotionMember entity.
// If the PromotionMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *PromotionMemberMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[promotionmember.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *PromotionMemberMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[promotionmember.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *PromotionMemberMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, promotionmember.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *PromotionMemberMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PromotionMemberMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the PromotionMember entity.
// If the PromotionMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PromotionMemberMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[promotionmember.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PromotionMemberMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[promotionmember.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PromotionMemberMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, promotionmember.FieldRemark)
}

// SetRiderID sets the "rider_id" field.
func (m *PromotionMemberMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *PromotionMemberMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the PromotionMember entity.
// If the PromotionMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberMutation) OldRiderID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ClearRiderID clears the value of the "rider_id" field.
func (m *PromotionMemberMutation) ClearRiderID() {
	m.rider = nil
	m.clearedFields[promotionmember.FieldRiderID] = struct{}{}
}

// RiderIDCleared returns if the "rider_id" field was cleared in this mutation.
func (m *PromotionMemberMutation) RiderIDCleared() bool {
	_, ok := m.clearedFields[promotionmember.FieldRiderID]
	return ok
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *PromotionMemberMutation) ResetRiderID() {
	m.rider = nil
	delete(m.clearedFields, promotionmember.FieldRiderID)
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *PromotionMemberMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *PromotionMemberMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the PromotionMember entity.
// If the PromotionMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberMutation) OldSubscribeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ClearSubscribeID clears the value of the "subscribe_id" field.
func (m *PromotionMemberMutation) ClearSubscribeID() {
	m.subscribe = nil
	m.clearedFields[promotionmember.FieldSubscribeID] = struct{}{}
}

// SubscribeIDCleared returns if the "subscribe_id" field was cleared in this mutation.
func (m *PromotionMemberMutation) SubscribeIDCleared() bool {
	_, ok := m.clearedFields[promotionmember.FieldSubscribeID]
	return ok
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *PromotionMemberMutation) ResetSubscribeID() {
	m.subscribe = nil
	delete(m.clearedFields, promotionmember.FieldSubscribeID)
}

// SetLevelID sets the "level_id" field.
func (m *PromotionMemberMutation) SetLevelID(u uint64) {
	m.level = &u
}

// LevelID returns the value of the "level_id" field in the mutation.
func (m *PromotionMemberMutation) LevelID() (r uint64, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevelID returns the old "level_id" field's value of the PromotionMember entity.
// If the PromotionMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberMutation) OldLevelID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevelID: %w", err)
	}
	return oldValue.LevelID, nil
}

// ClearLevelID clears the value of the "level_id" field.
func (m *PromotionMemberMutation) ClearLevelID() {
	m.level = nil
	m.clearedFields[promotionmember.FieldLevelID] = struct{}{}
}

// LevelIDCleared returns if the "level_id" field was cleared in this mutation.
func (m *PromotionMemberMutation) LevelIDCleared() bool {
	_, ok := m.clearedFields[promotionmember.FieldLevelID]
	return ok
}

// ResetLevelID resets all changes to the "level_id" field.
func (m *PromotionMemberMutation) ResetLevelID() {
	m.level = nil
	delete(m.clearedFields, promotionmember.FieldLevelID)
}

// SetPhone sets the "phone" field.
func (m *PromotionMemberMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *PromotionMemberMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the PromotionMember entity.
// If the PromotionMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *PromotionMemberMutation) ResetPhone() {
	m.phone = nil
}

// SetName sets the "name" field.
func (m *PromotionMemberMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PromotionMemberMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PromotionMember entity.
// If the PromotionMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *PromotionMemberMutation) ClearName() {
	m.name = nil
	m.clearedFields[promotionmember.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *PromotionMemberMutation) NameCleared() bool {
	_, ok := m.clearedFields[promotionmember.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *PromotionMemberMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, promotionmember.FieldName)
}

// SetBalance sets the "balance" field.
func (m *PromotionMemberMutation) SetBalance(f float64) {
	m.balance = &f
	m.addbalance = nil
}

// Balance returns the value of the "balance" field in the mutation.
func (m *PromotionMemberMutation) Balance() (r float64, exists bool) {
	v := m.balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "balance" field's value of the PromotionMember entity.
// If the PromotionMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberMutation) OldBalance(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "balance" field.
func (m *PromotionMemberMutation) AddBalance(f float64) {
	if m.addbalance != nil {
		*m.addbalance += f
	} else {
		m.addbalance = &f
	}
}

// AddedBalance returns the value that was added to the "balance" field in this mutation.
func (m *PromotionMemberMutation) AddedBalance() (r float64, exists bool) {
	v := m.addbalance
	if v == nil {
		return
	}
	return *v, true
}

// ResetBalance resets all changes to the "balance" field.
func (m *PromotionMemberMutation) ResetBalance() {
	m.balance = nil
	m.addbalance = nil
}

// SetFrozen sets the "frozen" field.
func (m *PromotionMemberMutation) SetFrozen(f float64) {
	m.frozen = &f
	m.addfrozen = nil
}

// Frozen returns the value of the "frozen" field in the mutation.
func (m *PromotionMemberMutation) Frozen() (r float64, exists bool) {
	v := m.frozen
	if v == nil {
		return
	}
	return *v, true
}

// OldFrozen returns the old "frozen" field's value of the PromotionMember entity.
// If the PromotionMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberMutation) OldFrozen(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrozen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrozen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrozen: %w", err)
	}
	return oldValue.Frozen, nil
}

// AddFrozen adds f to the "frozen" field.
func (m *PromotionMemberMutation) AddFrozen(f float64) {
	if m.addfrozen != nil {
		*m.addfrozen += f
	} else {
		m.addfrozen = &f
	}
}

// AddedFrozen returns the value that was added to the "frozen" field in this mutation.
func (m *PromotionMemberMutation) AddedFrozen() (r float64, exists bool) {
	v := m.addfrozen
	if v == nil {
		return
	}
	return *v, true
}

// ResetFrozen resets all changes to the "frozen" field.
func (m *PromotionMemberMutation) ResetFrozen() {
	m.frozen = nil
	m.addfrozen = nil
}

// SetTotalGrowthValue sets the "total_growth_value" field.
func (m *PromotionMemberMutation) SetTotalGrowthValue(u uint64) {
	m.total_growth_value = &u
	m.addtotal_growth_value = nil
}

// TotalGrowthValue returns the value of the "total_growth_value" field in the mutation.
func (m *PromotionMemberMutation) TotalGrowthValue() (r uint64, exists bool) {
	v := m.total_growth_value
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalGrowthValue returns the old "total_growth_value" field's value of the PromotionMember entity.
// If the PromotionMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberMutation) OldTotalGrowthValue(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalGrowthValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalGrowthValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalGrowthValue: %w", err)
	}
	return oldValue.TotalGrowthValue, nil
}

// AddTotalGrowthValue adds u to the "total_growth_value" field.
func (m *PromotionMemberMutation) AddTotalGrowthValue(u int64) {
	if m.addtotal_growth_value != nil {
		*m.addtotal_growth_value += u
	} else {
		m.addtotal_growth_value = &u
	}
}

// AddedTotalGrowthValue returns the value that was added to the "total_growth_value" field in this mutation.
func (m *PromotionMemberMutation) AddedTotalGrowthValue() (r int64, exists bool) {
	v := m.addtotal_growth_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalGrowthValue resets all changes to the "total_growth_value" field.
func (m *PromotionMemberMutation) ResetTotalGrowthValue() {
	m.total_growth_value = nil
	m.addtotal_growth_value = nil
}

// SetCurrentGrowthValue sets the "current_growth_value" field.
func (m *PromotionMemberMutation) SetCurrentGrowthValue(u uint64) {
	m.current_growth_value = &u
	m.addcurrent_growth_value = nil
}

// CurrentGrowthValue returns the value of the "current_growth_value" field in the mutation.
func (m *PromotionMemberMutation) CurrentGrowthValue() (r uint64, exists bool) {
	v := m.current_growth_value
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentGrowthValue returns the old "current_growth_value" field's value of the PromotionMember entity.
// If the PromotionMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberMutation) OldCurrentGrowthValue(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentGrowthValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentGrowthValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentGrowthValue: %w", err)
	}
	return oldValue.CurrentGrowthValue, nil
}

// AddCurrentGrowthValue adds u to the "current_growth_value" field.
func (m *PromotionMemberMutation) AddCurrentGrowthValue(u int64) {
	if m.addcurrent_growth_value != nil {
		*m.addcurrent_growth_value += u
	} else {
		m.addcurrent_growth_value = &u
	}
}

// AddedCurrentGrowthValue returns the value that was added to the "current_growth_value" field in this mutation.
func (m *PromotionMemberMutation) AddedCurrentGrowthValue() (r int64, exists bool) {
	v := m.addcurrent_growth_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetCurrentGrowthValue resets all changes to the "current_growth_value" field.
func (m *PromotionMemberMutation) ResetCurrentGrowthValue() {
	m.current_growth_value = nil
	m.addcurrent_growth_value = nil
}

// SetEnable sets the "enable" field.
func (m *PromotionMemberMutation) SetEnable(b bool) {
	m.enable = &b
}

// Enable returns the value of the "enable" field in the mutation.
func (m *PromotionMemberMutation) Enable() (r bool, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the PromotionMember entity.
// If the PromotionMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberMutation) OldEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// ResetEnable resets all changes to the "enable" field.
func (m *PromotionMemberMutation) ResetEnable() {
	m.enable = nil
}

// SetPersonID sets the "person_id" field.
func (m *PromotionMemberMutation) SetPersonID(u uint64) {
	m.person = &u
}

// PersonID returns the value of the "person_id" field in the mutation.
func (m *PromotionMemberMutation) PersonID() (r uint64, exists bool) {
	v := m.person
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonID returns the old "person_id" field's value of the PromotionMember entity.
// If the PromotionMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberMutation) OldPersonID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonID: %w", err)
	}
	return oldValue.PersonID, nil
}

// ClearPersonID clears the value of the "person_id" field.
func (m *PromotionMemberMutation) ClearPersonID() {
	m.person = nil
	m.clearedFields[promotionmember.FieldPersonID] = struct{}{}
}

// PersonIDCleared returns if the "person_id" field was cleared in this mutation.
func (m *PromotionMemberMutation) PersonIDCleared() bool {
	_, ok := m.clearedFields[promotionmember.FieldPersonID]
	return ok
}

// ResetPersonID resets all changes to the "person_id" field.
func (m *PromotionMemberMutation) ResetPersonID() {
	m.person = nil
	delete(m.clearedFields, promotionmember.FieldPersonID)
}

// SetAvatarURL sets the "avatar_url" field.
func (m *PromotionMemberMutation) SetAvatarURL(s string) {
	m.avatar_url = &s
}

// AvatarURL returns the value of the "avatar_url" field in the mutation.
func (m *PromotionMemberMutation) AvatarURL() (r string, exists bool) {
	v := m.avatar_url
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatarURL returns the old "avatar_url" field's value of the PromotionMember entity.
// If the PromotionMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberMutation) OldAvatarURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatarURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatarURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatarURL: %w", err)
	}
	return oldValue.AvatarURL, nil
}

// ClearAvatarURL clears the value of the "avatar_url" field.
func (m *PromotionMemberMutation) ClearAvatarURL() {
	m.avatar_url = nil
	m.clearedFields[promotionmember.FieldAvatarURL] = struct{}{}
}

// AvatarURLCleared returns if the "avatar_url" field was cleared in this mutation.
func (m *PromotionMemberMutation) AvatarURLCleared() bool {
	_, ok := m.clearedFields[promotionmember.FieldAvatarURL]
	return ok
}

// ResetAvatarURL resets all changes to the "avatar_url" field.
func (m *PromotionMemberMutation) ResetAvatarURL() {
	m.avatar_url = nil
	delete(m.clearedFields, promotionmember.FieldAvatarURL)
}

// SetNewSignCount sets the "new_sign_count" field.
func (m *PromotionMemberMutation) SetNewSignCount(u uint64) {
	m.new_sign_count = &u
	m.addnew_sign_count = nil
}

// NewSignCount returns the value of the "new_sign_count" field in the mutation.
func (m *PromotionMemberMutation) NewSignCount() (r uint64, exists bool) {
	v := m.new_sign_count
	if v == nil {
		return
	}
	return *v, true
}

// OldNewSignCount returns the old "new_sign_count" field's value of the PromotionMember entity.
// If the PromotionMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberMutation) OldNewSignCount(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNewSignCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNewSignCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewSignCount: %w", err)
	}
	return oldValue.NewSignCount, nil
}

// AddNewSignCount adds u to the "new_sign_count" field.
func (m *PromotionMemberMutation) AddNewSignCount(u int64) {
	if m.addnew_sign_count != nil {
		*m.addnew_sign_count += u
	} else {
		m.addnew_sign_count = &u
	}
}

// AddedNewSignCount returns the value that was added to the "new_sign_count" field in this mutation.
func (m *PromotionMemberMutation) AddedNewSignCount() (r int64, exists bool) {
	v := m.addnew_sign_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetNewSignCount resets all changes to the "new_sign_count" field.
func (m *PromotionMemberMutation) ResetNewSignCount() {
	m.new_sign_count = nil
	m.addnew_sign_count = nil
}

// SetRenewCount sets the "renew_count" field.
func (m *PromotionMemberMutation) SetRenewCount(u uint64) {
	m.renew_count = &u
	m.addrenew_count = nil
}

// RenewCount returns the value of the "renew_count" field in the mutation.
func (m *PromotionMemberMutation) RenewCount() (r uint64, exists bool) {
	v := m.renew_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRenewCount returns the old "renew_count" field's value of the PromotionMember entity.
// If the PromotionMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberMutation) OldRenewCount(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRenewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRenewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRenewCount: %w", err)
	}
	return oldValue.RenewCount, nil
}

// AddRenewCount adds u to the "renew_count" field.
func (m *PromotionMemberMutation) AddRenewCount(u int64) {
	if m.addrenew_count != nil {
		*m.addrenew_count += u
	} else {
		m.addrenew_count = &u
	}
}

// AddedRenewCount returns the value that was added to the "renew_count" field in this mutation.
func (m *PromotionMemberMutation) AddedRenewCount() (r int64, exists bool) {
	v := m.addrenew_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRenewCount resets all changes to the "renew_count" field.
func (m *PromotionMemberMutation) ResetRenewCount() {
	m.renew_count = nil
	m.addrenew_count = nil
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *PromotionMemberMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[promotionmember.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *PromotionMemberMutation) RiderCleared() bool {
	return m.RiderIDCleared() || m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *PromotionMemberMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *PromotionMemberMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *PromotionMemberMutation) ClearSubscribe() {
	m.clearedsubscribe = true
	m.clearedFields[promotionmember.FieldSubscribeID] = struct{}{}
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *PromotionMemberMutation) SubscribeCleared() bool {
	return m.SubscribeIDCleared() || m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *PromotionMemberMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *PromotionMemberMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// ClearLevel clears the "level" edge to the PromotionLevel entity.
func (m *PromotionMemberMutation) ClearLevel() {
	m.clearedlevel = true
	m.clearedFields[promotionmember.FieldLevelID] = struct{}{}
}

// LevelCleared reports if the "level" edge to the PromotionLevel entity was cleared.
func (m *PromotionMemberMutation) LevelCleared() bool {
	return m.LevelIDCleared() || m.clearedlevel
}

// LevelIDs returns the "level" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LevelID instead. It exists only for internal usage by the builders.
func (m *PromotionMemberMutation) LevelIDs() (ids []uint64) {
	if id := m.level; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLevel resets all changes to the "level" edge.
func (m *PromotionMemberMutation) ResetLevel() {
	m.level = nil
	m.clearedlevel = false
}

// AddReferralIDs adds the "referrals" edge to the PromotionReferrals entity by ids.
func (m *PromotionMemberMutation) AddReferralIDs(ids ...uint64) {
	if m.referrals == nil {
		m.referrals = make(map[uint64]struct{})
	}
	for i := range ids {
		m.referrals[ids[i]] = struct{}{}
	}
}

// ClearReferrals clears the "referrals" edge to the PromotionReferrals entity.
func (m *PromotionMemberMutation) ClearReferrals() {
	m.clearedreferrals = true
}

// ReferralsCleared reports if the "referrals" edge to the PromotionReferrals entity was cleared.
func (m *PromotionMemberMutation) ReferralsCleared() bool {
	return m.clearedreferrals
}

// RemoveReferralIDs removes the "referrals" edge to the PromotionReferrals entity by IDs.
func (m *PromotionMemberMutation) RemoveReferralIDs(ids ...uint64) {
	if m.removedreferrals == nil {
		m.removedreferrals = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.referrals, ids[i])
		m.removedreferrals[ids[i]] = struct{}{}
	}
}

// RemovedReferrals returns the removed IDs of the "referrals" edge to the PromotionReferrals entity.
func (m *PromotionMemberMutation) RemovedReferralsIDs() (ids []uint64) {
	for id := range m.removedreferrals {
		ids = append(ids, id)
	}
	return
}

// ReferralsIDs returns the "referrals" edge IDs in the mutation.
func (m *PromotionMemberMutation) ReferralsIDs() (ids []uint64) {
	for id := range m.referrals {
		ids = append(ids, id)
	}
	return
}

// ResetReferrals resets all changes to the "referrals" edge.
func (m *PromotionMemberMutation) ResetReferrals() {
	m.referrals = nil
	m.clearedreferrals = false
	m.removedreferrals = nil
}

// SetReferredID sets the "referred" edge to the PromotionReferrals entity by id.
func (m *PromotionMemberMutation) SetReferredID(id uint64) {
	m.referred = &id
}

// ClearReferred clears the "referred" edge to the PromotionReferrals entity.
func (m *PromotionMemberMutation) ClearReferred() {
	m.clearedreferred = true
}

// ReferredCleared reports if the "referred" edge to the PromotionReferrals entity was cleared.
func (m *PromotionMemberMutation) ReferredCleared() bool {
	return m.clearedreferred
}

// ReferredID returns the "referred" edge ID in the mutation.
func (m *PromotionMemberMutation) ReferredID() (id uint64, exists bool) {
	if m.referred != nil {
		return *m.referred, true
	}
	return
}

// ReferredIDs returns the "referred" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReferredID instead. It exists only for internal usage by the builders.
func (m *PromotionMemberMutation) ReferredIDs() (ids []uint64) {
	if id := m.referred; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReferred resets all changes to the "referred" edge.
func (m *PromotionMemberMutation) ResetReferred() {
	m.referred = nil
	m.clearedreferred = false
}

// ClearPerson clears the "person" edge to the PromotionPerson entity.
func (m *PromotionMemberMutation) ClearPerson() {
	m.clearedperson = true
	m.clearedFields[promotionmember.FieldPersonID] = struct{}{}
}

// PersonCleared reports if the "person" edge to the PromotionPerson entity was cleared.
func (m *PromotionMemberMutation) PersonCleared() bool {
	return m.PersonIDCleared() || m.clearedperson
}

// PersonIDs returns the "person" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PersonID instead. It exists only for internal usage by the builders.
func (m *PromotionMemberMutation) PersonIDs() (ids []uint64) {
	if id := m.person; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPerson resets all changes to the "person" edge.
func (m *PromotionMemberMutation) ResetPerson() {
	m.person = nil
	m.clearedperson = false
}

// AddCardIDs adds the "cards" edge to the PromotionBankCard entity by ids.
func (m *PromotionMemberMutation) AddCardIDs(ids ...uint64) {
	if m.cards == nil {
		m.cards = make(map[uint64]struct{})
	}
	for i := range ids {
		m.cards[ids[i]] = struct{}{}
	}
}

// ClearCards clears the "cards" edge to the PromotionBankCard entity.
func (m *PromotionMemberMutation) ClearCards() {
	m.clearedcards = true
}

// CardsCleared reports if the "cards" edge to the PromotionBankCard entity was cleared.
func (m *PromotionMemberMutation) CardsCleared() bool {
	return m.clearedcards
}

// RemoveCardIDs removes the "cards" edge to the PromotionBankCard entity by IDs.
func (m *PromotionMemberMutation) RemoveCardIDs(ids ...uint64) {
	if m.removedcards == nil {
		m.removedcards = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.cards, ids[i])
		m.removedcards[ids[i]] = struct{}{}
	}
}

// RemovedCards returns the removed IDs of the "cards" edge to the PromotionBankCard entity.
func (m *PromotionMemberMutation) RemovedCardsIDs() (ids []uint64) {
	for id := range m.removedcards {
		ids = append(ids, id)
	}
	return
}

// CardsIDs returns the "cards" edge IDs in the mutation.
func (m *PromotionMemberMutation) CardsIDs() (ids []uint64) {
	for id := range m.cards {
		ids = append(ids, id)
	}
	return
}

// ResetCards resets all changes to the "cards" edge.
func (m *PromotionMemberMutation) ResetCards() {
	m.cards = nil
	m.clearedcards = false
	m.removedcards = nil
}

// AddCommissionIDs adds the "commissions" edge to the PromotionMemberCommission entity by ids.
func (m *PromotionMemberMutation) AddCommissionIDs(ids ...uint64) {
	if m.commissions == nil {
		m.commissions = make(map[uint64]struct{})
	}
	for i := range ids {
		m.commissions[ids[i]] = struct{}{}
	}
}

// ClearCommissions clears the "commissions" edge to the PromotionMemberCommission entity.
func (m *PromotionMemberMutation) ClearCommissions() {
	m.clearedcommissions = true
}

// CommissionsCleared reports if the "commissions" edge to the PromotionMemberCommission entity was cleared.
func (m *PromotionMemberMutation) CommissionsCleared() bool {
	return m.clearedcommissions
}

// RemoveCommissionIDs removes the "commissions" edge to the PromotionMemberCommission entity by IDs.
func (m *PromotionMemberMutation) RemoveCommissionIDs(ids ...uint64) {
	if m.removedcommissions == nil {
		m.removedcommissions = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.commissions, ids[i])
		m.removedcommissions[ids[i]] = struct{}{}
	}
}

// RemovedCommissions returns the removed IDs of the "commissions" edge to the PromotionMemberCommission entity.
func (m *PromotionMemberMutation) RemovedCommissionsIDs() (ids []uint64) {
	for id := range m.removedcommissions {
		ids = append(ids, id)
	}
	return
}

// CommissionsIDs returns the "commissions" edge IDs in the mutation.
func (m *PromotionMemberMutation) CommissionsIDs() (ids []uint64) {
	for id := range m.commissions {
		ids = append(ids, id)
	}
	return
}

// ResetCommissions resets all changes to the "commissions" edge.
func (m *PromotionMemberMutation) ResetCommissions() {
	m.commissions = nil
	m.clearedcommissions = false
	m.removedcommissions = nil
}

// Where appends a list predicates to the PromotionMemberMutation builder.
func (m *PromotionMemberMutation) Where(ps ...predicate.PromotionMember) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromotionMemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromotionMemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromotionMember, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromotionMemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromotionMemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromotionMember).
func (m *PromotionMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromotionMemberMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, promotionmember.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, promotionmember.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, promotionmember.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, promotionmember.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, promotionmember.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, promotionmember.FieldRemark)
	}
	if m.rider != nil {
		fields = append(fields, promotionmember.FieldRiderID)
	}
	if m.subscribe != nil {
		fields = append(fields, promotionmember.FieldSubscribeID)
	}
	if m.level != nil {
		fields = append(fields, promotionmember.FieldLevelID)
	}
	if m.phone != nil {
		fields = append(fields, promotionmember.FieldPhone)
	}
	if m.name != nil {
		fields = append(fields, promotionmember.FieldName)
	}
	if m.balance != nil {
		fields = append(fields, promotionmember.FieldBalance)
	}
	if m.frozen != nil {
		fields = append(fields, promotionmember.FieldFrozen)
	}
	if m.total_growth_value != nil {
		fields = append(fields, promotionmember.FieldTotalGrowthValue)
	}
	if m.current_growth_value != nil {
		fields = append(fields, promotionmember.FieldCurrentGrowthValue)
	}
	if m.enable != nil {
		fields = append(fields, promotionmember.FieldEnable)
	}
	if m.person != nil {
		fields = append(fields, promotionmember.FieldPersonID)
	}
	if m.avatar_url != nil {
		fields = append(fields, promotionmember.FieldAvatarURL)
	}
	if m.new_sign_count != nil {
		fields = append(fields, promotionmember.FieldNewSignCount)
	}
	if m.renew_count != nil {
		fields = append(fields, promotionmember.FieldRenewCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromotionMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotionmember.FieldCreatedAt:
		return m.CreatedAt()
	case promotionmember.FieldUpdatedAt:
		return m.UpdatedAt()
	case promotionmember.FieldDeletedAt:
		return m.DeletedAt()
	case promotionmember.FieldCreator:
		return m.Creator()
	case promotionmember.FieldLastModifier:
		return m.LastModifier()
	case promotionmember.FieldRemark:
		return m.Remark()
	case promotionmember.FieldRiderID:
		return m.RiderID()
	case promotionmember.FieldSubscribeID:
		return m.SubscribeID()
	case promotionmember.FieldLevelID:
		return m.LevelID()
	case promotionmember.FieldPhone:
		return m.Phone()
	case promotionmember.FieldName:
		return m.Name()
	case promotionmember.FieldBalance:
		return m.Balance()
	case promotionmember.FieldFrozen:
		return m.Frozen()
	case promotionmember.FieldTotalGrowthValue:
		return m.TotalGrowthValue()
	case promotionmember.FieldCurrentGrowthValue:
		return m.CurrentGrowthValue()
	case promotionmember.FieldEnable:
		return m.Enable()
	case promotionmember.FieldPersonID:
		return m.PersonID()
	case promotionmember.FieldAvatarURL:
		return m.AvatarURL()
	case promotionmember.FieldNewSignCount:
		return m.NewSignCount()
	case promotionmember.FieldRenewCount:
		return m.RenewCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromotionMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotionmember.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case promotionmember.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case promotionmember.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case promotionmember.FieldCreator:
		return m.OldCreator(ctx)
	case promotionmember.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case promotionmember.FieldRemark:
		return m.OldRemark(ctx)
	case promotionmember.FieldRiderID:
		return m.OldRiderID(ctx)
	case promotionmember.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case promotionmember.FieldLevelID:
		return m.OldLevelID(ctx)
	case promotionmember.FieldPhone:
		return m.OldPhone(ctx)
	case promotionmember.FieldName:
		return m.OldName(ctx)
	case promotionmember.FieldBalance:
		return m.OldBalance(ctx)
	case promotionmember.FieldFrozen:
		return m.OldFrozen(ctx)
	case promotionmember.FieldTotalGrowthValue:
		return m.OldTotalGrowthValue(ctx)
	case promotionmember.FieldCurrentGrowthValue:
		return m.OldCurrentGrowthValue(ctx)
	case promotionmember.FieldEnable:
		return m.OldEnable(ctx)
	case promotionmember.FieldPersonID:
		return m.OldPersonID(ctx)
	case promotionmember.FieldAvatarURL:
		return m.OldAvatarURL(ctx)
	case promotionmember.FieldNewSignCount:
		return m.OldNewSignCount(ctx)
	case promotionmember.FieldRenewCount:
		return m.OldRenewCount(ctx)
	}
	return nil, fmt.Errorf("unknown PromotionMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotionmember.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case promotionmember.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case promotionmember.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case promotionmember.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case promotionmember.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case promotionmember.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case promotionmember.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case promotionmember.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case promotionmember.FieldLevelID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevelID(v)
		return nil
	case promotionmember.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case promotionmember.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case promotionmember.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case promotionmember.FieldFrozen:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrozen(v)
		return nil
	case promotionmember.FieldTotalGrowthValue:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalGrowthValue(v)
		return nil
	case promotionmember.FieldCurrentGrowthValue:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentGrowthValue(v)
		return nil
	case promotionmember.FieldEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case promotionmember.FieldPersonID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonID(v)
		return nil
	case promotionmember.FieldAvatarURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatarURL(v)
		return nil
	case promotionmember.FieldNewSignCount:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewSignCount(v)
		return nil
	case promotionmember.FieldRenewCount:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRenewCount(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromotionMemberMutation) AddedFields() []string {
	var fields []string
	if m.addbalance != nil {
		fields = append(fields, promotionmember.FieldBalance)
	}
	if m.addfrozen != nil {
		fields = append(fields, promotionmember.FieldFrozen)
	}
	if m.addtotal_growth_value != nil {
		fields = append(fields, promotionmember.FieldTotalGrowthValue)
	}
	if m.addcurrent_growth_value != nil {
		fields = append(fields, promotionmember.FieldCurrentGrowthValue)
	}
	if m.addnew_sign_count != nil {
		fields = append(fields, promotionmember.FieldNewSignCount)
	}
	if m.addrenew_count != nil {
		fields = append(fields, promotionmember.FieldRenewCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromotionMemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case promotionmember.FieldBalance:
		return m.AddedBalance()
	case promotionmember.FieldFrozen:
		return m.AddedFrozen()
	case promotionmember.FieldTotalGrowthValue:
		return m.AddedTotalGrowthValue()
	case promotionmember.FieldCurrentGrowthValue:
		return m.AddedCurrentGrowthValue()
	case promotionmember.FieldNewSignCount:
		return m.AddedNewSignCount()
	case promotionmember.FieldRenewCount:
		return m.AddedRenewCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	case promotionmember.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case promotionmember.FieldFrozen:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFrozen(v)
		return nil
	case promotionmember.FieldTotalGrowthValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalGrowthValue(v)
		return nil
	case promotionmember.FieldCurrentGrowthValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentGrowthValue(v)
		return nil
	case promotionmember.FieldNewSignCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNewSignCount(v)
		return nil
	case promotionmember.FieldRenewCount:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRenewCount(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromotionMemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promotionmember.FieldDeletedAt) {
		fields = append(fields, promotionmember.FieldDeletedAt)
	}
	if m.FieldCleared(promotionmember.FieldCreator) {
		fields = append(fields, promotionmember.FieldCreator)
	}
	if m.FieldCleared(promotionmember.FieldLastModifier) {
		fields = append(fields, promotionmember.FieldLastModifier)
	}
	if m.FieldCleared(promotionmember.FieldRemark) {
		fields = append(fields, promotionmember.FieldRemark)
	}
	if m.FieldCleared(promotionmember.FieldRiderID) {
		fields = append(fields, promotionmember.FieldRiderID)
	}
	if m.FieldCleared(promotionmember.FieldSubscribeID) {
		fields = append(fields, promotionmember.FieldSubscribeID)
	}
	if m.FieldCleared(promotionmember.FieldLevelID) {
		fields = append(fields, promotionmember.FieldLevelID)
	}
	if m.FieldCleared(promotionmember.FieldName) {
		fields = append(fields, promotionmember.FieldName)
	}
	if m.FieldCleared(promotionmember.FieldPersonID) {
		fields = append(fields, promotionmember.FieldPersonID)
	}
	if m.FieldCleared(promotionmember.FieldAvatarURL) {
		fields = append(fields, promotionmember.FieldAvatarURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromotionMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionMemberMutation) ClearField(name string) error {
	switch name {
	case promotionmember.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case promotionmember.FieldCreator:
		m.ClearCreator()
		return nil
	case promotionmember.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case promotionmember.FieldRemark:
		m.ClearRemark()
		return nil
	case promotionmember.FieldRiderID:
		m.ClearRiderID()
		return nil
	case promotionmember.FieldSubscribeID:
		m.ClearSubscribeID()
		return nil
	case promotionmember.FieldLevelID:
		m.ClearLevelID()
		return nil
	case promotionmember.FieldName:
		m.ClearName()
		return nil
	case promotionmember.FieldPersonID:
		m.ClearPersonID()
		return nil
	case promotionmember.FieldAvatarURL:
		m.ClearAvatarURL()
		return nil
	}
	return fmt.Errorf("unknown PromotionMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromotionMemberMutation) ResetField(name string) error {
	switch name {
	case promotionmember.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case promotionmember.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case promotionmember.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case promotionmember.FieldCreator:
		m.ResetCreator()
		return nil
	case promotionmember.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case promotionmember.FieldRemark:
		m.ResetRemark()
		return nil
	case promotionmember.FieldRiderID:
		m.ResetRiderID()
		return nil
	case promotionmember.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case promotionmember.FieldLevelID:
		m.ResetLevelID()
		return nil
	case promotionmember.FieldPhone:
		m.ResetPhone()
		return nil
	case promotionmember.FieldName:
		m.ResetName()
		return nil
	case promotionmember.FieldBalance:
		m.ResetBalance()
		return nil
	case promotionmember.FieldFrozen:
		m.ResetFrozen()
		return nil
	case promotionmember.FieldTotalGrowthValue:
		m.ResetTotalGrowthValue()
		return nil
	case promotionmember.FieldCurrentGrowthValue:
		m.ResetCurrentGrowthValue()
		return nil
	case promotionmember.FieldEnable:
		m.ResetEnable()
		return nil
	case promotionmember.FieldPersonID:
		m.ResetPersonID()
		return nil
	case promotionmember.FieldAvatarURL:
		m.ResetAvatarURL()
		return nil
	case promotionmember.FieldNewSignCount:
		m.ResetNewSignCount()
		return nil
	case promotionmember.FieldRenewCount:
		m.ResetRenewCount()
		return nil
	}
	return fmt.Errorf("unknown PromotionMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromotionMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.rider != nil {
		edges = append(edges, promotionmember.EdgeRider)
	}
	if m.subscribe != nil {
		edges = append(edges, promotionmember.EdgeSubscribe)
	}
	if m.level != nil {
		edges = append(edges, promotionmember.EdgeLevel)
	}
	if m.referrals != nil {
		edges = append(edges, promotionmember.EdgeReferrals)
	}
	if m.referred != nil {
		edges = append(edges, promotionmember.EdgeReferred)
	}
	if m.person != nil {
		edges = append(edges, promotionmember.EdgePerson)
	}
	if m.cards != nil {
		edges = append(edges, promotionmember.EdgeCards)
	}
	if m.commissions != nil {
		edges = append(edges, promotionmember.EdgeCommissions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromotionMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promotionmember.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case promotionmember.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	case promotionmember.EdgeLevel:
		if id := m.level; id != nil {
			return []ent.Value{*id}
		}
	case promotionmember.EdgeReferrals:
		ids := make([]ent.Value, 0, len(m.referrals))
		for id := range m.referrals {
			ids = append(ids, id)
		}
		return ids
	case promotionmember.EdgeReferred:
		if id := m.referred; id != nil {
			return []ent.Value{*id}
		}
	case promotionmember.EdgePerson:
		if id := m.person; id != nil {
			return []ent.Value{*id}
		}
	case promotionmember.EdgeCards:
		ids := make([]ent.Value, 0, len(m.cards))
		for id := range m.cards {
			ids = append(ids, id)
		}
		return ids
	case promotionmember.EdgeCommissions:
		ids := make([]ent.Value, 0, len(m.commissions))
		for id := range m.commissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromotionMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedreferrals != nil {
		edges = append(edges, promotionmember.EdgeReferrals)
	}
	if m.removedcards != nil {
		edges = append(edges, promotionmember.EdgeCards)
	}
	if m.removedcommissions != nil {
		edges = append(edges, promotionmember.EdgeCommissions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromotionMemberMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case promotionmember.EdgeReferrals:
		ids := make([]ent.Value, 0, len(m.removedreferrals))
		for id := range m.removedreferrals {
			ids = append(ids, id)
		}
		return ids
	case promotionmember.EdgeCards:
		ids := make([]ent.Value, 0, len(m.removedcards))
		for id := range m.removedcards {
			ids = append(ids, id)
		}
		return ids
	case promotionmember.EdgeCommissions:
		ids := make([]ent.Value, 0, len(m.removedcommissions))
		for id := range m.removedcommissions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromotionMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedrider {
		edges = append(edges, promotionmember.EdgeRider)
	}
	if m.clearedsubscribe {
		edges = append(edges, promotionmember.EdgeSubscribe)
	}
	if m.clearedlevel {
		edges = append(edges, promotionmember.EdgeLevel)
	}
	if m.clearedreferrals {
		edges = append(edges, promotionmember.EdgeReferrals)
	}
	if m.clearedreferred {
		edges = append(edges, promotionmember.EdgeReferred)
	}
	if m.clearedperson {
		edges = append(edges, promotionmember.EdgePerson)
	}
	if m.clearedcards {
		edges = append(edges, promotionmember.EdgeCards)
	}
	if m.clearedcommissions {
		edges = append(edges, promotionmember.EdgeCommissions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromotionMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case promotionmember.EdgeRider:
		return m.clearedrider
	case promotionmember.EdgeSubscribe:
		return m.clearedsubscribe
	case promotionmember.EdgeLevel:
		return m.clearedlevel
	case promotionmember.EdgeReferrals:
		return m.clearedreferrals
	case promotionmember.EdgeReferred:
		return m.clearedreferred
	case promotionmember.EdgePerson:
		return m.clearedperson
	case promotionmember.EdgeCards:
		return m.clearedcards
	case promotionmember.EdgeCommissions:
		return m.clearedcommissions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromotionMemberMutation) ClearEdge(name string) error {
	switch name {
	case promotionmember.EdgeRider:
		m.ClearRider()
		return nil
	case promotionmember.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	case promotionmember.EdgeLevel:
		m.ClearLevel()
		return nil
	case promotionmember.EdgeReferred:
		m.ClearReferred()
		return nil
	case promotionmember.EdgePerson:
		m.ClearPerson()
		return nil
	}
	return fmt.Errorf("unknown PromotionMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromotionMemberMutation) ResetEdge(name string) error {
	switch name {
	case promotionmember.EdgeRider:
		m.ResetRider()
		return nil
	case promotionmember.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	case promotionmember.EdgeLevel:
		m.ResetLevel()
		return nil
	case promotionmember.EdgeReferrals:
		m.ResetReferrals()
		return nil
	case promotionmember.EdgeReferred:
		m.ResetReferred()
		return nil
	case promotionmember.EdgePerson:
		m.ResetPerson()
		return nil
	case promotionmember.EdgeCards:
		m.ResetCards()
		return nil
	case promotionmember.EdgeCommissions:
		m.ResetCommissions()
		return nil
	}
	return fmt.Errorf("unknown PromotionMember edge %s", name)
}

// PromotionMemberCommissionMutation represents an operation that mutates the PromotionMemberCommission nodes in the graph.
type PromotionMemberCommissionMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	clearedFields     map[string]struct{}
	commission        *uint64
	clearedcommission bool
	member            *uint64
	clearedmember     bool
	done              bool
	oldValue          func(context.Context) (*PromotionMemberCommission, error)
	predicates        []predicate.PromotionMemberCommission
}

var _ ent.Mutation = (*PromotionMemberCommissionMutation)(nil)

// promotionmembercommissionOption allows management of the mutation configuration using functional options.
type promotionmembercommissionOption func(*PromotionMemberCommissionMutation)

// newPromotionMemberCommissionMutation creates new mutation for the PromotionMemberCommission entity.
func newPromotionMemberCommissionMutation(c config, op Op, opts ...promotionmembercommissionOption) *PromotionMemberCommissionMutation {
	m := &PromotionMemberCommissionMutation{
		config:        c,
		op:            op,
		typ:           TypePromotionMemberCommission,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionMemberCommissionID sets the ID field of the mutation.
func withPromotionMemberCommissionID(id uint64) promotionmembercommissionOption {
	return func(m *PromotionMemberCommissionMutation) {
		var (
			err   error
			once  sync.Once
			value *PromotionMemberCommission
		)
		m.oldValue = func(ctx context.Context) (*PromotionMemberCommission, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromotionMemberCommission.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotionMemberCommission sets the old PromotionMemberCommission of the mutation.
func withPromotionMemberCommission(node *PromotionMemberCommission) promotionmembercommissionOption {
	return func(m *PromotionMemberCommissionMutation) {
		m.oldValue = func(context.Context) (*PromotionMemberCommission, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionMemberCommissionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionMemberCommissionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromotionMemberCommissionMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromotionMemberCommissionMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromotionMemberCommission.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromotionMemberCommissionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromotionMemberCommissionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromotionMemberCommission entity.
// If the PromotionMemberCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberCommissionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromotionMemberCommissionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromotionMemberCommissionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromotionMemberCommissionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PromotionMemberCommission entity.
// If the PromotionMemberCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberCommissionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromotionMemberCommissionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PromotionMemberCommissionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PromotionMemberCommissionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PromotionMemberCommission entity.
// If the PromotionMemberCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberCommissionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PromotionMemberCommissionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[promotionmembercommission.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PromotionMemberCommissionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[promotionmembercommission.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PromotionMemberCommissionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, promotionmembercommission.FieldDeletedAt)
}

// SetCommissionID sets the "commission_id" field.
func (m *PromotionMemberCommissionMutation) SetCommissionID(u uint64) {
	m.commission = &u
}

// CommissionID returns the value of the "commission_id" field in the mutation.
func (m *PromotionMemberCommissionMutation) CommissionID() (r uint64, exists bool) {
	v := m.commission
	if v == nil {
		return
	}
	return *v, true
}

// OldCommissionID returns the old "commission_id" field's value of the PromotionMemberCommission entity.
// If the PromotionMemberCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberCommissionMutation) OldCommissionID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommissionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommissionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommissionID: %w", err)
	}
	return oldValue.CommissionID, nil
}

// ResetCommissionID resets all changes to the "commission_id" field.
func (m *PromotionMemberCommissionMutation) ResetCommissionID() {
	m.commission = nil
}

// SetMemberID sets the "member_id" field.
func (m *PromotionMemberCommissionMutation) SetMemberID(u uint64) {
	m.member = &u
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *PromotionMemberCommissionMutation) MemberID() (r uint64, exists bool) {
	v := m.member
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the PromotionMemberCommission entity.
// If the PromotionMemberCommission object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionMemberCommissionMutation) OldMemberID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *PromotionMemberCommissionMutation) ClearMemberID() {
	m.member = nil
	m.clearedFields[promotionmembercommission.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *PromotionMemberCommissionMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[promotionmembercommission.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *PromotionMemberCommissionMutation) ResetMemberID() {
	m.member = nil
	delete(m.clearedFields, promotionmembercommission.FieldMemberID)
}

// ClearCommission clears the "commission" edge to the PromotionCommission entity.
func (m *PromotionMemberCommissionMutation) ClearCommission() {
	m.clearedcommission = true
	m.clearedFields[promotionmembercommission.FieldCommissionID] = struct{}{}
}

// CommissionCleared reports if the "commission" edge to the PromotionCommission entity was cleared.
func (m *PromotionMemberCommissionMutation) CommissionCleared() bool {
	return m.clearedcommission
}

// CommissionIDs returns the "commission" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CommissionID instead. It exists only for internal usage by the builders.
func (m *PromotionMemberCommissionMutation) CommissionIDs() (ids []uint64) {
	if id := m.commission; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCommission resets all changes to the "commission" edge.
func (m *PromotionMemberCommissionMutation) ResetCommission() {
	m.commission = nil
	m.clearedcommission = false
}

// ClearMember clears the "member" edge to the PromotionMember entity.
func (m *PromotionMemberCommissionMutation) ClearMember() {
	m.clearedmember = true
	m.clearedFields[promotionmembercommission.FieldMemberID] = struct{}{}
}

// MemberCleared reports if the "member" edge to the PromotionMember entity was cleared.
func (m *PromotionMemberCommissionMutation) MemberCleared() bool {
	return m.MemberIDCleared() || m.clearedmember
}

// MemberIDs returns the "member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberID instead. It exists only for internal usage by the builders.
func (m *PromotionMemberCommissionMutation) MemberIDs() (ids []uint64) {
	if id := m.member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMember resets all changes to the "member" edge.
func (m *PromotionMemberCommissionMutation) ResetMember() {
	m.member = nil
	m.clearedmember = false
}

// Where appends a list predicates to the PromotionMemberCommissionMutation builder.
func (m *PromotionMemberCommissionMutation) Where(ps ...predicate.PromotionMemberCommission) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromotionMemberCommissionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromotionMemberCommissionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromotionMemberCommission, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromotionMemberCommissionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromotionMemberCommissionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromotionMemberCommission).
func (m *PromotionMemberCommissionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromotionMemberCommissionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, promotionmembercommission.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, promotionmembercommission.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, promotionmembercommission.FieldDeletedAt)
	}
	if m.commission != nil {
		fields = append(fields, promotionmembercommission.FieldCommissionID)
	}
	if m.member != nil {
		fields = append(fields, promotionmembercommission.FieldMemberID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromotionMemberCommissionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotionmembercommission.FieldCreatedAt:
		return m.CreatedAt()
	case promotionmembercommission.FieldUpdatedAt:
		return m.UpdatedAt()
	case promotionmembercommission.FieldDeletedAt:
		return m.DeletedAt()
	case promotionmembercommission.FieldCommissionID:
		return m.CommissionID()
	case promotionmembercommission.FieldMemberID:
		return m.MemberID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromotionMemberCommissionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotionmembercommission.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case promotionmembercommission.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case promotionmembercommission.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case promotionmembercommission.FieldCommissionID:
		return m.OldCommissionID(ctx)
	case promotionmembercommission.FieldMemberID:
		return m.OldMemberID(ctx)
	}
	return nil, fmt.Errorf("unknown PromotionMemberCommission field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionMemberCommissionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotionmembercommission.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case promotionmembercommission.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case promotionmembercommission.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case promotionmembercommission.FieldCommissionID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommissionID(v)
		return nil
	case promotionmembercommission.FieldMemberID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionMemberCommission field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromotionMemberCommissionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromotionMemberCommissionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionMemberCommissionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PromotionMemberCommission numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromotionMemberCommissionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promotionmembercommission.FieldDeletedAt) {
		fields = append(fields, promotionmembercommission.FieldDeletedAt)
	}
	if m.FieldCleared(promotionmembercommission.FieldMemberID) {
		fields = append(fields, promotionmembercommission.FieldMemberID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromotionMemberCommissionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionMemberCommissionMutation) ClearField(name string) error {
	switch name {
	case promotionmembercommission.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case promotionmembercommission.FieldMemberID:
		m.ClearMemberID()
		return nil
	}
	return fmt.Errorf("unknown PromotionMemberCommission nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromotionMemberCommissionMutation) ResetField(name string) error {
	switch name {
	case promotionmembercommission.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case promotionmembercommission.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case promotionmembercommission.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case promotionmembercommission.FieldCommissionID:
		m.ResetCommissionID()
		return nil
	case promotionmembercommission.FieldMemberID:
		m.ResetMemberID()
		return nil
	}
	return fmt.Errorf("unknown PromotionMemberCommission field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromotionMemberCommissionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.commission != nil {
		edges = append(edges, promotionmembercommission.EdgeCommission)
	}
	if m.member != nil {
		edges = append(edges, promotionmembercommission.EdgeMember)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromotionMemberCommissionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promotionmembercommission.EdgeCommission:
		if id := m.commission; id != nil {
			return []ent.Value{*id}
		}
	case promotionmembercommission.EdgeMember:
		if id := m.member; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromotionMemberCommissionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromotionMemberCommissionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromotionMemberCommissionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcommission {
		edges = append(edges, promotionmembercommission.EdgeCommission)
	}
	if m.clearedmember {
		edges = append(edges, promotionmembercommission.EdgeMember)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromotionMemberCommissionMutation) EdgeCleared(name string) bool {
	switch name {
	case promotionmembercommission.EdgeCommission:
		return m.clearedcommission
	case promotionmembercommission.EdgeMember:
		return m.clearedmember
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromotionMemberCommissionMutation) ClearEdge(name string) error {
	switch name {
	case promotionmembercommission.EdgeCommission:
		m.ClearCommission()
		return nil
	case promotionmembercommission.EdgeMember:
		m.ClearMember()
		return nil
	}
	return fmt.Errorf("unknown PromotionMemberCommission unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromotionMemberCommissionMutation) ResetEdge(name string) error {
	switch name {
	case promotionmembercommission.EdgeCommission:
		m.ResetCommission()
		return nil
	case promotionmembercommission.EdgeMember:
		m.ResetMember()
		return nil
	}
	return fmt.Errorf("unknown PromotionMemberCommission edge %s", name)
}

// PromotionPersonMutation represents an operation that mutates the PromotionPerson nodes in the graph.
type PromotionPersonMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	created_at     *time.Time
	updated_at     *time.Time
	status         *uint8
	addstatus      *int8
	name           *string
	id_card_number *string
	address        *string
	clearedFields  map[string]struct{}
	member         map[uint64]struct{}
	removedmember  map[uint64]struct{}
	clearedmember  bool
	done           bool
	oldValue       func(context.Context) (*PromotionPerson, error)
	predicates     []predicate.PromotionPerson
}

var _ ent.Mutation = (*PromotionPersonMutation)(nil)

// promotionpersonOption allows management of the mutation configuration using functional options.
type promotionpersonOption func(*PromotionPersonMutation)

// newPromotionPersonMutation creates new mutation for the PromotionPerson entity.
func newPromotionPersonMutation(c config, op Op, opts ...promotionpersonOption) *PromotionPersonMutation {
	m := &PromotionPersonMutation{
		config:        c,
		op:            op,
		typ:           TypePromotionPerson,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionPersonID sets the ID field of the mutation.
func withPromotionPersonID(id uint64) promotionpersonOption {
	return func(m *PromotionPersonMutation) {
		var (
			err   error
			once  sync.Once
			value *PromotionPerson
		)
		m.oldValue = func(ctx context.Context) (*PromotionPerson, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromotionPerson.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotionPerson sets the old PromotionPerson of the mutation.
func withPromotionPerson(node *PromotionPerson) promotionpersonOption {
	return func(m *PromotionPersonMutation) {
		m.oldValue = func(context.Context) (*PromotionPerson, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionPersonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionPersonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromotionPersonMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromotionPersonMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromotionPerson.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromotionPersonMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromotionPersonMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromotionPerson entity.
// If the PromotionPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionPersonMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromotionPersonMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromotionPersonMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromotionPersonMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PromotionPerson entity.
// If the PromotionPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionPersonMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromotionPersonMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *PromotionPersonMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *PromotionPersonMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PromotionPerson entity.
// If the PromotionPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionPersonMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *PromotionPersonMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *PromotionPersonMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *PromotionPersonMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetName sets the "name" field.
func (m *PromotionPersonMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PromotionPersonMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PromotionPerson entity.
// If the PromotionPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionPersonMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *PromotionPersonMutation) ClearName() {
	m.name = nil
	m.clearedFields[promotionperson.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *PromotionPersonMutation) NameCleared() bool {
	_, ok := m.clearedFields[promotionperson.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *PromotionPersonMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, promotionperson.FieldName)
}

// SetIDCardNumber sets the "id_card_number" field.
func (m *PromotionPersonMutation) SetIDCardNumber(s string) {
	m.id_card_number = &s
}

// IDCardNumber returns the value of the "id_card_number" field in the mutation.
func (m *PromotionPersonMutation) IDCardNumber() (r string, exists bool) {
	v := m.id_card_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCardNumber returns the old "id_card_number" field's value of the PromotionPerson entity.
// If the PromotionPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionPersonMutation) OldIDCardNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCardNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCardNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCardNumber: %w", err)
	}
	return oldValue.IDCardNumber, nil
}

// ClearIDCardNumber clears the value of the "id_card_number" field.
func (m *PromotionPersonMutation) ClearIDCardNumber() {
	m.id_card_number = nil
	m.clearedFields[promotionperson.FieldIDCardNumber] = struct{}{}
}

// IDCardNumberCleared returns if the "id_card_number" field was cleared in this mutation.
func (m *PromotionPersonMutation) IDCardNumberCleared() bool {
	_, ok := m.clearedFields[promotionperson.FieldIDCardNumber]
	return ok
}

// ResetIDCardNumber resets all changes to the "id_card_number" field.
func (m *PromotionPersonMutation) ResetIDCardNumber() {
	m.id_card_number = nil
	delete(m.clearedFields, promotionperson.FieldIDCardNumber)
}

// SetAddress sets the "address" field.
func (m *PromotionPersonMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *PromotionPersonMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the PromotionPerson entity.
// If the PromotionPerson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionPersonMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *PromotionPersonMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[promotionperson.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *PromotionPersonMutation) AddressCleared() bool {
	_, ok := m.clearedFields[promotionperson.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *PromotionPersonMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, promotionperson.FieldAddress)
}

// AddMemberIDs adds the "member" edge to the PromotionMember entity by ids.
func (m *PromotionPersonMutation) AddMemberIDs(ids ...uint64) {
	if m.member == nil {
		m.member = make(map[uint64]struct{})
	}
	for i := range ids {
		m.member[ids[i]] = struct{}{}
	}
}

// ClearMember clears the "member" edge to the PromotionMember entity.
func (m *PromotionPersonMutation) ClearMember() {
	m.clearedmember = true
}

// MemberCleared reports if the "member" edge to the PromotionMember entity was cleared.
func (m *PromotionPersonMutation) MemberCleared() bool {
	return m.clearedmember
}

// RemoveMemberIDs removes the "member" edge to the PromotionMember entity by IDs.
func (m *PromotionPersonMutation) RemoveMemberIDs(ids ...uint64) {
	if m.removedmember == nil {
		m.removedmember = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.member, ids[i])
		m.removedmember[ids[i]] = struct{}{}
	}
}

// RemovedMember returns the removed IDs of the "member" edge to the PromotionMember entity.
func (m *PromotionPersonMutation) RemovedMemberIDs() (ids []uint64) {
	for id := range m.removedmember {
		ids = append(ids, id)
	}
	return
}

// MemberIDs returns the "member" edge IDs in the mutation.
func (m *PromotionPersonMutation) MemberIDs() (ids []uint64) {
	for id := range m.member {
		ids = append(ids, id)
	}
	return
}

// ResetMember resets all changes to the "member" edge.
func (m *PromotionPersonMutation) ResetMember() {
	m.member = nil
	m.clearedmember = false
	m.removedmember = nil
}

// Where appends a list predicates to the PromotionPersonMutation builder.
func (m *PromotionPersonMutation) Where(ps ...predicate.PromotionPerson) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromotionPersonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromotionPersonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromotionPerson, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromotionPersonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromotionPersonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromotionPerson).
func (m *PromotionPersonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromotionPersonMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, promotionperson.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, promotionperson.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, promotionperson.FieldStatus)
	}
	if m.name != nil {
		fields = append(fields, promotionperson.FieldName)
	}
	if m.id_card_number != nil {
		fields = append(fields, promotionperson.FieldIDCardNumber)
	}
	if m.address != nil {
		fields = append(fields, promotionperson.FieldAddress)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromotionPersonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotionperson.FieldCreatedAt:
		return m.CreatedAt()
	case promotionperson.FieldUpdatedAt:
		return m.UpdatedAt()
	case promotionperson.FieldStatus:
		return m.Status()
	case promotionperson.FieldName:
		return m.Name()
	case promotionperson.FieldIDCardNumber:
		return m.IDCardNumber()
	case promotionperson.FieldAddress:
		return m.Address()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromotionPersonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotionperson.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case promotionperson.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case promotionperson.FieldStatus:
		return m.OldStatus(ctx)
	case promotionperson.FieldName:
		return m.OldName(ctx)
	case promotionperson.FieldIDCardNumber:
		return m.OldIDCardNumber(ctx)
	case promotionperson.FieldAddress:
		return m.OldAddress(ctx)
	}
	return nil, fmt.Errorf("unknown PromotionPerson field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionPersonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotionperson.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case promotionperson.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case promotionperson.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case promotionperson.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case promotionperson.FieldIDCardNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCardNumber(v)
		return nil
	case promotionperson.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionPerson field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromotionPersonMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, promotionperson.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromotionPersonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case promotionperson.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionPersonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case promotionperson.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionPerson numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromotionPersonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promotionperson.FieldName) {
		fields = append(fields, promotionperson.FieldName)
	}
	if m.FieldCleared(promotionperson.FieldIDCardNumber) {
		fields = append(fields, promotionperson.FieldIDCardNumber)
	}
	if m.FieldCleared(promotionperson.FieldAddress) {
		fields = append(fields, promotionperson.FieldAddress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromotionPersonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionPersonMutation) ClearField(name string) error {
	switch name {
	case promotionperson.FieldName:
		m.ClearName()
		return nil
	case promotionperson.FieldIDCardNumber:
		m.ClearIDCardNumber()
		return nil
	case promotionperson.FieldAddress:
		m.ClearAddress()
		return nil
	}
	return fmt.Errorf("unknown PromotionPerson nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromotionPersonMutation) ResetField(name string) error {
	switch name {
	case promotionperson.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case promotionperson.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case promotionperson.FieldStatus:
		m.ResetStatus()
		return nil
	case promotionperson.FieldName:
		m.ResetName()
		return nil
	case promotionperson.FieldIDCardNumber:
		m.ResetIDCardNumber()
		return nil
	case promotionperson.FieldAddress:
		m.ResetAddress()
		return nil
	}
	return fmt.Errorf("unknown PromotionPerson field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromotionPersonMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.member != nil {
		edges = append(edges, promotionperson.EdgeMember)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromotionPersonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promotionperson.EdgeMember:
		ids := make([]ent.Value, 0, len(m.member))
		for id := range m.member {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromotionPersonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmember != nil {
		edges = append(edges, promotionperson.EdgeMember)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromotionPersonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case promotionperson.EdgeMember:
		ids := make([]ent.Value, 0, len(m.removedmember))
		for id := range m.removedmember {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromotionPersonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmember {
		edges = append(edges, promotionperson.EdgeMember)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromotionPersonMutation) EdgeCleared(name string) bool {
	switch name {
	case promotionperson.EdgeMember:
		return m.clearedmember
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromotionPersonMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PromotionPerson unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromotionPersonMutation) ResetEdge(name string) error {
	switch name {
	case promotionperson.EdgeMember:
		m.ResetMember()
		return nil
	}
	return fmt.Errorf("unknown PromotionPerson edge %s", name)
}

// PromotionPrivilegeMutation represents an operation that mutates the PromotionPrivilege nodes in the graph.
type PromotionPrivilegeMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	creator       **model.Modifier
	last_modifier **model.Modifier
	remark        *string
	_type         *uint8
	add_type      *int8
	name          *string
	description   *string
	value         *uint64
	addvalue      *int64
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PromotionPrivilege, error)
	predicates    []predicate.PromotionPrivilege
}

var _ ent.Mutation = (*PromotionPrivilegeMutation)(nil)

// promotionprivilegeOption allows management of the mutation configuration using functional options.
type promotionprivilegeOption func(*PromotionPrivilegeMutation)

// newPromotionPrivilegeMutation creates new mutation for the PromotionPrivilege entity.
func newPromotionPrivilegeMutation(c config, op Op, opts ...promotionprivilegeOption) *PromotionPrivilegeMutation {
	m := &PromotionPrivilegeMutation{
		config:        c,
		op:            op,
		typ:           TypePromotionPrivilege,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionPrivilegeID sets the ID field of the mutation.
func withPromotionPrivilegeID(id uint64) promotionprivilegeOption {
	return func(m *PromotionPrivilegeMutation) {
		var (
			err   error
			once  sync.Once
			value *PromotionPrivilege
		)
		m.oldValue = func(ctx context.Context) (*PromotionPrivilege, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromotionPrivilege.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotionPrivilege sets the old PromotionPrivilege of the mutation.
func withPromotionPrivilege(node *PromotionPrivilege) promotionprivilegeOption {
	return func(m *PromotionPrivilegeMutation) {
		m.oldValue = func(context.Context) (*PromotionPrivilege, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionPrivilegeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionPrivilegeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromotionPrivilegeMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromotionPrivilegeMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromotionPrivilege.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromotionPrivilegeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromotionPrivilegeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromotionPrivilege entity.
// If the PromotionPrivilege object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionPrivilegeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromotionPrivilegeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromotionPrivilegeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromotionPrivilegeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PromotionPrivilege entity.
// If the PromotionPrivilege object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionPrivilegeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromotionPrivilegeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PromotionPrivilegeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PromotionPrivilegeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PromotionPrivilege entity.
// If the PromotionPrivilege object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionPrivilegeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PromotionPrivilegeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[promotionprivilege.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PromotionPrivilegeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[promotionprivilege.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PromotionPrivilegeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, promotionprivilege.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *PromotionPrivilegeMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *PromotionPrivilegeMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the PromotionPrivilege entity.
// If the PromotionPrivilege object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionPrivilegeMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *PromotionPrivilegeMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[promotionprivilege.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *PromotionPrivilegeMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[promotionprivilege.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *PromotionPrivilegeMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, promotionprivilege.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *PromotionPrivilegeMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *PromotionPrivilegeMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the PromotionPrivilege entity.
// If the PromotionPrivilege object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionPrivilegeMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *PromotionPrivilegeMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[promotionprivilege.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *PromotionPrivilegeMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[promotionprivilege.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *PromotionPrivilegeMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, promotionprivilege.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *PromotionPrivilegeMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PromotionPrivilegeMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the PromotionPrivilege entity.
// If the PromotionPrivilege object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionPrivilegeMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PromotionPrivilegeMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[promotionprivilege.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PromotionPrivilegeMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[promotionprivilege.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PromotionPrivilegeMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, promotionprivilege.FieldRemark)
}

// SetType sets the "type" field.
func (m *PromotionPrivilegeMutation) SetType(u uint8) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *PromotionPrivilegeMutation) GetType() (r uint8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PromotionPrivilege entity.
// If the PromotionPrivilege object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionPrivilegeMutation) OldType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *PromotionPrivilegeMutation) AddType(u int8) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *PromotionPrivilegeMutation) AddedType() (r int8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *PromotionPrivilegeMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetName sets the "name" field.
func (m *PromotionPrivilegeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PromotionPrivilegeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PromotionPrivilege entity.
// If the PromotionPrivilege object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionPrivilegeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PromotionPrivilegeMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *PromotionPrivilegeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PromotionPrivilegeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PromotionPrivilege entity.
// If the PromotionPrivilege object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionPrivilegeMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PromotionPrivilegeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[promotionprivilege.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PromotionPrivilegeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[promotionprivilege.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PromotionPrivilegeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, promotionprivilege.FieldDescription)
}

// SetValue sets the "value" field.
func (m *PromotionPrivilegeMutation) SetValue(u uint64) {
	m.value = &u
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *PromotionPrivilegeMutation) Value() (r uint64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the PromotionPrivilege entity.
// If the PromotionPrivilege object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionPrivilegeMutation) OldValue(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds u to the "value" field.
func (m *PromotionPrivilegeMutation) AddValue(u int64) {
	if m.addvalue != nil {
		*m.addvalue += u
	} else {
		m.addvalue = &u
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *PromotionPrivilegeMutation) AddedValue() (r int64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ClearValue clears the value of the "value" field.
func (m *PromotionPrivilegeMutation) ClearValue() {
	m.value = nil
	m.addvalue = nil
	m.clearedFields[promotionprivilege.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *PromotionPrivilegeMutation) ValueCleared() bool {
	_, ok := m.clearedFields[promotionprivilege.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *PromotionPrivilegeMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
	delete(m.clearedFields, promotionprivilege.FieldValue)
}

// Where appends a list predicates to the PromotionPrivilegeMutation builder.
func (m *PromotionPrivilegeMutation) Where(ps ...predicate.PromotionPrivilege) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromotionPrivilegeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromotionPrivilegeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromotionPrivilege, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromotionPrivilegeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromotionPrivilegeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromotionPrivilege).
func (m *PromotionPrivilegeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromotionPrivilegeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, promotionprivilege.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, promotionprivilege.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, promotionprivilege.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, promotionprivilege.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, promotionprivilege.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, promotionprivilege.FieldRemark)
	}
	if m._type != nil {
		fields = append(fields, promotionprivilege.FieldType)
	}
	if m.name != nil {
		fields = append(fields, promotionprivilege.FieldName)
	}
	if m.description != nil {
		fields = append(fields, promotionprivilege.FieldDescription)
	}
	if m.value != nil {
		fields = append(fields, promotionprivilege.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromotionPrivilegeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotionprivilege.FieldCreatedAt:
		return m.CreatedAt()
	case promotionprivilege.FieldUpdatedAt:
		return m.UpdatedAt()
	case promotionprivilege.FieldDeletedAt:
		return m.DeletedAt()
	case promotionprivilege.FieldCreator:
		return m.Creator()
	case promotionprivilege.FieldLastModifier:
		return m.LastModifier()
	case promotionprivilege.FieldRemark:
		return m.Remark()
	case promotionprivilege.FieldType:
		return m.GetType()
	case promotionprivilege.FieldName:
		return m.Name()
	case promotionprivilege.FieldDescription:
		return m.Description()
	case promotionprivilege.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromotionPrivilegeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotionprivilege.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case promotionprivilege.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case promotionprivilege.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case promotionprivilege.FieldCreator:
		return m.OldCreator(ctx)
	case promotionprivilege.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case promotionprivilege.FieldRemark:
		return m.OldRemark(ctx)
	case promotionprivilege.FieldType:
		return m.OldType(ctx)
	case promotionprivilege.FieldName:
		return m.OldName(ctx)
	case promotionprivilege.FieldDescription:
		return m.OldDescription(ctx)
	case promotionprivilege.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown PromotionPrivilege field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionPrivilegeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotionprivilege.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case promotionprivilege.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case promotionprivilege.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case promotionprivilege.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case promotionprivilege.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case promotionprivilege.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case promotionprivilege.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case promotionprivilege.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case promotionprivilege.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case promotionprivilege.FieldValue:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionPrivilege field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromotionPrivilegeMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, promotionprivilege.FieldType)
	}
	if m.addvalue != nil {
		fields = append(fields, promotionprivilege.FieldValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromotionPrivilegeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case promotionprivilege.FieldType:
		return m.AddedType()
	case promotionprivilege.FieldValue:
		return m.AddedValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionPrivilegeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case promotionprivilege.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case promotionprivilege.FieldValue:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionPrivilege numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromotionPrivilegeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promotionprivilege.FieldDeletedAt) {
		fields = append(fields, promotionprivilege.FieldDeletedAt)
	}
	if m.FieldCleared(promotionprivilege.FieldCreator) {
		fields = append(fields, promotionprivilege.FieldCreator)
	}
	if m.FieldCleared(promotionprivilege.FieldLastModifier) {
		fields = append(fields, promotionprivilege.FieldLastModifier)
	}
	if m.FieldCleared(promotionprivilege.FieldRemark) {
		fields = append(fields, promotionprivilege.FieldRemark)
	}
	if m.FieldCleared(promotionprivilege.FieldDescription) {
		fields = append(fields, promotionprivilege.FieldDescription)
	}
	if m.FieldCleared(promotionprivilege.FieldValue) {
		fields = append(fields, promotionprivilege.FieldValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromotionPrivilegeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionPrivilegeMutation) ClearField(name string) error {
	switch name {
	case promotionprivilege.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case promotionprivilege.FieldCreator:
		m.ClearCreator()
		return nil
	case promotionprivilege.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case promotionprivilege.FieldRemark:
		m.ClearRemark()
		return nil
	case promotionprivilege.FieldDescription:
		m.ClearDescription()
		return nil
	case promotionprivilege.FieldValue:
		m.ClearValue()
		return nil
	}
	return fmt.Errorf("unknown PromotionPrivilege nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromotionPrivilegeMutation) ResetField(name string) error {
	switch name {
	case promotionprivilege.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case promotionprivilege.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case promotionprivilege.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case promotionprivilege.FieldCreator:
		m.ResetCreator()
		return nil
	case promotionprivilege.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case promotionprivilege.FieldRemark:
		m.ResetRemark()
		return nil
	case promotionprivilege.FieldType:
		m.ResetType()
		return nil
	case promotionprivilege.FieldName:
		m.ResetName()
		return nil
	case promotionprivilege.FieldDescription:
		m.ResetDescription()
		return nil
	case promotionprivilege.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown PromotionPrivilege field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromotionPrivilegeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromotionPrivilegeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromotionPrivilegeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromotionPrivilegeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromotionPrivilegeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromotionPrivilegeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromotionPrivilegeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PromotionPrivilege unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromotionPrivilegeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PromotionPrivilege edge %s", name)
}

// PromotionReferralsMutation represents an operation that mutates the PromotionReferrals nodes in the graph.
type PromotionReferralsMutation struct {
	config
	op                      Op
	typ                     string
	id                      *uint64
	created_at              *time.Time
	updated_at              *time.Time
	creator                 **model.Modifier
	last_modifier           **model.Modifier
	remark                  *string
	clearedFields           map[string]struct{}
	rider                   *uint64
	clearedrider            bool
	subscribe               *uint64
	clearedsubscribe        bool
	referring_member        *uint64
	clearedreferring_member bool
	referred_member         *uint64
	clearedreferred_member  bool
	done                    bool
	oldValue                func(context.Context) (*PromotionReferrals, error)
	predicates              []predicate.PromotionReferrals
}

var _ ent.Mutation = (*PromotionReferralsMutation)(nil)

// promotionreferralsOption allows management of the mutation configuration using functional options.
type promotionreferralsOption func(*PromotionReferralsMutation)

// newPromotionReferralsMutation creates new mutation for the PromotionReferrals entity.
func newPromotionReferralsMutation(c config, op Op, opts ...promotionreferralsOption) *PromotionReferralsMutation {
	m := &PromotionReferralsMutation{
		config:        c,
		op:            op,
		typ:           TypePromotionReferrals,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionReferralsID sets the ID field of the mutation.
func withPromotionReferralsID(id uint64) promotionreferralsOption {
	return func(m *PromotionReferralsMutation) {
		var (
			err   error
			once  sync.Once
			value *PromotionReferrals
		)
		m.oldValue = func(ctx context.Context) (*PromotionReferrals, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromotionReferrals.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotionReferrals sets the old PromotionReferrals of the mutation.
func withPromotionReferrals(node *PromotionReferrals) promotionreferralsOption {
	return func(m *PromotionReferralsMutation) {
		m.oldValue = func(context.Context) (*PromotionReferrals, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionReferralsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionReferralsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromotionReferralsMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromotionReferralsMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromotionReferrals.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromotionReferralsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromotionReferralsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromotionReferrals entity.
// If the PromotionReferrals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionReferralsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromotionReferralsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromotionReferralsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromotionReferralsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PromotionReferrals entity.
// If the PromotionReferrals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionReferralsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromotionReferralsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreator sets the "creator" field.
func (m *PromotionReferralsMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *PromotionReferralsMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the PromotionReferrals entity.
// If the PromotionReferrals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionReferralsMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *PromotionReferralsMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[promotionreferrals.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *PromotionReferralsMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[promotionreferrals.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *PromotionReferralsMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, promotionreferrals.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *PromotionReferralsMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *PromotionReferralsMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the PromotionReferrals entity.
// If the PromotionReferrals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionReferralsMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *PromotionReferralsMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[promotionreferrals.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *PromotionReferralsMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[promotionreferrals.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *PromotionReferralsMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, promotionreferrals.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *PromotionReferralsMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PromotionReferralsMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the PromotionReferrals entity.
// If the PromotionReferrals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionReferralsMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PromotionReferralsMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[promotionreferrals.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PromotionReferralsMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[promotionreferrals.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PromotionReferralsMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, promotionreferrals.FieldRemark)
}

// SetRiderID sets the "rider_id" field.
func (m *PromotionReferralsMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *PromotionReferralsMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the PromotionReferrals entity.
// If the PromotionReferrals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionReferralsMutation) OldRiderID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ClearRiderID clears the value of the "rider_id" field.
func (m *PromotionReferralsMutation) ClearRiderID() {
	m.rider = nil
	m.clearedFields[promotionreferrals.FieldRiderID] = struct{}{}
}

// RiderIDCleared returns if the "rider_id" field was cleared in this mutation.
func (m *PromotionReferralsMutation) RiderIDCleared() bool {
	_, ok := m.clearedFields[promotionreferrals.FieldRiderID]
	return ok
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *PromotionReferralsMutation) ResetRiderID() {
	m.rider = nil
	delete(m.clearedFields, promotionreferrals.FieldRiderID)
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *PromotionReferralsMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *PromotionReferralsMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the PromotionReferrals entity.
// If the PromotionReferrals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionReferralsMutation) OldSubscribeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ClearSubscribeID clears the value of the "subscribe_id" field.
func (m *PromotionReferralsMutation) ClearSubscribeID() {
	m.subscribe = nil
	m.clearedFields[promotionreferrals.FieldSubscribeID] = struct{}{}
}

// SubscribeIDCleared returns if the "subscribe_id" field was cleared in this mutation.
func (m *PromotionReferralsMutation) SubscribeIDCleared() bool {
	_, ok := m.clearedFields[promotionreferrals.FieldSubscribeID]
	return ok
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *PromotionReferralsMutation) ResetSubscribeID() {
	m.subscribe = nil
	delete(m.clearedFields, promotionreferrals.FieldSubscribeID)
}

// SetReferringMemberID sets the "referring_member_id" field.
func (m *PromotionReferralsMutation) SetReferringMemberID(u uint64) {
	m.referring_member = &u
}

// ReferringMemberID returns the value of the "referring_member_id" field in the mutation.
func (m *PromotionReferralsMutation) ReferringMemberID() (r uint64, exists bool) {
	v := m.referring_member
	if v == nil {
		return
	}
	return *v, true
}

// OldReferringMemberID returns the old "referring_member_id" field's value of the PromotionReferrals entity.
// If the PromotionReferrals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionReferralsMutation) OldReferringMemberID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferringMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferringMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferringMemberID: %w", err)
	}
	return oldValue.ReferringMemberID, nil
}

// ClearReferringMemberID clears the value of the "referring_member_id" field.
func (m *PromotionReferralsMutation) ClearReferringMemberID() {
	m.referring_member = nil
	m.clearedFields[promotionreferrals.FieldReferringMemberID] = struct{}{}
}

// ReferringMemberIDCleared returns if the "referring_member_id" field was cleared in this mutation.
func (m *PromotionReferralsMutation) ReferringMemberIDCleared() bool {
	_, ok := m.clearedFields[promotionreferrals.FieldReferringMemberID]
	return ok
}

// ResetReferringMemberID resets all changes to the "referring_member_id" field.
func (m *PromotionReferralsMutation) ResetReferringMemberID() {
	m.referring_member = nil
	delete(m.clearedFields, promotionreferrals.FieldReferringMemberID)
}

// SetReferredMemberID sets the "referred_member_id" field.
func (m *PromotionReferralsMutation) SetReferredMemberID(u uint64) {
	m.referred_member = &u
}

// ReferredMemberID returns the value of the "referred_member_id" field in the mutation.
func (m *PromotionReferralsMutation) ReferredMemberID() (r uint64, exists bool) {
	v := m.referred_member
	if v == nil {
		return
	}
	return *v, true
}

// OldReferredMemberID returns the old "referred_member_id" field's value of the PromotionReferrals entity.
// If the PromotionReferrals object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionReferralsMutation) OldReferredMemberID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferredMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferredMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferredMemberID: %w", err)
	}
	return oldValue.ReferredMemberID, nil
}

// ResetReferredMemberID resets all changes to the "referred_member_id" field.
func (m *PromotionReferralsMutation) ResetReferredMemberID() {
	m.referred_member = nil
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *PromotionReferralsMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[promotionreferrals.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *PromotionReferralsMutation) RiderCleared() bool {
	return m.RiderIDCleared() || m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *PromotionReferralsMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *PromotionReferralsMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *PromotionReferralsMutation) ClearSubscribe() {
	m.clearedsubscribe = true
	m.clearedFields[promotionreferrals.FieldSubscribeID] = struct{}{}
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *PromotionReferralsMutation) SubscribeCleared() bool {
	return m.SubscribeIDCleared() || m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *PromotionReferralsMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *PromotionReferralsMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// ClearReferringMember clears the "referring_member" edge to the PromotionMember entity.
func (m *PromotionReferralsMutation) ClearReferringMember() {
	m.clearedreferring_member = true
	m.clearedFields[promotionreferrals.FieldReferringMemberID] = struct{}{}
}

// ReferringMemberCleared reports if the "referring_member" edge to the PromotionMember entity was cleared.
func (m *PromotionReferralsMutation) ReferringMemberCleared() bool {
	return m.ReferringMemberIDCleared() || m.clearedreferring_member
}

// ReferringMemberIDs returns the "referring_member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReferringMemberID instead. It exists only for internal usage by the builders.
func (m *PromotionReferralsMutation) ReferringMemberIDs() (ids []uint64) {
	if id := m.referring_member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReferringMember resets all changes to the "referring_member" edge.
func (m *PromotionReferralsMutation) ResetReferringMember() {
	m.referring_member = nil
	m.clearedreferring_member = false
}

// ClearReferredMember clears the "referred_member" edge to the PromotionMember entity.
func (m *PromotionReferralsMutation) ClearReferredMember() {
	m.clearedreferred_member = true
	m.clearedFields[promotionreferrals.FieldReferredMemberID] = struct{}{}
}

// ReferredMemberCleared reports if the "referred_member" edge to the PromotionMember entity was cleared.
func (m *PromotionReferralsMutation) ReferredMemberCleared() bool {
	return m.clearedreferred_member
}

// ReferredMemberIDs returns the "referred_member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReferredMemberID instead. It exists only for internal usage by the builders.
func (m *PromotionReferralsMutation) ReferredMemberIDs() (ids []uint64) {
	if id := m.referred_member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReferredMember resets all changes to the "referred_member" edge.
func (m *PromotionReferralsMutation) ResetReferredMember() {
	m.referred_member = nil
	m.clearedreferred_member = false
}

// Where appends a list predicates to the PromotionReferralsMutation builder.
func (m *PromotionReferralsMutation) Where(ps ...predicate.PromotionReferrals) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromotionReferralsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromotionReferralsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromotionReferrals, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromotionReferralsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromotionReferralsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromotionReferrals).
func (m *PromotionReferralsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromotionReferralsMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, promotionreferrals.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, promotionreferrals.FieldUpdatedAt)
	}
	if m.creator != nil {
		fields = append(fields, promotionreferrals.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, promotionreferrals.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, promotionreferrals.FieldRemark)
	}
	if m.rider != nil {
		fields = append(fields, promotionreferrals.FieldRiderID)
	}
	if m.subscribe != nil {
		fields = append(fields, promotionreferrals.FieldSubscribeID)
	}
	if m.referring_member != nil {
		fields = append(fields, promotionreferrals.FieldReferringMemberID)
	}
	if m.referred_member != nil {
		fields = append(fields, promotionreferrals.FieldReferredMemberID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromotionReferralsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotionreferrals.FieldCreatedAt:
		return m.CreatedAt()
	case promotionreferrals.FieldUpdatedAt:
		return m.UpdatedAt()
	case promotionreferrals.FieldCreator:
		return m.Creator()
	case promotionreferrals.FieldLastModifier:
		return m.LastModifier()
	case promotionreferrals.FieldRemark:
		return m.Remark()
	case promotionreferrals.FieldRiderID:
		return m.RiderID()
	case promotionreferrals.FieldSubscribeID:
		return m.SubscribeID()
	case promotionreferrals.FieldReferringMemberID:
		return m.ReferringMemberID()
	case promotionreferrals.FieldReferredMemberID:
		return m.ReferredMemberID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromotionReferralsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotionreferrals.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case promotionreferrals.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case promotionreferrals.FieldCreator:
		return m.OldCreator(ctx)
	case promotionreferrals.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case promotionreferrals.FieldRemark:
		return m.OldRemark(ctx)
	case promotionreferrals.FieldRiderID:
		return m.OldRiderID(ctx)
	case promotionreferrals.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case promotionreferrals.FieldReferringMemberID:
		return m.OldReferringMemberID(ctx)
	case promotionreferrals.FieldReferredMemberID:
		return m.OldReferredMemberID(ctx)
	}
	return nil, fmt.Errorf("unknown PromotionReferrals field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionReferralsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotionreferrals.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case promotionreferrals.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case promotionreferrals.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case promotionreferrals.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case promotionreferrals.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case promotionreferrals.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case promotionreferrals.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case promotionreferrals.FieldReferringMemberID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferringMemberID(v)
		return nil
	case promotionreferrals.FieldReferredMemberID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferredMemberID(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionReferrals field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromotionReferralsMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromotionReferralsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionReferralsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PromotionReferrals numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromotionReferralsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promotionreferrals.FieldCreator) {
		fields = append(fields, promotionreferrals.FieldCreator)
	}
	if m.FieldCleared(promotionreferrals.FieldLastModifier) {
		fields = append(fields, promotionreferrals.FieldLastModifier)
	}
	if m.FieldCleared(promotionreferrals.FieldRemark) {
		fields = append(fields, promotionreferrals.FieldRemark)
	}
	if m.FieldCleared(promotionreferrals.FieldRiderID) {
		fields = append(fields, promotionreferrals.FieldRiderID)
	}
	if m.FieldCleared(promotionreferrals.FieldSubscribeID) {
		fields = append(fields, promotionreferrals.FieldSubscribeID)
	}
	if m.FieldCleared(promotionreferrals.FieldReferringMemberID) {
		fields = append(fields, promotionreferrals.FieldReferringMemberID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromotionReferralsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionReferralsMutation) ClearField(name string) error {
	switch name {
	case promotionreferrals.FieldCreator:
		m.ClearCreator()
		return nil
	case promotionreferrals.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case promotionreferrals.FieldRemark:
		m.ClearRemark()
		return nil
	case promotionreferrals.FieldRiderID:
		m.ClearRiderID()
		return nil
	case promotionreferrals.FieldSubscribeID:
		m.ClearSubscribeID()
		return nil
	case promotionreferrals.FieldReferringMemberID:
		m.ClearReferringMemberID()
		return nil
	}
	return fmt.Errorf("unknown PromotionReferrals nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromotionReferralsMutation) ResetField(name string) error {
	switch name {
	case promotionreferrals.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case promotionreferrals.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case promotionreferrals.FieldCreator:
		m.ResetCreator()
		return nil
	case promotionreferrals.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case promotionreferrals.FieldRemark:
		m.ResetRemark()
		return nil
	case promotionreferrals.FieldRiderID:
		m.ResetRiderID()
		return nil
	case promotionreferrals.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case promotionreferrals.FieldReferringMemberID:
		m.ResetReferringMemberID()
		return nil
	case promotionreferrals.FieldReferredMemberID:
		m.ResetReferredMemberID()
		return nil
	}
	return fmt.Errorf("unknown PromotionReferrals field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromotionReferralsMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.rider != nil {
		edges = append(edges, promotionreferrals.EdgeRider)
	}
	if m.subscribe != nil {
		edges = append(edges, promotionreferrals.EdgeSubscribe)
	}
	if m.referring_member != nil {
		edges = append(edges, promotionreferrals.EdgeReferringMember)
	}
	if m.referred_member != nil {
		edges = append(edges, promotionreferrals.EdgeReferredMember)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromotionReferralsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promotionreferrals.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case promotionreferrals.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	case promotionreferrals.EdgeReferringMember:
		if id := m.referring_member; id != nil {
			return []ent.Value{*id}
		}
	case promotionreferrals.EdgeReferredMember:
		if id := m.referred_member; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromotionReferralsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromotionReferralsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromotionReferralsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedrider {
		edges = append(edges, promotionreferrals.EdgeRider)
	}
	if m.clearedsubscribe {
		edges = append(edges, promotionreferrals.EdgeSubscribe)
	}
	if m.clearedreferring_member {
		edges = append(edges, promotionreferrals.EdgeReferringMember)
	}
	if m.clearedreferred_member {
		edges = append(edges, promotionreferrals.EdgeReferredMember)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromotionReferralsMutation) EdgeCleared(name string) bool {
	switch name {
	case promotionreferrals.EdgeRider:
		return m.clearedrider
	case promotionreferrals.EdgeSubscribe:
		return m.clearedsubscribe
	case promotionreferrals.EdgeReferringMember:
		return m.clearedreferring_member
	case promotionreferrals.EdgeReferredMember:
		return m.clearedreferred_member
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromotionReferralsMutation) ClearEdge(name string) error {
	switch name {
	case promotionreferrals.EdgeRider:
		m.ClearRider()
		return nil
	case promotionreferrals.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	case promotionreferrals.EdgeReferringMember:
		m.ClearReferringMember()
		return nil
	case promotionreferrals.EdgeReferredMember:
		m.ClearReferredMember()
		return nil
	}
	return fmt.Errorf("unknown PromotionReferrals unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromotionReferralsMutation) ResetEdge(name string) error {
	switch name {
	case promotionreferrals.EdgeRider:
		m.ResetRider()
		return nil
	case promotionreferrals.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	case promotionreferrals.EdgeReferringMember:
		m.ResetReferringMember()
		return nil
	case promotionreferrals.EdgeReferredMember:
		m.ResetReferredMember()
		return nil
	}
	return fmt.Errorf("unknown PromotionReferrals edge %s", name)
}

// PromotionReferralsProgressMutation represents an operation that mutates the PromotionReferralsProgress nodes in the graph.
type PromotionReferralsProgressMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uint64
	created_at             *time.Time
	updated_at             *time.Time
	creator                **model.Modifier
	last_modifier          **model.Modifier
	remark                 *string
	referring_member_id    *uint64
	addreferring_member_id *int64
	referred_member_id     *uint64
	addreferred_member_id  *int64
	name                   *string
	status                 *uint8
	addstatus              *int8
	clearedFields          map[string]struct{}
	rider                  *uint64
	clearedrider           bool
	done                   bool
	oldValue               func(context.Context) (*PromotionReferralsProgress, error)
	predicates             []predicate.PromotionReferralsProgress
}

var _ ent.Mutation = (*PromotionReferralsProgressMutation)(nil)

// promotionreferralsprogressOption allows management of the mutation configuration using functional options.
type promotionreferralsprogressOption func(*PromotionReferralsProgressMutation)

// newPromotionReferralsProgressMutation creates new mutation for the PromotionReferralsProgress entity.
func newPromotionReferralsProgressMutation(c config, op Op, opts ...promotionreferralsprogressOption) *PromotionReferralsProgressMutation {
	m := &PromotionReferralsProgressMutation{
		config:        c,
		op:            op,
		typ:           TypePromotionReferralsProgress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionReferralsProgressID sets the ID field of the mutation.
func withPromotionReferralsProgressID(id uint64) promotionreferralsprogressOption {
	return func(m *PromotionReferralsProgressMutation) {
		var (
			err   error
			once  sync.Once
			value *PromotionReferralsProgress
		)
		m.oldValue = func(ctx context.Context) (*PromotionReferralsProgress, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromotionReferralsProgress.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotionReferralsProgress sets the old PromotionReferralsProgress of the mutation.
func withPromotionReferralsProgress(node *PromotionReferralsProgress) promotionreferralsprogressOption {
	return func(m *PromotionReferralsProgressMutation) {
		m.oldValue = func(context.Context) (*PromotionReferralsProgress, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionReferralsProgressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionReferralsProgressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromotionReferralsProgressMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromotionReferralsProgressMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromotionReferralsProgress.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromotionReferralsProgressMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromotionReferralsProgressMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromotionReferralsProgress entity.
// If the PromotionReferralsProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionReferralsProgressMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromotionReferralsProgressMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromotionReferralsProgressMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromotionReferralsProgressMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PromotionReferralsProgress entity.
// If the PromotionReferralsProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionReferralsProgressMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromotionReferralsProgressMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreator sets the "creator" field.
func (m *PromotionReferralsProgressMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *PromotionReferralsProgressMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the PromotionReferralsProgress entity.
// If the PromotionReferralsProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionReferralsProgressMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *PromotionReferralsProgressMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[promotionreferralsprogress.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *PromotionReferralsProgressMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[promotionreferralsprogress.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *PromotionReferralsProgressMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, promotionreferralsprogress.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *PromotionReferralsProgressMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *PromotionReferralsProgressMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the PromotionReferralsProgress entity.
// If the PromotionReferralsProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionReferralsProgressMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *PromotionReferralsProgressMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[promotionreferralsprogress.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *PromotionReferralsProgressMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[promotionreferralsprogress.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *PromotionReferralsProgressMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, promotionreferralsprogress.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *PromotionReferralsProgressMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PromotionReferralsProgressMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the PromotionReferralsProgress entity.
// If the PromotionReferralsProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionReferralsProgressMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PromotionReferralsProgressMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[promotionreferralsprogress.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PromotionReferralsProgressMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[promotionreferralsprogress.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PromotionReferralsProgressMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, promotionreferralsprogress.FieldRemark)
}

// SetRiderID sets the "rider_id" field.
func (m *PromotionReferralsProgressMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *PromotionReferralsProgressMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the PromotionReferralsProgress entity.
// If the PromotionReferralsProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionReferralsProgressMutation) OldRiderID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ClearRiderID clears the value of the "rider_id" field.
func (m *PromotionReferralsProgressMutation) ClearRiderID() {
	m.rider = nil
	m.clearedFields[promotionreferralsprogress.FieldRiderID] = struct{}{}
}

// RiderIDCleared returns if the "rider_id" field was cleared in this mutation.
func (m *PromotionReferralsProgressMutation) RiderIDCleared() bool {
	_, ok := m.clearedFields[promotionreferralsprogress.FieldRiderID]
	return ok
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *PromotionReferralsProgressMutation) ResetRiderID() {
	m.rider = nil
	delete(m.clearedFields, promotionreferralsprogress.FieldRiderID)
}

// SetReferringMemberID sets the "referring_member_id" field.
func (m *PromotionReferralsProgressMutation) SetReferringMemberID(u uint64) {
	m.referring_member_id = &u
	m.addreferring_member_id = nil
}

// ReferringMemberID returns the value of the "referring_member_id" field in the mutation.
func (m *PromotionReferralsProgressMutation) ReferringMemberID() (r uint64, exists bool) {
	v := m.referring_member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferringMemberID returns the old "referring_member_id" field's value of the PromotionReferralsProgress entity.
// If the PromotionReferralsProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionReferralsProgressMutation) OldReferringMemberID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferringMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferringMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferringMemberID: %w", err)
	}
	return oldValue.ReferringMemberID, nil
}

// AddReferringMemberID adds u to the "referring_member_id" field.
func (m *PromotionReferralsProgressMutation) AddReferringMemberID(u int64) {
	if m.addreferring_member_id != nil {
		*m.addreferring_member_id += u
	} else {
		m.addreferring_member_id = &u
	}
}

// AddedReferringMemberID returns the value that was added to the "referring_member_id" field in this mutation.
func (m *PromotionReferralsProgressMutation) AddedReferringMemberID() (r int64, exists bool) {
	v := m.addreferring_member_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearReferringMemberID clears the value of the "referring_member_id" field.
func (m *PromotionReferralsProgressMutation) ClearReferringMemberID() {
	m.referring_member_id = nil
	m.addreferring_member_id = nil
	m.clearedFields[promotionreferralsprogress.FieldReferringMemberID] = struct{}{}
}

// ReferringMemberIDCleared returns if the "referring_member_id" field was cleared in this mutation.
func (m *PromotionReferralsProgressMutation) ReferringMemberIDCleared() bool {
	_, ok := m.clearedFields[promotionreferralsprogress.FieldReferringMemberID]
	return ok
}

// ResetReferringMemberID resets all changes to the "referring_member_id" field.
func (m *PromotionReferralsProgressMutation) ResetReferringMemberID() {
	m.referring_member_id = nil
	m.addreferring_member_id = nil
	delete(m.clearedFields, promotionreferralsprogress.FieldReferringMemberID)
}

// SetReferredMemberID sets the "referred_member_id" field.
func (m *PromotionReferralsProgressMutation) SetReferredMemberID(u uint64) {
	m.referred_member_id = &u
	m.addreferred_member_id = nil
}

// ReferredMemberID returns the value of the "referred_member_id" field in the mutation.
func (m *PromotionReferralsProgressMutation) ReferredMemberID() (r uint64, exists bool) {
	v := m.referred_member_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferredMemberID returns the old "referred_member_id" field's value of the PromotionReferralsProgress entity.
// If the PromotionReferralsProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionReferralsProgressMutation) OldReferredMemberID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferredMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferredMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferredMemberID: %w", err)
	}
	return oldValue.ReferredMemberID, nil
}

// AddReferredMemberID adds u to the "referred_member_id" field.
func (m *PromotionReferralsProgressMutation) AddReferredMemberID(u int64) {
	if m.addreferred_member_id != nil {
		*m.addreferred_member_id += u
	} else {
		m.addreferred_member_id = &u
	}
}

// AddedReferredMemberID returns the value that was added to the "referred_member_id" field in this mutation.
func (m *PromotionReferralsProgressMutation) AddedReferredMemberID() (r int64, exists bool) {
	v := m.addreferred_member_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearReferredMemberID clears the value of the "referred_member_id" field.
func (m *PromotionReferralsProgressMutation) ClearReferredMemberID() {
	m.referred_member_id = nil
	m.addreferred_member_id = nil
	m.clearedFields[promotionreferralsprogress.FieldReferredMemberID] = struct{}{}
}

// ReferredMemberIDCleared returns if the "referred_member_id" field was cleared in this mutation.
func (m *PromotionReferralsProgressMutation) ReferredMemberIDCleared() bool {
	_, ok := m.clearedFields[promotionreferralsprogress.FieldReferredMemberID]
	return ok
}

// ResetReferredMemberID resets all changes to the "referred_member_id" field.
func (m *PromotionReferralsProgressMutation) ResetReferredMemberID() {
	m.referred_member_id = nil
	m.addreferred_member_id = nil
	delete(m.clearedFields, promotionreferralsprogress.FieldReferredMemberID)
}

// SetName sets the "name" field.
func (m *PromotionReferralsProgressMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PromotionReferralsProgressMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PromotionReferralsProgress entity.
// If the PromotionReferralsProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionReferralsProgressMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *PromotionReferralsProgressMutation) ClearName() {
	m.name = nil
	m.clearedFields[promotionreferralsprogress.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *PromotionReferralsProgressMutation) NameCleared() bool {
	_, ok := m.clearedFields[promotionreferralsprogress.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *PromotionReferralsProgressMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, promotionreferralsprogress.FieldName)
}

// SetStatus sets the "status" field.
func (m *PromotionReferralsProgressMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *PromotionReferralsProgressMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PromotionReferralsProgress entity.
// If the PromotionReferralsProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionReferralsProgressMutation) OldStatus(ctx context.Context) (v *uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *PromotionReferralsProgressMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *PromotionReferralsProgressMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *PromotionReferralsProgressMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *PromotionReferralsProgressMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[promotionreferralsprogress.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *PromotionReferralsProgressMutation) RiderCleared() bool {
	return m.RiderIDCleared() || m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *PromotionReferralsProgressMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *PromotionReferralsProgressMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// Where appends a list predicates to the PromotionReferralsProgressMutation builder.
func (m *PromotionReferralsProgressMutation) Where(ps ...predicate.PromotionReferralsProgress) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromotionReferralsProgressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromotionReferralsProgressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromotionReferralsProgress, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromotionReferralsProgressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromotionReferralsProgressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromotionReferralsProgress).
func (m *PromotionReferralsProgressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromotionReferralsProgressMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, promotionreferralsprogress.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, promotionreferralsprogress.FieldUpdatedAt)
	}
	if m.creator != nil {
		fields = append(fields, promotionreferralsprogress.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, promotionreferralsprogress.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, promotionreferralsprogress.FieldRemark)
	}
	if m.rider != nil {
		fields = append(fields, promotionreferralsprogress.FieldRiderID)
	}
	if m.referring_member_id != nil {
		fields = append(fields, promotionreferralsprogress.FieldReferringMemberID)
	}
	if m.referred_member_id != nil {
		fields = append(fields, promotionreferralsprogress.FieldReferredMemberID)
	}
	if m.name != nil {
		fields = append(fields, promotionreferralsprogress.FieldName)
	}
	if m.status != nil {
		fields = append(fields, promotionreferralsprogress.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromotionReferralsProgressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotionreferralsprogress.FieldCreatedAt:
		return m.CreatedAt()
	case promotionreferralsprogress.FieldUpdatedAt:
		return m.UpdatedAt()
	case promotionreferralsprogress.FieldCreator:
		return m.Creator()
	case promotionreferralsprogress.FieldLastModifier:
		return m.LastModifier()
	case promotionreferralsprogress.FieldRemark:
		return m.Remark()
	case promotionreferralsprogress.FieldRiderID:
		return m.RiderID()
	case promotionreferralsprogress.FieldReferringMemberID:
		return m.ReferringMemberID()
	case promotionreferralsprogress.FieldReferredMemberID:
		return m.ReferredMemberID()
	case promotionreferralsprogress.FieldName:
		return m.Name()
	case promotionreferralsprogress.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromotionReferralsProgressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotionreferralsprogress.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case promotionreferralsprogress.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case promotionreferralsprogress.FieldCreator:
		return m.OldCreator(ctx)
	case promotionreferralsprogress.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case promotionreferralsprogress.FieldRemark:
		return m.OldRemark(ctx)
	case promotionreferralsprogress.FieldRiderID:
		return m.OldRiderID(ctx)
	case promotionreferralsprogress.FieldReferringMemberID:
		return m.OldReferringMemberID(ctx)
	case promotionreferralsprogress.FieldReferredMemberID:
		return m.OldReferredMemberID(ctx)
	case promotionreferralsprogress.FieldName:
		return m.OldName(ctx)
	case promotionreferralsprogress.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown PromotionReferralsProgress field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionReferralsProgressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotionreferralsprogress.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case promotionreferralsprogress.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case promotionreferralsprogress.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case promotionreferralsprogress.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case promotionreferralsprogress.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case promotionreferralsprogress.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case promotionreferralsprogress.FieldReferringMemberID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferringMemberID(v)
		return nil
	case promotionreferralsprogress.FieldReferredMemberID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferredMemberID(v)
		return nil
	case promotionreferralsprogress.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case promotionreferralsprogress.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionReferralsProgress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromotionReferralsProgressMutation) AddedFields() []string {
	var fields []string
	if m.addreferring_member_id != nil {
		fields = append(fields, promotionreferralsprogress.FieldReferringMemberID)
	}
	if m.addreferred_member_id != nil {
		fields = append(fields, promotionreferralsprogress.FieldReferredMemberID)
	}
	if m.addstatus != nil {
		fields = append(fields, promotionreferralsprogress.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromotionReferralsProgressMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case promotionreferralsprogress.FieldReferringMemberID:
		return m.AddedReferringMemberID()
	case promotionreferralsprogress.FieldReferredMemberID:
		return m.AddedReferredMemberID()
	case promotionreferralsprogress.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionReferralsProgressMutation) AddField(name string, value ent.Value) error {
	switch name {
	case promotionreferralsprogress.FieldReferringMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReferringMemberID(v)
		return nil
	case promotionreferralsprogress.FieldReferredMemberID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReferredMemberID(v)
		return nil
	case promotionreferralsprogress.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionReferralsProgress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromotionReferralsProgressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promotionreferralsprogress.FieldCreator) {
		fields = append(fields, promotionreferralsprogress.FieldCreator)
	}
	if m.FieldCleared(promotionreferralsprogress.FieldLastModifier) {
		fields = append(fields, promotionreferralsprogress.FieldLastModifier)
	}
	if m.FieldCleared(promotionreferralsprogress.FieldRemark) {
		fields = append(fields, promotionreferralsprogress.FieldRemark)
	}
	if m.FieldCleared(promotionreferralsprogress.FieldRiderID) {
		fields = append(fields, promotionreferralsprogress.FieldRiderID)
	}
	if m.FieldCleared(promotionreferralsprogress.FieldReferringMemberID) {
		fields = append(fields, promotionreferralsprogress.FieldReferringMemberID)
	}
	if m.FieldCleared(promotionreferralsprogress.FieldReferredMemberID) {
		fields = append(fields, promotionreferralsprogress.FieldReferredMemberID)
	}
	if m.FieldCleared(promotionreferralsprogress.FieldName) {
		fields = append(fields, promotionreferralsprogress.FieldName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromotionReferralsProgressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionReferralsProgressMutation) ClearField(name string) error {
	switch name {
	case promotionreferralsprogress.FieldCreator:
		m.ClearCreator()
		return nil
	case promotionreferralsprogress.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case promotionreferralsprogress.FieldRemark:
		m.ClearRemark()
		return nil
	case promotionreferralsprogress.FieldRiderID:
		m.ClearRiderID()
		return nil
	case promotionreferralsprogress.FieldReferringMemberID:
		m.ClearReferringMemberID()
		return nil
	case promotionreferralsprogress.FieldReferredMemberID:
		m.ClearReferredMemberID()
		return nil
	case promotionreferralsprogress.FieldName:
		m.ClearName()
		return nil
	}
	return fmt.Errorf("unknown PromotionReferralsProgress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromotionReferralsProgressMutation) ResetField(name string) error {
	switch name {
	case promotionreferralsprogress.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case promotionreferralsprogress.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case promotionreferralsprogress.FieldCreator:
		m.ResetCreator()
		return nil
	case promotionreferralsprogress.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case promotionreferralsprogress.FieldRemark:
		m.ResetRemark()
		return nil
	case promotionreferralsprogress.FieldRiderID:
		m.ResetRiderID()
		return nil
	case promotionreferralsprogress.FieldReferringMemberID:
		m.ResetReferringMemberID()
		return nil
	case promotionreferralsprogress.FieldReferredMemberID:
		m.ResetReferredMemberID()
		return nil
	case promotionreferralsprogress.FieldName:
		m.ResetName()
		return nil
	case promotionreferralsprogress.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown PromotionReferralsProgress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromotionReferralsProgressMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.rider != nil {
		edges = append(edges, promotionreferralsprogress.EdgeRider)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromotionReferralsProgressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promotionreferralsprogress.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromotionReferralsProgressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromotionReferralsProgressMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromotionReferralsProgressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrider {
		edges = append(edges, promotionreferralsprogress.EdgeRider)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromotionReferralsProgressMutation) EdgeCleared(name string) bool {
	switch name {
	case promotionreferralsprogress.EdgeRider:
		return m.clearedrider
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromotionReferralsProgressMutation) ClearEdge(name string) error {
	switch name {
	case promotionreferralsprogress.EdgeRider:
		m.ClearRider()
		return nil
	}
	return fmt.Errorf("unknown PromotionReferralsProgress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromotionReferralsProgressMutation) ResetEdge(name string) error {
	switch name {
	case promotionreferralsprogress.EdgeRider:
		m.ResetRider()
		return nil
	}
	return fmt.Errorf("unknown PromotionReferralsProgress edge %s", name)
}

// PromotionSettingMutation represents an operation that mutates the PromotionSetting nodes in the graph.
type PromotionSettingMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	creator       **model.Modifier
	last_modifier **model.Modifier
	remark        *string
	title         *string
	content       *string
	key           *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*PromotionSetting, error)
	predicates    []predicate.PromotionSetting
}

var _ ent.Mutation = (*PromotionSettingMutation)(nil)

// promotionsettingOption allows management of the mutation configuration using functional options.
type promotionsettingOption func(*PromotionSettingMutation)

// newPromotionSettingMutation creates new mutation for the PromotionSetting entity.
func newPromotionSettingMutation(c config, op Op, opts ...promotionsettingOption) *PromotionSettingMutation {
	m := &PromotionSettingMutation{
		config:        c,
		op:            op,
		typ:           TypePromotionSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionSettingID sets the ID field of the mutation.
func withPromotionSettingID(id uint64) promotionsettingOption {
	return func(m *PromotionSettingMutation) {
		var (
			err   error
			once  sync.Once
			value *PromotionSetting
		)
		m.oldValue = func(ctx context.Context) (*PromotionSetting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromotionSetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotionSetting sets the old PromotionSetting of the mutation.
func withPromotionSetting(node *PromotionSetting) promotionsettingOption {
	return func(m *PromotionSettingMutation) {
		m.oldValue = func(context.Context) (*PromotionSetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionSettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionSettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromotionSettingMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromotionSettingMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromotionSetting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromotionSettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromotionSettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromotionSetting entity.
// If the PromotionSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionSettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromotionSettingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromotionSettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromotionSettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PromotionSetting entity.
// If the PromotionSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionSettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromotionSettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreator sets the "creator" field.
func (m *PromotionSettingMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *PromotionSettingMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the PromotionSetting entity.
// If the PromotionSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionSettingMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *PromotionSettingMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[promotionsetting.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *PromotionSettingMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[promotionsetting.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *PromotionSettingMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, promotionsetting.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *PromotionSettingMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *PromotionSettingMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the PromotionSetting entity.
// If the PromotionSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionSettingMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *PromotionSettingMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[promotionsetting.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *PromotionSettingMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[promotionsetting.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *PromotionSettingMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, promotionsetting.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *PromotionSettingMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PromotionSettingMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the PromotionSetting entity.
// If the PromotionSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionSettingMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PromotionSettingMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[promotionsetting.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PromotionSettingMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[promotionsetting.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PromotionSettingMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, promotionsetting.FieldRemark)
}

// SetTitle sets the "title" field.
func (m *PromotionSettingMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PromotionSettingMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the PromotionSetting entity.
// If the PromotionSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionSettingMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *PromotionSettingMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[promotionsetting.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *PromotionSettingMutation) TitleCleared() bool {
	_, ok := m.clearedFields[promotionsetting.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *PromotionSettingMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, promotionsetting.FieldTitle)
}

// SetContent sets the "content" field.
func (m *PromotionSettingMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *PromotionSettingMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the PromotionSetting entity.
// If the PromotionSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionSettingMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *PromotionSettingMutation) ClearContent() {
	m.content = nil
	m.clearedFields[promotionsetting.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *PromotionSettingMutation) ContentCleared() bool {
	_, ok := m.clearedFields[promotionsetting.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *PromotionSettingMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, promotionsetting.FieldContent)
}

// SetKey sets the "key" field.
func (m *PromotionSettingMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *PromotionSettingMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the PromotionSetting entity.
// If the PromotionSetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionSettingMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *PromotionSettingMutation) ResetKey() {
	m.key = nil
}

// Where appends a list predicates to the PromotionSettingMutation builder.
func (m *PromotionSettingMutation) Where(ps ...predicate.PromotionSetting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromotionSettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromotionSettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromotionSetting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromotionSettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromotionSettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromotionSetting).
func (m *PromotionSettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromotionSettingMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, promotionsetting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, promotionsetting.FieldUpdatedAt)
	}
	if m.creator != nil {
		fields = append(fields, promotionsetting.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, promotionsetting.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, promotionsetting.FieldRemark)
	}
	if m.title != nil {
		fields = append(fields, promotionsetting.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, promotionsetting.FieldContent)
	}
	if m.key != nil {
		fields = append(fields, promotionsetting.FieldKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromotionSettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotionsetting.FieldCreatedAt:
		return m.CreatedAt()
	case promotionsetting.FieldUpdatedAt:
		return m.UpdatedAt()
	case promotionsetting.FieldCreator:
		return m.Creator()
	case promotionsetting.FieldLastModifier:
		return m.LastModifier()
	case promotionsetting.FieldRemark:
		return m.Remark()
	case promotionsetting.FieldTitle:
		return m.Title()
	case promotionsetting.FieldContent:
		return m.Content()
	case promotionsetting.FieldKey:
		return m.Key()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromotionSettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotionsetting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case promotionsetting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case promotionsetting.FieldCreator:
		return m.OldCreator(ctx)
	case promotionsetting.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case promotionsetting.FieldRemark:
		return m.OldRemark(ctx)
	case promotionsetting.FieldTitle:
		return m.OldTitle(ctx)
	case promotionsetting.FieldContent:
		return m.OldContent(ctx)
	case promotionsetting.FieldKey:
		return m.OldKey(ctx)
	}
	return nil, fmt.Errorf("unknown PromotionSetting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionSettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotionsetting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case promotionsetting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case promotionsetting.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case promotionsetting.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case promotionsetting.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case promotionsetting.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case promotionsetting.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case promotionsetting.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionSetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromotionSettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromotionSettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionSettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PromotionSetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromotionSettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promotionsetting.FieldCreator) {
		fields = append(fields, promotionsetting.FieldCreator)
	}
	if m.FieldCleared(promotionsetting.FieldLastModifier) {
		fields = append(fields, promotionsetting.FieldLastModifier)
	}
	if m.FieldCleared(promotionsetting.FieldRemark) {
		fields = append(fields, promotionsetting.FieldRemark)
	}
	if m.FieldCleared(promotionsetting.FieldTitle) {
		fields = append(fields, promotionsetting.FieldTitle)
	}
	if m.FieldCleared(promotionsetting.FieldContent) {
		fields = append(fields, promotionsetting.FieldContent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromotionSettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionSettingMutation) ClearField(name string) error {
	switch name {
	case promotionsetting.FieldCreator:
		m.ClearCreator()
		return nil
	case promotionsetting.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case promotionsetting.FieldRemark:
		m.ClearRemark()
		return nil
	case promotionsetting.FieldTitle:
		m.ClearTitle()
		return nil
	case promotionsetting.FieldContent:
		m.ClearContent()
		return nil
	}
	return fmt.Errorf("unknown PromotionSetting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromotionSettingMutation) ResetField(name string) error {
	switch name {
	case promotionsetting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case promotionsetting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case promotionsetting.FieldCreator:
		m.ResetCreator()
		return nil
	case promotionsetting.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case promotionsetting.FieldRemark:
		m.ResetRemark()
		return nil
	case promotionsetting.FieldTitle:
		m.ResetTitle()
		return nil
	case promotionsetting.FieldContent:
		m.ResetContent()
		return nil
	case promotionsetting.FieldKey:
		m.ResetKey()
		return nil
	}
	return fmt.Errorf("unknown PromotionSetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromotionSettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromotionSettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromotionSettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromotionSettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromotionSettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromotionSettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromotionSettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PromotionSetting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromotionSettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PromotionSetting edge %s", name)
}

// PromotionWithdrawalMutation represents an operation that mutates the PromotionWithdrawal nodes in the graph.
type PromotionWithdrawalMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	creator         **model.Modifier
	last_modifier   **model.Modifier
	remark          *string
	status          *uint8
	addstatus       *int8
	apply_amount    *float64
	addapply_amount *float64
	amount          *float64
	addamount       *float64
	fee             *float64
	addfee          *float64
	tex             *float64
	addtex          *float64
	method          *uint8
	addmethod       *int8
	apply_time      *time.Time
	review_time     *time.Time
	clearedFields   map[string]struct{}
	member          *uint64
	clearedmember   bool
	cards           *uint64
	clearedcards    bool
	done            bool
	oldValue        func(context.Context) (*PromotionWithdrawal, error)
	predicates      []predicate.PromotionWithdrawal
}

var _ ent.Mutation = (*PromotionWithdrawalMutation)(nil)

// promotionwithdrawalOption allows management of the mutation configuration using functional options.
type promotionwithdrawalOption func(*PromotionWithdrawalMutation)

// newPromotionWithdrawalMutation creates new mutation for the PromotionWithdrawal entity.
func newPromotionWithdrawalMutation(c config, op Op, opts ...promotionwithdrawalOption) *PromotionWithdrawalMutation {
	m := &PromotionWithdrawalMutation{
		config:        c,
		op:            op,
		typ:           TypePromotionWithdrawal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPromotionWithdrawalID sets the ID field of the mutation.
func withPromotionWithdrawalID(id uint64) promotionwithdrawalOption {
	return func(m *PromotionWithdrawalMutation) {
		var (
			err   error
			once  sync.Once
			value *PromotionWithdrawal
		)
		m.oldValue = func(ctx context.Context) (*PromotionWithdrawal, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PromotionWithdrawal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPromotionWithdrawal sets the old PromotionWithdrawal of the mutation.
func withPromotionWithdrawal(node *PromotionWithdrawal) promotionwithdrawalOption {
	return func(m *PromotionWithdrawalMutation) {
		m.oldValue = func(context.Context) (*PromotionWithdrawal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PromotionWithdrawalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PromotionWithdrawalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PromotionWithdrawalMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PromotionWithdrawalMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PromotionWithdrawal.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PromotionWithdrawalMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PromotionWithdrawalMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PromotionWithdrawal entity.
// If the PromotionWithdrawal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionWithdrawalMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PromotionWithdrawalMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PromotionWithdrawalMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PromotionWithdrawalMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PromotionWithdrawal entity.
// If the PromotionWithdrawal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionWithdrawalMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PromotionWithdrawalMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PromotionWithdrawalMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PromotionWithdrawalMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the PromotionWithdrawal entity.
// If the PromotionWithdrawal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionWithdrawalMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PromotionWithdrawalMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[promotionwithdrawal.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PromotionWithdrawalMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[promotionwithdrawal.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PromotionWithdrawalMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, promotionwithdrawal.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *PromotionWithdrawalMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *PromotionWithdrawalMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the PromotionWithdrawal entity.
// If the PromotionWithdrawal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionWithdrawalMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *PromotionWithdrawalMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[promotionwithdrawal.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *PromotionWithdrawalMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[promotionwithdrawal.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *PromotionWithdrawalMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, promotionwithdrawal.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *PromotionWithdrawalMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *PromotionWithdrawalMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the PromotionWithdrawal entity.
// If the PromotionWithdrawal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionWithdrawalMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *PromotionWithdrawalMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[promotionwithdrawal.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *PromotionWithdrawalMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[promotionwithdrawal.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *PromotionWithdrawalMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, promotionwithdrawal.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *PromotionWithdrawalMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PromotionWithdrawalMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the PromotionWithdrawal entity.
// If the PromotionWithdrawal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionWithdrawalMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PromotionWithdrawalMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[promotionwithdrawal.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PromotionWithdrawalMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[promotionwithdrawal.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PromotionWithdrawalMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, promotionwithdrawal.FieldRemark)
}

// SetMemberID sets the "member_id" field.
func (m *PromotionWithdrawalMutation) SetMemberID(u uint64) {
	m.member = &u
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *PromotionWithdrawalMutation) MemberID() (r uint64, exists bool) {
	v := m.member
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the PromotionWithdrawal entity.
// If the PromotionWithdrawal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionWithdrawalMutation) OldMemberID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *PromotionWithdrawalMutation) ResetMemberID() {
	m.member = nil
}

// SetStatus sets the "status" field.
func (m *PromotionWithdrawalMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *PromotionWithdrawalMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PromotionWithdrawal entity.
// If the PromotionWithdrawal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionWithdrawalMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *PromotionWithdrawalMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *PromotionWithdrawalMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *PromotionWithdrawalMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetApplyAmount sets the "apply_amount" field.
func (m *PromotionWithdrawalMutation) SetApplyAmount(f float64) {
	m.apply_amount = &f
	m.addapply_amount = nil
}

// ApplyAmount returns the value of the "apply_amount" field in the mutation.
func (m *PromotionWithdrawalMutation) ApplyAmount() (r float64, exists bool) {
	v := m.apply_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldApplyAmount returns the old "apply_amount" field's value of the PromotionWithdrawal entity.
// If the PromotionWithdrawal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionWithdrawalMutation) OldApplyAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplyAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplyAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplyAmount: %w", err)
	}
	return oldValue.ApplyAmount, nil
}

// AddApplyAmount adds f to the "apply_amount" field.
func (m *PromotionWithdrawalMutation) AddApplyAmount(f float64) {
	if m.addapply_amount != nil {
		*m.addapply_amount += f
	} else {
		m.addapply_amount = &f
	}
}

// AddedApplyAmount returns the value that was added to the "apply_amount" field in this mutation.
func (m *PromotionWithdrawalMutation) AddedApplyAmount() (r float64, exists bool) {
	v := m.addapply_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetApplyAmount resets all changes to the "apply_amount" field.
func (m *PromotionWithdrawalMutation) ResetApplyAmount() {
	m.apply_amount = nil
	m.addapply_amount = nil
}

// SetAmount sets the "amount" field.
func (m *PromotionWithdrawalMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PromotionWithdrawalMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the PromotionWithdrawal entity.
// If the PromotionWithdrawal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionWithdrawalMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *PromotionWithdrawalMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PromotionWithdrawalMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PromotionWithdrawalMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetFee sets the "fee" field.
func (m *PromotionWithdrawalMutation) SetFee(f float64) {
	m.fee = &f
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *PromotionWithdrawalMutation) Fee() (r float64, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the PromotionWithdrawal entity.
// If the PromotionWithdrawal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionWithdrawalMutation) OldFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds f to the "fee" field.
func (m *PromotionWithdrawalMutation) AddFee(f float64) {
	if m.addfee != nil {
		*m.addfee += f
	} else {
		m.addfee = &f
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *PromotionWithdrawalMutation) AddedFee() (r float64, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ResetFee resets all changes to the "fee" field.
func (m *PromotionWithdrawalMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
}

// SetTex sets the "tex" field.
func (m *PromotionWithdrawalMutation) SetTex(f float64) {
	m.tex = &f
	m.addtex = nil
}

// Tex returns the value of the "tex" field in the mutation.
func (m *PromotionWithdrawalMutation) Tex() (r float64, exists bool) {
	v := m.tex
	if v == nil {
		return
	}
	return *v, true
}

// OldTex returns the old "tex" field's value of the PromotionWithdrawal entity.
// If the PromotionWithdrawal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionWithdrawalMutation) OldTex(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTex: %w", err)
	}
	return oldValue.Tex, nil
}

// AddTex adds f to the "tex" field.
func (m *PromotionWithdrawalMutation) AddTex(f float64) {
	if m.addtex != nil {
		*m.addtex += f
	} else {
		m.addtex = &f
	}
}

// AddedTex returns the value that was added to the "tex" field in this mutation.
func (m *PromotionWithdrawalMutation) AddedTex() (r float64, exists bool) {
	v := m.addtex
	if v == nil {
		return
	}
	return *v, true
}

// ResetTex resets all changes to the "tex" field.
func (m *PromotionWithdrawalMutation) ResetTex() {
	m.tex = nil
	m.addtex = nil
}

// SetMethod sets the "method" field.
func (m *PromotionWithdrawalMutation) SetMethod(u uint8) {
	m.method = &u
	m.addmethod = nil
}

// Method returns the value of the "method" field in the mutation.
func (m *PromotionWithdrawalMutation) Method() (r uint8, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the PromotionWithdrawal entity.
// If the PromotionWithdrawal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionWithdrawalMutation) OldMethod(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// AddMethod adds u to the "method" field.
func (m *PromotionWithdrawalMutation) AddMethod(u int8) {
	if m.addmethod != nil {
		*m.addmethod += u
	} else {
		m.addmethod = &u
	}
}

// AddedMethod returns the value that was added to the "method" field in this mutation.
func (m *PromotionWithdrawalMutation) AddedMethod() (r int8, exists bool) {
	v := m.addmethod
	if v == nil {
		return
	}
	return *v, true
}

// ResetMethod resets all changes to the "method" field.
func (m *PromotionWithdrawalMutation) ResetMethod() {
	m.method = nil
	m.addmethod = nil
}

// SetAccountID sets the "account_id" field.
func (m *PromotionWithdrawalMutation) SetAccountID(u uint64) {
	m.cards = &u
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *PromotionWithdrawalMutation) AccountID() (r uint64, exists bool) {
	v := m.cards
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the PromotionWithdrawal entity.
// If the PromotionWithdrawal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionWithdrawalMutation) OldAccountID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ClearAccountID clears the value of the "account_id" field.
func (m *PromotionWithdrawalMutation) ClearAccountID() {
	m.cards = nil
	m.clearedFields[promotionwithdrawal.FieldAccountID] = struct{}{}
}

// AccountIDCleared returns if the "account_id" field was cleared in this mutation.
func (m *PromotionWithdrawalMutation) AccountIDCleared() bool {
	_, ok := m.clearedFields[promotionwithdrawal.FieldAccountID]
	return ok
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *PromotionWithdrawalMutation) ResetAccountID() {
	m.cards = nil
	delete(m.clearedFields, promotionwithdrawal.FieldAccountID)
}

// SetApplyTime sets the "apply_time" field.
func (m *PromotionWithdrawalMutation) SetApplyTime(t time.Time) {
	m.apply_time = &t
}

// ApplyTime returns the value of the "apply_time" field in the mutation.
func (m *PromotionWithdrawalMutation) ApplyTime() (r time.Time, exists bool) {
	v := m.apply_time
	if v == nil {
		return
	}
	return *v, true
}

// OldApplyTime returns the old "apply_time" field's value of the PromotionWithdrawal entity.
// If the PromotionWithdrawal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionWithdrawalMutation) OldApplyTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplyTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplyTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplyTime: %w", err)
	}
	return oldValue.ApplyTime, nil
}

// ClearApplyTime clears the value of the "apply_time" field.
func (m *PromotionWithdrawalMutation) ClearApplyTime() {
	m.apply_time = nil
	m.clearedFields[promotionwithdrawal.FieldApplyTime] = struct{}{}
}

// ApplyTimeCleared returns if the "apply_time" field was cleared in this mutation.
func (m *PromotionWithdrawalMutation) ApplyTimeCleared() bool {
	_, ok := m.clearedFields[promotionwithdrawal.FieldApplyTime]
	return ok
}

// ResetApplyTime resets all changes to the "apply_time" field.
func (m *PromotionWithdrawalMutation) ResetApplyTime() {
	m.apply_time = nil
	delete(m.clearedFields, promotionwithdrawal.FieldApplyTime)
}

// SetReviewTime sets the "review_time" field.
func (m *PromotionWithdrawalMutation) SetReviewTime(t time.Time) {
	m.review_time = &t
}

// ReviewTime returns the value of the "review_time" field in the mutation.
func (m *PromotionWithdrawalMutation) ReviewTime() (r time.Time, exists bool) {
	v := m.review_time
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewTime returns the old "review_time" field's value of the PromotionWithdrawal entity.
// If the PromotionWithdrawal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PromotionWithdrawalMutation) OldReviewTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewTime: %w", err)
	}
	return oldValue.ReviewTime, nil
}

// ClearReviewTime clears the value of the "review_time" field.
func (m *PromotionWithdrawalMutation) ClearReviewTime() {
	m.review_time = nil
	m.clearedFields[promotionwithdrawal.FieldReviewTime] = struct{}{}
}

// ReviewTimeCleared returns if the "review_time" field was cleared in this mutation.
func (m *PromotionWithdrawalMutation) ReviewTimeCleared() bool {
	_, ok := m.clearedFields[promotionwithdrawal.FieldReviewTime]
	return ok
}

// ResetReviewTime resets all changes to the "review_time" field.
func (m *PromotionWithdrawalMutation) ResetReviewTime() {
	m.review_time = nil
	delete(m.clearedFields, promotionwithdrawal.FieldReviewTime)
}

// ClearMember clears the "member" edge to the PromotionMember entity.
func (m *PromotionWithdrawalMutation) ClearMember() {
	m.clearedmember = true
	m.clearedFields[promotionwithdrawal.FieldMemberID] = struct{}{}
}

// MemberCleared reports if the "member" edge to the PromotionMember entity was cleared.
func (m *PromotionWithdrawalMutation) MemberCleared() bool {
	return m.clearedmember
}

// MemberIDs returns the "member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberID instead. It exists only for internal usage by the builders.
func (m *PromotionWithdrawalMutation) MemberIDs() (ids []uint64) {
	if id := m.member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMember resets all changes to the "member" edge.
func (m *PromotionWithdrawalMutation) ResetMember() {
	m.member = nil
	m.clearedmember = false
}

// SetCardsID sets the "cards" edge to the PromotionBankCard entity by id.
func (m *PromotionWithdrawalMutation) SetCardsID(id uint64) {
	m.cards = &id
}

// ClearCards clears the "cards" edge to the PromotionBankCard entity.
func (m *PromotionWithdrawalMutation) ClearCards() {
	m.clearedcards = true
	m.clearedFields[promotionwithdrawal.FieldAccountID] = struct{}{}
}

// CardsCleared reports if the "cards" edge to the PromotionBankCard entity was cleared.
func (m *PromotionWithdrawalMutation) CardsCleared() bool {
	return m.AccountIDCleared() || m.clearedcards
}

// CardsID returns the "cards" edge ID in the mutation.
func (m *PromotionWithdrawalMutation) CardsID() (id uint64, exists bool) {
	if m.cards != nil {
		return *m.cards, true
	}
	return
}

// CardsIDs returns the "cards" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CardsID instead. It exists only for internal usage by the builders.
func (m *PromotionWithdrawalMutation) CardsIDs() (ids []uint64) {
	if id := m.cards; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCards resets all changes to the "cards" edge.
func (m *PromotionWithdrawalMutation) ResetCards() {
	m.cards = nil
	m.clearedcards = false
}

// Where appends a list predicates to the PromotionWithdrawalMutation builder.
func (m *PromotionWithdrawalMutation) Where(ps ...predicate.PromotionWithdrawal) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PromotionWithdrawalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PromotionWithdrawalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PromotionWithdrawal, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PromotionWithdrawalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PromotionWithdrawalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PromotionWithdrawal).
func (m *PromotionWithdrawalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PromotionWithdrawalMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, promotionwithdrawal.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, promotionwithdrawal.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, promotionwithdrawal.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, promotionwithdrawal.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, promotionwithdrawal.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, promotionwithdrawal.FieldRemark)
	}
	if m.member != nil {
		fields = append(fields, promotionwithdrawal.FieldMemberID)
	}
	if m.status != nil {
		fields = append(fields, promotionwithdrawal.FieldStatus)
	}
	if m.apply_amount != nil {
		fields = append(fields, promotionwithdrawal.FieldApplyAmount)
	}
	if m.amount != nil {
		fields = append(fields, promotionwithdrawal.FieldAmount)
	}
	if m.fee != nil {
		fields = append(fields, promotionwithdrawal.FieldFee)
	}
	if m.tex != nil {
		fields = append(fields, promotionwithdrawal.FieldTex)
	}
	if m.method != nil {
		fields = append(fields, promotionwithdrawal.FieldMethod)
	}
	if m.cards != nil {
		fields = append(fields, promotionwithdrawal.FieldAccountID)
	}
	if m.apply_time != nil {
		fields = append(fields, promotionwithdrawal.FieldApplyTime)
	}
	if m.review_time != nil {
		fields = append(fields, promotionwithdrawal.FieldReviewTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PromotionWithdrawalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case promotionwithdrawal.FieldCreatedAt:
		return m.CreatedAt()
	case promotionwithdrawal.FieldUpdatedAt:
		return m.UpdatedAt()
	case promotionwithdrawal.FieldDeletedAt:
		return m.DeletedAt()
	case promotionwithdrawal.FieldCreator:
		return m.Creator()
	case promotionwithdrawal.FieldLastModifier:
		return m.LastModifier()
	case promotionwithdrawal.FieldRemark:
		return m.Remark()
	case promotionwithdrawal.FieldMemberID:
		return m.MemberID()
	case promotionwithdrawal.FieldStatus:
		return m.Status()
	case promotionwithdrawal.FieldApplyAmount:
		return m.ApplyAmount()
	case promotionwithdrawal.FieldAmount:
		return m.Amount()
	case promotionwithdrawal.FieldFee:
		return m.Fee()
	case promotionwithdrawal.FieldTex:
		return m.Tex()
	case promotionwithdrawal.FieldMethod:
		return m.Method()
	case promotionwithdrawal.FieldAccountID:
		return m.AccountID()
	case promotionwithdrawal.FieldApplyTime:
		return m.ApplyTime()
	case promotionwithdrawal.FieldReviewTime:
		return m.ReviewTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PromotionWithdrawalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case promotionwithdrawal.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case promotionwithdrawal.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case promotionwithdrawal.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case promotionwithdrawal.FieldCreator:
		return m.OldCreator(ctx)
	case promotionwithdrawal.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case promotionwithdrawal.FieldRemark:
		return m.OldRemark(ctx)
	case promotionwithdrawal.FieldMemberID:
		return m.OldMemberID(ctx)
	case promotionwithdrawal.FieldStatus:
		return m.OldStatus(ctx)
	case promotionwithdrawal.FieldApplyAmount:
		return m.OldApplyAmount(ctx)
	case promotionwithdrawal.FieldAmount:
		return m.OldAmount(ctx)
	case promotionwithdrawal.FieldFee:
		return m.OldFee(ctx)
	case promotionwithdrawal.FieldTex:
		return m.OldTex(ctx)
	case promotionwithdrawal.FieldMethod:
		return m.OldMethod(ctx)
	case promotionwithdrawal.FieldAccountID:
		return m.OldAccountID(ctx)
	case promotionwithdrawal.FieldApplyTime:
		return m.OldApplyTime(ctx)
	case promotionwithdrawal.FieldReviewTime:
		return m.OldReviewTime(ctx)
	}
	return nil, fmt.Errorf("unknown PromotionWithdrawal field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionWithdrawalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case promotionwithdrawal.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case promotionwithdrawal.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case promotionwithdrawal.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case promotionwithdrawal.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case promotionwithdrawal.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case promotionwithdrawal.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case promotionwithdrawal.FieldMemberID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	case promotionwithdrawal.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case promotionwithdrawal.FieldApplyAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplyAmount(v)
		return nil
	case promotionwithdrawal.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case promotionwithdrawal.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case promotionwithdrawal.FieldTex:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTex(v)
		return nil
	case promotionwithdrawal.FieldMethod:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case promotionwithdrawal.FieldAccountID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case promotionwithdrawal.FieldApplyTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplyTime(v)
		return nil
	case promotionwithdrawal.FieldReviewTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewTime(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionWithdrawal field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PromotionWithdrawalMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, promotionwithdrawal.FieldStatus)
	}
	if m.addapply_amount != nil {
		fields = append(fields, promotionwithdrawal.FieldApplyAmount)
	}
	if m.addamount != nil {
		fields = append(fields, promotionwithdrawal.FieldAmount)
	}
	if m.addfee != nil {
		fields = append(fields, promotionwithdrawal.FieldFee)
	}
	if m.addtex != nil {
		fields = append(fields, promotionwithdrawal.FieldTex)
	}
	if m.addmethod != nil {
		fields = append(fields, promotionwithdrawal.FieldMethod)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PromotionWithdrawalMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case promotionwithdrawal.FieldStatus:
		return m.AddedStatus()
	case promotionwithdrawal.FieldApplyAmount:
		return m.AddedApplyAmount()
	case promotionwithdrawal.FieldAmount:
		return m.AddedAmount()
	case promotionwithdrawal.FieldFee:
		return m.AddedFee()
	case promotionwithdrawal.FieldTex:
		return m.AddedTex()
	case promotionwithdrawal.FieldMethod:
		return m.AddedMethod()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PromotionWithdrawalMutation) AddField(name string, value ent.Value) error {
	switch name {
	case promotionwithdrawal.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case promotionwithdrawal.FieldApplyAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddApplyAmount(v)
		return nil
	case promotionwithdrawal.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case promotionwithdrawal.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	case promotionwithdrawal.FieldTex:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTex(v)
		return nil
	case promotionwithdrawal.FieldMethod:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMethod(v)
		return nil
	}
	return fmt.Errorf("unknown PromotionWithdrawal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PromotionWithdrawalMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(promotionwithdrawal.FieldDeletedAt) {
		fields = append(fields, promotionwithdrawal.FieldDeletedAt)
	}
	if m.FieldCleared(promotionwithdrawal.FieldCreator) {
		fields = append(fields, promotionwithdrawal.FieldCreator)
	}
	if m.FieldCleared(promotionwithdrawal.FieldLastModifier) {
		fields = append(fields, promotionwithdrawal.FieldLastModifier)
	}
	if m.FieldCleared(promotionwithdrawal.FieldRemark) {
		fields = append(fields, promotionwithdrawal.FieldRemark)
	}
	if m.FieldCleared(promotionwithdrawal.FieldAccountID) {
		fields = append(fields, promotionwithdrawal.FieldAccountID)
	}
	if m.FieldCleared(promotionwithdrawal.FieldApplyTime) {
		fields = append(fields, promotionwithdrawal.FieldApplyTime)
	}
	if m.FieldCleared(promotionwithdrawal.FieldReviewTime) {
		fields = append(fields, promotionwithdrawal.FieldReviewTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PromotionWithdrawalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PromotionWithdrawalMutation) ClearField(name string) error {
	switch name {
	case promotionwithdrawal.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case promotionwithdrawal.FieldCreator:
		m.ClearCreator()
		return nil
	case promotionwithdrawal.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case promotionwithdrawal.FieldRemark:
		m.ClearRemark()
		return nil
	case promotionwithdrawal.FieldAccountID:
		m.ClearAccountID()
		return nil
	case promotionwithdrawal.FieldApplyTime:
		m.ClearApplyTime()
		return nil
	case promotionwithdrawal.FieldReviewTime:
		m.ClearReviewTime()
		return nil
	}
	return fmt.Errorf("unknown PromotionWithdrawal nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PromotionWithdrawalMutation) ResetField(name string) error {
	switch name {
	case promotionwithdrawal.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case promotionwithdrawal.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case promotionwithdrawal.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case promotionwithdrawal.FieldCreator:
		m.ResetCreator()
		return nil
	case promotionwithdrawal.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case promotionwithdrawal.FieldRemark:
		m.ResetRemark()
		return nil
	case promotionwithdrawal.FieldMemberID:
		m.ResetMemberID()
		return nil
	case promotionwithdrawal.FieldStatus:
		m.ResetStatus()
		return nil
	case promotionwithdrawal.FieldApplyAmount:
		m.ResetApplyAmount()
		return nil
	case promotionwithdrawal.FieldAmount:
		m.ResetAmount()
		return nil
	case promotionwithdrawal.FieldFee:
		m.ResetFee()
		return nil
	case promotionwithdrawal.FieldTex:
		m.ResetTex()
		return nil
	case promotionwithdrawal.FieldMethod:
		m.ResetMethod()
		return nil
	case promotionwithdrawal.FieldAccountID:
		m.ResetAccountID()
		return nil
	case promotionwithdrawal.FieldApplyTime:
		m.ResetApplyTime()
		return nil
	case promotionwithdrawal.FieldReviewTime:
		m.ResetReviewTime()
		return nil
	}
	return fmt.Errorf("unknown PromotionWithdrawal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PromotionWithdrawalMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.member != nil {
		edges = append(edges, promotionwithdrawal.EdgeMember)
	}
	if m.cards != nil {
		edges = append(edges, promotionwithdrawal.EdgeCards)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PromotionWithdrawalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case promotionwithdrawal.EdgeMember:
		if id := m.member; id != nil {
			return []ent.Value{*id}
		}
	case promotionwithdrawal.EdgeCards:
		if id := m.cards; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PromotionWithdrawalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PromotionWithdrawalMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PromotionWithdrawalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmember {
		edges = append(edges, promotionwithdrawal.EdgeMember)
	}
	if m.clearedcards {
		edges = append(edges, promotionwithdrawal.EdgeCards)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PromotionWithdrawalMutation) EdgeCleared(name string) bool {
	switch name {
	case promotionwithdrawal.EdgeMember:
		return m.clearedmember
	case promotionwithdrawal.EdgeCards:
		return m.clearedcards
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PromotionWithdrawalMutation) ClearEdge(name string) error {
	switch name {
	case promotionwithdrawal.EdgeMember:
		m.ClearMember()
		return nil
	case promotionwithdrawal.EdgeCards:
		m.ClearCards()
		return nil
	}
	return fmt.Errorf("unknown PromotionWithdrawal unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PromotionWithdrawalMutation) ResetEdge(name string) error {
	switch name {
	case promotionwithdrawal.EdgeMember:
		m.ResetMember()
		return nil
	case promotionwithdrawal.EdgeCards:
		m.ResetCards()
		return nil
	}
	return fmt.Errorf("unknown PromotionWithdrawal edge %s", name)
}

// PushmessageMutation represents an operation that mutates the Pushmessage nodes in the graph.
type PushmessageMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	title             *string
	image             *string
	content           *string
	push_type         *uint8
	addpush_type      *int8
	push_time         *time.Time
	is_home           *bool
	home_content      *string
	message_status    *uint8
	addmessage_status *int8
	message_type      *uint8
	addmessage_type   *int8
	third_party_id    *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Pushmessage, error)
	predicates        []predicate.Pushmessage
}

var _ ent.Mutation = (*PushmessageMutation)(nil)

// pushmessageOption allows management of the mutation configuration using functional options.
type pushmessageOption func(*PushmessageMutation)

// newPushmessageMutation creates new mutation for the Pushmessage entity.
func newPushmessageMutation(c config, op Op, opts ...pushmessageOption) *PushmessageMutation {
	m := &PushmessageMutation{
		config:        c,
		op:            op,
		typ:           TypePushmessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPushmessageID sets the ID field of the mutation.
func withPushmessageID(id uint64) pushmessageOption {
	return func(m *PushmessageMutation) {
		var (
			err   error
			once  sync.Once
			value *Pushmessage
		)
		m.oldValue = func(ctx context.Context) (*Pushmessage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pushmessage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPushmessage sets the old Pushmessage of the mutation.
func withPushmessage(node *Pushmessage) pushmessageOption {
	return func(m *PushmessageMutation) {
		m.oldValue = func(context.Context) (*Pushmessage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PushmessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PushmessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PushmessageMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PushmessageMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Pushmessage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PushmessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PushmessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Pushmessage entity.
// If the Pushmessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PushmessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PushmessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PushmessageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PushmessageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Pushmessage entity.
// If the Pushmessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PushmessageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PushmessageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PushmessageMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PushmessageMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Pushmessage entity.
// If the Pushmessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PushmessageMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PushmessageMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[pushmessage.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PushmessageMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[pushmessage.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PushmessageMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, pushmessage.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *PushmessageMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *PushmessageMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Pushmessage entity.
// If the Pushmessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PushmessageMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *PushmessageMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[pushmessage.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *PushmessageMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[pushmessage.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *PushmessageMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, pushmessage.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *PushmessageMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *PushmessageMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Pushmessage entity.
// If the Pushmessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PushmessageMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *PushmessageMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[pushmessage.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *PushmessageMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[pushmessage.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *PushmessageMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, pushmessage.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *PushmessageMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PushmessageMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Pushmessage entity.
// If the Pushmessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PushmessageMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PushmessageMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[pushmessage.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PushmessageMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[pushmessage.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PushmessageMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, pushmessage.FieldRemark)
}

// SetTitle sets the "title" field.
func (m *PushmessageMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PushmessageMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Pushmessage entity.
// If the Pushmessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PushmessageMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *PushmessageMutation) ResetTitle() {
	m.title = nil
}

// SetImage sets the "image" field.
func (m *PushmessageMutation) SetImage(s string) {
	m.image = &s
}

// Image returns the value of the "image" field in the mutation.
func (m *PushmessageMutation) Image() (r string, exists bool) {
	v := m.image
	if v == nil {
		return
	}
	return *v, true
}

// OldImage returns the old "image" field's value of the Pushmessage entity.
// If the Pushmessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PushmessageMutation) OldImage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImage: %w", err)
	}
	return oldValue.Image, nil
}

// ResetImage resets all changes to the "image" field.
func (m *PushmessageMutation) ResetImage() {
	m.image = nil
}

// SetContent sets the "content" field.
func (m *PushmessageMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *PushmessageMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Pushmessage entity.
// If the Pushmessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PushmessageMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *PushmessageMutation) ResetContent() {
	m.content = nil
}

// SetPushType sets the "push_type" field.
func (m *PushmessageMutation) SetPushType(u uint8) {
	m.push_type = &u
	m.addpush_type = nil
}

// PushType returns the value of the "push_type" field in the mutation.
func (m *PushmessageMutation) PushType() (r uint8, exists bool) {
	v := m.push_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPushType returns the old "push_type" field's value of the Pushmessage entity.
// If the Pushmessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PushmessageMutation) OldPushType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPushType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPushType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPushType: %w", err)
	}
	return oldValue.PushType, nil
}

// AddPushType adds u to the "push_type" field.
func (m *PushmessageMutation) AddPushType(u int8) {
	if m.addpush_type != nil {
		*m.addpush_type += u
	} else {
		m.addpush_type = &u
	}
}

// AddedPushType returns the value that was added to the "push_type" field in this mutation.
func (m *PushmessageMutation) AddedPushType() (r int8, exists bool) {
	v := m.addpush_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetPushType resets all changes to the "push_type" field.
func (m *PushmessageMutation) ResetPushType() {
	m.push_type = nil
	m.addpush_type = nil
}

// SetPushTime sets the "push_time" field.
func (m *PushmessageMutation) SetPushTime(t time.Time) {
	m.push_time = &t
}

// PushTime returns the value of the "push_time" field in the mutation.
func (m *PushmessageMutation) PushTime() (r time.Time, exists bool) {
	v := m.push_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPushTime returns the old "push_time" field's value of the Pushmessage entity.
// If the Pushmessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PushmessageMutation) OldPushTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPushTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPushTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPushTime: %w", err)
	}
	return oldValue.PushTime, nil
}

// ClearPushTime clears the value of the "push_time" field.
func (m *PushmessageMutation) ClearPushTime() {
	m.push_time = nil
	m.clearedFields[pushmessage.FieldPushTime] = struct{}{}
}

// PushTimeCleared returns if the "push_time" field was cleared in this mutation.
func (m *PushmessageMutation) PushTimeCleared() bool {
	_, ok := m.clearedFields[pushmessage.FieldPushTime]
	return ok
}

// ResetPushTime resets all changes to the "push_time" field.
func (m *PushmessageMutation) ResetPushTime() {
	m.push_time = nil
	delete(m.clearedFields, pushmessage.FieldPushTime)
}

// SetIsHome sets the "is_home" field.
func (m *PushmessageMutation) SetIsHome(b bool) {
	m.is_home = &b
}

// IsHome returns the value of the "is_home" field in the mutation.
func (m *PushmessageMutation) IsHome() (r bool, exists bool) {
	v := m.is_home
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHome returns the old "is_home" field's value of the Pushmessage entity.
// If the Pushmessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PushmessageMutation) OldIsHome(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHome is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHome requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHome: %w", err)
	}
	return oldValue.IsHome, nil
}

// ResetIsHome resets all changes to the "is_home" field.
func (m *PushmessageMutation) ResetIsHome() {
	m.is_home = nil
}

// SetHomeContent sets the "home_content" field.
func (m *PushmessageMutation) SetHomeContent(s string) {
	m.home_content = &s
}

// HomeContent returns the value of the "home_content" field in the mutation.
func (m *PushmessageMutation) HomeContent() (r string, exists bool) {
	v := m.home_content
	if v == nil {
		return
	}
	return *v, true
}

// OldHomeContent returns the old "home_content" field's value of the Pushmessage entity.
// If the Pushmessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PushmessageMutation) OldHomeContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHomeContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHomeContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHomeContent: %w", err)
	}
	return oldValue.HomeContent, nil
}

// ResetHomeContent resets all changes to the "home_content" field.
func (m *PushmessageMutation) ResetHomeContent() {
	m.home_content = nil
}

// SetMessageStatus sets the "message_status" field.
func (m *PushmessageMutation) SetMessageStatus(u uint8) {
	m.message_status = &u
	m.addmessage_status = nil
}

// MessageStatus returns the value of the "message_status" field in the mutation.
func (m *PushmessageMutation) MessageStatus() (r uint8, exists bool) {
	v := m.message_status
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageStatus returns the old "message_status" field's value of the Pushmessage entity.
// If the Pushmessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PushmessageMutation) OldMessageStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageStatus: %w", err)
	}
	return oldValue.MessageStatus, nil
}

// AddMessageStatus adds u to the "message_status" field.
func (m *PushmessageMutation) AddMessageStatus(u int8) {
	if m.addmessage_status != nil {
		*m.addmessage_status += u
	} else {
		m.addmessage_status = &u
	}
}

// AddedMessageStatus returns the value that was added to the "message_status" field in this mutation.
func (m *PushmessageMutation) AddedMessageStatus() (r int8, exists bool) {
	v := m.addmessage_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetMessageStatus resets all changes to the "message_status" field.
func (m *PushmessageMutation) ResetMessageStatus() {
	m.message_status = nil
	m.addmessage_status = nil
}

// SetMessageType sets the "message_type" field.
func (m *PushmessageMutation) SetMessageType(u uint8) {
	m.message_type = &u
	m.addmessage_type = nil
}

// MessageType returns the value of the "message_type" field in the mutation.
func (m *PushmessageMutation) MessageType() (r uint8, exists bool) {
	v := m.message_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageType returns the old "message_type" field's value of the Pushmessage entity.
// If the Pushmessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PushmessageMutation) OldMessageType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageType: %w", err)
	}
	return oldValue.MessageType, nil
}

// AddMessageType adds u to the "message_type" field.
func (m *PushmessageMutation) AddMessageType(u int8) {
	if m.addmessage_type != nil {
		*m.addmessage_type += u
	} else {
		m.addmessage_type = &u
	}
}

// AddedMessageType returns the value that was added to the "message_type" field in this mutation.
func (m *PushmessageMutation) AddedMessageType() (r int8, exists bool) {
	v := m.addmessage_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetMessageType resets all changes to the "message_type" field.
func (m *PushmessageMutation) ResetMessageType() {
	m.message_type = nil
	m.addmessage_type = nil
}

// SetThirdPartyID sets the "third_party_id" field.
func (m *PushmessageMutation) SetThirdPartyID(s string) {
	m.third_party_id = &s
}

// ThirdPartyID returns the value of the "third_party_id" field in the mutation.
func (m *PushmessageMutation) ThirdPartyID() (r string, exists bool) {
	v := m.third_party_id
	if v == nil {
		return
	}
	return *v, true
}

// OldThirdPartyID returns the old "third_party_id" field's value of the Pushmessage entity.
// If the Pushmessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PushmessageMutation) OldThirdPartyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldThirdPartyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldThirdPartyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldThirdPartyID: %w", err)
	}
	return oldValue.ThirdPartyID, nil
}

// ResetThirdPartyID resets all changes to the "third_party_id" field.
func (m *PushmessageMutation) ResetThirdPartyID() {
	m.third_party_id = nil
}

// Where appends a list predicates to the PushmessageMutation builder.
func (m *PushmessageMutation) Where(ps ...predicate.Pushmessage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PushmessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PushmessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Pushmessage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PushmessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PushmessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Pushmessage).
func (m *PushmessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PushmessageMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, pushmessage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pushmessage.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, pushmessage.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, pushmessage.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, pushmessage.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, pushmessage.FieldRemark)
	}
	if m.title != nil {
		fields = append(fields, pushmessage.FieldTitle)
	}
	if m.image != nil {
		fields = append(fields, pushmessage.FieldImage)
	}
	if m.content != nil {
		fields = append(fields, pushmessage.FieldContent)
	}
	if m.push_type != nil {
		fields = append(fields, pushmessage.FieldPushType)
	}
	if m.push_time != nil {
		fields = append(fields, pushmessage.FieldPushTime)
	}
	if m.is_home != nil {
		fields = append(fields, pushmessage.FieldIsHome)
	}
	if m.home_content != nil {
		fields = append(fields, pushmessage.FieldHomeContent)
	}
	if m.message_status != nil {
		fields = append(fields, pushmessage.FieldMessageStatus)
	}
	if m.message_type != nil {
		fields = append(fields, pushmessage.FieldMessageType)
	}
	if m.third_party_id != nil {
		fields = append(fields, pushmessage.FieldThirdPartyID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PushmessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pushmessage.FieldCreatedAt:
		return m.CreatedAt()
	case pushmessage.FieldUpdatedAt:
		return m.UpdatedAt()
	case pushmessage.FieldDeletedAt:
		return m.DeletedAt()
	case pushmessage.FieldCreator:
		return m.Creator()
	case pushmessage.FieldLastModifier:
		return m.LastModifier()
	case pushmessage.FieldRemark:
		return m.Remark()
	case pushmessage.FieldTitle:
		return m.Title()
	case pushmessage.FieldImage:
		return m.Image()
	case pushmessage.FieldContent:
		return m.Content()
	case pushmessage.FieldPushType:
		return m.PushType()
	case pushmessage.FieldPushTime:
		return m.PushTime()
	case pushmessage.FieldIsHome:
		return m.IsHome()
	case pushmessage.FieldHomeContent:
		return m.HomeContent()
	case pushmessage.FieldMessageStatus:
		return m.MessageStatus()
	case pushmessage.FieldMessageType:
		return m.MessageType()
	case pushmessage.FieldThirdPartyID:
		return m.ThirdPartyID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PushmessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pushmessage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pushmessage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pushmessage.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case pushmessage.FieldCreator:
		return m.OldCreator(ctx)
	case pushmessage.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case pushmessage.FieldRemark:
		return m.OldRemark(ctx)
	case pushmessage.FieldTitle:
		return m.OldTitle(ctx)
	case pushmessage.FieldImage:
		return m.OldImage(ctx)
	case pushmessage.FieldContent:
		return m.OldContent(ctx)
	case pushmessage.FieldPushType:
		return m.OldPushType(ctx)
	case pushmessage.FieldPushTime:
		return m.OldPushTime(ctx)
	case pushmessage.FieldIsHome:
		return m.OldIsHome(ctx)
	case pushmessage.FieldHomeContent:
		return m.OldHomeContent(ctx)
	case pushmessage.FieldMessageStatus:
		return m.OldMessageStatus(ctx)
	case pushmessage.FieldMessageType:
		return m.OldMessageType(ctx)
	case pushmessage.FieldThirdPartyID:
		return m.OldThirdPartyID(ctx)
	}
	return nil, fmt.Errorf("unknown Pushmessage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PushmessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pushmessage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pushmessage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pushmessage.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case pushmessage.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case pushmessage.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case pushmessage.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case pushmessage.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case pushmessage.FieldImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImage(v)
		return nil
	case pushmessage.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case pushmessage.FieldPushType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPushType(v)
		return nil
	case pushmessage.FieldPushTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPushTime(v)
		return nil
	case pushmessage.FieldIsHome:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHome(v)
		return nil
	case pushmessage.FieldHomeContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHomeContent(v)
		return nil
	case pushmessage.FieldMessageStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageStatus(v)
		return nil
	case pushmessage.FieldMessageType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageType(v)
		return nil
	case pushmessage.FieldThirdPartyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetThirdPartyID(v)
		return nil
	}
	return fmt.Errorf("unknown Pushmessage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PushmessageMutation) AddedFields() []string {
	var fields []string
	if m.addpush_type != nil {
		fields = append(fields, pushmessage.FieldPushType)
	}
	if m.addmessage_status != nil {
		fields = append(fields, pushmessage.FieldMessageStatus)
	}
	if m.addmessage_type != nil {
		fields = append(fields, pushmessage.FieldMessageType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PushmessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pushmessage.FieldPushType:
		return m.AddedPushType()
	case pushmessage.FieldMessageStatus:
		return m.AddedMessageStatus()
	case pushmessage.FieldMessageType:
		return m.AddedMessageType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PushmessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pushmessage.FieldPushType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPushType(v)
		return nil
	case pushmessage.FieldMessageStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMessageStatus(v)
		return nil
	case pushmessage.FieldMessageType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMessageType(v)
		return nil
	}
	return fmt.Errorf("unknown Pushmessage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PushmessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pushmessage.FieldDeletedAt) {
		fields = append(fields, pushmessage.FieldDeletedAt)
	}
	if m.FieldCleared(pushmessage.FieldCreator) {
		fields = append(fields, pushmessage.FieldCreator)
	}
	if m.FieldCleared(pushmessage.FieldLastModifier) {
		fields = append(fields, pushmessage.FieldLastModifier)
	}
	if m.FieldCleared(pushmessage.FieldRemark) {
		fields = append(fields, pushmessage.FieldRemark)
	}
	if m.FieldCleared(pushmessage.FieldPushTime) {
		fields = append(fields, pushmessage.FieldPushTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PushmessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PushmessageMutation) ClearField(name string) error {
	switch name {
	case pushmessage.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case pushmessage.FieldCreator:
		m.ClearCreator()
		return nil
	case pushmessage.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case pushmessage.FieldRemark:
		m.ClearRemark()
		return nil
	case pushmessage.FieldPushTime:
		m.ClearPushTime()
		return nil
	}
	return fmt.Errorf("unknown Pushmessage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PushmessageMutation) ResetField(name string) error {
	switch name {
	case pushmessage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pushmessage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pushmessage.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case pushmessage.FieldCreator:
		m.ResetCreator()
		return nil
	case pushmessage.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case pushmessage.FieldRemark:
		m.ResetRemark()
		return nil
	case pushmessage.FieldTitle:
		m.ResetTitle()
		return nil
	case pushmessage.FieldImage:
		m.ResetImage()
		return nil
	case pushmessage.FieldContent:
		m.ResetContent()
		return nil
	case pushmessage.FieldPushType:
		m.ResetPushType()
		return nil
	case pushmessage.FieldPushTime:
		m.ResetPushTime()
		return nil
	case pushmessage.FieldIsHome:
		m.ResetIsHome()
		return nil
	case pushmessage.FieldHomeContent:
		m.ResetHomeContent()
		return nil
	case pushmessage.FieldMessageStatus:
		m.ResetMessageStatus()
		return nil
	case pushmessage.FieldMessageType:
		m.ResetMessageType()
		return nil
	case pushmessage.FieldThirdPartyID:
		m.ResetThirdPartyID()
		return nil
	}
	return fmt.Errorf("unknown Pushmessage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PushmessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PushmessageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PushmessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PushmessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PushmessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PushmessageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PushmessageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Pushmessage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PushmessageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Pushmessage edge %s", name)
}

// ReserveMutation represents an operation that mutates the Reserve nodes in the graph.
type ReserveMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	creator         **model.Modifier
	last_modifier   **model.Modifier
	remark          *string
	status          *uint8
	addstatus       *int8
	_type           *string
	clearedFields   map[string]struct{}
	cabinet         *uint64
	clearedcabinet  bool
	rider           *uint64
	clearedrider    bool
	city            *uint64
	clearedcity     bool
	business        *uint64
	clearedbusiness bool
	done            bool
	oldValue        func(context.Context) (*Reserve, error)
	predicates      []predicate.Reserve
}

var _ ent.Mutation = (*ReserveMutation)(nil)

// reserveOption allows management of the mutation configuration using functional options.
type reserveOption func(*ReserveMutation)

// newReserveMutation creates new mutation for the Reserve entity.
func newReserveMutation(c config, op Op, opts ...reserveOption) *ReserveMutation {
	m := &ReserveMutation{
		config:        c,
		op:            op,
		typ:           TypeReserve,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReserveID sets the ID field of the mutation.
func withReserveID(id uint64) reserveOption {
	return func(m *ReserveMutation) {
		var (
			err   error
			once  sync.Once
			value *Reserve
		)
		m.oldValue = func(ctx context.Context) (*Reserve, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Reserve.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReserve sets the old Reserve of the mutation.
func withReserve(node *Reserve) reserveOption {
	return func(m *ReserveMutation) {
		m.oldValue = func(context.Context) (*Reserve, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReserveMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReserveMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReserveMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReserveMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Reserve.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ReserveMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReserveMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Reserve entity.
// If the Reserve object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReserveMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReserveMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ReserveMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ReserveMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Reserve entity.
// If the Reserve object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReserveMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ReserveMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ReserveMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ReserveMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Reserve entity.
// If the Reserve object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReserveMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ReserveMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[reserve.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ReserveMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[reserve.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ReserveMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, reserve.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *ReserveMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *ReserveMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Reserve entity.
// If the Reserve object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReserveMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *ReserveMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[reserve.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *ReserveMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[reserve.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *ReserveMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, reserve.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *ReserveMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *ReserveMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Reserve entity.
// If the Reserve object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReserveMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *ReserveMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[reserve.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *ReserveMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[reserve.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *ReserveMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, reserve.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *ReserveMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ReserveMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Reserve entity.
// If the Reserve object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReserveMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ReserveMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[reserve.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ReserveMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[reserve.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ReserveMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, reserve.FieldRemark)
}

// SetCabinetID sets the "cabinet_id" field.
func (m *ReserveMutation) SetCabinetID(u uint64) {
	m.cabinet = &u
}

// CabinetID returns the value of the "cabinet_id" field in the mutation.
func (m *ReserveMutation) CabinetID() (r uint64, exists bool) {
	v := m.cabinet
	if v == nil {
		return
	}
	return *v, true
}

// OldCabinetID returns the old "cabinet_id" field's value of the Reserve entity.
// If the Reserve object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReserveMutation) OldCabinetID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCabinetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCabinetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCabinetID: %w", err)
	}
	return oldValue.CabinetID, nil
}

// ResetCabinetID resets all changes to the "cabinet_id" field.
func (m *ReserveMutation) ResetCabinetID() {
	m.cabinet = nil
}

// SetRiderID sets the "rider_id" field.
func (m *ReserveMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *ReserveMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the Reserve entity.
// If the Reserve object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReserveMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *ReserveMutation) ResetRiderID() {
	m.rider = nil
}

// SetCityID sets the "city_id" field.
func (m *ReserveMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *ReserveMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Reserve entity.
// If the Reserve object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReserveMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *ReserveMutation) ResetCityID() {
	m.city = nil
}

// SetBusinessID sets the "business_id" field.
func (m *ReserveMutation) SetBusinessID(u uint64) {
	m.business = &u
}

// BusinessID returns the value of the "business_id" field in the mutation.
func (m *ReserveMutation) BusinessID() (r uint64, exists bool) {
	v := m.business
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessID returns the old "business_id" field's value of the Reserve entity.
// If the Reserve object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReserveMutation) OldBusinessID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessID: %w", err)
	}
	return oldValue.BusinessID, nil
}

// ClearBusinessID clears the value of the "business_id" field.
func (m *ReserveMutation) ClearBusinessID() {
	m.business = nil
	m.clearedFields[reserve.FieldBusinessID] = struct{}{}
}

// BusinessIDCleared returns if the "business_id" field was cleared in this mutation.
func (m *ReserveMutation) BusinessIDCleared() bool {
	_, ok := m.clearedFields[reserve.FieldBusinessID]
	return ok
}

// ResetBusinessID resets all changes to the "business_id" field.
func (m *ReserveMutation) ResetBusinessID() {
	m.business = nil
	delete(m.clearedFields, reserve.FieldBusinessID)
}

// SetStatus sets the "status" field.
func (m *ReserveMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ReserveMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Reserve entity.
// If the Reserve object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReserveMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *ReserveMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ReserveMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ReserveMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetType sets the "type" field.
func (m *ReserveMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ReserveMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Reserve entity.
// If the Reserve object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReserveMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ReserveMutation) ResetType() {
	m._type = nil
}

// ClearCabinet clears the "cabinet" edge to the Cabinet entity.
func (m *ReserveMutation) ClearCabinet() {
	m.clearedcabinet = true
	m.clearedFields[reserve.FieldCabinetID] = struct{}{}
}

// CabinetCleared reports if the "cabinet" edge to the Cabinet entity was cleared.
func (m *ReserveMutation) CabinetCleared() bool {
	return m.clearedcabinet
}

// CabinetIDs returns the "cabinet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CabinetID instead. It exists only for internal usage by the builders.
func (m *ReserveMutation) CabinetIDs() (ids []uint64) {
	if id := m.cabinet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCabinet resets all changes to the "cabinet" edge.
func (m *ReserveMutation) ResetCabinet() {
	m.cabinet = nil
	m.clearedcabinet = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *ReserveMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[reserve.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *ReserveMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *ReserveMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *ReserveMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *ReserveMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[reserve.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *ReserveMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *ReserveMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *ReserveMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearBusiness clears the "business" edge to the Business entity.
func (m *ReserveMutation) ClearBusiness() {
	m.clearedbusiness = true
	m.clearedFields[reserve.FieldBusinessID] = struct{}{}
}

// BusinessCleared reports if the "business" edge to the Business entity was cleared.
func (m *ReserveMutation) BusinessCleared() bool {
	return m.BusinessIDCleared() || m.clearedbusiness
}

// BusinessIDs returns the "business" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BusinessID instead. It exists only for internal usage by the builders.
func (m *ReserveMutation) BusinessIDs() (ids []uint64) {
	if id := m.business; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBusiness resets all changes to the "business" edge.
func (m *ReserveMutation) ResetBusiness() {
	m.business = nil
	m.clearedbusiness = false
}

// Where appends a list predicates to the ReserveMutation builder.
func (m *ReserveMutation) Where(ps ...predicate.Reserve) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReserveMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReserveMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Reserve, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReserveMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReserveMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Reserve).
func (m *ReserveMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReserveMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, reserve.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, reserve.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, reserve.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, reserve.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, reserve.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, reserve.FieldRemark)
	}
	if m.cabinet != nil {
		fields = append(fields, reserve.FieldCabinetID)
	}
	if m.rider != nil {
		fields = append(fields, reserve.FieldRiderID)
	}
	if m.city != nil {
		fields = append(fields, reserve.FieldCityID)
	}
	if m.business != nil {
		fields = append(fields, reserve.FieldBusinessID)
	}
	if m.status != nil {
		fields = append(fields, reserve.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, reserve.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReserveMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reserve.FieldCreatedAt:
		return m.CreatedAt()
	case reserve.FieldUpdatedAt:
		return m.UpdatedAt()
	case reserve.FieldDeletedAt:
		return m.DeletedAt()
	case reserve.FieldCreator:
		return m.Creator()
	case reserve.FieldLastModifier:
		return m.LastModifier()
	case reserve.FieldRemark:
		return m.Remark()
	case reserve.FieldCabinetID:
		return m.CabinetID()
	case reserve.FieldRiderID:
		return m.RiderID()
	case reserve.FieldCityID:
		return m.CityID()
	case reserve.FieldBusinessID:
		return m.BusinessID()
	case reserve.FieldStatus:
		return m.Status()
	case reserve.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReserveMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reserve.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case reserve.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case reserve.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case reserve.FieldCreator:
		return m.OldCreator(ctx)
	case reserve.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case reserve.FieldRemark:
		return m.OldRemark(ctx)
	case reserve.FieldCabinetID:
		return m.OldCabinetID(ctx)
	case reserve.FieldRiderID:
		return m.OldRiderID(ctx)
	case reserve.FieldCityID:
		return m.OldCityID(ctx)
	case reserve.FieldBusinessID:
		return m.OldBusinessID(ctx)
	case reserve.FieldStatus:
		return m.OldStatus(ctx)
	case reserve.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown Reserve field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReserveMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reserve.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case reserve.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case reserve.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case reserve.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case reserve.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case reserve.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case reserve.FieldCabinetID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCabinetID(v)
		return nil
	case reserve.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case reserve.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case reserve.FieldBusinessID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessID(v)
		return nil
	case reserve.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case reserve.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown Reserve field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReserveMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, reserve.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReserveMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case reserve.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReserveMutation) AddField(name string, value ent.Value) error {
	switch name {
	case reserve.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Reserve numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReserveMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reserve.FieldDeletedAt) {
		fields = append(fields, reserve.FieldDeletedAt)
	}
	if m.FieldCleared(reserve.FieldCreator) {
		fields = append(fields, reserve.FieldCreator)
	}
	if m.FieldCleared(reserve.FieldLastModifier) {
		fields = append(fields, reserve.FieldLastModifier)
	}
	if m.FieldCleared(reserve.FieldRemark) {
		fields = append(fields, reserve.FieldRemark)
	}
	if m.FieldCleared(reserve.FieldBusinessID) {
		fields = append(fields, reserve.FieldBusinessID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReserveMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReserveMutation) ClearField(name string) error {
	switch name {
	case reserve.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case reserve.FieldCreator:
		m.ClearCreator()
		return nil
	case reserve.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case reserve.FieldRemark:
		m.ClearRemark()
		return nil
	case reserve.FieldBusinessID:
		m.ClearBusinessID()
		return nil
	}
	return fmt.Errorf("unknown Reserve nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReserveMutation) ResetField(name string) error {
	switch name {
	case reserve.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case reserve.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case reserve.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case reserve.FieldCreator:
		m.ResetCreator()
		return nil
	case reserve.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case reserve.FieldRemark:
		m.ResetRemark()
		return nil
	case reserve.FieldCabinetID:
		m.ResetCabinetID()
		return nil
	case reserve.FieldRiderID:
		m.ResetRiderID()
		return nil
	case reserve.FieldCityID:
		m.ResetCityID()
		return nil
	case reserve.FieldBusinessID:
		m.ResetBusinessID()
		return nil
	case reserve.FieldStatus:
		m.ResetStatus()
		return nil
	case reserve.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Reserve field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReserveMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cabinet != nil {
		edges = append(edges, reserve.EdgeCabinet)
	}
	if m.rider != nil {
		edges = append(edges, reserve.EdgeRider)
	}
	if m.city != nil {
		edges = append(edges, reserve.EdgeCity)
	}
	if m.business != nil {
		edges = append(edges, reserve.EdgeBusiness)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReserveMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case reserve.EdgeCabinet:
		if id := m.cabinet; id != nil {
			return []ent.Value{*id}
		}
	case reserve.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case reserve.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case reserve.EdgeBusiness:
		if id := m.business; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReserveMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReserveMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReserveMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcabinet {
		edges = append(edges, reserve.EdgeCabinet)
	}
	if m.clearedrider {
		edges = append(edges, reserve.EdgeRider)
	}
	if m.clearedcity {
		edges = append(edges, reserve.EdgeCity)
	}
	if m.clearedbusiness {
		edges = append(edges, reserve.EdgeBusiness)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReserveMutation) EdgeCleared(name string) bool {
	switch name {
	case reserve.EdgeCabinet:
		return m.clearedcabinet
	case reserve.EdgeRider:
		return m.clearedrider
	case reserve.EdgeCity:
		return m.clearedcity
	case reserve.EdgeBusiness:
		return m.clearedbusiness
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReserveMutation) ClearEdge(name string) error {
	switch name {
	case reserve.EdgeCabinet:
		m.ClearCabinet()
		return nil
	case reserve.EdgeRider:
		m.ClearRider()
		return nil
	case reserve.EdgeCity:
		m.ClearCity()
		return nil
	case reserve.EdgeBusiness:
		m.ClearBusiness()
		return nil
	}
	return fmt.Errorf("unknown Reserve unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReserveMutation) ResetEdge(name string) error {
	switch name {
	case reserve.EdgeCabinet:
		m.ResetCabinet()
		return nil
	case reserve.EdgeRider:
		m.ResetRider()
		return nil
	case reserve.EdgeCity:
		m.ResetCity()
		return nil
	case reserve.EdgeBusiness:
		m.ResetBusiness()
		return nil
	}
	return fmt.Errorf("unknown Reserve edge %s", name)
}

// RiderMutation represents an operation that mutates the Rider nodes in the graph.
type RiderMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uint64
	created_at               *time.Time
	updated_at               *time.Time
	deleted_at               *time.Time
	creator                  **model.Modifier
	last_modifier            **model.Modifier
	remark                   *string
	name                     *string
	id_card_number           *string
	phone                    *string
	contact                  **model.RiderContact
	device_type              *uint8
	adddevice_type           *int8
	last_device              *string
	is_new_device            *bool
	push_id                  *string
	last_signin_at           *time.Time
	blocked                  *bool
	points                   *int64
	addpoints                *int64
	exchange_limit           *model.RiderExchangeLimit
	appendexchange_limit     model.RiderExchangeLimit
	exchange_frequency       *model.RiderExchangeFrequency
	appendexchange_frequency model.RiderExchangeFrequency
	join_enterprise_at       *time.Time
	clearedFields            map[string]struct{}
	station                  *uint64
	clearedstation           bool
	person                   *uint64
	clearedperson            bool
	enterprise               *uint64
	clearedenterprise        bool
	contracts                map[uint64]struct{}
	removedcontracts         map[uint64]struct{}
	clearedcontracts         bool
	faults                   map[uint64]struct{}
	removedfaults            map[uint64]struct{}
	clearedfaults            bool
	orders                   map[uint64]struct{}
	removedorders            map[uint64]struct{}
	clearedorders            bool
	exchanges                map[uint64]struct{}
	removedexchanges         map[uint64]struct{}
	clearedexchanges         bool
	subscribes               map[uint64]struct{}
	removedsubscribes        map[uint64]struct{}
	clearedsubscribes        bool
	stocks                   map[uint64]struct{}
	removedstocks            map[uint64]struct{}
	clearedstocks            bool
	followups                map[uint64]struct{}
	removedfollowups         map[uint64]struct{}
	clearedfollowups         bool
	battery                  *uint64
	clearedbattery           bool
	battery_flows            map[uint64]struct{}
	removedbattery_flows     map[uint64]struct{}
	clearedbattery_flows     bool
	done                     bool
	oldValue                 func(context.Context) (*Rider, error)
	predicates               []predicate.Rider
}

var _ ent.Mutation = (*RiderMutation)(nil)

// riderOption allows management of the mutation configuration using functional options.
type riderOption func(*RiderMutation)

// newRiderMutation creates new mutation for the Rider entity.
func newRiderMutation(c config, op Op, opts ...riderOption) *RiderMutation {
	m := &RiderMutation{
		config:        c,
		op:            op,
		typ:           TypeRider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRiderID sets the ID field of the mutation.
func withRiderID(id uint64) riderOption {
	return func(m *RiderMutation) {
		var (
			err   error
			once  sync.Once
			value *Rider
		)
		m.oldValue = func(ctx context.Context) (*Rider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Rider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRider sets the old Rider of the mutation.
func withRider(node *Rider) riderOption {
	return func(m *RiderMutation) {
		m.oldValue = func(context.Context) (*Rider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RiderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RiderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RiderMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RiderMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Rider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RiderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RiderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RiderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RiderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RiderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RiderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RiderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RiderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RiderMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[rider.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RiderMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[rider.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RiderMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, rider.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *RiderMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *RiderMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *RiderMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[rider.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *RiderMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[rider.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *RiderMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, rider.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *RiderMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *RiderMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *RiderMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[rider.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *RiderMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[rider.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *RiderMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, rider.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *RiderMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *RiderMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *RiderMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[rider.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *RiderMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[rider.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *RiderMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, rider.FieldRemark)
}

// SetStationID sets the "station_id" field.
func (m *RiderMutation) SetStationID(u uint64) {
	m.station = &u
}

// StationID returns the value of the "station_id" field in the mutation.
func (m *RiderMutation) StationID() (r uint64, exists bool) {
	v := m.station
	if v == nil {
		return
	}
	return *v, true
}

// OldStationID returns the old "station_id" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldStationID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStationID: %w", err)
	}
	return oldValue.StationID, nil
}

// ClearStationID clears the value of the "station_id" field.
func (m *RiderMutation) ClearStationID() {
	m.station = nil
	m.clearedFields[rider.FieldStationID] = struct{}{}
}

// StationIDCleared returns if the "station_id" field was cleared in this mutation.
func (m *RiderMutation) StationIDCleared() bool {
	_, ok := m.clearedFields[rider.FieldStationID]
	return ok
}

// ResetStationID resets all changes to the "station_id" field.
func (m *RiderMutation) ResetStationID() {
	m.station = nil
	delete(m.clearedFields, rider.FieldStationID)
}

// SetPersonID sets the "person_id" field.
func (m *RiderMutation) SetPersonID(u uint64) {
	m.person = &u
}

// PersonID returns the value of the "person_id" field in the mutation.
func (m *RiderMutation) PersonID() (r uint64, exists bool) {
	v := m.person
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonID returns the old "person_id" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldPersonID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonID: %w", err)
	}
	return oldValue.PersonID, nil
}

// ClearPersonID clears the value of the "person_id" field.
func (m *RiderMutation) ClearPersonID() {
	m.person = nil
	m.clearedFields[rider.FieldPersonID] = struct{}{}
}

// PersonIDCleared returns if the "person_id" field was cleared in this mutation.
func (m *RiderMutation) PersonIDCleared() bool {
	_, ok := m.clearedFields[rider.FieldPersonID]
	return ok
}

// ResetPersonID resets all changes to the "person_id" field.
func (m *RiderMutation) ResetPersonID() {
	m.person = nil
	delete(m.clearedFields, rider.FieldPersonID)
}

// SetName sets the "name" field.
func (m *RiderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RiderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *RiderMutation) ClearName() {
	m.name = nil
	m.clearedFields[rider.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *RiderMutation) NameCleared() bool {
	_, ok := m.clearedFields[rider.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *RiderMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, rider.FieldName)
}

// SetIDCardNumber sets the "id_card_number" field.
func (m *RiderMutation) SetIDCardNumber(s string) {
	m.id_card_number = &s
}

// IDCardNumber returns the value of the "id_card_number" field in the mutation.
func (m *RiderMutation) IDCardNumber() (r string, exists bool) {
	v := m.id_card_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCardNumber returns the old "id_card_number" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldIDCardNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCardNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCardNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCardNumber: %w", err)
	}
	return oldValue.IDCardNumber, nil
}

// ClearIDCardNumber clears the value of the "id_card_number" field.
func (m *RiderMutation) ClearIDCardNumber() {
	m.id_card_number = nil
	m.clearedFields[rider.FieldIDCardNumber] = struct{}{}
}

// IDCardNumberCleared returns if the "id_card_number" field was cleared in this mutation.
func (m *RiderMutation) IDCardNumberCleared() bool {
	_, ok := m.clearedFields[rider.FieldIDCardNumber]
	return ok
}

// ResetIDCardNumber resets all changes to the "id_card_number" field.
func (m *RiderMutation) ResetIDCardNumber() {
	m.id_card_number = nil
	delete(m.clearedFields, rider.FieldIDCardNumber)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *RiderMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *RiderMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldEnterpriseID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ClearEnterpriseID clears the value of the "enterprise_id" field.
func (m *RiderMutation) ClearEnterpriseID() {
	m.enterprise = nil
	m.clearedFields[rider.FieldEnterpriseID] = struct{}{}
}

// EnterpriseIDCleared returns if the "enterprise_id" field was cleared in this mutation.
func (m *RiderMutation) EnterpriseIDCleared() bool {
	_, ok := m.clearedFields[rider.FieldEnterpriseID]
	return ok
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *RiderMutation) ResetEnterpriseID() {
	m.enterprise = nil
	delete(m.clearedFields, rider.FieldEnterpriseID)
}

// SetPhone sets the "phone" field.
func (m *RiderMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *RiderMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *RiderMutation) ResetPhone() {
	m.phone = nil
}

// SetContact sets the "contact" field.
func (m *RiderMutation) SetContact(mc *model.RiderContact) {
	m.contact = &mc
}

// Contact returns the value of the "contact" field in the mutation.
func (m *RiderMutation) Contact() (r *model.RiderContact, exists bool) {
	v := m.contact
	if v == nil {
		return
	}
	return *v, true
}

// OldContact returns the old "contact" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldContact(ctx context.Context) (v *model.RiderContact, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContact: %w", err)
	}
	return oldValue.Contact, nil
}

// ClearContact clears the value of the "contact" field.
func (m *RiderMutation) ClearContact() {
	m.contact = nil
	m.clearedFields[rider.FieldContact] = struct{}{}
}

// ContactCleared returns if the "contact" field was cleared in this mutation.
func (m *RiderMutation) ContactCleared() bool {
	_, ok := m.clearedFields[rider.FieldContact]
	return ok
}

// ResetContact resets all changes to the "contact" field.
func (m *RiderMutation) ResetContact() {
	m.contact = nil
	delete(m.clearedFields, rider.FieldContact)
}

// SetDeviceType sets the "device_type" field.
func (m *RiderMutation) SetDeviceType(u uint8) {
	m.device_type = &u
	m.adddevice_type = nil
}

// DeviceType returns the value of the "device_type" field in the mutation.
func (m *RiderMutation) DeviceType() (r uint8, exists bool) {
	v := m.device_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceType returns the old "device_type" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldDeviceType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceType: %w", err)
	}
	return oldValue.DeviceType, nil
}

// AddDeviceType adds u to the "device_type" field.
func (m *RiderMutation) AddDeviceType(u int8) {
	if m.adddevice_type != nil {
		*m.adddevice_type += u
	} else {
		m.adddevice_type = &u
	}
}

// AddedDeviceType returns the value that was added to the "device_type" field in this mutation.
func (m *RiderMutation) AddedDeviceType() (r int8, exists bool) {
	v := m.adddevice_type
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeviceType clears the value of the "device_type" field.
func (m *RiderMutation) ClearDeviceType() {
	m.device_type = nil
	m.adddevice_type = nil
	m.clearedFields[rider.FieldDeviceType] = struct{}{}
}

// DeviceTypeCleared returns if the "device_type" field was cleared in this mutation.
func (m *RiderMutation) DeviceTypeCleared() bool {
	_, ok := m.clearedFields[rider.FieldDeviceType]
	return ok
}

// ResetDeviceType resets all changes to the "device_type" field.
func (m *RiderMutation) ResetDeviceType() {
	m.device_type = nil
	m.adddevice_type = nil
	delete(m.clearedFields, rider.FieldDeviceType)
}

// SetLastDevice sets the "last_device" field.
func (m *RiderMutation) SetLastDevice(s string) {
	m.last_device = &s
}

// LastDevice returns the value of the "last_device" field in the mutation.
func (m *RiderMutation) LastDevice() (r string, exists bool) {
	v := m.last_device
	if v == nil {
		return
	}
	return *v, true
}

// OldLastDevice returns the old "last_device" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldLastDevice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastDevice: %w", err)
	}
	return oldValue.LastDevice, nil
}

// ClearLastDevice clears the value of the "last_device" field.
func (m *RiderMutation) ClearLastDevice() {
	m.last_device = nil
	m.clearedFields[rider.FieldLastDevice] = struct{}{}
}

// LastDeviceCleared returns if the "last_device" field was cleared in this mutation.
func (m *RiderMutation) LastDeviceCleared() bool {
	_, ok := m.clearedFields[rider.FieldLastDevice]
	return ok
}

// ResetLastDevice resets all changes to the "last_device" field.
func (m *RiderMutation) ResetLastDevice() {
	m.last_device = nil
	delete(m.clearedFields, rider.FieldLastDevice)
}

// SetIsNewDevice sets the "is_new_device" field.
func (m *RiderMutation) SetIsNewDevice(b bool) {
	m.is_new_device = &b
}

// IsNewDevice returns the value of the "is_new_device" field in the mutation.
func (m *RiderMutation) IsNewDevice() (r bool, exists bool) {
	v := m.is_new_device
	if v == nil {
		return
	}
	return *v, true
}

// OldIsNewDevice returns the old "is_new_device" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldIsNewDevice(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsNewDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsNewDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsNewDevice: %w", err)
	}
	return oldValue.IsNewDevice, nil
}

// ResetIsNewDevice resets all changes to the "is_new_device" field.
func (m *RiderMutation) ResetIsNewDevice() {
	m.is_new_device = nil
}

// SetPushID sets the "push_id" field.
func (m *RiderMutation) SetPushID(s string) {
	m.push_id = &s
}

// PushID returns the value of the "push_id" field in the mutation.
func (m *RiderMutation) PushID() (r string, exists bool) {
	v := m.push_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPushID returns the old "push_id" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldPushID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPushID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPushID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPushID: %w", err)
	}
	return oldValue.PushID, nil
}

// ClearPushID clears the value of the "push_id" field.
func (m *RiderMutation) ClearPushID() {
	m.push_id = nil
	m.clearedFields[rider.FieldPushID] = struct{}{}
}

// PushIDCleared returns if the "push_id" field was cleared in this mutation.
func (m *RiderMutation) PushIDCleared() bool {
	_, ok := m.clearedFields[rider.FieldPushID]
	return ok
}

// ResetPushID resets all changes to the "push_id" field.
func (m *RiderMutation) ResetPushID() {
	m.push_id = nil
	delete(m.clearedFields, rider.FieldPushID)
}

// SetLastSigninAt sets the "last_signin_at" field.
func (m *RiderMutation) SetLastSigninAt(t time.Time) {
	m.last_signin_at = &t
}

// LastSigninAt returns the value of the "last_signin_at" field in the mutation.
func (m *RiderMutation) LastSigninAt() (r time.Time, exists bool) {
	v := m.last_signin_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSigninAt returns the old "last_signin_at" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldLastSigninAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSigninAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSigninAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSigninAt: %w", err)
	}
	return oldValue.LastSigninAt, nil
}

// ClearLastSigninAt clears the value of the "last_signin_at" field.
func (m *RiderMutation) ClearLastSigninAt() {
	m.last_signin_at = nil
	m.clearedFields[rider.FieldLastSigninAt] = struct{}{}
}

// LastSigninAtCleared returns if the "last_signin_at" field was cleared in this mutation.
func (m *RiderMutation) LastSigninAtCleared() bool {
	_, ok := m.clearedFields[rider.FieldLastSigninAt]
	return ok
}

// ResetLastSigninAt resets all changes to the "last_signin_at" field.
func (m *RiderMutation) ResetLastSigninAt() {
	m.last_signin_at = nil
	delete(m.clearedFields, rider.FieldLastSigninAt)
}

// SetBlocked sets the "blocked" field.
func (m *RiderMutation) SetBlocked(b bool) {
	m.blocked = &b
}

// Blocked returns the value of the "blocked" field in the mutation.
func (m *RiderMutation) Blocked() (r bool, exists bool) {
	v := m.blocked
	if v == nil {
		return
	}
	return *v, true
}

// OldBlocked returns the old "blocked" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldBlocked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlocked: %w", err)
	}
	return oldValue.Blocked, nil
}

// ResetBlocked resets all changes to the "blocked" field.
func (m *RiderMutation) ResetBlocked() {
	m.blocked = nil
}

// SetPoints sets the "points" field.
func (m *RiderMutation) SetPoints(i int64) {
	m.points = &i
	m.addpoints = nil
}

// Points returns the value of the "points" field in the mutation.
func (m *RiderMutation) Points() (r int64, exists bool) {
	v := m.points
	if v == nil {
		return
	}
	return *v, true
}

// OldPoints returns the old "points" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldPoints(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoints: %w", err)
	}
	return oldValue.Points, nil
}

// AddPoints adds i to the "points" field.
func (m *RiderMutation) AddPoints(i int64) {
	if m.addpoints != nil {
		*m.addpoints += i
	} else {
		m.addpoints = &i
	}
}

// AddedPoints returns the value that was added to the "points" field in this mutation.
func (m *RiderMutation) AddedPoints() (r int64, exists bool) {
	v := m.addpoints
	if v == nil {
		return
	}
	return *v, true
}

// ResetPoints resets all changes to the "points" field.
func (m *RiderMutation) ResetPoints() {
	m.points = nil
	m.addpoints = nil
}

// SetExchangeLimit sets the "exchange_limit" field.
func (m *RiderMutation) SetExchangeLimit(mel model.RiderExchangeLimit) {
	m.exchange_limit = &mel
	m.appendexchange_limit = nil
}

// ExchangeLimit returns the value of the "exchange_limit" field in the mutation.
func (m *RiderMutation) ExchangeLimit() (r model.RiderExchangeLimit, exists bool) {
	v := m.exchange_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldExchangeLimit returns the old "exchange_limit" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldExchangeLimit(ctx context.Context) (v model.RiderExchangeLimit, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExchangeLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExchangeLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExchangeLimit: %w", err)
	}
	return oldValue.ExchangeLimit, nil
}

// AppendExchangeLimit adds mel to the "exchange_limit" field.
func (m *RiderMutation) AppendExchangeLimit(mel model.RiderExchangeLimit) {
	m.appendexchange_limit = append(m.appendexchange_limit, mel...)
}

// AppendedExchangeLimit returns the list of values that were appended to the "exchange_limit" field in this mutation.
func (m *RiderMutation) AppendedExchangeLimit() (model.RiderExchangeLimit, bool) {
	if len(m.appendexchange_limit) == 0 {
		return nil, false
	}
	return m.appendexchange_limit, true
}

// ClearExchangeLimit clears the value of the "exchange_limit" field.
func (m *RiderMutation) ClearExchangeLimit() {
	m.exchange_limit = nil
	m.appendexchange_limit = nil
	m.clearedFields[rider.FieldExchangeLimit] = struct{}{}
}

// ExchangeLimitCleared returns if the "exchange_limit" field was cleared in this mutation.
func (m *RiderMutation) ExchangeLimitCleared() bool {
	_, ok := m.clearedFields[rider.FieldExchangeLimit]
	return ok
}

// ResetExchangeLimit resets all changes to the "exchange_limit" field.
func (m *RiderMutation) ResetExchangeLimit() {
	m.exchange_limit = nil
	m.appendexchange_limit = nil
	delete(m.clearedFields, rider.FieldExchangeLimit)
}

// SetExchangeFrequency sets the "exchange_frequency" field.
func (m *RiderMutation) SetExchangeFrequency(mef model.RiderExchangeFrequency) {
	m.exchange_frequency = &mef
	m.appendexchange_frequency = nil
}

// ExchangeFrequency returns the value of the "exchange_frequency" field in the mutation.
func (m *RiderMutation) ExchangeFrequency() (r model.RiderExchangeFrequency, exists bool) {
	v := m.exchange_frequency
	if v == nil {
		return
	}
	return *v, true
}

// OldExchangeFrequency returns the old "exchange_frequency" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldExchangeFrequency(ctx context.Context) (v model.RiderExchangeFrequency, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExchangeFrequency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExchangeFrequency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExchangeFrequency: %w", err)
	}
	return oldValue.ExchangeFrequency, nil
}

// AppendExchangeFrequency adds mef to the "exchange_frequency" field.
func (m *RiderMutation) AppendExchangeFrequency(mef model.RiderExchangeFrequency) {
	m.appendexchange_frequency = append(m.appendexchange_frequency, mef...)
}

// AppendedExchangeFrequency returns the list of values that were appended to the "exchange_frequency" field in this mutation.
func (m *RiderMutation) AppendedExchangeFrequency() (model.RiderExchangeFrequency, bool) {
	if len(m.appendexchange_frequency) == 0 {
		return nil, false
	}
	return m.appendexchange_frequency, true
}

// ClearExchangeFrequency clears the value of the "exchange_frequency" field.
func (m *RiderMutation) ClearExchangeFrequency() {
	m.exchange_frequency = nil
	m.appendexchange_frequency = nil
	m.clearedFields[rider.FieldExchangeFrequency] = struct{}{}
}

// ExchangeFrequencyCleared returns if the "exchange_frequency" field was cleared in this mutation.
func (m *RiderMutation) ExchangeFrequencyCleared() bool {
	_, ok := m.clearedFields[rider.FieldExchangeFrequency]
	return ok
}

// ResetExchangeFrequency resets all changes to the "exchange_frequency" field.
func (m *RiderMutation) ResetExchangeFrequency() {
	m.exchange_frequency = nil
	m.appendexchange_frequency = nil
	delete(m.clearedFields, rider.FieldExchangeFrequency)
}

// SetJoinEnterpriseAt sets the "join_enterprise_at" field.
func (m *RiderMutation) SetJoinEnterpriseAt(t time.Time) {
	m.join_enterprise_at = &t
}

// JoinEnterpriseAt returns the value of the "join_enterprise_at" field in the mutation.
func (m *RiderMutation) JoinEnterpriseAt() (r time.Time, exists bool) {
	v := m.join_enterprise_at
	if v == nil {
		return
	}
	return *v, true
}

// OldJoinEnterpriseAt returns the old "join_enterprise_at" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldJoinEnterpriseAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJoinEnterpriseAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJoinEnterpriseAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJoinEnterpriseAt: %w", err)
	}
	return oldValue.JoinEnterpriseAt, nil
}

// ClearJoinEnterpriseAt clears the value of the "join_enterprise_at" field.
func (m *RiderMutation) ClearJoinEnterpriseAt() {
	m.join_enterprise_at = nil
	m.clearedFields[rider.FieldJoinEnterpriseAt] = struct{}{}
}

// JoinEnterpriseAtCleared returns if the "join_enterprise_at" field was cleared in this mutation.
func (m *RiderMutation) JoinEnterpriseAtCleared() bool {
	_, ok := m.clearedFields[rider.FieldJoinEnterpriseAt]
	return ok
}

// ResetJoinEnterpriseAt resets all changes to the "join_enterprise_at" field.
func (m *RiderMutation) ResetJoinEnterpriseAt() {
	m.join_enterprise_at = nil
	delete(m.clearedFields, rider.FieldJoinEnterpriseAt)
}

// ClearStation clears the "station" edge to the EnterpriseStation entity.
func (m *RiderMutation) ClearStation() {
	m.clearedstation = true
	m.clearedFields[rider.FieldStationID] = struct{}{}
}

// StationCleared reports if the "station" edge to the EnterpriseStation entity was cleared.
func (m *RiderMutation) StationCleared() bool {
	return m.StationIDCleared() || m.clearedstation
}

// StationIDs returns the "station" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StationID instead. It exists only for internal usage by the builders.
func (m *RiderMutation) StationIDs() (ids []uint64) {
	if id := m.station; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStation resets all changes to the "station" edge.
func (m *RiderMutation) ResetStation() {
	m.station = nil
	m.clearedstation = false
}

// ClearPerson clears the "person" edge to the Person entity.
func (m *RiderMutation) ClearPerson() {
	m.clearedperson = true
	m.clearedFields[rider.FieldPersonID] = struct{}{}
}

// PersonCleared reports if the "person" edge to the Person entity was cleared.
func (m *RiderMutation) PersonCleared() bool {
	return m.PersonIDCleared() || m.clearedperson
}

// PersonIDs returns the "person" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PersonID instead. It exists only for internal usage by the builders.
func (m *RiderMutation) PersonIDs() (ids []uint64) {
	if id := m.person; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPerson resets all changes to the "person" edge.
func (m *RiderMutation) ResetPerson() {
	m.person = nil
	m.clearedperson = false
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *RiderMutation) ClearEnterprise() {
	m.clearedenterprise = true
	m.clearedFields[rider.FieldEnterpriseID] = struct{}{}
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *RiderMutation) EnterpriseCleared() bool {
	return m.EnterpriseIDCleared() || m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *RiderMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *RiderMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// AddContractIDs adds the "contracts" edge to the Contract entity by ids.
func (m *RiderMutation) AddContractIDs(ids ...uint64) {
	if m.contracts == nil {
		m.contracts = make(map[uint64]struct{})
	}
	for i := range ids {
		m.contracts[ids[i]] = struct{}{}
	}
}

// ClearContracts clears the "contracts" edge to the Contract entity.
func (m *RiderMutation) ClearContracts() {
	m.clearedcontracts = true
}

// ContractsCleared reports if the "contracts" edge to the Contract entity was cleared.
func (m *RiderMutation) ContractsCleared() bool {
	return m.clearedcontracts
}

// RemoveContractIDs removes the "contracts" edge to the Contract entity by IDs.
func (m *RiderMutation) RemoveContractIDs(ids ...uint64) {
	if m.removedcontracts == nil {
		m.removedcontracts = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.contracts, ids[i])
		m.removedcontracts[ids[i]] = struct{}{}
	}
}

// RemovedContracts returns the removed IDs of the "contracts" edge to the Contract entity.
func (m *RiderMutation) RemovedContractsIDs() (ids []uint64) {
	for id := range m.removedcontracts {
		ids = append(ids, id)
	}
	return
}

// ContractsIDs returns the "contracts" edge IDs in the mutation.
func (m *RiderMutation) ContractsIDs() (ids []uint64) {
	for id := range m.contracts {
		ids = append(ids, id)
	}
	return
}

// ResetContracts resets all changes to the "contracts" edge.
func (m *RiderMutation) ResetContracts() {
	m.contracts = nil
	m.clearedcontracts = false
	m.removedcontracts = nil
}

// AddFaultIDs adds the "faults" edge to the CabinetFault entity by ids.
func (m *RiderMutation) AddFaultIDs(ids ...uint64) {
	if m.faults == nil {
		m.faults = make(map[uint64]struct{})
	}
	for i := range ids {
		m.faults[ids[i]] = struct{}{}
	}
}

// ClearFaults clears the "faults" edge to the CabinetFault entity.
func (m *RiderMutation) ClearFaults() {
	m.clearedfaults = true
}

// FaultsCleared reports if the "faults" edge to the CabinetFault entity was cleared.
func (m *RiderMutation) FaultsCleared() bool {
	return m.clearedfaults
}

// RemoveFaultIDs removes the "faults" edge to the CabinetFault entity by IDs.
func (m *RiderMutation) RemoveFaultIDs(ids ...uint64) {
	if m.removedfaults == nil {
		m.removedfaults = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.faults, ids[i])
		m.removedfaults[ids[i]] = struct{}{}
	}
}

// RemovedFaults returns the removed IDs of the "faults" edge to the CabinetFault entity.
func (m *RiderMutation) RemovedFaultsIDs() (ids []uint64) {
	for id := range m.removedfaults {
		ids = append(ids, id)
	}
	return
}

// FaultsIDs returns the "faults" edge IDs in the mutation.
func (m *RiderMutation) FaultsIDs() (ids []uint64) {
	for id := range m.faults {
		ids = append(ids, id)
	}
	return
}

// ResetFaults resets all changes to the "faults" edge.
func (m *RiderMutation) ResetFaults() {
	m.faults = nil
	m.clearedfaults = false
	m.removedfaults = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *RiderMutation) AddOrderIDs(ids ...uint64) {
	if m.orders == nil {
		m.orders = make(map[uint64]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *RiderMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *RiderMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *RiderMutation) RemoveOrderIDs(ids ...uint64) {
	if m.removedorders == nil {
		m.removedorders = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *RiderMutation) RemovedOrdersIDs() (ids []uint64) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *RiderMutation) OrdersIDs() (ids []uint64) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *RiderMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// AddExchangeIDs adds the "exchanges" edge to the Exchange entity by ids.
func (m *RiderMutation) AddExchangeIDs(ids ...uint64) {
	if m.exchanges == nil {
		m.exchanges = make(map[uint64]struct{})
	}
	for i := range ids {
		m.exchanges[ids[i]] = struct{}{}
	}
}

// ClearExchanges clears the "exchanges" edge to the Exchange entity.
func (m *RiderMutation) ClearExchanges() {
	m.clearedexchanges = true
}

// ExchangesCleared reports if the "exchanges" edge to the Exchange entity was cleared.
func (m *RiderMutation) ExchangesCleared() bool {
	return m.clearedexchanges
}

// RemoveExchangeIDs removes the "exchanges" edge to the Exchange entity by IDs.
func (m *RiderMutation) RemoveExchangeIDs(ids ...uint64) {
	if m.removedexchanges == nil {
		m.removedexchanges = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.exchanges, ids[i])
		m.removedexchanges[ids[i]] = struct{}{}
	}
}

// RemovedExchanges returns the removed IDs of the "exchanges" edge to the Exchange entity.
func (m *RiderMutation) RemovedExchangesIDs() (ids []uint64) {
	for id := range m.removedexchanges {
		ids = append(ids, id)
	}
	return
}

// ExchangesIDs returns the "exchanges" edge IDs in the mutation.
func (m *RiderMutation) ExchangesIDs() (ids []uint64) {
	for id := range m.exchanges {
		ids = append(ids, id)
	}
	return
}

// ResetExchanges resets all changes to the "exchanges" edge.
func (m *RiderMutation) ResetExchanges() {
	m.exchanges = nil
	m.clearedexchanges = false
	m.removedexchanges = nil
}

// AddSubscribeIDs adds the "subscribes" edge to the Subscribe entity by ids.
func (m *RiderMutation) AddSubscribeIDs(ids ...uint64) {
	if m.subscribes == nil {
		m.subscribes = make(map[uint64]struct{})
	}
	for i := range ids {
		m.subscribes[ids[i]] = struct{}{}
	}
}

// ClearSubscribes clears the "subscribes" edge to the Subscribe entity.
func (m *RiderMutation) ClearSubscribes() {
	m.clearedsubscribes = true
}

// SubscribesCleared reports if the "subscribes" edge to the Subscribe entity was cleared.
func (m *RiderMutation) SubscribesCleared() bool {
	return m.clearedsubscribes
}

// RemoveSubscribeIDs removes the "subscribes" edge to the Subscribe entity by IDs.
func (m *RiderMutation) RemoveSubscribeIDs(ids ...uint64) {
	if m.removedsubscribes == nil {
		m.removedsubscribes = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.subscribes, ids[i])
		m.removedsubscribes[ids[i]] = struct{}{}
	}
}

// RemovedSubscribes returns the removed IDs of the "subscribes" edge to the Subscribe entity.
func (m *RiderMutation) RemovedSubscribesIDs() (ids []uint64) {
	for id := range m.removedsubscribes {
		ids = append(ids, id)
	}
	return
}

// SubscribesIDs returns the "subscribes" edge IDs in the mutation.
func (m *RiderMutation) SubscribesIDs() (ids []uint64) {
	for id := range m.subscribes {
		ids = append(ids, id)
	}
	return
}

// ResetSubscribes resets all changes to the "subscribes" edge.
func (m *RiderMutation) ResetSubscribes() {
	m.subscribes = nil
	m.clearedsubscribes = false
	m.removedsubscribes = nil
}

// AddStockIDs adds the "stocks" edge to the Stock entity by ids.
func (m *RiderMutation) AddStockIDs(ids ...uint64) {
	if m.stocks == nil {
		m.stocks = make(map[uint64]struct{})
	}
	for i := range ids {
		m.stocks[ids[i]] = struct{}{}
	}
}

// ClearStocks clears the "stocks" edge to the Stock entity.
func (m *RiderMutation) ClearStocks() {
	m.clearedstocks = true
}

// StocksCleared reports if the "stocks" edge to the Stock entity was cleared.
func (m *RiderMutation) StocksCleared() bool {
	return m.clearedstocks
}

// RemoveStockIDs removes the "stocks" edge to the Stock entity by IDs.
func (m *RiderMutation) RemoveStockIDs(ids ...uint64) {
	if m.removedstocks == nil {
		m.removedstocks = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.stocks, ids[i])
		m.removedstocks[ids[i]] = struct{}{}
	}
}

// RemovedStocks returns the removed IDs of the "stocks" edge to the Stock entity.
func (m *RiderMutation) RemovedStocksIDs() (ids []uint64) {
	for id := range m.removedstocks {
		ids = append(ids, id)
	}
	return
}

// StocksIDs returns the "stocks" edge IDs in the mutation.
func (m *RiderMutation) StocksIDs() (ids []uint64) {
	for id := range m.stocks {
		ids = append(ids, id)
	}
	return
}

// ResetStocks resets all changes to the "stocks" edge.
func (m *RiderMutation) ResetStocks() {
	m.stocks = nil
	m.clearedstocks = false
	m.removedstocks = nil
}

// AddFollowupIDs adds the "followups" edge to the RiderFollowUp entity by ids.
func (m *RiderMutation) AddFollowupIDs(ids ...uint64) {
	if m.followups == nil {
		m.followups = make(map[uint64]struct{})
	}
	for i := range ids {
		m.followups[ids[i]] = struct{}{}
	}
}

// ClearFollowups clears the "followups" edge to the RiderFollowUp entity.
func (m *RiderMutation) ClearFollowups() {
	m.clearedfollowups = true
}

// FollowupsCleared reports if the "followups" edge to the RiderFollowUp entity was cleared.
func (m *RiderMutation) FollowupsCleared() bool {
	return m.clearedfollowups
}

// RemoveFollowupIDs removes the "followups" edge to the RiderFollowUp entity by IDs.
func (m *RiderMutation) RemoveFollowupIDs(ids ...uint64) {
	if m.removedfollowups == nil {
		m.removedfollowups = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.followups, ids[i])
		m.removedfollowups[ids[i]] = struct{}{}
	}
}

// RemovedFollowups returns the removed IDs of the "followups" edge to the RiderFollowUp entity.
func (m *RiderMutation) RemovedFollowupsIDs() (ids []uint64) {
	for id := range m.removedfollowups {
		ids = append(ids, id)
	}
	return
}

// FollowupsIDs returns the "followups" edge IDs in the mutation.
func (m *RiderMutation) FollowupsIDs() (ids []uint64) {
	for id := range m.followups {
		ids = append(ids, id)
	}
	return
}

// ResetFollowups resets all changes to the "followups" edge.
func (m *RiderMutation) ResetFollowups() {
	m.followups = nil
	m.clearedfollowups = false
	m.removedfollowups = nil
}

// SetBatteryID sets the "battery" edge to the Battery entity by id.
func (m *RiderMutation) SetBatteryID(id uint64) {
	m.battery = &id
}

// ClearBattery clears the "battery" edge to the Battery entity.
func (m *RiderMutation) ClearBattery() {
	m.clearedbattery = true
}

// BatteryCleared reports if the "battery" edge to the Battery entity was cleared.
func (m *RiderMutation) BatteryCleared() bool {
	return m.clearedbattery
}

// BatteryID returns the "battery" edge ID in the mutation.
func (m *RiderMutation) BatteryID() (id uint64, exists bool) {
	if m.battery != nil {
		return *m.battery, true
	}
	return
}

// BatteryIDs returns the "battery" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BatteryID instead. It exists only for internal usage by the builders.
func (m *RiderMutation) BatteryIDs() (ids []uint64) {
	if id := m.battery; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBattery resets all changes to the "battery" edge.
func (m *RiderMutation) ResetBattery() {
	m.battery = nil
	m.clearedbattery = false
}

// AddBatteryFlowIDs adds the "battery_flows" edge to the BatteryFlow entity by ids.
func (m *RiderMutation) AddBatteryFlowIDs(ids ...uint64) {
	if m.battery_flows == nil {
		m.battery_flows = make(map[uint64]struct{})
	}
	for i := range ids {
		m.battery_flows[ids[i]] = struct{}{}
	}
}

// ClearBatteryFlows clears the "battery_flows" edge to the BatteryFlow entity.
func (m *RiderMutation) ClearBatteryFlows() {
	m.clearedbattery_flows = true
}

// BatteryFlowsCleared reports if the "battery_flows" edge to the BatteryFlow entity was cleared.
func (m *RiderMutation) BatteryFlowsCleared() bool {
	return m.clearedbattery_flows
}

// RemoveBatteryFlowIDs removes the "battery_flows" edge to the BatteryFlow entity by IDs.
func (m *RiderMutation) RemoveBatteryFlowIDs(ids ...uint64) {
	if m.removedbattery_flows == nil {
		m.removedbattery_flows = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.battery_flows, ids[i])
		m.removedbattery_flows[ids[i]] = struct{}{}
	}
}

// RemovedBatteryFlows returns the removed IDs of the "battery_flows" edge to the BatteryFlow entity.
func (m *RiderMutation) RemovedBatteryFlowsIDs() (ids []uint64) {
	for id := range m.removedbattery_flows {
		ids = append(ids, id)
	}
	return
}

// BatteryFlowsIDs returns the "battery_flows" edge IDs in the mutation.
func (m *RiderMutation) BatteryFlowsIDs() (ids []uint64) {
	for id := range m.battery_flows {
		ids = append(ids, id)
	}
	return
}

// ResetBatteryFlows resets all changes to the "battery_flows" edge.
func (m *RiderMutation) ResetBatteryFlows() {
	m.battery_flows = nil
	m.clearedbattery_flows = false
	m.removedbattery_flows = nil
}

// Where appends a list predicates to the RiderMutation builder.
func (m *RiderMutation) Where(ps ...predicate.Rider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RiderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RiderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Rider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RiderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RiderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Rider).
func (m *RiderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RiderMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.created_at != nil {
		fields = append(fields, rider.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, rider.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, rider.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, rider.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, rider.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, rider.FieldRemark)
	}
	if m.station != nil {
		fields = append(fields, rider.FieldStationID)
	}
	if m.person != nil {
		fields = append(fields, rider.FieldPersonID)
	}
	if m.name != nil {
		fields = append(fields, rider.FieldName)
	}
	if m.id_card_number != nil {
		fields = append(fields, rider.FieldIDCardNumber)
	}
	if m.enterprise != nil {
		fields = append(fields, rider.FieldEnterpriseID)
	}
	if m.phone != nil {
		fields = append(fields, rider.FieldPhone)
	}
	if m.contact != nil {
		fields = append(fields, rider.FieldContact)
	}
	if m.device_type != nil {
		fields = append(fields, rider.FieldDeviceType)
	}
	if m.last_device != nil {
		fields = append(fields, rider.FieldLastDevice)
	}
	if m.is_new_device != nil {
		fields = append(fields, rider.FieldIsNewDevice)
	}
	if m.push_id != nil {
		fields = append(fields, rider.FieldPushID)
	}
	if m.last_signin_at != nil {
		fields = append(fields, rider.FieldLastSigninAt)
	}
	if m.blocked != nil {
		fields = append(fields, rider.FieldBlocked)
	}
	if m.points != nil {
		fields = append(fields, rider.FieldPoints)
	}
	if m.exchange_limit != nil {
		fields = append(fields, rider.FieldExchangeLimit)
	}
	if m.exchange_frequency != nil {
		fields = append(fields, rider.FieldExchangeFrequency)
	}
	if m.join_enterprise_at != nil {
		fields = append(fields, rider.FieldJoinEnterpriseAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RiderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rider.FieldCreatedAt:
		return m.CreatedAt()
	case rider.FieldUpdatedAt:
		return m.UpdatedAt()
	case rider.FieldDeletedAt:
		return m.DeletedAt()
	case rider.FieldCreator:
		return m.Creator()
	case rider.FieldLastModifier:
		return m.LastModifier()
	case rider.FieldRemark:
		return m.Remark()
	case rider.FieldStationID:
		return m.StationID()
	case rider.FieldPersonID:
		return m.PersonID()
	case rider.FieldName:
		return m.Name()
	case rider.FieldIDCardNumber:
		return m.IDCardNumber()
	case rider.FieldEnterpriseID:
		return m.EnterpriseID()
	case rider.FieldPhone:
		return m.Phone()
	case rider.FieldContact:
		return m.Contact()
	case rider.FieldDeviceType:
		return m.DeviceType()
	case rider.FieldLastDevice:
		return m.LastDevice()
	case rider.FieldIsNewDevice:
		return m.IsNewDevice()
	case rider.FieldPushID:
		return m.PushID()
	case rider.FieldLastSigninAt:
		return m.LastSigninAt()
	case rider.FieldBlocked:
		return m.Blocked()
	case rider.FieldPoints:
		return m.Points()
	case rider.FieldExchangeLimit:
		return m.ExchangeLimit()
	case rider.FieldExchangeFrequency:
		return m.ExchangeFrequency()
	case rider.FieldJoinEnterpriseAt:
		return m.JoinEnterpriseAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RiderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rider.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case rider.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case rider.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case rider.FieldCreator:
		return m.OldCreator(ctx)
	case rider.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case rider.FieldRemark:
		return m.OldRemark(ctx)
	case rider.FieldStationID:
		return m.OldStationID(ctx)
	case rider.FieldPersonID:
		return m.OldPersonID(ctx)
	case rider.FieldName:
		return m.OldName(ctx)
	case rider.FieldIDCardNumber:
		return m.OldIDCardNumber(ctx)
	case rider.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case rider.FieldPhone:
		return m.OldPhone(ctx)
	case rider.FieldContact:
		return m.OldContact(ctx)
	case rider.FieldDeviceType:
		return m.OldDeviceType(ctx)
	case rider.FieldLastDevice:
		return m.OldLastDevice(ctx)
	case rider.FieldIsNewDevice:
		return m.OldIsNewDevice(ctx)
	case rider.FieldPushID:
		return m.OldPushID(ctx)
	case rider.FieldLastSigninAt:
		return m.OldLastSigninAt(ctx)
	case rider.FieldBlocked:
		return m.OldBlocked(ctx)
	case rider.FieldPoints:
		return m.OldPoints(ctx)
	case rider.FieldExchangeLimit:
		return m.OldExchangeLimit(ctx)
	case rider.FieldExchangeFrequency:
		return m.OldExchangeFrequency(ctx)
	case rider.FieldJoinEnterpriseAt:
		return m.OldJoinEnterpriseAt(ctx)
	}
	return nil, fmt.Errorf("unknown Rider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rider.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case rider.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case rider.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case rider.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case rider.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case rider.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case rider.FieldStationID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStationID(v)
		return nil
	case rider.FieldPersonID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonID(v)
		return nil
	case rider.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case rider.FieldIDCardNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCardNumber(v)
		return nil
	case rider.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case rider.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case rider.FieldContact:
		v, ok := value.(*model.RiderContact)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContact(v)
		return nil
	case rider.FieldDeviceType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceType(v)
		return nil
	case rider.FieldLastDevice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastDevice(v)
		return nil
	case rider.FieldIsNewDevice:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNewDevice(v)
		return nil
	case rider.FieldPushID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPushID(v)
		return nil
	case rider.FieldLastSigninAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSigninAt(v)
		return nil
	case rider.FieldBlocked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlocked(v)
		return nil
	case rider.FieldPoints:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoints(v)
		return nil
	case rider.FieldExchangeLimit:
		v, ok := value.(model.RiderExchangeLimit)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExchangeLimit(v)
		return nil
	case rider.FieldExchangeFrequency:
		v, ok := value.(model.RiderExchangeFrequency)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExchangeFrequency(v)
		return nil
	case rider.FieldJoinEnterpriseAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJoinEnterpriseAt(v)
		return nil
	}
	return fmt.Errorf("unknown Rider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RiderMutation) AddedFields() []string {
	var fields []string
	if m.adddevice_type != nil {
		fields = append(fields, rider.FieldDeviceType)
	}
	if m.addpoints != nil {
		fields = append(fields, rider.FieldPoints)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RiderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rider.FieldDeviceType:
		return m.AddedDeviceType()
	case rider.FieldPoints:
		return m.AddedPoints()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rider.FieldDeviceType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceType(v)
		return nil
	case rider.FieldPoints:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoints(v)
		return nil
	}
	return fmt.Errorf("unknown Rider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RiderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rider.FieldDeletedAt) {
		fields = append(fields, rider.FieldDeletedAt)
	}
	if m.FieldCleared(rider.FieldCreator) {
		fields = append(fields, rider.FieldCreator)
	}
	if m.FieldCleared(rider.FieldLastModifier) {
		fields = append(fields, rider.FieldLastModifier)
	}
	if m.FieldCleared(rider.FieldRemark) {
		fields = append(fields, rider.FieldRemark)
	}
	if m.FieldCleared(rider.FieldStationID) {
		fields = append(fields, rider.FieldStationID)
	}
	if m.FieldCleared(rider.FieldPersonID) {
		fields = append(fields, rider.FieldPersonID)
	}
	if m.FieldCleared(rider.FieldName) {
		fields = append(fields, rider.FieldName)
	}
	if m.FieldCleared(rider.FieldIDCardNumber) {
		fields = append(fields, rider.FieldIDCardNumber)
	}
	if m.FieldCleared(rider.FieldEnterpriseID) {
		fields = append(fields, rider.FieldEnterpriseID)
	}
	if m.FieldCleared(rider.FieldContact) {
		fields = append(fields, rider.FieldContact)
	}
	if m.FieldCleared(rider.FieldDeviceType) {
		fields = append(fields, rider.FieldDeviceType)
	}
	if m.FieldCleared(rider.FieldLastDevice) {
		fields = append(fields, rider.FieldLastDevice)
	}
	if m.FieldCleared(rider.FieldPushID) {
		fields = append(fields, rider.FieldPushID)
	}
	if m.FieldCleared(rider.FieldLastSigninAt) {
		fields = append(fields, rider.FieldLastSigninAt)
	}
	if m.FieldCleared(rider.FieldExchangeLimit) {
		fields = append(fields, rider.FieldExchangeLimit)
	}
	if m.FieldCleared(rider.FieldExchangeFrequency) {
		fields = append(fields, rider.FieldExchangeFrequency)
	}
	if m.FieldCleared(rider.FieldJoinEnterpriseAt) {
		fields = append(fields, rider.FieldJoinEnterpriseAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RiderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RiderMutation) ClearField(name string) error {
	switch name {
	case rider.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case rider.FieldCreator:
		m.ClearCreator()
		return nil
	case rider.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case rider.FieldRemark:
		m.ClearRemark()
		return nil
	case rider.FieldStationID:
		m.ClearStationID()
		return nil
	case rider.FieldPersonID:
		m.ClearPersonID()
		return nil
	case rider.FieldName:
		m.ClearName()
		return nil
	case rider.FieldIDCardNumber:
		m.ClearIDCardNumber()
		return nil
	case rider.FieldEnterpriseID:
		m.ClearEnterpriseID()
		return nil
	case rider.FieldContact:
		m.ClearContact()
		return nil
	case rider.FieldDeviceType:
		m.ClearDeviceType()
		return nil
	case rider.FieldLastDevice:
		m.ClearLastDevice()
		return nil
	case rider.FieldPushID:
		m.ClearPushID()
		return nil
	case rider.FieldLastSigninAt:
		m.ClearLastSigninAt()
		return nil
	case rider.FieldExchangeLimit:
		m.ClearExchangeLimit()
		return nil
	case rider.FieldExchangeFrequency:
		m.ClearExchangeFrequency()
		return nil
	case rider.FieldJoinEnterpriseAt:
		m.ClearJoinEnterpriseAt()
		return nil
	}
	return fmt.Errorf("unknown Rider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RiderMutation) ResetField(name string) error {
	switch name {
	case rider.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case rider.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case rider.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case rider.FieldCreator:
		m.ResetCreator()
		return nil
	case rider.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case rider.FieldRemark:
		m.ResetRemark()
		return nil
	case rider.FieldStationID:
		m.ResetStationID()
		return nil
	case rider.FieldPersonID:
		m.ResetPersonID()
		return nil
	case rider.FieldName:
		m.ResetName()
		return nil
	case rider.FieldIDCardNumber:
		m.ResetIDCardNumber()
		return nil
	case rider.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case rider.FieldPhone:
		m.ResetPhone()
		return nil
	case rider.FieldContact:
		m.ResetContact()
		return nil
	case rider.FieldDeviceType:
		m.ResetDeviceType()
		return nil
	case rider.FieldLastDevice:
		m.ResetLastDevice()
		return nil
	case rider.FieldIsNewDevice:
		m.ResetIsNewDevice()
		return nil
	case rider.FieldPushID:
		m.ResetPushID()
		return nil
	case rider.FieldLastSigninAt:
		m.ResetLastSigninAt()
		return nil
	case rider.FieldBlocked:
		m.ResetBlocked()
		return nil
	case rider.FieldPoints:
		m.ResetPoints()
		return nil
	case rider.FieldExchangeLimit:
		m.ResetExchangeLimit()
		return nil
	case rider.FieldExchangeFrequency:
		m.ResetExchangeFrequency()
		return nil
	case rider.FieldJoinEnterpriseAt:
		m.ResetJoinEnterpriseAt()
		return nil
	}
	return fmt.Errorf("unknown Rider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RiderMutation) AddedEdges() []string {
	edges := make([]string, 0, 12)
	if m.station != nil {
		edges = append(edges, rider.EdgeStation)
	}
	if m.person != nil {
		edges = append(edges, rider.EdgePerson)
	}
	if m.enterprise != nil {
		edges = append(edges, rider.EdgeEnterprise)
	}
	if m.contracts != nil {
		edges = append(edges, rider.EdgeContracts)
	}
	if m.faults != nil {
		edges = append(edges, rider.EdgeFaults)
	}
	if m.orders != nil {
		edges = append(edges, rider.EdgeOrders)
	}
	if m.exchanges != nil {
		edges = append(edges, rider.EdgeExchanges)
	}
	if m.subscribes != nil {
		edges = append(edges, rider.EdgeSubscribes)
	}
	if m.stocks != nil {
		edges = append(edges, rider.EdgeStocks)
	}
	if m.followups != nil {
		edges = append(edges, rider.EdgeFollowups)
	}
	if m.battery != nil {
		edges = append(edges, rider.EdgeBattery)
	}
	if m.battery_flows != nil {
		edges = append(edges, rider.EdgeBatteryFlows)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RiderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rider.EdgeStation:
		if id := m.station; id != nil {
			return []ent.Value{*id}
		}
	case rider.EdgePerson:
		if id := m.person; id != nil {
			return []ent.Value{*id}
		}
	case rider.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	case rider.EdgeContracts:
		ids := make([]ent.Value, 0, len(m.contracts))
		for id := range m.contracts {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeFaults:
		ids := make([]ent.Value, 0, len(m.faults))
		for id := range m.faults {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeExchanges:
		ids := make([]ent.Value, 0, len(m.exchanges))
		for id := range m.exchanges {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeSubscribes:
		ids := make([]ent.Value, 0, len(m.subscribes))
		for id := range m.subscribes {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.stocks))
		for id := range m.stocks {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeFollowups:
		ids := make([]ent.Value, 0, len(m.followups))
		for id := range m.followups {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeBattery:
		if id := m.battery; id != nil {
			return []ent.Value{*id}
		}
	case rider.EdgeBatteryFlows:
		ids := make([]ent.Value, 0, len(m.battery_flows))
		for id := range m.battery_flows {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RiderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 12)
	if m.removedcontracts != nil {
		edges = append(edges, rider.EdgeContracts)
	}
	if m.removedfaults != nil {
		edges = append(edges, rider.EdgeFaults)
	}
	if m.removedorders != nil {
		edges = append(edges, rider.EdgeOrders)
	}
	if m.removedexchanges != nil {
		edges = append(edges, rider.EdgeExchanges)
	}
	if m.removedsubscribes != nil {
		edges = append(edges, rider.EdgeSubscribes)
	}
	if m.removedstocks != nil {
		edges = append(edges, rider.EdgeStocks)
	}
	if m.removedfollowups != nil {
		edges = append(edges, rider.EdgeFollowups)
	}
	if m.removedbattery_flows != nil {
		edges = append(edges, rider.EdgeBatteryFlows)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RiderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case rider.EdgeContracts:
		ids := make([]ent.Value, 0, len(m.removedcontracts))
		for id := range m.removedcontracts {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeFaults:
		ids := make([]ent.Value, 0, len(m.removedfaults))
		for id := range m.removedfaults {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeExchanges:
		ids := make([]ent.Value, 0, len(m.removedexchanges))
		for id := range m.removedexchanges {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeSubscribes:
		ids := make([]ent.Value, 0, len(m.removedsubscribes))
		for id := range m.removedsubscribes {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.removedstocks))
		for id := range m.removedstocks {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeFollowups:
		ids := make([]ent.Value, 0, len(m.removedfollowups))
		for id := range m.removedfollowups {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeBatteryFlows:
		ids := make([]ent.Value, 0, len(m.removedbattery_flows))
		for id := range m.removedbattery_flows {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RiderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 12)
	if m.clearedstation {
		edges = append(edges, rider.EdgeStation)
	}
	if m.clearedperson {
		edges = append(edges, rider.EdgePerson)
	}
	if m.clearedenterprise {
		edges = append(edges, rider.EdgeEnterprise)
	}
	if m.clearedcontracts {
		edges = append(edges, rider.EdgeContracts)
	}
	if m.clearedfaults {
		edges = append(edges, rider.EdgeFaults)
	}
	if m.clearedorders {
		edges = append(edges, rider.EdgeOrders)
	}
	if m.clearedexchanges {
		edges = append(edges, rider.EdgeExchanges)
	}
	if m.clearedsubscribes {
		edges = append(edges, rider.EdgeSubscribes)
	}
	if m.clearedstocks {
		edges = append(edges, rider.EdgeStocks)
	}
	if m.clearedfollowups {
		edges = append(edges, rider.EdgeFollowups)
	}
	if m.clearedbattery {
		edges = append(edges, rider.EdgeBattery)
	}
	if m.clearedbattery_flows {
		edges = append(edges, rider.EdgeBatteryFlows)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RiderMutation) EdgeCleared(name string) bool {
	switch name {
	case rider.EdgeStation:
		return m.clearedstation
	case rider.EdgePerson:
		return m.clearedperson
	case rider.EdgeEnterprise:
		return m.clearedenterprise
	case rider.EdgeContracts:
		return m.clearedcontracts
	case rider.EdgeFaults:
		return m.clearedfaults
	case rider.EdgeOrders:
		return m.clearedorders
	case rider.EdgeExchanges:
		return m.clearedexchanges
	case rider.EdgeSubscribes:
		return m.clearedsubscribes
	case rider.EdgeStocks:
		return m.clearedstocks
	case rider.EdgeFollowups:
		return m.clearedfollowups
	case rider.EdgeBattery:
		return m.clearedbattery
	case rider.EdgeBatteryFlows:
		return m.clearedbattery_flows
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RiderMutation) ClearEdge(name string) error {
	switch name {
	case rider.EdgeStation:
		m.ClearStation()
		return nil
	case rider.EdgePerson:
		m.ClearPerson()
		return nil
	case rider.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	case rider.EdgeBattery:
		m.ClearBattery()
		return nil
	}
	return fmt.Errorf("unknown Rider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RiderMutation) ResetEdge(name string) error {
	switch name {
	case rider.EdgeStation:
		m.ResetStation()
		return nil
	case rider.EdgePerson:
		m.ResetPerson()
		return nil
	case rider.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	case rider.EdgeContracts:
		m.ResetContracts()
		return nil
	case rider.EdgeFaults:
		m.ResetFaults()
		return nil
	case rider.EdgeOrders:
		m.ResetOrders()
		return nil
	case rider.EdgeExchanges:
		m.ResetExchanges()
		return nil
	case rider.EdgeSubscribes:
		m.ResetSubscribes()
		return nil
	case rider.EdgeStocks:
		m.ResetStocks()
		return nil
	case rider.EdgeFollowups:
		m.ResetFollowups()
		return nil
	case rider.EdgeBattery:
		m.ResetBattery()
		return nil
	case rider.EdgeBatteryFlows:
		m.ResetBatteryFlows()
		return nil
	}
	return fmt.Errorf("unknown Rider edge %s", name)
}

// RiderFollowUpMutation represents an operation that mutates the RiderFollowUp nodes in the graph.
type RiderFollowUpMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	creator        **model.Modifier
	last_modifier  **model.Modifier
	remark         *string
	clearedFields  map[string]struct{}
	manager        *uint64
	clearedmanager bool
	rider          *uint64
	clearedrider   bool
	done           bool
	oldValue       func(context.Context) (*RiderFollowUp, error)
	predicates     []predicate.RiderFollowUp
}

var _ ent.Mutation = (*RiderFollowUpMutation)(nil)

// riderfollowupOption allows management of the mutation configuration using functional options.
type riderfollowupOption func(*RiderFollowUpMutation)

// newRiderFollowUpMutation creates new mutation for the RiderFollowUp entity.
func newRiderFollowUpMutation(c config, op Op, opts ...riderfollowupOption) *RiderFollowUpMutation {
	m := &RiderFollowUpMutation{
		config:        c,
		op:            op,
		typ:           TypeRiderFollowUp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRiderFollowUpID sets the ID field of the mutation.
func withRiderFollowUpID(id uint64) riderfollowupOption {
	return func(m *RiderFollowUpMutation) {
		var (
			err   error
			once  sync.Once
			value *RiderFollowUp
		)
		m.oldValue = func(ctx context.Context) (*RiderFollowUp, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RiderFollowUp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRiderFollowUp sets the old RiderFollowUp of the mutation.
func withRiderFollowUp(node *RiderFollowUp) riderfollowupOption {
	return func(m *RiderFollowUpMutation) {
		m.oldValue = func(context.Context) (*RiderFollowUp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RiderFollowUpMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RiderFollowUpMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RiderFollowUpMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RiderFollowUpMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RiderFollowUp.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RiderFollowUpMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RiderFollowUpMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RiderFollowUp entity.
// If the RiderFollowUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderFollowUpMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RiderFollowUpMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RiderFollowUpMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RiderFollowUpMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the RiderFollowUp entity.
// If the RiderFollowUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderFollowUpMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RiderFollowUpMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RiderFollowUpMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RiderFollowUpMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the RiderFollowUp entity.
// If the RiderFollowUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderFollowUpMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RiderFollowUpMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[riderfollowup.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RiderFollowUpMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[riderfollowup.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RiderFollowUpMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, riderfollowup.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *RiderFollowUpMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *RiderFollowUpMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the RiderFollowUp entity.
// If the RiderFollowUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderFollowUpMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *RiderFollowUpMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[riderfollowup.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *RiderFollowUpMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[riderfollowup.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *RiderFollowUpMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, riderfollowup.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *RiderFollowUpMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *RiderFollowUpMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the RiderFollowUp entity.
// If the RiderFollowUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderFollowUpMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *RiderFollowUpMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[riderfollowup.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *RiderFollowUpMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[riderfollowup.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *RiderFollowUpMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, riderfollowup.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *RiderFollowUpMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *RiderFollowUpMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the RiderFollowUp entity.
// If the RiderFollowUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderFollowUpMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *RiderFollowUpMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[riderfollowup.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *RiderFollowUpMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[riderfollowup.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *RiderFollowUpMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, riderfollowup.FieldRemark)
}

// SetManagerID sets the "manager_id" field.
func (m *RiderFollowUpMutation) SetManagerID(u uint64) {
	m.manager = &u
}

// ManagerID returns the value of the "manager_id" field in the mutation.
func (m *RiderFollowUpMutation) ManagerID() (r uint64, exists bool) {
	v := m.manager
	if v == nil {
		return
	}
	return *v, true
}

// OldManagerID returns the old "manager_id" field's value of the RiderFollowUp entity.
// If the RiderFollowUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderFollowUpMutation) OldManagerID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagerID: %w", err)
	}
	return oldValue.ManagerID, nil
}

// ResetManagerID resets all changes to the "manager_id" field.
func (m *RiderFollowUpMutation) ResetManagerID() {
	m.manager = nil
}

// SetRiderID sets the "rider_id" field.
func (m *RiderFollowUpMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *RiderFollowUpMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the RiderFollowUp entity.
// If the RiderFollowUp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderFollowUpMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *RiderFollowUpMutation) ResetRiderID() {
	m.rider = nil
}

// ClearManager clears the "manager" edge to the Manager entity.
func (m *RiderFollowUpMutation) ClearManager() {
	m.clearedmanager = true
	m.clearedFields[riderfollowup.FieldManagerID] = struct{}{}
}

// ManagerCleared reports if the "manager" edge to the Manager entity was cleared.
func (m *RiderFollowUpMutation) ManagerCleared() bool {
	return m.clearedmanager
}

// ManagerIDs returns the "manager" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ManagerID instead. It exists only for internal usage by the builders.
func (m *RiderFollowUpMutation) ManagerIDs() (ids []uint64) {
	if id := m.manager; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetManager resets all changes to the "manager" edge.
func (m *RiderFollowUpMutation) ResetManager() {
	m.manager = nil
	m.clearedmanager = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *RiderFollowUpMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[riderfollowup.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *RiderFollowUpMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *RiderFollowUpMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *RiderFollowUpMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// Where appends a list predicates to the RiderFollowUpMutation builder.
func (m *RiderFollowUpMutation) Where(ps ...predicate.RiderFollowUp) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RiderFollowUpMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RiderFollowUpMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RiderFollowUp, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RiderFollowUpMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RiderFollowUpMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RiderFollowUp).
func (m *RiderFollowUpMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RiderFollowUpMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, riderfollowup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, riderfollowup.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, riderfollowup.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, riderfollowup.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, riderfollowup.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, riderfollowup.FieldRemark)
	}
	if m.manager != nil {
		fields = append(fields, riderfollowup.FieldManagerID)
	}
	if m.rider != nil {
		fields = append(fields, riderfollowup.FieldRiderID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RiderFollowUpMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case riderfollowup.FieldCreatedAt:
		return m.CreatedAt()
	case riderfollowup.FieldUpdatedAt:
		return m.UpdatedAt()
	case riderfollowup.FieldDeletedAt:
		return m.DeletedAt()
	case riderfollowup.FieldCreator:
		return m.Creator()
	case riderfollowup.FieldLastModifier:
		return m.LastModifier()
	case riderfollowup.FieldRemark:
		return m.Remark()
	case riderfollowup.FieldManagerID:
		return m.ManagerID()
	case riderfollowup.FieldRiderID:
		return m.RiderID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RiderFollowUpMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case riderfollowup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case riderfollowup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case riderfollowup.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case riderfollowup.FieldCreator:
		return m.OldCreator(ctx)
	case riderfollowup.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case riderfollowup.FieldRemark:
		return m.OldRemark(ctx)
	case riderfollowup.FieldManagerID:
		return m.OldManagerID(ctx)
	case riderfollowup.FieldRiderID:
		return m.OldRiderID(ctx)
	}
	return nil, fmt.Errorf("unknown RiderFollowUp field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiderFollowUpMutation) SetField(name string, value ent.Value) error {
	switch name {
	case riderfollowup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case riderfollowup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case riderfollowup.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case riderfollowup.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case riderfollowup.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case riderfollowup.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case riderfollowup.FieldManagerID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagerID(v)
		return nil
	case riderfollowup.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	}
	return fmt.Errorf("unknown RiderFollowUp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RiderFollowUpMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RiderFollowUpMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiderFollowUpMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RiderFollowUp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RiderFollowUpMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(riderfollowup.FieldDeletedAt) {
		fields = append(fields, riderfollowup.FieldDeletedAt)
	}
	if m.FieldCleared(riderfollowup.FieldCreator) {
		fields = append(fields, riderfollowup.FieldCreator)
	}
	if m.FieldCleared(riderfollowup.FieldLastModifier) {
		fields = append(fields, riderfollowup.FieldLastModifier)
	}
	if m.FieldCleared(riderfollowup.FieldRemark) {
		fields = append(fields, riderfollowup.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RiderFollowUpMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RiderFollowUpMutation) ClearField(name string) error {
	switch name {
	case riderfollowup.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case riderfollowup.FieldCreator:
		m.ClearCreator()
		return nil
	case riderfollowup.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case riderfollowup.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown RiderFollowUp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RiderFollowUpMutation) ResetField(name string) error {
	switch name {
	case riderfollowup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case riderfollowup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case riderfollowup.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case riderfollowup.FieldCreator:
		m.ResetCreator()
		return nil
	case riderfollowup.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case riderfollowup.FieldRemark:
		m.ResetRemark()
		return nil
	case riderfollowup.FieldManagerID:
		m.ResetManagerID()
		return nil
	case riderfollowup.FieldRiderID:
		m.ResetRiderID()
		return nil
	}
	return fmt.Errorf("unknown RiderFollowUp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RiderFollowUpMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.manager != nil {
		edges = append(edges, riderfollowup.EdgeManager)
	}
	if m.rider != nil {
		edges = append(edges, riderfollowup.EdgeRider)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RiderFollowUpMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case riderfollowup.EdgeManager:
		if id := m.manager; id != nil {
			return []ent.Value{*id}
		}
	case riderfollowup.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RiderFollowUpMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RiderFollowUpMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RiderFollowUpMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmanager {
		edges = append(edges, riderfollowup.EdgeManager)
	}
	if m.clearedrider {
		edges = append(edges, riderfollowup.EdgeRider)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RiderFollowUpMutation) EdgeCleared(name string) bool {
	switch name {
	case riderfollowup.EdgeManager:
		return m.clearedmanager
	case riderfollowup.EdgeRider:
		return m.clearedrider
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RiderFollowUpMutation) ClearEdge(name string) error {
	switch name {
	case riderfollowup.EdgeManager:
		m.ClearManager()
		return nil
	case riderfollowup.EdgeRider:
		m.ClearRider()
		return nil
	}
	return fmt.Errorf("unknown RiderFollowUp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RiderFollowUpMutation) ResetEdge(name string) error {
	switch name {
	case riderfollowup.EdgeManager:
		m.ResetManager()
		return nil
	case riderfollowup.EdgeRider:
		m.ResetRider()
		return nil
	}
	return fmt.Errorf("unknown RiderFollowUp edge %s", name)
}

// RoleMutation represents an operation that mutates the Role nodes in the graph.
type RoleMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	name              *string
	permissions       *[]string
	appendpermissions []string
	buildin           *bool
	super             *bool
	created_at        *time.Time
	clearedFields     map[string]struct{}
	managers          map[uint64]struct{}
	removedmanagers   map[uint64]struct{}
	clearedmanagers   bool
	done              bool
	oldValue          func(context.Context) (*Role, error)
	predicates        []predicate.Role
}

var _ ent.Mutation = (*RoleMutation)(nil)

// roleOption allows management of the mutation configuration using functional options.
type roleOption func(*RoleMutation)

// newRoleMutation creates new mutation for the Role entity.
func newRoleMutation(c config, op Op, opts ...roleOption) *RoleMutation {
	m := &RoleMutation{
		config:        c,
		op:            op,
		typ:           TypeRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoleID sets the ID field of the mutation.
func withRoleID(id uint64) roleOption {
	return func(m *RoleMutation) {
		var (
			err   error
			once  sync.Once
			value *Role
		)
		m.oldValue = func(ctx context.Context) (*Role, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Role.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRole sets the old Role of the mutation.
func withRole(node *Role) roleOption {
	return func(m *RoleMutation) {
		m.oldValue = func(context.Context) (*Role, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RoleMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RoleMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Role.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *RoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RoleMutation) ResetName() {
	m.name = nil
}

// SetPermissions sets the "permissions" field.
func (m *RoleMutation) SetPermissions(s []string) {
	m.permissions = &s
	m.appendpermissions = nil
}

// Permissions returns the value of the "permissions" field in the mutation.
func (m *RoleMutation) Permissions() (r []string, exists bool) {
	v := m.permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissions returns the old "permissions" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldPermissions(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissions: %w", err)
	}
	return oldValue.Permissions, nil
}

// AppendPermissions adds s to the "permissions" field.
func (m *RoleMutation) AppendPermissions(s []string) {
	m.appendpermissions = append(m.appendpermissions, s...)
}

// AppendedPermissions returns the list of values that were appended to the "permissions" field in this mutation.
func (m *RoleMutation) AppendedPermissions() ([]string, bool) {
	if len(m.appendpermissions) == 0 {
		return nil, false
	}
	return m.appendpermissions, true
}

// ClearPermissions clears the value of the "permissions" field.
func (m *RoleMutation) ClearPermissions() {
	m.permissions = nil
	m.appendpermissions = nil
	m.clearedFields[role.FieldPermissions] = struct{}{}
}

// PermissionsCleared returns if the "permissions" field was cleared in this mutation.
func (m *RoleMutation) PermissionsCleared() bool {
	_, ok := m.clearedFields[role.FieldPermissions]
	return ok
}

// ResetPermissions resets all changes to the "permissions" field.
func (m *RoleMutation) ResetPermissions() {
	m.permissions = nil
	m.appendpermissions = nil
	delete(m.clearedFields, role.FieldPermissions)
}

// SetBuildin sets the "buildin" field.
func (m *RoleMutation) SetBuildin(b bool) {
	m.buildin = &b
}

// Buildin returns the value of the "buildin" field in the mutation.
func (m *RoleMutation) Buildin() (r bool, exists bool) {
	v := m.buildin
	if v == nil {
		return
	}
	return *v, true
}

// OldBuildin returns the old "buildin" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldBuildin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBuildin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBuildin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuildin: %w", err)
	}
	return oldValue.Buildin, nil
}

// ResetBuildin resets all changes to the "buildin" field.
func (m *RoleMutation) ResetBuildin() {
	m.buildin = nil
}

// SetSuper sets the "super" field.
func (m *RoleMutation) SetSuper(b bool) {
	m.super = &b
}

// Super returns the value of the "super" field in the mutation.
func (m *RoleMutation) Super() (r bool, exists bool) {
	v := m.super
	if v == nil {
		return
	}
	return *v, true
}

// OldSuper returns the old "super" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldSuper(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuper is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuper requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuper: %w", err)
	}
	return oldValue.Super, nil
}

// ResetSuper resets all changes to the "super" field.
func (m *RoleMutation) ResetSuper() {
	m.super = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Role entity.
// If the Role object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RoleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddManagerIDs adds the "managers" edge to the Manager entity by ids.
func (m *RoleMutation) AddManagerIDs(ids ...uint64) {
	if m.managers == nil {
		m.managers = make(map[uint64]struct{})
	}
	for i := range ids {
		m.managers[ids[i]] = struct{}{}
	}
}

// ClearManagers clears the "managers" edge to the Manager entity.
func (m *RoleMutation) ClearManagers() {
	m.clearedmanagers = true
}

// ManagersCleared reports if the "managers" edge to the Manager entity was cleared.
func (m *RoleMutation) ManagersCleared() bool {
	return m.clearedmanagers
}

// RemoveManagerIDs removes the "managers" edge to the Manager entity by IDs.
func (m *RoleMutation) RemoveManagerIDs(ids ...uint64) {
	if m.removedmanagers == nil {
		m.removedmanagers = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.managers, ids[i])
		m.removedmanagers[ids[i]] = struct{}{}
	}
}

// RemovedManagers returns the removed IDs of the "managers" edge to the Manager entity.
func (m *RoleMutation) RemovedManagersIDs() (ids []uint64) {
	for id := range m.removedmanagers {
		ids = append(ids, id)
	}
	return
}

// ManagersIDs returns the "managers" edge IDs in the mutation.
func (m *RoleMutation) ManagersIDs() (ids []uint64) {
	for id := range m.managers {
		ids = append(ids, id)
	}
	return
}

// ResetManagers resets all changes to the "managers" edge.
func (m *RoleMutation) ResetManagers() {
	m.managers = nil
	m.clearedmanagers = false
	m.removedmanagers = nil
}

// Where appends a list predicates to the RoleMutation builder.
func (m *RoleMutation) Where(ps ...predicate.Role) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Role, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Role).
func (m *RoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RoleMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, role.FieldName)
	}
	if m.permissions != nil {
		fields = append(fields, role.FieldPermissions)
	}
	if m.buildin != nil {
		fields = append(fields, role.FieldBuildin)
	}
	if m.super != nil {
		fields = append(fields, role.FieldSuper)
	}
	if m.created_at != nil {
		fields = append(fields, role.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case role.FieldName:
		return m.Name()
	case role.FieldPermissions:
		return m.Permissions()
	case role.FieldBuildin:
		return m.Buildin()
	case role.FieldSuper:
		return m.Super()
	case role.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case role.FieldName:
		return m.OldName(ctx)
	case role.FieldPermissions:
		return m.OldPermissions(ctx)
	case role.FieldBuildin:
		return m.OldBuildin(ctx)
	case role.FieldSuper:
		return m.OldSuper(ctx)
	case role.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Role field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case role.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case role.FieldPermissions:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissions(v)
		return nil
	case role.FieldBuildin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuildin(v)
		return nil
	case role.FieldSuper:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuper(v)
		return nil
	case role.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Role numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(role.FieldPermissions) {
		fields = append(fields, role.FieldPermissions)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoleMutation) ClearField(name string) error {
	switch name {
	case role.FieldPermissions:
		m.ClearPermissions()
		return nil
	}
	return fmt.Errorf("unknown Role nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RoleMutation) ResetField(name string) error {
	switch name {
	case role.FieldName:
		m.ResetName()
		return nil
	case role.FieldPermissions:
		m.ResetPermissions()
		return nil
	case role.FieldBuildin:
		m.ResetBuildin()
		return nil
	case role.FieldSuper:
		m.ResetSuper()
		return nil
	case role.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Role field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.managers != nil {
		edges = append(edges, role.EdgeManagers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeManagers:
		ids := make([]ent.Value, 0, len(m.managers))
		for id := range m.managers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmanagers != nil {
		edges = append(edges, role.EdgeManagers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case role.EdgeManagers:
		ids := make([]ent.Value, 0, len(m.removedmanagers))
		for id := range m.removedmanagers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmanagers {
		edges = append(edges, role.EdgeManagers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RoleMutation) EdgeCleared(name string) bool {
	switch name {
	case role.EdgeManagers:
		return m.clearedmanagers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RoleMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Role unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RoleMutation) ResetEdge(name string) error {
	switch name {
	case role.EdgeManagers:
		m.ResetManagers()
		return nil
	}
	return fmt.Errorf("unknown Role edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	creator       **model.Modifier
	last_modifier **model.Modifier
	remark        *string
	key           *string
	desc          *string
	content       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id uint64) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SettingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreator sets the "creator" field.
func (m *SettingMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *SettingMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *SettingMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[setting.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *SettingMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[setting.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *SettingMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, setting.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *SettingMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *SettingMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *SettingMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[setting.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *SettingMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[setting.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *SettingMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, setting.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *SettingMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *SettingMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *SettingMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[setting.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *SettingMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[setting.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *SettingMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, setting.FieldRemark)
}

// SetKey sets the "key" field.
func (m *SettingMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SettingMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SettingMutation) ResetKey() {
	m.key = nil
}

// SetDesc sets the "desc" field.
func (m *SettingMutation) SetDesc(s string) {
	m.desc = &s
}

// Desc returns the value of the "desc" field in the mutation.
func (m *SettingMutation) Desc() (r string, exists bool) {
	v := m.desc
	if v == nil {
		return
	}
	return *v, true
}

// OldDesc returns the old "desc" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDesc: %w", err)
	}
	return oldValue.Desc, nil
}

// ResetDesc resets all changes to the "desc" field.
func (m *SettingMutation) ResetDesc() {
	m.desc = nil
}

// SetContent sets the "content" field.
func (m *SettingMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *SettingMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *SettingMutation) ResetContent() {
	m.content = nil
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Setting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, setting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, setting.FieldUpdatedAt)
	}
	if m.creator != nil {
		fields = append(fields, setting.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, setting.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, setting.FieldRemark)
	}
	if m.key != nil {
		fields = append(fields, setting.FieldKey)
	}
	if m.desc != nil {
		fields = append(fields, setting.FieldDesc)
	}
	if m.content != nil {
		fields = append(fields, setting.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldCreatedAt:
		return m.CreatedAt()
	case setting.FieldUpdatedAt:
		return m.UpdatedAt()
	case setting.FieldCreator:
		return m.Creator()
	case setting.FieldLastModifier:
		return m.LastModifier()
	case setting.FieldRemark:
		return m.Remark()
	case setting.FieldKey:
		return m.Key()
	case setting.FieldDesc:
		return m.Desc()
	case setting.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case setting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case setting.FieldCreator:
		return m.OldCreator(ctx)
	case setting.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case setting.FieldRemark:
		return m.OldRemark(ctx)
	case setting.FieldKey:
		return m.OldKey(ctx)
	case setting.FieldDesc:
		return m.OldDesc(ctx)
	case setting.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case setting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case setting.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case setting.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case setting.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case setting.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case setting.FieldDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDesc(v)
		return nil
	case setting.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(setting.FieldCreator) {
		fields = append(fields, setting.FieldCreator)
	}
	if m.FieldCleared(setting.FieldLastModifier) {
		fields = append(fields, setting.FieldLastModifier)
	}
	if m.FieldCleared(setting.FieldRemark) {
		fields = append(fields, setting.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	switch name {
	case setting.FieldCreator:
		m.ClearCreator()
		return nil
	case setting.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case setting.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case setting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case setting.FieldCreator:
		m.ResetCreator()
		return nil
	case setting.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case setting.FieldRemark:
		m.ResetRemark()
		return nil
	case setting.FieldKey:
		m.ResetKey()
		return nil
	case setting.FieldDesc:
		m.ResetDesc()
		return nil
	case setting.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// StockMutation represents an operation that mutates the Stock nodes in the graph.
type StockMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	sn                *string
	_type             *uint8
	add_type          *int8
	name              *string
	model             *string
	num               *int
	addnum            *int
	material          *stock.Material
	clearedFields     map[string]struct{}
	city              *uint64
	clearedcity       bool
	subscribe         *uint64
	clearedsubscribe  bool
	ebike             *uint64
	clearedebike      bool
	brand             *uint64
	clearedbrand      bool
	battery           *uint64
	clearedbattery    bool
	agent             *uint64
	clearedagent      bool
	store             *uint64
	clearedstore      bool
	cabinet           *uint64
	clearedcabinet    bool
	rider             *uint64
	clearedrider      bool
	employee          *uint64
	clearedemployee   bool
	spouse            *uint64
	clearedspouse     bool
	parent            *uint64
	clearedparent     bool
	children          map[uint64]struct{}
	removedchildren   map[uint64]struct{}
	clearedchildren   bool
	enterprise        *uint64
	clearedenterprise bool
	station           *uint64
	clearedstation    bool
	done              bool
	oldValue          func(context.Context) (*Stock, error)
	predicates        []predicate.Stock
}

var _ ent.Mutation = (*StockMutation)(nil)

// stockOption allows management of the mutation configuration using functional options.
type stockOption func(*StockMutation)

// newStockMutation creates new mutation for the Stock entity.
func newStockMutation(c config, op Op, opts ...stockOption) *StockMutation {
	m := &StockMutation{
		config:        c,
		op:            op,
		typ:           TypeStock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStockID sets the ID field of the mutation.
func withStockID(id uint64) stockOption {
	return func(m *StockMutation) {
		var (
			err   error
			once  sync.Once
			value *Stock
		)
		m.oldValue = func(ctx context.Context) (*Stock, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Stock.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStock sets the old Stock of the mutation.
func withStock(node *Stock) stockOption {
	return func(m *StockMutation) {
		m.oldValue = func(context.Context) (*Stock, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StockMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StockMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Stock.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StockMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StockMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StockMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StockMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StockMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StockMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreator sets the "creator" field.
func (m *StockMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *StockMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *StockMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[stock.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *StockMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[stock.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *StockMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, stock.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *StockMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *StockMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *StockMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[stock.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *StockMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[stock.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *StockMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, stock.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *StockMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *StockMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *StockMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[stock.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *StockMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[stock.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *StockMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, stock.FieldRemark)
}

// SetCityID sets the "city_id" field.
func (m *StockMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *StockMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldCityID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ClearCityID clears the value of the "city_id" field.
func (m *StockMutation) ClearCityID() {
	m.city = nil
	m.clearedFields[stock.FieldCityID] = struct{}{}
}

// CityIDCleared returns if the "city_id" field was cleared in this mutation.
func (m *StockMutation) CityIDCleared() bool {
	_, ok := m.clearedFields[stock.FieldCityID]
	return ok
}

// ResetCityID resets all changes to the "city_id" field.
func (m *StockMutation) ResetCityID() {
	m.city = nil
	delete(m.clearedFields, stock.FieldCityID)
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *StockMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *StockMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldSubscribeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ClearSubscribeID clears the value of the "subscribe_id" field.
func (m *StockMutation) ClearSubscribeID() {
	m.subscribe = nil
	m.clearedFields[stock.FieldSubscribeID] = struct{}{}
}

// SubscribeIDCleared returns if the "subscribe_id" field was cleared in this mutation.
func (m *StockMutation) SubscribeIDCleared() bool {
	_, ok := m.clearedFields[stock.FieldSubscribeID]
	return ok
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *StockMutation) ResetSubscribeID() {
	m.subscribe = nil
	delete(m.clearedFields, stock.FieldSubscribeID)
}

// SetEbikeID sets the "ebike_id" field.
func (m *StockMutation) SetEbikeID(u uint64) {
	m.ebike = &u
}

// EbikeID returns the value of the "ebike_id" field in the mutation.
func (m *StockMutation) EbikeID() (r uint64, exists bool) {
	v := m.ebike
	if v == nil {
		return
	}
	return *v, true
}

// OldEbikeID returns the old "ebike_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldEbikeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEbikeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEbikeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEbikeID: %w", err)
	}
	return oldValue.EbikeID, nil
}

// ClearEbikeID clears the value of the "ebike_id" field.
func (m *StockMutation) ClearEbikeID() {
	m.ebike = nil
	m.clearedFields[stock.FieldEbikeID] = struct{}{}
}

// EbikeIDCleared returns if the "ebike_id" field was cleared in this mutation.
func (m *StockMutation) EbikeIDCleared() bool {
	_, ok := m.clearedFields[stock.FieldEbikeID]
	return ok
}

// ResetEbikeID resets all changes to the "ebike_id" field.
func (m *StockMutation) ResetEbikeID() {
	m.ebike = nil
	delete(m.clearedFields, stock.FieldEbikeID)
}

// SetBrandID sets the "brand_id" field.
func (m *StockMutation) SetBrandID(u uint64) {
	m.brand = &u
}

// BrandID returns the value of the "brand_id" field in the mutation.
func (m *StockMutation) BrandID() (r uint64, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrandID returns the old "brand_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldBrandID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrandID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrandID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrandID: %w", err)
	}
	return oldValue.BrandID, nil
}

// ClearBrandID clears the value of the "brand_id" field.
func (m *StockMutation) ClearBrandID() {
	m.brand = nil
	m.clearedFields[stock.FieldBrandID] = struct{}{}
}

// BrandIDCleared returns if the "brand_id" field was cleared in this mutation.
func (m *StockMutation) BrandIDCleared() bool {
	_, ok := m.clearedFields[stock.FieldBrandID]
	return ok
}

// ResetBrandID resets all changes to the "brand_id" field.
func (m *StockMutation) ResetBrandID() {
	m.brand = nil
	delete(m.clearedFields, stock.FieldBrandID)
}

// SetBatteryID sets the "battery_id" field.
func (m *StockMutation) SetBatteryID(u uint64) {
	m.battery = &u
}

// BatteryID returns the value of the "battery_id" field in the mutation.
func (m *StockMutation) BatteryID() (r uint64, exists bool) {
	v := m.battery
	if v == nil {
		return
	}
	return *v, true
}

// OldBatteryID returns the old "battery_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldBatteryID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatteryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatteryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatteryID: %w", err)
	}
	return oldValue.BatteryID, nil
}

// ClearBatteryID clears the value of the "battery_id" field.
func (m *StockMutation) ClearBatteryID() {
	m.battery = nil
	m.clearedFields[stock.FieldBatteryID] = struct{}{}
}

// BatteryIDCleared returns if the "battery_id" field was cleared in this mutation.
func (m *StockMutation) BatteryIDCleared() bool {
	_, ok := m.clearedFields[stock.FieldBatteryID]
	return ok
}

// ResetBatteryID resets all changes to the "battery_id" field.
func (m *StockMutation) ResetBatteryID() {
	m.battery = nil
	delete(m.clearedFields, stock.FieldBatteryID)
}

// SetAgentID sets the "agent_id" field.
func (m *StockMutation) SetAgentID(u uint64) {
	m.agent = &u
}

// AgentID returns the value of the "agent_id" field in the mutation.
func (m *StockMutation) AgentID() (r uint64, exists bool) {
	v := m.agent
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentID returns the old "agent_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldAgentID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentID: %w", err)
	}
	return oldValue.AgentID, nil
}

// ClearAgentID clears the value of the "agent_id" field.
func (m *StockMutation) ClearAgentID() {
	m.agent = nil
	m.clearedFields[stock.FieldAgentID] = struct{}{}
}

// AgentIDCleared returns if the "agent_id" field was cleared in this mutation.
func (m *StockMutation) AgentIDCleared() bool {
	_, ok := m.clearedFields[stock.FieldAgentID]
	return ok
}

// ResetAgentID resets all changes to the "agent_id" field.
func (m *StockMutation) ResetAgentID() {
	m.agent = nil
	delete(m.clearedFields, stock.FieldAgentID)
}

// SetParentID sets the "parent_id" field.
func (m *StockMutation) SetParentID(u uint64) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *StockMutation) ParentID() (r uint64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldParentID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *StockMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[stock.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *StockMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[stock.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *StockMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, stock.FieldParentID)
}

// SetSn sets the "sn" field.
func (m *StockMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *StockMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *StockMutation) ResetSn() {
	m.sn = nil
}

// SetType sets the "type" field.
func (m *StockMutation) SetType(u uint8) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *StockMutation) GetType() (r uint8, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *StockMutation) AddType(u int8) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *StockMutation) AddedType() (r int8, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *StockMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetStoreID sets the "store_id" field.
func (m *StockMutation) SetStoreID(u uint64) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *StockMutation) StoreID() (r uint64, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldStoreID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *StockMutation) ClearStoreID() {
	m.store = nil
	m.clearedFields[stock.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *StockMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[stock.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *StockMutation) ResetStoreID() {
	m.store = nil
	delete(m.clearedFields, stock.FieldStoreID)
}

// SetCabinetID sets the "cabinet_id" field.
func (m *StockMutation) SetCabinetID(u uint64) {
	m.cabinet = &u
}

// CabinetID returns the value of the "cabinet_id" field in the mutation.
func (m *StockMutation) CabinetID() (r uint64, exists bool) {
	v := m.cabinet
	if v == nil {
		return
	}
	return *v, true
}

// OldCabinetID returns the old "cabinet_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldCabinetID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCabinetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCabinetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCabinetID: %w", err)
	}
	return oldValue.CabinetID, nil
}

// ClearCabinetID clears the value of the "cabinet_id" field.
func (m *StockMutation) ClearCabinetID() {
	m.cabinet = nil
	m.clearedFields[stock.FieldCabinetID] = struct{}{}
}

// CabinetIDCleared returns if the "cabinet_id" field was cleared in this mutation.
func (m *StockMutation) CabinetIDCleared() bool {
	_, ok := m.clearedFields[stock.FieldCabinetID]
	return ok
}

// ResetCabinetID resets all changes to the "cabinet_id" field.
func (m *StockMutation) ResetCabinetID() {
	m.cabinet = nil
	delete(m.clearedFields, stock.FieldCabinetID)
}

// SetRiderID sets the "rider_id" field.
func (m *StockMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *StockMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldRiderID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ClearRiderID clears the value of the "rider_id" field.
func (m *StockMutation) ClearRiderID() {
	m.rider = nil
	m.clearedFields[stock.FieldRiderID] = struct{}{}
}

// RiderIDCleared returns if the "rider_id" field was cleared in this mutation.
func (m *StockMutation) RiderIDCleared() bool {
	_, ok := m.clearedFields[stock.FieldRiderID]
	return ok
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *StockMutation) ResetRiderID() {
	m.rider = nil
	delete(m.clearedFields, stock.FieldRiderID)
}

// SetEmployeeID sets the "employee_id" field.
func (m *StockMutation) SetEmployeeID(u uint64) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *StockMutation) EmployeeID() (r uint64, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldEmployeeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *StockMutation) ClearEmployeeID() {
	m.employee = nil
	m.clearedFields[stock.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *StockMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[stock.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *StockMutation) ResetEmployeeID() {
	m.employee = nil
	delete(m.clearedFields, stock.FieldEmployeeID)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *StockMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *StockMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldEnterpriseID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ClearEnterpriseID clears the value of the "enterprise_id" field.
func (m *StockMutation) ClearEnterpriseID() {
	m.enterprise = nil
	m.clearedFields[stock.FieldEnterpriseID] = struct{}{}
}

// EnterpriseIDCleared returns if the "enterprise_id" field was cleared in this mutation.
func (m *StockMutation) EnterpriseIDCleared() bool {
	_, ok := m.clearedFields[stock.FieldEnterpriseID]
	return ok
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *StockMutation) ResetEnterpriseID() {
	m.enterprise = nil
	delete(m.clearedFields, stock.FieldEnterpriseID)
}

// SetStationID sets the "station_id" field.
func (m *StockMutation) SetStationID(u uint64) {
	m.station = &u
}

// StationID returns the value of the "station_id" field in the mutation.
func (m *StockMutation) StationID() (r uint64, exists bool) {
	v := m.station
	if v == nil {
		return
	}
	return *v, true
}

// OldStationID returns the old "station_id" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldStationID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStationID: %w", err)
	}
	return oldValue.StationID, nil
}

// ClearStationID clears the value of the "station_id" field.
func (m *StockMutation) ClearStationID() {
	m.station = nil
	m.clearedFields[stock.FieldStationID] = struct{}{}
}

// StationIDCleared returns if the "station_id" field was cleared in this mutation.
func (m *StockMutation) StationIDCleared() bool {
	_, ok := m.clearedFields[stock.FieldStationID]
	return ok
}

// ResetStationID resets all changes to the "station_id" field.
func (m *StockMutation) ResetStationID() {
	m.station = nil
	delete(m.clearedFields, stock.FieldStationID)
}

// SetName sets the "name" field.
func (m *StockMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StockMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StockMutation) ResetName() {
	m.name = nil
}

// SetModel sets the "model" field.
func (m *StockMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *StockMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldModel(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *StockMutation) ClearModel() {
	m.model = nil
	m.clearedFields[stock.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *StockMutation) ModelCleared() bool {
	_, ok := m.clearedFields[stock.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *StockMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, stock.FieldModel)
}

// SetNum sets the "num" field.
func (m *StockMutation) SetNum(i int) {
	m.num = &i
	m.addnum = nil
}

// Num returns the value of the "num" field in the mutation.
func (m *StockMutation) Num() (r int, exists bool) {
	v := m.num
	if v == nil {
		return
	}
	return *v, true
}

// OldNum returns the old "num" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNum: %w", err)
	}
	return oldValue.Num, nil
}

// AddNum adds i to the "num" field.
func (m *StockMutation) AddNum(i int) {
	if m.addnum != nil {
		*m.addnum += i
	} else {
		m.addnum = &i
	}
}

// AddedNum returns the value that was added to the "num" field in this mutation.
func (m *StockMutation) AddedNum() (r int, exists bool) {
	v := m.addnum
	if v == nil {
		return
	}
	return *v, true
}

// ResetNum resets all changes to the "num" field.
func (m *StockMutation) ResetNum() {
	m.num = nil
	m.addnum = nil
}

// SetMaterial sets the "material" field.
func (m *StockMutation) SetMaterial(s stock.Material) {
	m.material = &s
}

// Material returns the value of the "material" field in the mutation.
func (m *StockMutation) Material() (r stock.Material, exists bool) {
	v := m.material
	if v == nil {
		return
	}
	return *v, true
}

// OldMaterial returns the old "material" field's value of the Stock entity.
// If the Stock object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockMutation) OldMaterial(ctx context.Context) (v stock.Material, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaterial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaterial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaterial: %w", err)
	}
	return oldValue.Material, nil
}

// ResetMaterial resets all changes to the "material" field.
func (m *StockMutation) ResetMaterial() {
	m.material = nil
}

// ClearCity clears the "city" edge to the City entity.
func (m *StockMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[stock.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *StockMutation) CityCleared() bool {
	return m.CityIDCleared() || m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *StockMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *StockMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *StockMutation) ClearSubscribe() {
	m.clearedsubscribe = true
	m.clearedFields[stock.FieldSubscribeID] = struct{}{}
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *StockMutation) SubscribeCleared() bool {
	return m.SubscribeIDCleared() || m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *StockMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *StockMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// ClearEbike clears the "ebike" edge to the Ebike entity.
func (m *StockMutation) ClearEbike() {
	m.clearedebike = true
	m.clearedFields[stock.FieldEbikeID] = struct{}{}
}

// EbikeCleared reports if the "ebike" edge to the Ebike entity was cleared.
func (m *StockMutation) EbikeCleared() bool {
	return m.EbikeIDCleared() || m.clearedebike
}

// EbikeIDs returns the "ebike" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EbikeID instead. It exists only for internal usage by the builders.
func (m *StockMutation) EbikeIDs() (ids []uint64) {
	if id := m.ebike; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEbike resets all changes to the "ebike" edge.
func (m *StockMutation) ResetEbike() {
	m.ebike = nil
	m.clearedebike = false
}

// ClearBrand clears the "brand" edge to the EbikeBrand entity.
func (m *StockMutation) ClearBrand() {
	m.clearedbrand = true
	m.clearedFields[stock.FieldBrandID] = struct{}{}
}

// BrandCleared reports if the "brand" edge to the EbikeBrand entity was cleared.
func (m *StockMutation) BrandCleared() bool {
	return m.BrandIDCleared() || m.clearedbrand
}

// BrandIDs returns the "brand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BrandID instead. It exists only for internal usage by the builders.
func (m *StockMutation) BrandIDs() (ids []uint64) {
	if id := m.brand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBrand resets all changes to the "brand" edge.
func (m *StockMutation) ResetBrand() {
	m.brand = nil
	m.clearedbrand = false
}

// ClearBattery clears the "battery" edge to the Battery entity.
func (m *StockMutation) ClearBattery() {
	m.clearedbattery = true
	m.clearedFields[stock.FieldBatteryID] = struct{}{}
}

// BatteryCleared reports if the "battery" edge to the Battery entity was cleared.
func (m *StockMutation) BatteryCleared() bool {
	return m.BatteryIDCleared() || m.clearedbattery
}

// BatteryIDs returns the "battery" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BatteryID instead. It exists only for internal usage by the builders.
func (m *StockMutation) BatteryIDs() (ids []uint64) {
	if id := m.battery; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBattery resets all changes to the "battery" edge.
func (m *StockMutation) ResetBattery() {
	m.battery = nil
	m.clearedbattery = false
}

// ClearAgent clears the "agent" edge to the Agent entity.
func (m *StockMutation) ClearAgent() {
	m.clearedagent = true
	m.clearedFields[stock.FieldAgentID] = struct{}{}
}

// AgentCleared reports if the "agent" edge to the Agent entity was cleared.
func (m *StockMutation) AgentCleared() bool {
	return m.AgentIDCleared() || m.clearedagent
}

// AgentIDs returns the "agent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentID instead. It exists only for internal usage by the builders.
func (m *StockMutation) AgentIDs() (ids []uint64) {
	if id := m.agent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgent resets all changes to the "agent" edge.
func (m *StockMutation) ResetAgent() {
	m.agent = nil
	m.clearedagent = false
}

// ClearStore clears the "store" edge to the Store entity.
func (m *StockMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[stock.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *StockMutation) StoreCleared() bool {
	return m.StoreIDCleared() || m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *StockMutation) StoreIDs() (ids []uint64) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *StockMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// ClearCabinet clears the "cabinet" edge to the Cabinet entity.
func (m *StockMutation) ClearCabinet() {
	m.clearedcabinet = true
	m.clearedFields[stock.FieldCabinetID] = struct{}{}
}

// CabinetCleared reports if the "cabinet" edge to the Cabinet entity was cleared.
func (m *StockMutation) CabinetCleared() bool {
	return m.CabinetIDCleared() || m.clearedcabinet
}

// CabinetIDs returns the "cabinet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CabinetID instead. It exists only for internal usage by the builders.
func (m *StockMutation) CabinetIDs() (ids []uint64) {
	if id := m.cabinet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCabinet resets all changes to the "cabinet" edge.
func (m *StockMutation) ResetCabinet() {
	m.cabinet = nil
	m.clearedcabinet = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *StockMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[stock.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *StockMutation) RiderCleared() bool {
	return m.RiderIDCleared() || m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *StockMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *StockMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *StockMutation) ClearEmployee() {
	m.clearedemployee = true
	m.clearedFields[stock.FieldEmployeeID] = struct{}{}
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *StockMutation) EmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *StockMutation) EmployeeIDs() (ids []uint64) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *StockMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// SetSpouseID sets the "spouse" edge to the Stock entity by id.
func (m *StockMutation) SetSpouseID(id uint64) {
	m.spouse = &id
}

// ClearSpouse clears the "spouse" edge to the Stock entity.
func (m *StockMutation) ClearSpouse() {
	m.clearedspouse = true
}

// SpouseCleared reports if the "spouse" edge to the Stock entity was cleared.
func (m *StockMutation) SpouseCleared() bool {
	return m.clearedspouse
}

// SpouseID returns the "spouse" edge ID in the mutation.
func (m *StockMutation) SpouseID() (id uint64, exists bool) {
	if m.spouse != nil {
		return *m.spouse, true
	}
	return
}

// SpouseIDs returns the "spouse" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpouseID instead. It exists only for internal usage by the builders.
func (m *StockMutation) SpouseIDs() (ids []uint64) {
	if id := m.spouse; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpouse resets all changes to the "spouse" edge.
func (m *StockMutation) ResetSpouse() {
	m.spouse = nil
	m.clearedspouse = false
}

// ClearParent clears the "parent" edge to the Stock entity.
func (m *StockMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[stock.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Stock entity was cleared.
func (m *StockMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *StockMutation) ParentIDs() (ids []uint64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *StockMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Stock entity by ids.
func (m *StockMutation) AddChildIDs(ids ...uint64) {
	if m.children == nil {
		m.children = make(map[uint64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Stock entity.
func (m *StockMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Stock entity was cleared.
func (m *StockMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Stock entity by IDs.
func (m *StockMutation) RemoveChildIDs(ids ...uint64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Stock entity.
func (m *StockMutation) RemovedChildrenIDs() (ids []uint64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *StockMutation) ChildrenIDs() (ids []uint64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *StockMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *StockMutation) ClearEnterprise() {
	m.clearedenterprise = true
	m.clearedFields[stock.FieldEnterpriseID] = struct{}{}
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *StockMutation) EnterpriseCleared() bool {
	return m.EnterpriseIDCleared() || m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *StockMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *StockMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// ClearStation clears the "station" edge to the EnterpriseStation entity.
func (m *StockMutation) ClearStation() {
	m.clearedstation = true
	m.clearedFields[stock.FieldStationID] = struct{}{}
}

// StationCleared reports if the "station" edge to the EnterpriseStation entity was cleared.
func (m *StockMutation) StationCleared() bool {
	return m.StationIDCleared() || m.clearedstation
}

// StationIDs returns the "station" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StationID instead. It exists only for internal usage by the builders.
func (m *StockMutation) StationIDs() (ids []uint64) {
	if id := m.station; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStation resets all changes to the "station" edge.
func (m *StockMutation) ResetStation() {
	m.station = nil
	m.clearedstation = false
}

// Where appends a list predicates to the StockMutation builder.
func (m *StockMutation) Where(ps ...predicate.Stock) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Stock, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Stock).
func (m *StockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StockMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.created_at != nil {
		fields = append(fields, stock.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, stock.FieldUpdatedAt)
	}
	if m.creator != nil {
		fields = append(fields, stock.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, stock.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, stock.FieldRemark)
	}
	if m.city != nil {
		fields = append(fields, stock.FieldCityID)
	}
	if m.subscribe != nil {
		fields = append(fields, stock.FieldSubscribeID)
	}
	if m.ebike != nil {
		fields = append(fields, stock.FieldEbikeID)
	}
	if m.brand != nil {
		fields = append(fields, stock.FieldBrandID)
	}
	if m.battery != nil {
		fields = append(fields, stock.FieldBatteryID)
	}
	if m.agent != nil {
		fields = append(fields, stock.FieldAgentID)
	}
	if m.parent != nil {
		fields = append(fields, stock.FieldParentID)
	}
	if m.sn != nil {
		fields = append(fields, stock.FieldSn)
	}
	if m._type != nil {
		fields = append(fields, stock.FieldType)
	}
	if m.store != nil {
		fields = append(fields, stock.FieldStoreID)
	}
	if m.cabinet != nil {
		fields = append(fields, stock.FieldCabinetID)
	}
	if m.rider != nil {
		fields = append(fields, stock.FieldRiderID)
	}
	if m.employee != nil {
		fields = append(fields, stock.FieldEmployeeID)
	}
	if m.enterprise != nil {
		fields = append(fields, stock.FieldEnterpriseID)
	}
	if m.station != nil {
		fields = append(fields, stock.FieldStationID)
	}
	if m.name != nil {
		fields = append(fields, stock.FieldName)
	}
	if m.model != nil {
		fields = append(fields, stock.FieldModel)
	}
	if m.num != nil {
		fields = append(fields, stock.FieldNum)
	}
	if m.material != nil {
		fields = append(fields, stock.FieldMaterial)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stock.FieldCreatedAt:
		return m.CreatedAt()
	case stock.FieldUpdatedAt:
		return m.UpdatedAt()
	case stock.FieldCreator:
		return m.Creator()
	case stock.FieldLastModifier:
		return m.LastModifier()
	case stock.FieldRemark:
		return m.Remark()
	case stock.FieldCityID:
		return m.CityID()
	case stock.FieldSubscribeID:
		return m.SubscribeID()
	case stock.FieldEbikeID:
		return m.EbikeID()
	case stock.FieldBrandID:
		return m.BrandID()
	case stock.FieldBatteryID:
		return m.BatteryID()
	case stock.FieldAgentID:
		return m.AgentID()
	case stock.FieldParentID:
		return m.ParentID()
	case stock.FieldSn:
		return m.Sn()
	case stock.FieldType:
		return m.GetType()
	case stock.FieldStoreID:
		return m.StoreID()
	case stock.FieldCabinetID:
		return m.CabinetID()
	case stock.FieldRiderID:
		return m.RiderID()
	case stock.FieldEmployeeID:
		return m.EmployeeID()
	case stock.FieldEnterpriseID:
		return m.EnterpriseID()
	case stock.FieldStationID:
		return m.StationID()
	case stock.FieldName:
		return m.Name()
	case stock.FieldModel:
		return m.Model()
	case stock.FieldNum:
		return m.Num()
	case stock.FieldMaterial:
		return m.Material()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stock.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case stock.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case stock.FieldCreator:
		return m.OldCreator(ctx)
	case stock.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case stock.FieldRemark:
		return m.OldRemark(ctx)
	case stock.FieldCityID:
		return m.OldCityID(ctx)
	case stock.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case stock.FieldEbikeID:
		return m.OldEbikeID(ctx)
	case stock.FieldBrandID:
		return m.OldBrandID(ctx)
	case stock.FieldBatteryID:
		return m.OldBatteryID(ctx)
	case stock.FieldAgentID:
		return m.OldAgentID(ctx)
	case stock.FieldParentID:
		return m.OldParentID(ctx)
	case stock.FieldSn:
		return m.OldSn(ctx)
	case stock.FieldType:
		return m.OldType(ctx)
	case stock.FieldStoreID:
		return m.OldStoreID(ctx)
	case stock.FieldCabinetID:
		return m.OldCabinetID(ctx)
	case stock.FieldRiderID:
		return m.OldRiderID(ctx)
	case stock.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case stock.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case stock.FieldStationID:
		return m.OldStationID(ctx)
	case stock.FieldName:
		return m.OldName(ctx)
	case stock.FieldModel:
		return m.OldModel(ctx)
	case stock.FieldNum:
		return m.OldNum(ctx)
	case stock.FieldMaterial:
		return m.OldMaterial(ctx)
	}
	return nil, fmt.Errorf("unknown Stock field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stock.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case stock.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case stock.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case stock.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case stock.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case stock.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case stock.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case stock.FieldEbikeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEbikeID(v)
		return nil
	case stock.FieldBrandID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrandID(v)
		return nil
	case stock.FieldBatteryID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatteryID(v)
		return nil
	case stock.FieldAgentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentID(v)
		return nil
	case stock.FieldParentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case stock.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case stock.FieldType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case stock.FieldStoreID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case stock.FieldCabinetID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCabinetID(v)
		return nil
	case stock.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case stock.FieldEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case stock.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case stock.FieldStationID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStationID(v)
		return nil
	case stock.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case stock.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case stock.FieldNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNum(v)
		return nil
	case stock.FieldMaterial:
		v, ok := value.(stock.Material)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaterial(v)
		return nil
	}
	return fmt.Errorf("unknown Stock field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StockMutation) AddedFields() []string {
	var fields []string
	if m.add_type != nil {
		fields = append(fields, stock.FieldType)
	}
	if m.addnum != nil {
		fields = append(fields, stock.FieldNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StockMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case stock.FieldType:
		return m.AddedType()
	case stock.FieldNum:
		return m.AddedNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockMutation) AddField(name string, value ent.Value) error {
	switch name {
	case stock.FieldType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case stock.FieldNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNum(v)
		return nil
	}
	return fmt.Errorf("unknown Stock numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StockMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(stock.FieldCreator) {
		fields = append(fields, stock.FieldCreator)
	}
	if m.FieldCleared(stock.FieldLastModifier) {
		fields = append(fields, stock.FieldLastModifier)
	}
	if m.FieldCleared(stock.FieldRemark) {
		fields = append(fields, stock.FieldRemark)
	}
	if m.FieldCleared(stock.FieldCityID) {
		fields = append(fields, stock.FieldCityID)
	}
	if m.FieldCleared(stock.FieldSubscribeID) {
		fields = append(fields, stock.FieldSubscribeID)
	}
	if m.FieldCleared(stock.FieldEbikeID) {
		fields = append(fields, stock.FieldEbikeID)
	}
	if m.FieldCleared(stock.FieldBrandID) {
		fields = append(fields, stock.FieldBrandID)
	}
	if m.FieldCleared(stock.FieldBatteryID) {
		fields = append(fields, stock.FieldBatteryID)
	}
	if m.FieldCleared(stock.FieldAgentID) {
		fields = append(fields, stock.FieldAgentID)
	}
	if m.FieldCleared(stock.FieldParentID) {
		fields = append(fields, stock.FieldParentID)
	}
	if m.FieldCleared(stock.FieldStoreID) {
		fields = append(fields, stock.FieldStoreID)
	}
	if m.FieldCleared(stock.FieldCabinetID) {
		fields = append(fields, stock.FieldCabinetID)
	}
	if m.FieldCleared(stock.FieldRiderID) {
		fields = append(fields, stock.FieldRiderID)
	}
	if m.FieldCleared(stock.FieldEmployeeID) {
		fields = append(fields, stock.FieldEmployeeID)
	}
	if m.FieldCleared(stock.FieldEnterpriseID) {
		fields = append(fields, stock.FieldEnterpriseID)
	}
	if m.FieldCleared(stock.FieldStationID) {
		fields = append(fields, stock.FieldStationID)
	}
	if m.FieldCleared(stock.FieldModel) {
		fields = append(fields, stock.FieldModel)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StockMutation) ClearField(name string) error {
	switch name {
	case stock.FieldCreator:
		m.ClearCreator()
		return nil
	case stock.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case stock.FieldRemark:
		m.ClearRemark()
		return nil
	case stock.FieldCityID:
		m.ClearCityID()
		return nil
	case stock.FieldSubscribeID:
		m.ClearSubscribeID()
		return nil
	case stock.FieldEbikeID:
		m.ClearEbikeID()
		return nil
	case stock.FieldBrandID:
		m.ClearBrandID()
		return nil
	case stock.FieldBatteryID:
		m.ClearBatteryID()
		return nil
	case stock.FieldAgentID:
		m.ClearAgentID()
		return nil
	case stock.FieldParentID:
		m.ClearParentID()
		return nil
	case stock.FieldStoreID:
		m.ClearStoreID()
		return nil
	case stock.FieldCabinetID:
		m.ClearCabinetID()
		return nil
	case stock.FieldRiderID:
		m.ClearRiderID()
		return nil
	case stock.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case stock.FieldEnterpriseID:
		m.ClearEnterpriseID()
		return nil
	case stock.FieldStationID:
		m.ClearStationID()
		return nil
	case stock.FieldModel:
		m.ClearModel()
		return nil
	}
	return fmt.Errorf("unknown Stock nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StockMutation) ResetField(name string) error {
	switch name {
	case stock.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case stock.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case stock.FieldCreator:
		m.ResetCreator()
		return nil
	case stock.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case stock.FieldRemark:
		m.ResetRemark()
		return nil
	case stock.FieldCityID:
		m.ResetCityID()
		return nil
	case stock.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case stock.FieldEbikeID:
		m.ResetEbikeID()
		return nil
	case stock.FieldBrandID:
		m.ResetBrandID()
		return nil
	case stock.FieldBatteryID:
		m.ResetBatteryID()
		return nil
	case stock.FieldAgentID:
		m.ResetAgentID()
		return nil
	case stock.FieldParentID:
		m.ResetParentID()
		return nil
	case stock.FieldSn:
		m.ResetSn()
		return nil
	case stock.FieldType:
		m.ResetType()
		return nil
	case stock.FieldStoreID:
		m.ResetStoreID()
		return nil
	case stock.FieldCabinetID:
		m.ResetCabinetID()
		return nil
	case stock.FieldRiderID:
		m.ResetRiderID()
		return nil
	case stock.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case stock.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case stock.FieldStationID:
		m.ResetStationID()
		return nil
	case stock.FieldName:
		m.ResetName()
		return nil
	case stock.FieldModel:
		m.ResetModel()
		return nil
	case stock.FieldNum:
		m.ResetNum()
		return nil
	case stock.FieldMaterial:
		m.ResetMaterial()
		return nil
	}
	return fmt.Errorf("unknown Stock field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StockMutation) AddedEdges() []string {
	edges := make([]string, 0, 15)
	if m.city != nil {
		edges = append(edges, stock.EdgeCity)
	}
	if m.subscribe != nil {
		edges = append(edges, stock.EdgeSubscribe)
	}
	if m.ebike != nil {
		edges = append(edges, stock.EdgeEbike)
	}
	if m.brand != nil {
		edges = append(edges, stock.EdgeBrand)
	}
	if m.battery != nil {
		edges = append(edges, stock.EdgeBattery)
	}
	if m.agent != nil {
		edges = append(edges, stock.EdgeAgent)
	}
	if m.store != nil {
		edges = append(edges, stock.EdgeStore)
	}
	if m.cabinet != nil {
		edges = append(edges, stock.EdgeCabinet)
	}
	if m.rider != nil {
		edges = append(edges, stock.EdgeRider)
	}
	if m.employee != nil {
		edges = append(edges, stock.EdgeEmployee)
	}
	if m.spouse != nil {
		edges = append(edges, stock.EdgeSpouse)
	}
	if m.parent != nil {
		edges = append(edges, stock.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, stock.EdgeChildren)
	}
	if m.enterprise != nil {
		edges = append(edges, stock.EdgeEnterprise)
	}
	if m.station != nil {
		edges = append(edges, stock.EdgeStation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StockMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stock.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case stock.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	case stock.EdgeEbike:
		if id := m.ebike; id != nil {
			return []ent.Value{*id}
		}
	case stock.EdgeBrand:
		if id := m.brand; id != nil {
			return []ent.Value{*id}
		}
	case stock.EdgeBattery:
		if id := m.battery; id != nil {
			return []ent.Value{*id}
		}
	case stock.EdgeAgent:
		if id := m.agent; id != nil {
			return []ent.Value{*id}
		}
	case stock.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	case stock.EdgeCabinet:
		if id := m.cabinet; id != nil {
			return []ent.Value{*id}
		}
	case stock.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case stock.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case stock.EdgeSpouse:
		if id := m.spouse; id != nil {
			return []ent.Value{*id}
		}
	case stock.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case stock.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case stock.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	case stock.EdgeStation:
		if id := m.station; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 15)
	if m.removedchildren != nil {
		edges = append(edges, stock.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StockMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case stock.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 15)
	if m.clearedcity {
		edges = append(edges, stock.EdgeCity)
	}
	if m.clearedsubscribe {
		edges = append(edges, stock.EdgeSubscribe)
	}
	if m.clearedebike {
		edges = append(edges, stock.EdgeEbike)
	}
	if m.clearedbrand {
		edges = append(edges, stock.EdgeBrand)
	}
	if m.clearedbattery {
		edges = append(edges, stock.EdgeBattery)
	}
	if m.clearedagent {
		edges = append(edges, stock.EdgeAgent)
	}
	if m.clearedstore {
		edges = append(edges, stock.EdgeStore)
	}
	if m.clearedcabinet {
		edges = append(edges, stock.EdgeCabinet)
	}
	if m.clearedrider {
		edges = append(edges, stock.EdgeRider)
	}
	if m.clearedemployee {
		edges = append(edges, stock.EdgeEmployee)
	}
	if m.clearedspouse {
		edges = append(edges, stock.EdgeSpouse)
	}
	if m.clearedparent {
		edges = append(edges, stock.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, stock.EdgeChildren)
	}
	if m.clearedenterprise {
		edges = append(edges, stock.EdgeEnterprise)
	}
	if m.clearedstation {
		edges = append(edges, stock.EdgeStation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StockMutation) EdgeCleared(name string) bool {
	switch name {
	case stock.EdgeCity:
		return m.clearedcity
	case stock.EdgeSubscribe:
		return m.clearedsubscribe
	case stock.EdgeEbike:
		return m.clearedebike
	case stock.EdgeBrand:
		return m.clearedbrand
	case stock.EdgeBattery:
		return m.clearedbattery
	case stock.EdgeAgent:
		return m.clearedagent
	case stock.EdgeStore:
		return m.clearedstore
	case stock.EdgeCabinet:
		return m.clearedcabinet
	case stock.EdgeRider:
		return m.clearedrider
	case stock.EdgeEmployee:
		return m.clearedemployee
	case stock.EdgeSpouse:
		return m.clearedspouse
	case stock.EdgeParent:
		return m.clearedparent
	case stock.EdgeChildren:
		return m.clearedchildren
	case stock.EdgeEnterprise:
		return m.clearedenterprise
	case stock.EdgeStation:
		return m.clearedstation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StockMutation) ClearEdge(name string) error {
	switch name {
	case stock.EdgeCity:
		m.ClearCity()
		return nil
	case stock.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	case stock.EdgeEbike:
		m.ClearEbike()
		return nil
	case stock.EdgeBrand:
		m.ClearBrand()
		return nil
	case stock.EdgeBattery:
		m.ClearBattery()
		return nil
	case stock.EdgeAgent:
		m.ClearAgent()
		return nil
	case stock.EdgeStore:
		m.ClearStore()
		return nil
	case stock.EdgeCabinet:
		m.ClearCabinet()
		return nil
	case stock.EdgeRider:
		m.ClearRider()
		return nil
	case stock.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case stock.EdgeSpouse:
		m.ClearSpouse()
		return nil
	case stock.EdgeParent:
		m.ClearParent()
		return nil
	case stock.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	case stock.EdgeStation:
		m.ClearStation()
		return nil
	}
	return fmt.Errorf("unknown Stock unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StockMutation) ResetEdge(name string) error {
	switch name {
	case stock.EdgeCity:
		m.ResetCity()
		return nil
	case stock.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	case stock.EdgeEbike:
		m.ResetEbike()
		return nil
	case stock.EdgeBrand:
		m.ResetBrand()
		return nil
	case stock.EdgeBattery:
		m.ResetBattery()
		return nil
	case stock.EdgeAgent:
		m.ResetAgent()
		return nil
	case stock.EdgeStore:
		m.ResetStore()
		return nil
	case stock.EdgeCabinet:
		m.ResetCabinet()
		return nil
	case stock.EdgeRider:
		m.ResetRider()
		return nil
	case stock.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case stock.EdgeSpouse:
		m.ResetSpouse()
		return nil
	case stock.EdgeParent:
		m.ResetParent()
		return nil
	case stock.EdgeChildren:
		m.ResetChildren()
		return nil
	case stock.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	case stock.EdgeStation:
		m.ResetStation()
		return nil
	}
	return fmt.Errorf("unknown Stock edge %s", name)
}

// StockSummaryMutation represents an operation that mutates the StockSummary nodes in the graph.
type StockSummaryMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	date              *string
	model             *string
	num               *int
	addnum            *int
	today_num         *int
	addtoday_num      *int
	outbound_num      *int
	addoutbound_num   *int
	inbound_num       *int
	addinbound_num    *int
	in_rider_num      *int
	addin_rider_num   *int
	material          *stocksummary.Material
	clearedFields     map[string]struct{}
	enterprise        *uint64
	clearedenterprise bool
	station           *uint64
	clearedstation    bool
	store             *uint64
	clearedstore      bool
	rider             *uint64
	clearedrider      bool
	cabinet           *uint64
	clearedcabinet    bool
	done              bool
	oldValue          func(context.Context) (*StockSummary, error)
	predicates        []predicate.StockSummary
}

var _ ent.Mutation = (*StockSummaryMutation)(nil)

// stocksummaryOption allows management of the mutation configuration using functional options.
type stocksummaryOption func(*StockSummaryMutation)

// newStockSummaryMutation creates new mutation for the StockSummary entity.
func newStockSummaryMutation(c config, op Op, opts ...stocksummaryOption) *StockSummaryMutation {
	m := &StockSummaryMutation{
		config:        c,
		op:            op,
		typ:           TypeStockSummary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStockSummaryID sets the ID field of the mutation.
func withStockSummaryID(id uint64) stocksummaryOption {
	return func(m *StockSummaryMutation) {
		var (
			err   error
			once  sync.Once
			value *StockSummary
		)
		m.oldValue = func(ctx context.Context) (*StockSummary, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StockSummary.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStockSummary sets the old StockSummary of the mutation.
func withStockSummary(node *StockSummary) stocksummaryOption {
	return func(m *StockSummaryMutation) {
		m.oldValue = func(context.Context) (*StockSummary, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StockSummaryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StockSummaryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StockSummaryMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StockSummaryMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StockSummary.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *StockSummaryMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *StockSummaryMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the StockSummary entity.
// If the StockSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockSummaryMutation) OldEnterpriseID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ClearEnterpriseID clears the value of the "enterprise_id" field.
func (m *StockSummaryMutation) ClearEnterpriseID() {
	m.enterprise = nil
	m.clearedFields[stocksummary.FieldEnterpriseID] = struct{}{}
}

// EnterpriseIDCleared returns if the "enterprise_id" field was cleared in this mutation.
func (m *StockSummaryMutation) EnterpriseIDCleared() bool {
	_, ok := m.clearedFields[stocksummary.FieldEnterpriseID]
	return ok
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *StockSummaryMutation) ResetEnterpriseID() {
	m.enterprise = nil
	delete(m.clearedFields, stocksummary.FieldEnterpriseID)
}

// SetStationID sets the "station_id" field.
func (m *StockSummaryMutation) SetStationID(u uint64) {
	m.station = &u
}

// StationID returns the value of the "station_id" field in the mutation.
func (m *StockSummaryMutation) StationID() (r uint64, exists bool) {
	v := m.station
	if v == nil {
		return
	}
	return *v, true
}

// OldStationID returns the old "station_id" field's value of the StockSummary entity.
// If the StockSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockSummaryMutation) OldStationID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStationID: %w", err)
	}
	return oldValue.StationID, nil
}

// ClearStationID clears the value of the "station_id" field.
func (m *StockSummaryMutation) ClearStationID() {
	m.station = nil
	m.clearedFields[stocksummary.FieldStationID] = struct{}{}
}

// StationIDCleared returns if the "station_id" field was cleared in this mutation.
func (m *StockSummaryMutation) StationIDCleared() bool {
	_, ok := m.clearedFields[stocksummary.FieldStationID]
	return ok
}

// ResetStationID resets all changes to the "station_id" field.
func (m *StockSummaryMutation) ResetStationID() {
	m.station = nil
	delete(m.clearedFields, stocksummary.FieldStationID)
}

// SetStoreID sets the "store_id" field.
func (m *StockSummaryMutation) SetStoreID(u uint64) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *StockSummaryMutation) StoreID() (r uint64, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the StockSummary entity.
// If the StockSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockSummaryMutation) OldStoreID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *StockSummaryMutation) ClearStoreID() {
	m.store = nil
	m.clearedFields[stocksummary.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *StockSummaryMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[stocksummary.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *StockSummaryMutation) ResetStoreID() {
	m.store = nil
	delete(m.clearedFields, stocksummary.FieldStoreID)
}

// SetRiderID sets the "rider_id" field.
func (m *StockSummaryMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *StockSummaryMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the StockSummary entity.
// If the StockSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockSummaryMutation) OldRiderID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ClearRiderID clears the value of the "rider_id" field.
func (m *StockSummaryMutation) ClearRiderID() {
	m.rider = nil
	m.clearedFields[stocksummary.FieldRiderID] = struct{}{}
}

// RiderIDCleared returns if the "rider_id" field was cleared in this mutation.
func (m *StockSummaryMutation) RiderIDCleared() bool {
	_, ok := m.clearedFields[stocksummary.FieldRiderID]
	return ok
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *StockSummaryMutation) ResetRiderID() {
	m.rider = nil
	delete(m.clearedFields, stocksummary.FieldRiderID)
}

// SetCabinetID sets the "cabinet_id" field.
func (m *StockSummaryMutation) SetCabinetID(u uint64) {
	m.cabinet = &u
}

// CabinetID returns the value of the "cabinet_id" field in the mutation.
func (m *StockSummaryMutation) CabinetID() (r uint64, exists bool) {
	v := m.cabinet
	if v == nil {
		return
	}
	return *v, true
}

// OldCabinetID returns the old "cabinet_id" field's value of the StockSummary entity.
// If the StockSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockSummaryMutation) OldCabinetID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCabinetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCabinetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCabinetID: %w", err)
	}
	return oldValue.CabinetID, nil
}

// ClearCabinetID clears the value of the "cabinet_id" field.
func (m *StockSummaryMutation) ClearCabinetID() {
	m.cabinet = nil
	m.clearedFields[stocksummary.FieldCabinetID] = struct{}{}
}

// CabinetIDCleared returns if the "cabinet_id" field was cleared in this mutation.
func (m *StockSummaryMutation) CabinetIDCleared() bool {
	_, ok := m.clearedFields[stocksummary.FieldCabinetID]
	return ok
}

// ResetCabinetID resets all changes to the "cabinet_id" field.
func (m *StockSummaryMutation) ResetCabinetID() {
	m.cabinet = nil
	delete(m.clearedFields, stocksummary.FieldCabinetID)
}

// SetDate sets the "date" field.
func (m *StockSummaryMutation) SetDate(s string) {
	m.date = &s
}

// Date returns the value of the "date" field in the mutation.
func (m *StockSummaryMutation) Date() (r string, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the StockSummary entity.
// If the StockSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockSummaryMutation) OldDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *StockSummaryMutation) ResetDate() {
	m.date = nil
}

// SetModel sets the "model" field.
func (m *StockSummaryMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *StockSummaryMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the StockSummary entity.
// If the StockSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockSummaryMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ClearModel clears the value of the "model" field.
func (m *StockSummaryMutation) ClearModel() {
	m.model = nil
	m.clearedFields[stocksummary.FieldModel] = struct{}{}
}

// ModelCleared returns if the "model" field was cleared in this mutation.
func (m *StockSummaryMutation) ModelCleared() bool {
	_, ok := m.clearedFields[stocksummary.FieldModel]
	return ok
}

// ResetModel resets all changes to the "model" field.
func (m *StockSummaryMutation) ResetModel() {
	m.model = nil
	delete(m.clearedFields, stocksummary.FieldModel)
}

// SetNum sets the "num" field.
func (m *StockSummaryMutation) SetNum(i int) {
	m.num = &i
	m.addnum = nil
}

// Num returns the value of the "num" field in the mutation.
func (m *StockSummaryMutation) Num() (r int, exists bool) {
	v := m.num
	if v == nil {
		return
	}
	return *v, true
}

// OldNum returns the old "num" field's value of the StockSummary entity.
// If the StockSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockSummaryMutation) OldNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNum: %w", err)
	}
	return oldValue.Num, nil
}

// AddNum adds i to the "num" field.
func (m *StockSummaryMutation) AddNum(i int) {
	if m.addnum != nil {
		*m.addnum += i
	} else {
		m.addnum = &i
	}
}

// AddedNum returns the value that was added to the "num" field in this mutation.
func (m *StockSummaryMutation) AddedNum() (r int, exists bool) {
	v := m.addnum
	if v == nil {
		return
	}
	return *v, true
}

// ResetNum resets all changes to the "num" field.
func (m *StockSummaryMutation) ResetNum() {
	m.num = nil
	m.addnum = nil
}

// SetTodayNum sets the "today_num" field.
func (m *StockSummaryMutation) SetTodayNum(i int) {
	m.today_num = &i
	m.addtoday_num = nil
}

// TodayNum returns the value of the "today_num" field in the mutation.
func (m *StockSummaryMutation) TodayNum() (r int, exists bool) {
	v := m.today_num
	if v == nil {
		return
	}
	return *v, true
}

// OldTodayNum returns the old "today_num" field's value of the StockSummary entity.
// If the StockSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockSummaryMutation) OldTodayNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTodayNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTodayNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTodayNum: %w", err)
	}
	return oldValue.TodayNum, nil
}

// AddTodayNum adds i to the "today_num" field.
func (m *StockSummaryMutation) AddTodayNum(i int) {
	if m.addtoday_num != nil {
		*m.addtoday_num += i
	} else {
		m.addtoday_num = &i
	}
}

// AddedTodayNum returns the value that was added to the "today_num" field in this mutation.
func (m *StockSummaryMutation) AddedTodayNum() (r int, exists bool) {
	v := m.addtoday_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetTodayNum resets all changes to the "today_num" field.
func (m *StockSummaryMutation) ResetTodayNum() {
	m.today_num = nil
	m.addtoday_num = nil
}

// SetOutboundNum sets the "outbound_num" field.
func (m *StockSummaryMutation) SetOutboundNum(i int) {
	m.outbound_num = &i
	m.addoutbound_num = nil
}

// OutboundNum returns the value of the "outbound_num" field in the mutation.
func (m *StockSummaryMutation) OutboundNum() (r int, exists bool) {
	v := m.outbound_num
	if v == nil {
		return
	}
	return *v, true
}

// OldOutboundNum returns the old "outbound_num" field's value of the StockSummary entity.
// If the StockSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockSummaryMutation) OldOutboundNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutboundNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutboundNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutboundNum: %w", err)
	}
	return oldValue.OutboundNum, nil
}

// AddOutboundNum adds i to the "outbound_num" field.
func (m *StockSummaryMutation) AddOutboundNum(i int) {
	if m.addoutbound_num != nil {
		*m.addoutbound_num += i
	} else {
		m.addoutbound_num = &i
	}
}

// AddedOutboundNum returns the value that was added to the "outbound_num" field in this mutation.
func (m *StockSummaryMutation) AddedOutboundNum() (r int, exists bool) {
	v := m.addoutbound_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutboundNum resets all changes to the "outbound_num" field.
func (m *StockSummaryMutation) ResetOutboundNum() {
	m.outbound_num = nil
	m.addoutbound_num = nil
}

// SetInboundNum sets the "inbound_num" field.
func (m *StockSummaryMutation) SetInboundNum(i int) {
	m.inbound_num = &i
	m.addinbound_num = nil
}

// InboundNum returns the value of the "inbound_num" field in the mutation.
func (m *StockSummaryMutation) InboundNum() (r int, exists bool) {
	v := m.inbound_num
	if v == nil {
		return
	}
	return *v, true
}

// OldInboundNum returns the old "inbound_num" field's value of the StockSummary entity.
// If the StockSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockSummaryMutation) OldInboundNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInboundNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInboundNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInboundNum: %w", err)
	}
	return oldValue.InboundNum, nil
}

// AddInboundNum adds i to the "inbound_num" field.
func (m *StockSummaryMutation) AddInboundNum(i int) {
	if m.addinbound_num != nil {
		*m.addinbound_num += i
	} else {
		m.addinbound_num = &i
	}
}

// AddedInboundNum returns the value that was added to the "inbound_num" field in this mutation.
func (m *StockSummaryMutation) AddedInboundNum() (r int, exists bool) {
	v := m.addinbound_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetInboundNum resets all changes to the "inbound_num" field.
func (m *StockSummaryMutation) ResetInboundNum() {
	m.inbound_num = nil
	m.addinbound_num = nil
}

// SetInRiderNum sets the "in_rider_num" field.
func (m *StockSummaryMutation) SetInRiderNum(i int) {
	m.in_rider_num = &i
	m.addin_rider_num = nil
}

// InRiderNum returns the value of the "in_rider_num" field in the mutation.
func (m *StockSummaryMutation) InRiderNum() (r int, exists bool) {
	v := m.in_rider_num
	if v == nil {
		return
	}
	return *v, true
}

// OldInRiderNum returns the old "in_rider_num" field's value of the StockSummary entity.
// If the StockSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockSummaryMutation) OldInRiderNum(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInRiderNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInRiderNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInRiderNum: %w", err)
	}
	return oldValue.InRiderNum, nil
}

// AddInRiderNum adds i to the "in_rider_num" field.
func (m *StockSummaryMutation) AddInRiderNum(i int) {
	if m.addin_rider_num != nil {
		*m.addin_rider_num += i
	} else {
		m.addin_rider_num = &i
	}
}

// AddedInRiderNum returns the value that was added to the "in_rider_num" field in this mutation.
func (m *StockSummaryMutation) AddedInRiderNum() (r int, exists bool) {
	v := m.addin_rider_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetInRiderNum resets all changes to the "in_rider_num" field.
func (m *StockSummaryMutation) ResetInRiderNum() {
	m.in_rider_num = nil
	m.addin_rider_num = nil
}

// SetMaterial sets the "material" field.
func (m *StockSummaryMutation) SetMaterial(s stocksummary.Material) {
	m.material = &s
}

// Material returns the value of the "material" field in the mutation.
func (m *StockSummaryMutation) Material() (r stocksummary.Material, exists bool) {
	v := m.material
	if v == nil {
		return
	}
	return *v, true
}

// OldMaterial returns the old "material" field's value of the StockSummary entity.
// If the StockSummary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StockSummaryMutation) OldMaterial(ctx context.Context) (v stocksummary.Material, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaterial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaterial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaterial: %w", err)
	}
	return oldValue.Material, nil
}

// ClearMaterial clears the value of the "material" field.
func (m *StockSummaryMutation) ClearMaterial() {
	m.material = nil
	m.clearedFields[stocksummary.FieldMaterial] = struct{}{}
}

// MaterialCleared returns if the "material" field was cleared in this mutation.
func (m *StockSummaryMutation) MaterialCleared() bool {
	_, ok := m.clearedFields[stocksummary.FieldMaterial]
	return ok
}

// ResetMaterial resets all changes to the "material" field.
func (m *StockSummaryMutation) ResetMaterial() {
	m.material = nil
	delete(m.clearedFields, stocksummary.FieldMaterial)
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *StockSummaryMutation) ClearEnterprise() {
	m.clearedenterprise = true
	m.clearedFields[stocksummary.FieldEnterpriseID] = struct{}{}
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *StockSummaryMutation) EnterpriseCleared() bool {
	return m.EnterpriseIDCleared() || m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *StockSummaryMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *StockSummaryMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// ClearStation clears the "station" edge to the EnterpriseStation entity.
func (m *StockSummaryMutation) ClearStation() {
	m.clearedstation = true
	m.clearedFields[stocksummary.FieldStationID] = struct{}{}
}

// StationCleared reports if the "station" edge to the EnterpriseStation entity was cleared.
func (m *StockSummaryMutation) StationCleared() bool {
	return m.StationIDCleared() || m.clearedstation
}

// StationIDs returns the "station" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StationID instead. It exists only for internal usage by the builders.
func (m *StockSummaryMutation) StationIDs() (ids []uint64) {
	if id := m.station; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStation resets all changes to the "station" edge.
func (m *StockSummaryMutation) ResetStation() {
	m.station = nil
	m.clearedstation = false
}

// ClearStore clears the "store" edge to the Store entity.
func (m *StockSummaryMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[stocksummary.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *StockSummaryMutation) StoreCleared() bool {
	return m.StoreIDCleared() || m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *StockSummaryMutation) StoreIDs() (ids []uint64) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *StockSummaryMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *StockSummaryMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[stocksummary.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *StockSummaryMutation) RiderCleared() bool {
	return m.RiderIDCleared() || m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *StockSummaryMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *StockSummaryMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearCabinet clears the "cabinet" edge to the Cabinet entity.
func (m *StockSummaryMutation) ClearCabinet() {
	m.clearedcabinet = true
	m.clearedFields[stocksummary.FieldCabinetID] = struct{}{}
}

// CabinetCleared reports if the "cabinet" edge to the Cabinet entity was cleared.
func (m *StockSummaryMutation) CabinetCleared() bool {
	return m.CabinetIDCleared() || m.clearedcabinet
}

// CabinetIDs returns the "cabinet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CabinetID instead. It exists only for internal usage by the builders.
func (m *StockSummaryMutation) CabinetIDs() (ids []uint64) {
	if id := m.cabinet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCabinet resets all changes to the "cabinet" edge.
func (m *StockSummaryMutation) ResetCabinet() {
	m.cabinet = nil
	m.clearedcabinet = false
}

// Where appends a list predicates to the StockSummaryMutation builder.
func (m *StockSummaryMutation) Where(ps ...predicate.StockSummary) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StockSummaryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StockSummaryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StockSummary, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StockSummaryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StockSummaryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StockSummary).
func (m *StockSummaryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StockSummaryMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.enterprise != nil {
		fields = append(fields, stocksummary.FieldEnterpriseID)
	}
	if m.station != nil {
		fields = append(fields, stocksummary.FieldStationID)
	}
	if m.store != nil {
		fields = append(fields, stocksummary.FieldStoreID)
	}
	if m.rider != nil {
		fields = append(fields, stocksummary.FieldRiderID)
	}
	if m.cabinet != nil {
		fields = append(fields, stocksummary.FieldCabinetID)
	}
	if m.date != nil {
		fields = append(fields, stocksummary.FieldDate)
	}
	if m.model != nil {
		fields = append(fields, stocksummary.FieldModel)
	}
	if m.num != nil {
		fields = append(fields, stocksummary.FieldNum)
	}
	if m.today_num != nil {
		fields = append(fields, stocksummary.FieldTodayNum)
	}
	if m.outbound_num != nil {
		fields = append(fields, stocksummary.FieldOutboundNum)
	}
	if m.inbound_num != nil {
		fields = append(fields, stocksummary.FieldInboundNum)
	}
	if m.in_rider_num != nil {
		fields = append(fields, stocksummary.FieldInRiderNum)
	}
	if m.material != nil {
		fields = append(fields, stocksummary.FieldMaterial)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StockSummaryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stocksummary.FieldEnterpriseID:
		return m.EnterpriseID()
	case stocksummary.FieldStationID:
		return m.StationID()
	case stocksummary.FieldStoreID:
		return m.StoreID()
	case stocksummary.FieldRiderID:
		return m.RiderID()
	case stocksummary.FieldCabinetID:
		return m.CabinetID()
	case stocksummary.FieldDate:
		return m.Date()
	case stocksummary.FieldModel:
		return m.Model()
	case stocksummary.FieldNum:
		return m.Num()
	case stocksummary.FieldTodayNum:
		return m.TodayNum()
	case stocksummary.FieldOutboundNum:
		return m.OutboundNum()
	case stocksummary.FieldInboundNum:
		return m.InboundNum()
	case stocksummary.FieldInRiderNum:
		return m.InRiderNum()
	case stocksummary.FieldMaterial:
		return m.Material()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StockSummaryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stocksummary.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case stocksummary.FieldStationID:
		return m.OldStationID(ctx)
	case stocksummary.FieldStoreID:
		return m.OldStoreID(ctx)
	case stocksummary.FieldRiderID:
		return m.OldRiderID(ctx)
	case stocksummary.FieldCabinetID:
		return m.OldCabinetID(ctx)
	case stocksummary.FieldDate:
		return m.OldDate(ctx)
	case stocksummary.FieldModel:
		return m.OldModel(ctx)
	case stocksummary.FieldNum:
		return m.OldNum(ctx)
	case stocksummary.FieldTodayNum:
		return m.OldTodayNum(ctx)
	case stocksummary.FieldOutboundNum:
		return m.OldOutboundNum(ctx)
	case stocksummary.FieldInboundNum:
		return m.OldInboundNum(ctx)
	case stocksummary.FieldInRiderNum:
		return m.OldInRiderNum(ctx)
	case stocksummary.FieldMaterial:
		return m.OldMaterial(ctx)
	}
	return nil, fmt.Errorf("unknown StockSummary field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockSummaryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stocksummary.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case stocksummary.FieldStationID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStationID(v)
		return nil
	case stocksummary.FieldStoreID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case stocksummary.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case stocksummary.FieldCabinetID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCabinetID(v)
		return nil
	case stocksummary.FieldDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case stocksummary.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case stocksummary.FieldNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNum(v)
		return nil
	case stocksummary.FieldTodayNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTodayNum(v)
		return nil
	case stocksummary.FieldOutboundNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutboundNum(v)
		return nil
	case stocksummary.FieldInboundNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInboundNum(v)
		return nil
	case stocksummary.FieldInRiderNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInRiderNum(v)
		return nil
	case stocksummary.FieldMaterial:
		v, ok := value.(stocksummary.Material)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaterial(v)
		return nil
	}
	return fmt.Errorf("unknown StockSummary field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StockSummaryMutation) AddedFields() []string {
	var fields []string
	if m.addnum != nil {
		fields = append(fields, stocksummary.FieldNum)
	}
	if m.addtoday_num != nil {
		fields = append(fields, stocksummary.FieldTodayNum)
	}
	if m.addoutbound_num != nil {
		fields = append(fields, stocksummary.FieldOutboundNum)
	}
	if m.addinbound_num != nil {
		fields = append(fields, stocksummary.FieldInboundNum)
	}
	if m.addin_rider_num != nil {
		fields = append(fields, stocksummary.FieldInRiderNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StockSummaryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case stocksummary.FieldNum:
		return m.AddedNum()
	case stocksummary.FieldTodayNum:
		return m.AddedTodayNum()
	case stocksummary.FieldOutboundNum:
		return m.AddedOutboundNum()
	case stocksummary.FieldInboundNum:
		return m.AddedInboundNum()
	case stocksummary.FieldInRiderNum:
		return m.AddedInRiderNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StockSummaryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case stocksummary.FieldNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNum(v)
		return nil
	case stocksummary.FieldTodayNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTodayNum(v)
		return nil
	case stocksummary.FieldOutboundNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutboundNum(v)
		return nil
	case stocksummary.FieldInboundNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInboundNum(v)
		return nil
	case stocksummary.FieldInRiderNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInRiderNum(v)
		return nil
	}
	return fmt.Errorf("unknown StockSummary numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StockSummaryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(stocksummary.FieldEnterpriseID) {
		fields = append(fields, stocksummary.FieldEnterpriseID)
	}
	if m.FieldCleared(stocksummary.FieldStationID) {
		fields = append(fields, stocksummary.FieldStationID)
	}
	if m.FieldCleared(stocksummary.FieldStoreID) {
		fields = append(fields, stocksummary.FieldStoreID)
	}
	if m.FieldCleared(stocksummary.FieldRiderID) {
		fields = append(fields, stocksummary.FieldRiderID)
	}
	if m.FieldCleared(stocksummary.FieldCabinetID) {
		fields = append(fields, stocksummary.FieldCabinetID)
	}
	if m.FieldCleared(stocksummary.FieldModel) {
		fields = append(fields, stocksummary.FieldModel)
	}
	if m.FieldCleared(stocksummary.FieldMaterial) {
		fields = append(fields, stocksummary.FieldMaterial)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StockSummaryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StockSummaryMutation) ClearField(name string) error {
	switch name {
	case stocksummary.FieldEnterpriseID:
		m.ClearEnterpriseID()
		return nil
	case stocksummary.FieldStationID:
		m.ClearStationID()
		return nil
	case stocksummary.FieldStoreID:
		m.ClearStoreID()
		return nil
	case stocksummary.FieldRiderID:
		m.ClearRiderID()
		return nil
	case stocksummary.FieldCabinetID:
		m.ClearCabinetID()
		return nil
	case stocksummary.FieldModel:
		m.ClearModel()
		return nil
	case stocksummary.FieldMaterial:
		m.ClearMaterial()
		return nil
	}
	return fmt.Errorf("unknown StockSummary nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StockSummaryMutation) ResetField(name string) error {
	switch name {
	case stocksummary.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case stocksummary.FieldStationID:
		m.ResetStationID()
		return nil
	case stocksummary.FieldStoreID:
		m.ResetStoreID()
		return nil
	case stocksummary.FieldRiderID:
		m.ResetRiderID()
		return nil
	case stocksummary.FieldCabinetID:
		m.ResetCabinetID()
		return nil
	case stocksummary.FieldDate:
		m.ResetDate()
		return nil
	case stocksummary.FieldModel:
		m.ResetModel()
		return nil
	case stocksummary.FieldNum:
		m.ResetNum()
		return nil
	case stocksummary.FieldTodayNum:
		m.ResetTodayNum()
		return nil
	case stocksummary.FieldOutboundNum:
		m.ResetOutboundNum()
		return nil
	case stocksummary.FieldInboundNum:
		m.ResetInboundNum()
		return nil
	case stocksummary.FieldInRiderNum:
		m.ResetInRiderNum()
		return nil
	case stocksummary.FieldMaterial:
		m.ResetMaterial()
		return nil
	}
	return fmt.Errorf("unknown StockSummary field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StockSummaryMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.enterprise != nil {
		edges = append(edges, stocksummary.EdgeEnterprise)
	}
	if m.station != nil {
		edges = append(edges, stocksummary.EdgeStation)
	}
	if m.store != nil {
		edges = append(edges, stocksummary.EdgeStore)
	}
	if m.rider != nil {
		edges = append(edges, stocksummary.EdgeRider)
	}
	if m.cabinet != nil {
		edges = append(edges, stocksummary.EdgeCabinet)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StockSummaryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case stocksummary.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	case stocksummary.EdgeStation:
		if id := m.station; id != nil {
			return []ent.Value{*id}
		}
	case stocksummary.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	case stocksummary.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case stocksummary.EdgeCabinet:
		if id := m.cabinet; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StockSummaryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StockSummaryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StockSummaryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedenterprise {
		edges = append(edges, stocksummary.EdgeEnterprise)
	}
	if m.clearedstation {
		edges = append(edges, stocksummary.EdgeStation)
	}
	if m.clearedstore {
		edges = append(edges, stocksummary.EdgeStore)
	}
	if m.clearedrider {
		edges = append(edges, stocksummary.EdgeRider)
	}
	if m.clearedcabinet {
		edges = append(edges, stocksummary.EdgeCabinet)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StockSummaryMutation) EdgeCleared(name string) bool {
	switch name {
	case stocksummary.EdgeEnterprise:
		return m.clearedenterprise
	case stocksummary.EdgeStation:
		return m.clearedstation
	case stocksummary.EdgeStore:
		return m.clearedstore
	case stocksummary.EdgeRider:
		return m.clearedrider
	case stocksummary.EdgeCabinet:
		return m.clearedcabinet
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StockSummaryMutation) ClearEdge(name string) error {
	switch name {
	case stocksummary.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	case stocksummary.EdgeStation:
		m.ClearStation()
		return nil
	case stocksummary.EdgeStore:
		m.ClearStore()
		return nil
	case stocksummary.EdgeRider:
		m.ClearRider()
		return nil
	case stocksummary.EdgeCabinet:
		m.ClearCabinet()
		return nil
	}
	return fmt.Errorf("unknown StockSummary unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StockSummaryMutation) ResetEdge(name string) error {
	switch name {
	case stocksummary.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	case stocksummary.EdgeStation:
		m.ResetStation()
		return nil
	case stocksummary.EdgeStore:
		m.ResetStore()
		return nil
	case stocksummary.EdgeRider:
		m.ResetRider()
		return nil
	case stocksummary.EdgeCabinet:
		m.ResetCabinet()
		return nil
	}
	return fmt.Errorf("unknown StockSummary edge %s", name)
}

// StoreMutation represents an operation that mutates the Store nodes in the graph.
type StoreMutation struct {
	config
	op                 Op
	typ                string
	id                 *uint64
	created_at         *time.Time
	updated_at         *time.Time
	deleted_at         *time.Time
	creator            **model.Modifier
	last_modifier      **model.Modifier
	remark             *string
	sn                 *string
	name               *string
	status             *uint8
	addstatus          *int8
	lng                *float64
	addlng             *float64
	lat                *float64
	addlat             *float64
	address            *string
	ebike_obtain       *bool
	ebike_repair       *bool
	clearedFields      map[string]struct{}
	city               *uint64
	clearedcity        bool
	branch             *uint64
	clearedbranch      bool
	employee           *uint64
	clearedemployee    bool
	stocks             map[uint64]struct{}
	removedstocks      map[uint64]struct{}
	clearedstocks      bool
	attendances        map[uint64]struct{}
	removedattendances map[uint64]struct{}
	clearedattendances bool
	exceptions         map[uint64]struct{}
	removedexceptions  map[uint64]struct{}
	clearedexceptions  bool
	done               bool
	oldValue           func(context.Context) (*Store, error)
	predicates         []predicate.Store
}

var _ ent.Mutation = (*StoreMutation)(nil)

// storeOption allows management of the mutation configuration using functional options.
type storeOption func(*StoreMutation)

// newStoreMutation creates new mutation for the Store entity.
func newStoreMutation(c config, op Op, opts ...storeOption) *StoreMutation {
	m := &StoreMutation{
		config:        c,
		op:            op,
		typ:           TypeStore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStoreID sets the ID field of the mutation.
func withStoreID(id uint64) storeOption {
	return func(m *StoreMutation) {
		var (
			err   error
			once  sync.Once
			value *Store
		)
		m.oldValue = func(ctx context.Context) (*Store, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Store.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStore sets the old Store of the mutation.
func withStore(node *Store) storeOption {
	return func(m *StoreMutation) {
		m.oldValue = func(context.Context) (*Store, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StoreMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StoreMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Store.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StoreMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StoreMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StoreMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StoreMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StoreMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StoreMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *StoreMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *StoreMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *StoreMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[store.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *StoreMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[store.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *StoreMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, store.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *StoreMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *StoreMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *StoreMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[store.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *StoreMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[store.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *StoreMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, store.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *StoreMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *StoreMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *StoreMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[store.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *StoreMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[store.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *StoreMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, store.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *StoreMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *StoreMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *StoreMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[store.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *StoreMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[store.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *StoreMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, store.FieldRemark)
}

// SetCityID sets the "city_id" field.
func (m *StoreMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *StoreMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *StoreMutation) ResetCityID() {
	m.city = nil
}

// SetEmployeeID sets the "employee_id" field.
func (m *StoreMutation) SetEmployeeID(u uint64) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *StoreMutation) EmployeeID() (r uint64, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldEmployeeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *StoreMutation) ClearEmployeeID() {
	m.employee = nil
	m.clearedFields[store.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *StoreMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[store.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *StoreMutation) ResetEmployeeID() {
	m.employee = nil
	delete(m.clearedFields, store.FieldEmployeeID)
}

// SetBranchID sets the "branch_id" field.
func (m *StoreMutation) SetBranchID(u uint64) {
	m.branch = &u
}

// BranchID returns the value of the "branch_id" field in the mutation.
func (m *StoreMutation) BranchID() (r uint64, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranchID returns the old "branch_id" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldBranchID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBranchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBranchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranchID: %w", err)
	}
	return oldValue.BranchID, nil
}

// ResetBranchID resets all changes to the "branch_id" field.
func (m *StoreMutation) ResetBranchID() {
	m.branch = nil
}

// SetSn sets the "sn" field.
func (m *StoreMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *StoreMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *StoreMutation) ResetSn() {
	m.sn = nil
}

// SetName sets the "name" field.
func (m *StoreMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StoreMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StoreMutation) ResetName() {
	m.name = nil
}

// SetStatus sets the "status" field.
func (m *StoreMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *StoreMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *StoreMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *StoreMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *StoreMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetLng sets the "lng" field.
func (m *StoreMutation) SetLng(f float64) {
	m.lng = &f
	m.addlng = nil
}

// Lng returns the value of the "lng" field in the mutation.
func (m *StoreMutation) Lng() (r float64, exists bool) {
	v := m.lng
	if v == nil {
		return
	}
	return *v, true
}

// OldLng returns the old "lng" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldLng(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLng is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLng requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLng: %w", err)
	}
	return oldValue.Lng, nil
}

// AddLng adds f to the "lng" field.
func (m *StoreMutation) AddLng(f float64) {
	if m.addlng != nil {
		*m.addlng += f
	} else {
		m.addlng = &f
	}
}

// AddedLng returns the value that was added to the "lng" field in this mutation.
func (m *StoreMutation) AddedLng() (r float64, exists bool) {
	v := m.addlng
	if v == nil {
		return
	}
	return *v, true
}

// ResetLng resets all changes to the "lng" field.
func (m *StoreMutation) ResetLng() {
	m.lng = nil
	m.addlng = nil
}

// SetLat sets the "lat" field.
func (m *StoreMutation) SetLat(f float64) {
	m.lat = &f
	m.addlat = nil
}

// Lat returns the value of the "lat" field in the mutation.
func (m *StoreMutation) Lat() (r float64, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "lat" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// AddLat adds f to the "lat" field.
func (m *StoreMutation) AddLat(f float64) {
	if m.addlat != nil {
		*m.addlat += f
	} else {
		m.addlat = &f
	}
}

// AddedLat returns the value that was added to the "lat" field in this mutation.
func (m *StoreMutation) AddedLat() (r float64, exists bool) {
	v := m.addlat
	if v == nil {
		return
	}
	return *v, true
}

// ResetLat resets all changes to the "lat" field.
func (m *StoreMutation) ResetLat() {
	m.lat = nil
	m.addlat = nil
}

// SetAddress sets the "address" field.
func (m *StoreMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *StoreMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *StoreMutation) ResetAddress() {
	m.address = nil
}

// SetEbikeObtain sets the "ebike_obtain" field.
func (m *StoreMutation) SetEbikeObtain(b bool) {
	m.ebike_obtain = &b
}

// EbikeObtain returns the value of the "ebike_obtain" field in the mutation.
func (m *StoreMutation) EbikeObtain() (r bool, exists bool) {
	v := m.ebike_obtain
	if v == nil {
		return
	}
	return *v, true
}

// OldEbikeObtain returns the old "ebike_obtain" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldEbikeObtain(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEbikeObtain is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEbikeObtain requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEbikeObtain: %w", err)
	}
	return oldValue.EbikeObtain, nil
}

// ResetEbikeObtain resets all changes to the "ebike_obtain" field.
func (m *StoreMutation) ResetEbikeObtain() {
	m.ebike_obtain = nil
}

// SetEbikeRepair sets the "ebike_repair" field.
func (m *StoreMutation) SetEbikeRepair(b bool) {
	m.ebike_repair = &b
}

// EbikeRepair returns the value of the "ebike_repair" field in the mutation.
func (m *StoreMutation) EbikeRepair() (r bool, exists bool) {
	v := m.ebike_repair
	if v == nil {
		return
	}
	return *v, true
}

// OldEbikeRepair returns the old "ebike_repair" field's value of the Store entity.
// If the Store object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoreMutation) OldEbikeRepair(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEbikeRepair is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEbikeRepair requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEbikeRepair: %w", err)
	}
	return oldValue.EbikeRepair, nil
}

// ResetEbikeRepair resets all changes to the "ebike_repair" field.
func (m *StoreMutation) ResetEbikeRepair() {
	m.ebike_repair = nil
}

// ClearCity clears the "city" edge to the City entity.
func (m *StoreMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[store.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *StoreMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *StoreMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *StoreMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearBranch clears the "branch" edge to the Branch entity.
func (m *StoreMutation) ClearBranch() {
	m.clearedbranch = true
	m.clearedFields[store.FieldBranchID] = struct{}{}
}

// BranchCleared reports if the "branch" edge to the Branch entity was cleared.
func (m *StoreMutation) BranchCleared() bool {
	return m.clearedbranch
}

// BranchIDs returns the "branch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BranchID instead. It exists only for internal usage by the builders.
func (m *StoreMutation) BranchIDs() (ids []uint64) {
	if id := m.branch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBranch resets all changes to the "branch" edge.
func (m *StoreMutation) ResetBranch() {
	m.branch = nil
	m.clearedbranch = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *StoreMutation) ClearEmployee() {
	m.clearedemployee = true
	m.clearedFields[store.FieldEmployeeID] = struct{}{}
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *StoreMutation) EmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *StoreMutation) EmployeeIDs() (ids []uint64) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *StoreMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// AddStockIDs adds the "stocks" edge to the Stock entity by ids.
func (m *StoreMutation) AddStockIDs(ids ...uint64) {
	if m.stocks == nil {
		m.stocks = make(map[uint64]struct{})
	}
	for i := range ids {
		m.stocks[ids[i]] = struct{}{}
	}
}

// ClearStocks clears the "stocks" edge to the Stock entity.
func (m *StoreMutation) ClearStocks() {
	m.clearedstocks = true
}

// StocksCleared reports if the "stocks" edge to the Stock entity was cleared.
func (m *StoreMutation) StocksCleared() bool {
	return m.clearedstocks
}

// RemoveStockIDs removes the "stocks" edge to the Stock entity by IDs.
func (m *StoreMutation) RemoveStockIDs(ids ...uint64) {
	if m.removedstocks == nil {
		m.removedstocks = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.stocks, ids[i])
		m.removedstocks[ids[i]] = struct{}{}
	}
}

// RemovedStocks returns the removed IDs of the "stocks" edge to the Stock entity.
func (m *StoreMutation) RemovedStocksIDs() (ids []uint64) {
	for id := range m.removedstocks {
		ids = append(ids, id)
	}
	return
}

// StocksIDs returns the "stocks" edge IDs in the mutation.
func (m *StoreMutation) StocksIDs() (ids []uint64) {
	for id := range m.stocks {
		ids = append(ids, id)
	}
	return
}

// ResetStocks resets all changes to the "stocks" edge.
func (m *StoreMutation) ResetStocks() {
	m.stocks = nil
	m.clearedstocks = false
	m.removedstocks = nil
}

// AddAttendanceIDs adds the "attendances" edge to the Attendance entity by ids.
func (m *StoreMutation) AddAttendanceIDs(ids ...uint64) {
	if m.attendances == nil {
		m.attendances = make(map[uint64]struct{})
	}
	for i := range ids {
		m.attendances[ids[i]] = struct{}{}
	}
}

// ClearAttendances clears the "attendances" edge to the Attendance entity.
func (m *StoreMutation) ClearAttendances() {
	m.clearedattendances = true
}

// AttendancesCleared reports if the "attendances" edge to the Attendance entity was cleared.
func (m *StoreMutation) AttendancesCleared() bool {
	return m.clearedattendances
}

// RemoveAttendanceIDs removes the "attendances" edge to the Attendance entity by IDs.
func (m *StoreMutation) RemoveAttendanceIDs(ids ...uint64) {
	if m.removedattendances == nil {
		m.removedattendances = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.attendances, ids[i])
		m.removedattendances[ids[i]] = struct{}{}
	}
}

// RemovedAttendances returns the removed IDs of the "attendances" edge to the Attendance entity.
func (m *StoreMutation) RemovedAttendancesIDs() (ids []uint64) {
	for id := range m.removedattendances {
		ids = append(ids, id)
	}
	return
}

// AttendancesIDs returns the "attendances" edge IDs in the mutation.
func (m *StoreMutation) AttendancesIDs() (ids []uint64) {
	for id := range m.attendances {
		ids = append(ids, id)
	}
	return
}

// ResetAttendances resets all changes to the "attendances" edge.
func (m *StoreMutation) ResetAttendances() {
	m.attendances = nil
	m.clearedattendances = false
	m.removedattendances = nil
}

// AddExceptionIDs adds the "exceptions" edge to the Exception entity by ids.
func (m *StoreMutation) AddExceptionIDs(ids ...uint64) {
	if m.exceptions == nil {
		m.exceptions = make(map[uint64]struct{})
	}
	for i := range ids {
		m.exceptions[ids[i]] = struct{}{}
	}
}

// ClearExceptions clears the "exceptions" edge to the Exception entity.
func (m *StoreMutation) ClearExceptions() {
	m.clearedexceptions = true
}

// ExceptionsCleared reports if the "exceptions" edge to the Exception entity was cleared.
func (m *StoreMutation) ExceptionsCleared() bool {
	return m.clearedexceptions
}

// RemoveExceptionIDs removes the "exceptions" edge to the Exception entity by IDs.
func (m *StoreMutation) RemoveExceptionIDs(ids ...uint64) {
	if m.removedexceptions == nil {
		m.removedexceptions = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.exceptions, ids[i])
		m.removedexceptions[ids[i]] = struct{}{}
	}
}

// RemovedExceptions returns the removed IDs of the "exceptions" edge to the Exception entity.
func (m *StoreMutation) RemovedExceptionsIDs() (ids []uint64) {
	for id := range m.removedexceptions {
		ids = append(ids, id)
	}
	return
}

// ExceptionsIDs returns the "exceptions" edge IDs in the mutation.
func (m *StoreMutation) ExceptionsIDs() (ids []uint64) {
	for id := range m.exceptions {
		ids = append(ids, id)
	}
	return
}

// ResetExceptions resets all changes to the "exceptions" edge.
func (m *StoreMutation) ResetExceptions() {
	m.exceptions = nil
	m.clearedexceptions = false
	m.removedexceptions = nil
}

// Where appends a list predicates to the StoreMutation builder.
func (m *StoreMutation) Where(ps ...predicate.Store) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StoreMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StoreMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Store, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StoreMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StoreMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Store).
func (m *StoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StoreMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, store.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, store.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, store.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, store.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, store.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, store.FieldRemark)
	}
	if m.city != nil {
		fields = append(fields, store.FieldCityID)
	}
	if m.employee != nil {
		fields = append(fields, store.FieldEmployeeID)
	}
	if m.branch != nil {
		fields = append(fields, store.FieldBranchID)
	}
	if m.sn != nil {
		fields = append(fields, store.FieldSn)
	}
	if m.name != nil {
		fields = append(fields, store.FieldName)
	}
	if m.status != nil {
		fields = append(fields, store.FieldStatus)
	}
	if m.lng != nil {
		fields = append(fields, store.FieldLng)
	}
	if m.lat != nil {
		fields = append(fields, store.FieldLat)
	}
	if m.address != nil {
		fields = append(fields, store.FieldAddress)
	}
	if m.ebike_obtain != nil {
		fields = append(fields, store.FieldEbikeObtain)
	}
	if m.ebike_repair != nil {
		fields = append(fields, store.FieldEbikeRepair)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case store.FieldCreatedAt:
		return m.CreatedAt()
	case store.FieldUpdatedAt:
		return m.UpdatedAt()
	case store.FieldDeletedAt:
		return m.DeletedAt()
	case store.FieldCreator:
		return m.Creator()
	case store.FieldLastModifier:
		return m.LastModifier()
	case store.FieldRemark:
		return m.Remark()
	case store.FieldCityID:
		return m.CityID()
	case store.FieldEmployeeID:
		return m.EmployeeID()
	case store.FieldBranchID:
		return m.BranchID()
	case store.FieldSn:
		return m.Sn()
	case store.FieldName:
		return m.Name()
	case store.FieldStatus:
		return m.Status()
	case store.FieldLng:
		return m.Lng()
	case store.FieldLat:
		return m.Lat()
	case store.FieldAddress:
		return m.Address()
	case store.FieldEbikeObtain:
		return m.EbikeObtain()
	case store.FieldEbikeRepair:
		return m.EbikeRepair()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case store.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case store.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case store.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case store.FieldCreator:
		return m.OldCreator(ctx)
	case store.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case store.FieldRemark:
		return m.OldRemark(ctx)
	case store.FieldCityID:
		return m.OldCityID(ctx)
	case store.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case store.FieldBranchID:
		return m.OldBranchID(ctx)
	case store.FieldSn:
		return m.OldSn(ctx)
	case store.FieldName:
		return m.OldName(ctx)
	case store.FieldStatus:
		return m.OldStatus(ctx)
	case store.FieldLng:
		return m.OldLng(ctx)
	case store.FieldLat:
		return m.OldLat(ctx)
	case store.FieldAddress:
		return m.OldAddress(ctx)
	case store.FieldEbikeObtain:
		return m.OldEbikeObtain(ctx)
	case store.FieldEbikeRepair:
		return m.OldEbikeRepair(ctx)
	}
	return nil, fmt.Errorf("unknown Store field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case store.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case store.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case store.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case store.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case store.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case store.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case store.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case store.FieldEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case store.FieldBranchID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranchID(v)
		return nil
	case store.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case store.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case store.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case store.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLng(v)
		return nil
	case store.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	case store.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case store.FieldEbikeObtain:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEbikeObtain(v)
		return nil
	case store.FieldEbikeRepair:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEbikeRepair(v)
		return nil
	}
	return fmt.Errorf("unknown Store field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StoreMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, store.FieldStatus)
	}
	if m.addlng != nil {
		fields = append(fields, store.FieldLng)
	}
	if m.addlat != nil {
		fields = append(fields, store.FieldLat)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StoreMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case store.FieldStatus:
		return m.AddedStatus()
	case store.FieldLng:
		return m.AddedLng()
	case store.FieldLat:
		return m.AddedLat()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	case store.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case store.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLng(v)
		return nil
	case store.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLat(v)
		return nil
	}
	return fmt.Errorf("unknown Store numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StoreMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(store.FieldDeletedAt) {
		fields = append(fields, store.FieldDeletedAt)
	}
	if m.FieldCleared(store.FieldCreator) {
		fields = append(fields, store.FieldCreator)
	}
	if m.FieldCleared(store.FieldLastModifier) {
		fields = append(fields, store.FieldLastModifier)
	}
	if m.FieldCleared(store.FieldRemark) {
		fields = append(fields, store.FieldRemark)
	}
	if m.FieldCleared(store.FieldEmployeeID) {
		fields = append(fields, store.FieldEmployeeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StoreMutation) ClearField(name string) error {
	switch name {
	case store.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case store.FieldCreator:
		m.ClearCreator()
		return nil
	case store.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case store.FieldRemark:
		m.ClearRemark()
		return nil
	case store.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	}
	return fmt.Errorf("unknown Store nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StoreMutation) ResetField(name string) error {
	switch name {
	case store.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case store.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case store.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case store.FieldCreator:
		m.ResetCreator()
		return nil
	case store.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case store.FieldRemark:
		m.ResetRemark()
		return nil
	case store.FieldCityID:
		m.ResetCityID()
		return nil
	case store.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case store.FieldBranchID:
		m.ResetBranchID()
		return nil
	case store.FieldSn:
		m.ResetSn()
		return nil
	case store.FieldName:
		m.ResetName()
		return nil
	case store.FieldStatus:
		m.ResetStatus()
		return nil
	case store.FieldLng:
		m.ResetLng()
		return nil
	case store.FieldLat:
		m.ResetLat()
		return nil
	case store.FieldAddress:
		m.ResetAddress()
		return nil
	case store.FieldEbikeObtain:
		m.ResetEbikeObtain()
		return nil
	case store.FieldEbikeRepair:
		m.ResetEbikeRepair()
		return nil
	}
	return fmt.Errorf("unknown Store field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.city != nil {
		edges = append(edges, store.EdgeCity)
	}
	if m.branch != nil {
		edges = append(edges, store.EdgeBranch)
	}
	if m.employee != nil {
		edges = append(edges, store.EdgeEmployee)
	}
	if m.stocks != nil {
		edges = append(edges, store.EdgeStocks)
	}
	if m.attendances != nil {
		edges = append(edges, store.EdgeAttendances)
	}
	if m.exceptions != nil {
		edges = append(edges, store.EdgeExceptions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StoreMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case store.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case store.EdgeBranch:
		if id := m.branch; id != nil {
			return []ent.Value{*id}
		}
	case store.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case store.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.stocks))
		for id := range m.stocks {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeAttendances:
		ids := make([]ent.Value, 0, len(m.attendances))
		for id := range m.attendances {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeExceptions:
		ids := make([]ent.Value, 0, len(m.exceptions))
		for id := range m.exceptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedstocks != nil {
		edges = append(edges, store.EdgeStocks)
	}
	if m.removedattendances != nil {
		edges = append(edges, store.EdgeAttendances)
	}
	if m.removedexceptions != nil {
		edges = append(edges, store.EdgeExceptions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StoreMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case store.EdgeStocks:
		ids := make([]ent.Value, 0, len(m.removedstocks))
		for id := range m.removedstocks {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeAttendances:
		ids := make([]ent.Value, 0, len(m.removedattendances))
		for id := range m.removedattendances {
			ids = append(ids, id)
		}
		return ids
	case store.EdgeExceptions:
		ids := make([]ent.Value, 0, len(m.removedexceptions))
		for id := range m.removedexceptions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcity {
		edges = append(edges, store.EdgeCity)
	}
	if m.clearedbranch {
		edges = append(edges, store.EdgeBranch)
	}
	if m.clearedemployee {
		edges = append(edges, store.EdgeEmployee)
	}
	if m.clearedstocks {
		edges = append(edges, store.EdgeStocks)
	}
	if m.clearedattendances {
		edges = append(edges, store.EdgeAttendances)
	}
	if m.clearedexceptions {
		edges = append(edges, store.EdgeExceptions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StoreMutation) EdgeCleared(name string) bool {
	switch name {
	case store.EdgeCity:
		return m.clearedcity
	case store.EdgeBranch:
		return m.clearedbranch
	case store.EdgeEmployee:
		return m.clearedemployee
	case store.EdgeStocks:
		return m.clearedstocks
	case store.EdgeAttendances:
		return m.clearedattendances
	case store.EdgeExceptions:
		return m.clearedexceptions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StoreMutation) ClearEdge(name string) error {
	switch name {
	case store.EdgeCity:
		m.ClearCity()
		return nil
	case store.EdgeBranch:
		m.ClearBranch()
		return nil
	case store.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown Store unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StoreMutation) ResetEdge(name string) error {
	switch name {
	case store.EdgeCity:
		m.ResetCity()
		return nil
	case store.EdgeBranch:
		m.ResetBranch()
		return nil
	case store.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case store.EdgeStocks:
		m.ResetStocks()
		return nil
	case store.EdgeAttendances:
		m.ResetAttendances()
		return nil
	case store.EdgeExceptions:
		m.ResetExceptions()
		return nil
	}
	return fmt.Errorf("unknown Store edge %s", name)
}

// SubscribeMutation represents an operation that mutates the Subscribe nodes in the graph.
type SubscribeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uint64
	created_at           *time.Time
	updated_at           *time.Time
	deleted_at           *time.Time
	creator              **model.Modifier
	last_modifier        **model.Modifier
	remark               *string
	status               *uint8
	addstatus            *int8
	_type                *uint
	add_type             *int
	model                *string
	initial_days         *int
	addinitial_days      *int
	alter_days           *int
	addalter_days        *int
	pause_days           *int
	addpause_days        *int
	suspend_days         *int
	addsuspend_days      *int
	renewal_days         *int
	addrenewal_days      *int
	overdue_days         *int
	addoverdue_days      *int
	remaining            *int
	addremaining         *int
	paused_at            *time.Time
	suspend_at           *time.Time
	start_at             *time.Time
	end_at               *time.Time
	refund_at            *time.Time
	unsubscribe_reason   *string
	last_bill_date       *time.Time
	pause_overdue        *bool
	agent_end_at         *time.Time
	formula              *string
	need_contract        *bool
	intelligent          *bool
	clearedFields        map[string]struct{}
	plan                 *uint64
	clearedplan          bool
	employee             *uint64
	clearedemployee      bool
	city                 *uint64
	clearedcity          bool
	station              *uint64
	clearedstation       bool
	store                *uint64
	clearedstore         bool
	cabinet              *uint64
	clearedcabinet       bool
	brand                *uint64
	clearedbrand         bool
	ebike                *uint64
	clearedebike         bool
	rider                *uint64
	clearedrider         bool
	enterprise           *uint64
	clearedenterprise    bool
	pauses               map[uint64]struct{}
	removedpauses        map[uint64]struct{}
	clearedpauses        bool
	suspends             map[uint64]struct{}
	removedsuspends      map[uint64]struct{}
	clearedsuspends      bool
	alters               map[uint64]struct{}
	removedalters        map[uint64]struct{}
	clearedalters        bool
	orders               map[uint64]struct{}
	removedorders        map[uint64]struct{}
	clearedorders        bool
	initial_order        *uint64
	clearedinitial_order bool
	bills                map[uint64]struct{}
	removedbills         map[uint64]struct{}
	clearedbills         bool
	battery              *uint64
	clearedbattery       bool
	done                 bool
	oldValue             func(context.Context) (*Subscribe, error)
	predicates           []predicate.Subscribe
}

var _ ent.Mutation = (*SubscribeMutation)(nil)

// subscribeOption allows management of the mutation configuration using functional options.
type subscribeOption func(*SubscribeMutation)

// newSubscribeMutation creates new mutation for the Subscribe entity.
func newSubscribeMutation(c config, op Op, opts ...subscribeOption) *SubscribeMutation {
	m := &SubscribeMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscribe,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscribeID sets the ID field of the mutation.
func withSubscribeID(id uint64) subscribeOption {
	return func(m *SubscribeMutation) {
		var (
			err   error
			once  sync.Once
			value *Subscribe
		)
		m.oldValue = func(ctx context.Context) (*Subscribe, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Subscribe.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscribe sets the old Subscribe of the mutation.
func withSubscribe(node *Subscribe) subscribeOption {
	return func(m *SubscribeMutation) {
		m.oldValue = func(context.Context) (*Subscribe, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscribeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscribeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscribeMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscribeMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Subscribe.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscribeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscribeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscribeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscribeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscribeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscribeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SubscribeMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SubscribeMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SubscribeMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[subscribe.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SubscribeMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SubscribeMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, subscribe.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *SubscribeMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *SubscribeMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *SubscribeMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[subscribe.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *SubscribeMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *SubscribeMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, subscribe.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *SubscribeMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *SubscribeMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *SubscribeMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[subscribe.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *SubscribeMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *SubscribeMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, subscribe.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *SubscribeMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *SubscribeMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *SubscribeMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[subscribe.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *SubscribeMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *SubscribeMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, subscribe.FieldRemark)
}

// SetPlanID sets the "plan_id" field.
func (m *SubscribeMutation) SetPlanID(u uint64) {
	m.plan = &u
}

// PlanID returns the value of the "plan_id" field in the mutation.
func (m *SubscribeMutation) PlanID() (r uint64, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanID returns the old "plan_id" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldPlanID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanID: %w", err)
	}
	return oldValue.PlanID, nil
}

// ClearPlanID clears the value of the "plan_id" field.
func (m *SubscribeMutation) ClearPlanID() {
	m.plan = nil
	m.clearedFields[subscribe.FieldPlanID] = struct{}{}
}

// PlanIDCleared returns if the "plan_id" field was cleared in this mutation.
func (m *SubscribeMutation) PlanIDCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldPlanID]
	return ok
}

// ResetPlanID resets all changes to the "plan_id" field.
func (m *SubscribeMutation) ResetPlanID() {
	m.plan = nil
	delete(m.clearedFields, subscribe.FieldPlanID)
}

// SetEmployeeID sets the "employee_id" field.
func (m *SubscribeMutation) SetEmployeeID(u uint64) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *SubscribeMutation) EmployeeID() (r uint64, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldEmployeeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *SubscribeMutation) ClearEmployeeID() {
	m.employee = nil
	m.clearedFields[subscribe.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *SubscribeMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *SubscribeMutation) ResetEmployeeID() {
	m.employee = nil
	delete(m.clearedFields, subscribe.FieldEmployeeID)
}

// SetCityID sets the "city_id" field.
func (m *SubscribeMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *SubscribeMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *SubscribeMutation) ResetCityID() {
	m.city = nil
}

// SetStationID sets the "station_id" field.
func (m *SubscribeMutation) SetStationID(u uint64) {
	m.station = &u
}

// StationID returns the value of the "station_id" field in the mutation.
func (m *SubscribeMutation) StationID() (r uint64, exists bool) {
	v := m.station
	if v == nil {
		return
	}
	return *v, true
}

// OldStationID returns the old "station_id" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldStationID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStationID: %w", err)
	}
	return oldValue.StationID, nil
}

// ClearStationID clears the value of the "station_id" field.
func (m *SubscribeMutation) ClearStationID() {
	m.station = nil
	m.clearedFields[subscribe.FieldStationID] = struct{}{}
}

// StationIDCleared returns if the "station_id" field was cleared in this mutation.
func (m *SubscribeMutation) StationIDCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldStationID]
	return ok
}

// ResetStationID resets all changes to the "station_id" field.
func (m *SubscribeMutation) ResetStationID() {
	m.station = nil
	delete(m.clearedFields, subscribe.FieldStationID)
}

// SetStoreID sets the "store_id" field.
func (m *SubscribeMutation) SetStoreID(u uint64) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *SubscribeMutation) StoreID() (r uint64, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldStoreID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *SubscribeMutation) ClearStoreID() {
	m.store = nil
	m.clearedFields[subscribe.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *SubscribeMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *SubscribeMutation) ResetStoreID() {
	m.store = nil
	delete(m.clearedFields, subscribe.FieldStoreID)
}

// SetCabinetID sets the "cabinet_id" field.
func (m *SubscribeMutation) SetCabinetID(u uint64) {
	m.cabinet = &u
}

// CabinetID returns the value of the "cabinet_id" field in the mutation.
func (m *SubscribeMutation) CabinetID() (r uint64, exists bool) {
	v := m.cabinet
	if v == nil {
		return
	}
	return *v, true
}

// OldCabinetID returns the old "cabinet_id" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldCabinetID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCabinetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCabinetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCabinetID: %w", err)
	}
	return oldValue.CabinetID, nil
}

// ClearCabinetID clears the value of the "cabinet_id" field.
func (m *SubscribeMutation) ClearCabinetID() {
	m.cabinet = nil
	m.clearedFields[subscribe.FieldCabinetID] = struct{}{}
}

// CabinetIDCleared returns if the "cabinet_id" field was cleared in this mutation.
func (m *SubscribeMutation) CabinetIDCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldCabinetID]
	return ok
}

// ResetCabinetID resets all changes to the "cabinet_id" field.
func (m *SubscribeMutation) ResetCabinetID() {
	m.cabinet = nil
	delete(m.clearedFields, subscribe.FieldCabinetID)
}

// SetBrandID sets the "brand_id" field.
func (m *SubscribeMutation) SetBrandID(u uint64) {
	m.brand = &u
}

// BrandID returns the value of the "brand_id" field in the mutation.
func (m *SubscribeMutation) BrandID() (r uint64, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrandID returns the old "brand_id" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldBrandID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrandID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrandID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrandID: %w", err)
	}
	return oldValue.BrandID, nil
}

// ClearBrandID clears the value of the "brand_id" field.
func (m *SubscribeMutation) ClearBrandID() {
	m.brand = nil
	m.clearedFields[subscribe.FieldBrandID] = struct{}{}
}

// BrandIDCleared returns if the "brand_id" field was cleared in this mutation.
func (m *SubscribeMutation) BrandIDCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldBrandID]
	return ok
}

// ResetBrandID resets all changes to the "brand_id" field.
func (m *SubscribeMutation) ResetBrandID() {
	m.brand = nil
	delete(m.clearedFields, subscribe.FieldBrandID)
}

// SetEbikeID sets the "ebike_id" field.
func (m *SubscribeMutation) SetEbikeID(u uint64) {
	m.ebike = &u
}

// EbikeID returns the value of the "ebike_id" field in the mutation.
func (m *SubscribeMutation) EbikeID() (r uint64, exists bool) {
	v := m.ebike
	if v == nil {
		return
	}
	return *v, true
}

// OldEbikeID returns the old "ebike_id" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldEbikeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEbikeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEbikeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEbikeID: %w", err)
	}
	return oldValue.EbikeID, nil
}

// ClearEbikeID clears the value of the "ebike_id" field.
func (m *SubscribeMutation) ClearEbikeID() {
	m.ebike = nil
	m.clearedFields[subscribe.FieldEbikeID] = struct{}{}
}

// EbikeIDCleared returns if the "ebike_id" field was cleared in this mutation.
func (m *SubscribeMutation) EbikeIDCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldEbikeID]
	return ok
}

// ResetEbikeID resets all changes to the "ebike_id" field.
func (m *SubscribeMutation) ResetEbikeID() {
	m.ebike = nil
	delete(m.clearedFields, subscribe.FieldEbikeID)
}

// SetRiderID sets the "rider_id" field.
func (m *SubscribeMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *SubscribeMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *SubscribeMutation) ResetRiderID() {
	m.rider = nil
}

// SetInitialOrderID sets the "initial_order_id" field.
func (m *SubscribeMutation) SetInitialOrderID(u uint64) {
	m.initial_order = &u
}

// InitialOrderID returns the value of the "initial_order_id" field in the mutation.
func (m *SubscribeMutation) InitialOrderID() (r uint64, exists bool) {
	v := m.initial_order
	if v == nil {
		return
	}
	return *v, true
}

// OldInitialOrderID returns the old "initial_order_id" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldInitialOrderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitialOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitialOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitialOrderID: %w", err)
	}
	return oldValue.InitialOrderID, nil
}

// ClearInitialOrderID clears the value of the "initial_order_id" field.
func (m *SubscribeMutation) ClearInitialOrderID() {
	m.initial_order = nil
	m.clearedFields[subscribe.FieldInitialOrderID] = struct{}{}
}

// InitialOrderIDCleared returns if the "initial_order_id" field was cleared in this mutation.
func (m *SubscribeMutation) InitialOrderIDCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldInitialOrderID]
	return ok
}

// ResetInitialOrderID resets all changes to the "initial_order_id" field.
func (m *SubscribeMutation) ResetInitialOrderID() {
	m.initial_order = nil
	delete(m.clearedFields, subscribe.FieldInitialOrderID)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *SubscribeMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *SubscribeMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldEnterpriseID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ClearEnterpriseID clears the value of the "enterprise_id" field.
func (m *SubscribeMutation) ClearEnterpriseID() {
	m.enterprise = nil
	m.clearedFields[subscribe.FieldEnterpriseID] = struct{}{}
}

// EnterpriseIDCleared returns if the "enterprise_id" field was cleared in this mutation.
func (m *SubscribeMutation) EnterpriseIDCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldEnterpriseID]
	return ok
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *SubscribeMutation) ResetEnterpriseID() {
	m.enterprise = nil
	delete(m.clearedFields, subscribe.FieldEnterpriseID)
}

// SetStatus sets the "status" field.
func (m *SubscribeMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SubscribeMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *SubscribeMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SubscribeMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *SubscribeMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetType sets the "type" field.
func (m *SubscribeMutation) SetType(u uint) {
	m._type = &u
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *SubscribeMutation) GetType() (r uint, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldType(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds u to the "type" field.
func (m *SubscribeMutation) AddType(u int) {
	if m.add_type != nil {
		*m.add_type += u
	} else {
		m.add_type = &u
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *SubscribeMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *SubscribeMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetModel sets the "model" field.
func (m *SubscribeMutation) SetModel(s string) {
	m.model = &s
}

// Model returns the value of the "model" field in the mutation.
func (m *SubscribeMutation) Model() (r string, exists bool) {
	v := m.model
	if v == nil {
		return
	}
	return *v, true
}

// OldModel returns the old "model" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModel: %w", err)
	}
	return oldValue.Model, nil
}

// ResetModel resets all changes to the "model" field.
func (m *SubscribeMutation) ResetModel() {
	m.model = nil
}

// SetInitialDays sets the "initial_days" field.
func (m *SubscribeMutation) SetInitialDays(i int) {
	m.initial_days = &i
	m.addinitial_days = nil
}

// InitialDays returns the value of the "initial_days" field in the mutation.
func (m *SubscribeMutation) InitialDays() (r int, exists bool) {
	v := m.initial_days
	if v == nil {
		return
	}
	return *v, true
}

// OldInitialDays returns the old "initial_days" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldInitialDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitialDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitialDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitialDays: %w", err)
	}
	return oldValue.InitialDays, nil
}

// AddInitialDays adds i to the "initial_days" field.
func (m *SubscribeMutation) AddInitialDays(i int) {
	if m.addinitial_days != nil {
		*m.addinitial_days += i
	} else {
		m.addinitial_days = &i
	}
}

// AddedInitialDays returns the value that was added to the "initial_days" field in this mutation.
func (m *SubscribeMutation) AddedInitialDays() (r int, exists bool) {
	v := m.addinitial_days
	if v == nil {
		return
	}
	return *v, true
}

// ClearInitialDays clears the value of the "initial_days" field.
func (m *SubscribeMutation) ClearInitialDays() {
	m.initial_days = nil
	m.addinitial_days = nil
	m.clearedFields[subscribe.FieldInitialDays] = struct{}{}
}

// InitialDaysCleared returns if the "initial_days" field was cleared in this mutation.
func (m *SubscribeMutation) InitialDaysCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldInitialDays]
	return ok
}

// ResetInitialDays resets all changes to the "initial_days" field.
func (m *SubscribeMutation) ResetInitialDays() {
	m.initial_days = nil
	m.addinitial_days = nil
	delete(m.clearedFields, subscribe.FieldInitialDays)
}

// SetAlterDays sets the "alter_days" field.
func (m *SubscribeMutation) SetAlterDays(i int) {
	m.alter_days = &i
	m.addalter_days = nil
}

// AlterDays returns the value of the "alter_days" field in the mutation.
func (m *SubscribeMutation) AlterDays() (r int, exists bool) {
	v := m.alter_days
	if v == nil {
		return
	}
	return *v, true
}

// OldAlterDays returns the old "alter_days" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldAlterDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlterDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlterDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlterDays: %w", err)
	}
	return oldValue.AlterDays, nil
}

// AddAlterDays adds i to the "alter_days" field.
func (m *SubscribeMutation) AddAlterDays(i int) {
	if m.addalter_days != nil {
		*m.addalter_days += i
	} else {
		m.addalter_days = &i
	}
}

// AddedAlterDays returns the value that was added to the "alter_days" field in this mutation.
func (m *SubscribeMutation) AddedAlterDays() (r int, exists bool) {
	v := m.addalter_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetAlterDays resets all changes to the "alter_days" field.
func (m *SubscribeMutation) ResetAlterDays() {
	m.alter_days = nil
	m.addalter_days = nil
}

// SetPauseDays sets the "pause_days" field.
func (m *SubscribeMutation) SetPauseDays(i int) {
	m.pause_days = &i
	m.addpause_days = nil
}

// PauseDays returns the value of the "pause_days" field in the mutation.
func (m *SubscribeMutation) PauseDays() (r int, exists bool) {
	v := m.pause_days
	if v == nil {
		return
	}
	return *v, true
}

// OldPauseDays returns the old "pause_days" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldPauseDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPauseDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPauseDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPauseDays: %w", err)
	}
	return oldValue.PauseDays, nil
}

// AddPauseDays adds i to the "pause_days" field.
func (m *SubscribeMutation) AddPauseDays(i int) {
	if m.addpause_days != nil {
		*m.addpause_days += i
	} else {
		m.addpause_days = &i
	}
}

// AddedPauseDays returns the value that was added to the "pause_days" field in this mutation.
func (m *SubscribeMutation) AddedPauseDays() (r int, exists bool) {
	v := m.addpause_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetPauseDays resets all changes to the "pause_days" field.
func (m *SubscribeMutation) ResetPauseDays() {
	m.pause_days = nil
	m.addpause_days = nil
}

// SetSuspendDays sets the "suspend_days" field.
func (m *SubscribeMutation) SetSuspendDays(i int) {
	m.suspend_days = &i
	m.addsuspend_days = nil
}

// SuspendDays returns the value of the "suspend_days" field in the mutation.
func (m *SubscribeMutation) SuspendDays() (r int, exists bool) {
	v := m.suspend_days
	if v == nil {
		return
	}
	return *v, true
}

// OldSuspendDays returns the old "suspend_days" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldSuspendDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuspendDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuspendDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuspendDays: %w", err)
	}
	return oldValue.SuspendDays, nil
}

// AddSuspendDays adds i to the "suspend_days" field.
func (m *SubscribeMutation) AddSuspendDays(i int) {
	if m.addsuspend_days != nil {
		*m.addsuspend_days += i
	} else {
		m.addsuspend_days = &i
	}
}

// AddedSuspendDays returns the value that was added to the "suspend_days" field in this mutation.
func (m *SubscribeMutation) AddedSuspendDays() (r int, exists bool) {
	v := m.addsuspend_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetSuspendDays resets all changes to the "suspend_days" field.
func (m *SubscribeMutation) ResetSuspendDays() {
	m.suspend_days = nil
	m.addsuspend_days = nil
}

// SetRenewalDays sets the "renewal_days" field.
func (m *SubscribeMutation) SetRenewalDays(i int) {
	m.renewal_days = &i
	m.addrenewal_days = nil
}

// RenewalDays returns the value of the "renewal_days" field in the mutation.
func (m *SubscribeMutation) RenewalDays() (r int, exists bool) {
	v := m.renewal_days
	if v == nil {
		return
	}
	return *v, true
}

// OldRenewalDays returns the old "renewal_days" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldRenewalDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRenewalDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRenewalDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRenewalDays: %w", err)
	}
	return oldValue.RenewalDays, nil
}

// AddRenewalDays adds i to the "renewal_days" field.
func (m *SubscribeMutation) AddRenewalDays(i int) {
	if m.addrenewal_days != nil {
		*m.addrenewal_days += i
	} else {
		m.addrenewal_days = &i
	}
}

// AddedRenewalDays returns the value that was added to the "renewal_days" field in this mutation.
func (m *SubscribeMutation) AddedRenewalDays() (r int, exists bool) {
	v := m.addrenewal_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetRenewalDays resets all changes to the "renewal_days" field.
func (m *SubscribeMutation) ResetRenewalDays() {
	m.renewal_days = nil
	m.addrenewal_days = nil
}

// SetOverdueDays sets the "overdue_days" field.
func (m *SubscribeMutation) SetOverdueDays(i int) {
	m.overdue_days = &i
	m.addoverdue_days = nil
}

// OverdueDays returns the value of the "overdue_days" field in the mutation.
func (m *SubscribeMutation) OverdueDays() (r int, exists bool) {
	v := m.overdue_days
	if v == nil {
		return
	}
	return *v, true
}

// OldOverdueDays returns the old "overdue_days" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldOverdueDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverdueDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverdueDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverdueDays: %w", err)
	}
	return oldValue.OverdueDays, nil
}

// AddOverdueDays adds i to the "overdue_days" field.
func (m *SubscribeMutation) AddOverdueDays(i int) {
	if m.addoverdue_days != nil {
		*m.addoverdue_days += i
	} else {
		m.addoverdue_days = &i
	}
}

// AddedOverdueDays returns the value that was added to the "overdue_days" field in this mutation.
func (m *SubscribeMutation) AddedOverdueDays() (r int, exists bool) {
	v := m.addoverdue_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetOverdueDays resets all changes to the "overdue_days" field.
func (m *SubscribeMutation) ResetOverdueDays() {
	m.overdue_days = nil
	m.addoverdue_days = nil
}

// SetRemaining sets the "remaining" field.
func (m *SubscribeMutation) SetRemaining(i int) {
	m.remaining = &i
	m.addremaining = nil
}

// Remaining returns the value of the "remaining" field in the mutation.
func (m *SubscribeMutation) Remaining() (r int, exists bool) {
	v := m.remaining
	if v == nil {
		return
	}
	return *v, true
}

// OldRemaining returns the old "remaining" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldRemaining(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemaining is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemaining requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemaining: %w", err)
	}
	return oldValue.Remaining, nil
}

// AddRemaining adds i to the "remaining" field.
func (m *SubscribeMutation) AddRemaining(i int) {
	if m.addremaining != nil {
		*m.addremaining += i
	} else {
		m.addremaining = &i
	}
}

// AddedRemaining returns the value that was added to the "remaining" field in this mutation.
func (m *SubscribeMutation) AddedRemaining() (r int, exists bool) {
	v := m.addremaining
	if v == nil {
		return
	}
	return *v, true
}

// ResetRemaining resets all changes to the "remaining" field.
func (m *SubscribeMutation) ResetRemaining() {
	m.remaining = nil
	m.addremaining = nil
}

// SetPausedAt sets the "paused_at" field.
func (m *SubscribeMutation) SetPausedAt(t time.Time) {
	m.paused_at = &t
}

// PausedAt returns the value of the "paused_at" field in the mutation.
func (m *SubscribeMutation) PausedAt() (r time.Time, exists bool) {
	v := m.paused_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPausedAt returns the old "paused_at" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldPausedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPausedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPausedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPausedAt: %w", err)
	}
	return oldValue.PausedAt, nil
}

// ClearPausedAt clears the value of the "paused_at" field.
func (m *SubscribeMutation) ClearPausedAt() {
	m.paused_at = nil
	m.clearedFields[subscribe.FieldPausedAt] = struct{}{}
}

// PausedAtCleared returns if the "paused_at" field was cleared in this mutation.
func (m *SubscribeMutation) PausedAtCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldPausedAt]
	return ok
}

// ResetPausedAt resets all changes to the "paused_at" field.
func (m *SubscribeMutation) ResetPausedAt() {
	m.paused_at = nil
	delete(m.clearedFields, subscribe.FieldPausedAt)
}

// SetSuspendAt sets the "suspend_at" field.
func (m *SubscribeMutation) SetSuspendAt(t time.Time) {
	m.suspend_at = &t
}

// SuspendAt returns the value of the "suspend_at" field in the mutation.
func (m *SubscribeMutation) SuspendAt() (r time.Time, exists bool) {
	v := m.suspend_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSuspendAt returns the old "suspend_at" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldSuspendAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuspendAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuspendAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuspendAt: %w", err)
	}
	return oldValue.SuspendAt, nil
}

// ClearSuspendAt clears the value of the "suspend_at" field.
func (m *SubscribeMutation) ClearSuspendAt() {
	m.suspend_at = nil
	m.clearedFields[subscribe.FieldSuspendAt] = struct{}{}
}

// SuspendAtCleared returns if the "suspend_at" field was cleared in this mutation.
func (m *SubscribeMutation) SuspendAtCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldSuspendAt]
	return ok
}

// ResetSuspendAt resets all changes to the "suspend_at" field.
func (m *SubscribeMutation) ResetSuspendAt() {
	m.suspend_at = nil
	delete(m.clearedFields, subscribe.FieldSuspendAt)
}

// SetStartAt sets the "start_at" field.
func (m *SubscribeMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *SubscribeMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldStartAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *SubscribeMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[subscribe.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *SubscribeMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *SubscribeMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, subscribe.FieldStartAt)
}

// SetEndAt sets the "end_at" field.
func (m *SubscribeMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *SubscribeMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldEndAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *SubscribeMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[subscribe.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *SubscribeMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *SubscribeMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, subscribe.FieldEndAt)
}

// SetRefundAt sets the "refund_at" field.
func (m *SubscribeMutation) SetRefundAt(t time.Time) {
	m.refund_at = &t
}

// RefundAt returns the value of the "refund_at" field in the mutation.
func (m *SubscribeMutation) RefundAt() (r time.Time, exists bool) {
	v := m.refund_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRefundAt returns the old "refund_at" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldRefundAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefundAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefundAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefundAt: %w", err)
	}
	return oldValue.RefundAt, nil
}

// ClearRefundAt clears the value of the "refund_at" field.
func (m *SubscribeMutation) ClearRefundAt() {
	m.refund_at = nil
	m.clearedFields[subscribe.FieldRefundAt] = struct{}{}
}

// RefundAtCleared returns if the "refund_at" field was cleared in this mutation.
func (m *SubscribeMutation) RefundAtCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldRefundAt]
	return ok
}

// ResetRefundAt resets all changes to the "refund_at" field.
func (m *SubscribeMutation) ResetRefundAt() {
	m.refund_at = nil
	delete(m.clearedFields, subscribe.FieldRefundAt)
}

// SetUnsubscribeReason sets the "unsubscribe_reason" field.
func (m *SubscribeMutation) SetUnsubscribeReason(s string) {
	m.unsubscribe_reason = &s
}

// UnsubscribeReason returns the value of the "unsubscribe_reason" field in the mutation.
func (m *SubscribeMutation) UnsubscribeReason() (r string, exists bool) {
	v := m.unsubscribe_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldUnsubscribeReason returns the old "unsubscribe_reason" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldUnsubscribeReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnsubscribeReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnsubscribeReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnsubscribeReason: %w", err)
	}
	return oldValue.UnsubscribeReason, nil
}

// ClearUnsubscribeReason clears the value of the "unsubscribe_reason" field.
func (m *SubscribeMutation) ClearUnsubscribeReason() {
	m.unsubscribe_reason = nil
	m.clearedFields[subscribe.FieldUnsubscribeReason] = struct{}{}
}

// UnsubscribeReasonCleared returns if the "unsubscribe_reason" field was cleared in this mutation.
func (m *SubscribeMutation) UnsubscribeReasonCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldUnsubscribeReason]
	return ok
}

// ResetUnsubscribeReason resets all changes to the "unsubscribe_reason" field.
func (m *SubscribeMutation) ResetUnsubscribeReason() {
	m.unsubscribe_reason = nil
	delete(m.clearedFields, subscribe.FieldUnsubscribeReason)
}

// SetLastBillDate sets the "last_bill_date" field.
func (m *SubscribeMutation) SetLastBillDate(t time.Time) {
	m.last_bill_date = &t
}

// LastBillDate returns the value of the "last_bill_date" field in the mutation.
func (m *SubscribeMutation) LastBillDate() (r time.Time, exists bool) {
	v := m.last_bill_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLastBillDate returns the old "last_bill_date" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldLastBillDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastBillDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastBillDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastBillDate: %w", err)
	}
	return oldValue.LastBillDate, nil
}

// ClearLastBillDate clears the value of the "last_bill_date" field.
func (m *SubscribeMutation) ClearLastBillDate() {
	m.last_bill_date = nil
	m.clearedFields[subscribe.FieldLastBillDate] = struct{}{}
}

// LastBillDateCleared returns if the "last_bill_date" field was cleared in this mutation.
func (m *SubscribeMutation) LastBillDateCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldLastBillDate]
	return ok
}

// ResetLastBillDate resets all changes to the "last_bill_date" field.
func (m *SubscribeMutation) ResetLastBillDate() {
	m.last_bill_date = nil
	delete(m.clearedFields, subscribe.FieldLastBillDate)
}

// SetPauseOverdue sets the "pause_overdue" field.
func (m *SubscribeMutation) SetPauseOverdue(b bool) {
	m.pause_overdue = &b
}

// PauseOverdue returns the value of the "pause_overdue" field in the mutation.
func (m *SubscribeMutation) PauseOverdue() (r bool, exists bool) {
	v := m.pause_overdue
	if v == nil {
		return
	}
	return *v, true
}

// OldPauseOverdue returns the old "pause_overdue" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldPauseOverdue(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPauseOverdue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPauseOverdue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPauseOverdue: %w", err)
	}
	return oldValue.PauseOverdue, nil
}

// ResetPauseOverdue resets all changes to the "pause_overdue" field.
func (m *SubscribeMutation) ResetPauseOverdue() {
	m.pause_overdue = nil
}

// SetAgentEndAt sets the "agent_end_at" field.
func (m *SubscribeMutation) SetAgentEndAt(t time.Time) {
	m.agent_end_at = &t
}

// AgentEndAt returns the value of the "agent_end_at" field in the mutation.
func (m *SubscribeMutation) AgentEndAt() (r time.Time, exists bool) {
	v := m.agent_end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentEndAt returns the old "agent_end_at" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldAgentEndAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentEndAt: %w", err)
	}
	return oldValue.AgentEndAt, nil
}

// ClearAgentEndAt clears the value of the "agent_end_at" field.
func (m *SubscribeMutation) ClearAgentEndAt() {
	m.agent_end_at = nil
	m.clearedFields[subscribe.FieldAgentEndAt] = struct{}{}
}

// AgentEndAtCleared returns if the "agent_end_at" field was cleared in this mutation.
func (m *SubscribeMutation) AgentEndAtCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldAgentEndAt]
	return ok
}

// ResetAgentEndAt resets all changes to the "agent_end_at" field.
func (m *SubscribeMutation) ResetAgentEndAt() {
	m.agent_end_at = nil
	delete(m.clearedFields, subscribe.FieldAgentEndAt)
}

// SetFormula sets the "formula" field.
func (m *SubscribeMutation) SetFormula(s string) {
	m.formula = &s
}

// Formula returns the value of the "formula" field in the mutation.
func (m *SubscribeMutation) Formula() (r string, exists bool) {
	v := m.formula
	if v == nil {
		return
	}
	return *v, true
}

// OldFormula returns the old "formula" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldFormula(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormula is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormula requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormula: %w", err)
	}
	return oldValue.Formula, nil
}

// ClearFormula clears the value of the "formula" field.
func (m *SubscribeMutation) ClearFormula() {
	m.formula = nil
	m.clearedFields[subscribe.FieldFormula] = struct{}{}
}

// FormulaCleared returns if the "formula" field was cleared in this mutation.
func (m *SubscribeMutation) FormulaCleared() bool {
	_, ok := m.clearedFields[subscribe.FieldFormula]
	return ok
}

// ResetFormula resets all changes to the "formula" field.
func (m *SubscribeMutation) ResetFormula() {
	m.formula = nil
	delete(m.clearedFields, subscribe.FieldFormula)
}

// SetNeedContract sets the "need_contract" field.
func (m *SubscribeMutation) SetNeedContract(b bool) {
	m.need_contract = &b
}

// NeedContract returns the value of the "need_contract" field in the mutation.
func (m *SubscribeMutation) NeedContract() (r bool, exists bool) {
	v := m.need_contract
	if v == nil {
		return
	}
	return *v, true
}

// OldNeedContract returns the old "need_contract" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldNeedContract(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNeedContract is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNeedContract requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeedContract: %w", err)
	}
	return oldValue.NeedContract, nil
}

// ResetNeedContract resets all changes to the "need_contract" field.
func (m *SubscribeMutation) ResetNeedContract() {
	m.need_contract = nil
}

// SetIntelligent sets the "intelligent" field.
func (m *SubscribeMutation) SetIntelligent(b bool) {
	m.intelligent = &b
}

// Intelligent returns the value of the "intelligent" field in the mutation.
func (m *SubscribeMutation) Intelligent() (r bool, exists bool) {
	v := m.intelligent
	if v == nil {
		return
	}
	return *v, true
}

// OldIntelligent returns the old "intelligent" field's value of the Subscribe entity.
// If the Subscribe object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeMutation) OldIntelligent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntelligent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntelligent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntelligent: %w", err)
	}
	return oldValue.Intelligent, nil
}

// ResetIntelligent resets all changes to the "intelligent" field.
func (m *SubscribeMutation) ResetIntelligent() {
	m.intelligent = nil
}

// ClearPlan clears the "plan" edge to the Plan entity.
func (m *SubscribeMutation) ClearPlan() {
	m.clearedplan = true
	m.clearedFields[subscribe.FieldPlanID] = struct{}{}
}

// PlanCleared reports if the "plan" edge to the Plan entity was cleared.
func (m *SubscribeMutation) PlanCleared() bool {
	return m.PlanIDCleared() || m.clearedplan
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *SubscribeMutation) PlanIDs() (ids []uint64) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *SubscribeMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *SubscribeMutation) ClearEmployee() {
	m.clearedemployee = true
	m.clearedFields[subscribe.FieldEmployeeID] = struct{}{}
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *SubscribeMutation) EmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *SubscribeMutation) EmployeeIDs() (ids []uint64) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *SubscribeMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *SubscribeMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[subscribe.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *SubscribeMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *SubscribeMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *SubscribeMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearStation clears the "station" edge to the EnterpriseStation entity.
func (m *SubscribeMutation) ClearStation() {
	m.clearedstation = true
	m.clearedFields[subscribe.FieldStationID] = struct{}{}
}

// StationCleared reports if the "station" edge to the EnterpriseStation entity was cleared.
func (m *SubscribeMutation) StationCleared() bool {
	return m.StationIDCleared() || m.clearedstation
}

// StationIDs returns the "station" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StationID instead. It exists only for internal usage by the builders.
func (m *SubscribeMutation) StationIDs() (ids []uint64) {
	if id := m.station; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStation resets all changes to the "station" edge.
func (m *SubscribeMutation) ResetStation() {
	m.station = nil
	m.clearedstation = false
}

// ClearStore clears the "store" edge to the Store entity.
func (m *SubscribeMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[subscribe.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *SubscribeMutation) StoreCleared() bool {
	return m.StoreIDCleared() || m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *SubscribeMutation) StoreIDs() (ids []uint64) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *SubscribeMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// ClearCabinet clears the "cabinet" edge to the Cabinet entity.
func (m *SubscribeMutation) ClearCabinet() {
	m.clearedcabinet = true
	m.clearedFields[subscribe.FieldCabinetID] = struct{}{}
}

// CabinetCleared reports if the "cabinet" edge to the Cabinet entity was cleared.
func (m *SubscribeMutation) CabinetCleared() bool {
	return m.CabinetIDCleared() || m.clearedcabinet
}

// CabinetIDs returns the "cabinet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CabinetID instead. It exists only for internal usage by the builders.
func (m *SubscribeMutation) CabinetIDs() (ids []uint64) {
	if id := m.cabinet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCabinet resets all changes to the "cabinet" edge.
func (m *SubscribeMutation) ResetCabinet() {
	m.cabinet = nil
	m.clearedcabinet = false
}

// ClearBrand clears the "brand" edge to the EbikeBrand entity.
func (m *SubscribeMutation) ClearBrand() {
	m.clearedbrand = true
	m.clearedFields[subscribe.FieldBrandID] = struct{}{}
}

// BrandCleared reports if the "brand" edge to the EbikeBrand entity was cleared.
func (m *SubscribeMutation) BrandCleared() bool {
	return m.BrandIDCleared() || m.clearedbrand
}

// BrandIDs returns the "brand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BrandID instead. It exists only for internal usage by the builders.
func (m *SubscribeMutation) BrandIDs() (ids []uint64) {
	if id := m.brand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBrand resets all changes to the "brand" edge.
func (m *SubscribeMutation) ResetBrand() {
	m.brand = nil
	m.clearedbrand = false
}

// ClearEbike clears the "ebike" edge to the Ebike entity.
func (m *SubscribeMutation) ClearEbike() {
	m.clearedebike = true
	m.clearedFields[subscribe.FieldEbikeID] = struct{}{}
}

// EbikeCleared reports if the "ebike" edge to the Ebike entity was cleared.
func (m *SubscribeMutation) EbikeCleared() bool {
	return m.EbikeIDCleared() || m.clearedebike
}

// EbikeIDs returns the "ebike" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EbikeID instead. It exists only for internal usage by the builders.
func (m *SubscribeMutation) EbikeIDs() (ids []uint64) {
	if id := m.ebike; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEbike resets all changes to the "ebike" edge.
func (m *SubscribeMutation) ResetEbike() {
	m.ebike = nil
	m.clearedebike = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *SubscribeMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[subscribe.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *SubscribeMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *SubscribeMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *SubscribeMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *SubscribeMutation) ClearEnterprise() {
	m.clearedenterprise = true
	m.clearedFields[subscribe.FieldEnterpriseID] = struct{}{}
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *SubscribeMutation) EnterpriseCleared() bool {
	return m.EnterpriseIDCleared() || m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *SubscribeMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *SubscribeMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// AddPauseIDs adds the "pauses" edge to the SubscribePause entity by ids.
func (m *SubscribeMutation) AddPauseIDs(ids ...uint64) {
	if m.pauses == nil {
		m.pauses = make(map[uint64]struct{})
	}
	for i := range ids {
		m.pauses[ids[i]] = struct{}{}
	}
}

// ClearPauses clears the "pauses" edge to the SubscribePause entity.
func (m *SubscribeMutation) ClearPauses() {
	m.clearedpauses = true
}

// PausesCleared reports if the "pauses" edge to the SubscribePause entity was cleared.
func (m *SubscribeMutation) PausesCleared() bool {
	return m.clearedpauses
}

// RemovePauseIDs removes the "pauses" edge to the SubscribePause entity by IDs.
func (m *SubscribeMutation) RemovePauseIDs(ids ...uint64) {
	if m.removedpauses == nil {
		m.removedpauses = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.pauses, ids[i])
		m.removedpauses[ids[i]] = struct{}{}
	}
}

// RemovedPauses returns the removed IDs of the "pauses" edge to the SubscribePause entity.
func (m *SubscribeMutation) RemovedPausesIDs() (ids []uint64) {
	for id := range m.removedpauses {
		ids = append(ids, id)
	}
	return
}

// PausesIDs returns the "pauses" edge IDs in the mutation.
func (m *SubscribeMutation) PausesIDs() (ids []uint64) {
	for id := range m.pauses {
		ids = append(ids, id)
	}
	return
}

// ResetPauses resets all changes to the "pauses" edge.
func (m *SubscribeMutation) ResetPauses() {
	m.pauses = nil
	m.clearedpauses = false
	m.removedpauses = nil
}

// AddSuspendIDs adds the "suspends" edge to the SubscribeSuspend entity by ids.
func (m *SubscribeMutation) AddSuspendIDs(ids ...uint64) {
	if m.suspends == nil {
		m.suspends = make(map[uint64]struct{})
	}
	for i := range ids {
		m.suspends[ids[i]] = struct{}{}
	}
}

// ClearSuspends clears the "suspends" edge to the SubscribeSuspend entity.
func (m *SubscribeMutation) ClearSuspends() {
	m.clearedsuspends = true
}

// SuspendsCleared reports if the "suspends" edge to the SubscribeSuspend entity was cleared.
func (m *SubscribeMutation) SuspendsCleared() bool {
	return m.clearedsuspends
}

// RemoveSuspendIDs removes the "suspends" edge to the SubscribeSuspend entity by IDs.
func (m *SubscribeMutation) RemoveSuspendIDs(ids ...uint64) {
	if m.removedsuspends == nil {
		m.removedsuspends = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.suspends, ids[i])
		m.removedsuspends[ids[i]] = struct{}{}
	}
}

// RemovedSuspends returns the removed IDs of the "suspends" edge to the SubscribeSuspend entity.
func (m *SubscribeMutation) RemovedSuspendsIDs() (ids []uint64) {
	for id := range m.removedsuspends {
		ids = append(ids, id)
	}
	return
}

// SuspendsIDs returns the "suspends" edge IDs in the mutation.
func (m *SubscribeMutation) SuspendsIDs() (ids []uint64) {
	for id := range m.suspends {
		ids = append(ids, id)
	}
	return
}

// ResetSuspends resets all changes to the "suspends" edge.
func (m *SubscribeMutation) ResetSuspends() {
	m.suspends = nil
	m.clearedsuspends = false
	m.removedsuspends = nil
}

// AddAlterIDs adds the "alters" edge to the SubscribeAlter entity by ids.
func (m *SubscribeMutation) AddAlterIDs(ids ...uint64) {
	if m.alters == nil {
		m.alters = make(map[uint64]struct{})
	}
	for i := range ids {
		m.alters[ids[i]] = struct{}{}
	}
}

// ClearAlters clears the "alters" edge to the SubscribeAlter entity.
func (m *SubscribeMutation) ClearAlters() {
	m.clearedalters = true
}

// AltersCleared reports if the "alters" edge to the SubscribeAlter entity was cleared.
func (m *SubscribeMutation) AltersCleared() bool {
	return m.clearedalters
}

// RemoveAlterIDs removes the "alters" edge to the SubscribeAlter entity by IDs.
func (m *SubscribeMutation) RemoveAlterIDs(ids ...uint64) {
	if m.removedalters == nil {
		m.removedalters = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.alters, ids[i])
		m.removedalters[ids[i]] = struct{}{}
	}
}

// RemovedAlters returns the removed IDs of the "alters" edge to the SubscribeAlter entity.
func (m *SubscribeMutation) RemovedAltersIDs() (ids []uint64) {
	for id := range m.removedalters {
		ids = append(ids, id)
	}
	return
}

// AltersIDs returns the "alters" edge IDs in the mutation.
func (m *SubscribeMutation) AltersIDs() (ids []uint64) {
	for id := range m.alters {
		ids = append(ids, id)
	}
	return
}

// ResetAlters resets all changes to the "alters" edge.
func (m *SubscribeMutation) ResetAlters() {
	m.alters = nil
	m.clearedalters = false
	m.removedalters = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *SubscribeMutation) AddOrderIDs(ids ...uint64) {
	if m.orders == nil {
		m.orders = make(map[uint64]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *SubscribeMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *SubscribeMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *SubscribeMutation) RemoveOrderIDs(ids ...uint64) {
	if m.removedorders == nil {
		m.removedorders = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *SubscribeMutation) RemovedOrdersIDs() (ids []uint64) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *SubscribeMutation) OrdersIDs() (ids []uint64) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *SubscribeMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// ClearInitialOrder clears the "initial_order" edge to the Order entity.
func (m *SubscribeMutation) ClearInitialOrder() {
	m.clearedinitial_order = true
	m.clearedFields[subscribe.FieldInitialOrderID] = struct{}{}
}

// InitialOrderCleared reports if the "initial_order" edge to the Order entity was cleared.
func (m *SubscribeMutation) InitialOrderCleared() bool {
	return m.InitialOrderIDCleared() || m.clearedinitial_order
}

// InitialOrderIDs returns the "initial_order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InitialOrderID instead. It exists only for internal usage by the builders.
func (m *SubscribeMutation) InitialOrderIDs() (ids []uint64) {
	if id := m.initial_order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInitialOrder resets all changes to the "initial_order" edge.
func (m *SubscribeMutation) ResetInitialOrder() {
	m.initial_order = nil
	m.clearedinitial_order = false
}

// AddBillIDs adds the "bills" edge to the EnterpriseBill entity by ids.
func (m *SubscribeMutation) AddBillIDs(ids ...uint64) {
	if m.bills == nil {
		m.bills = make(map[uint64]struct{})
	}
	for i := range ids {
		m.bills[ids[i]] = struct{}{}
	}
}

// ClearBills clears the "bills" edge to the EnterpriseBill entity.
func (m *SubscribeMutation) ClearBills() {
	m.clearedbills = true
}

// BillsCleared reports if the "bills" edge to the EnterpriseBill entity was cleared.
func (m *SubscribeMutation) BillsCleared() bool {
	return m.clearedbills
}

// RemoveBillIDs removes the "bills" edge to the EnterpriseBill entity by IDs.
func (m *SubscribeMutation) RemoveBillIDs(ids ...uint64) {
	if m.removedbills == nil {
		m.removedbills = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.bills, ids[i])
		m.removedbills[ids[i]] = struct{}{}
	}
}

// RemovedBills returns the removed IDs of the "bills" edge to the EnterpriseBill entity.
func (m *SubscribeMutation) RemovedBillsIDs() (ids []uint64) {
	for id := range m.removedbills {
		ids = append(ids, id)
	}
	return
}

// BillsIDs returns the "bills" edge IDs in the mutation.
func (m *SubscribeMutation) BillsIDs() (ids []uint64) {
	for id := range m.bills {
		ids = append(ids, id)
	}
	return
}

// ResetBills resets all changes to the "bills" edge.
func (m *SubscribeMutation) ResetBills() {
	m.bills = nil
	m.clearedbills = false
	m.removedbills = nil
}

// SetBatteryID sets the "battery" edge to the Battery entity by id.
func (m *SubscribeMutation) SetBatteryID(id uint64) {
	m.battery = &id
}

// ClearBattery clears the "battery" edge to the Battery entity.
func (m *SubscribeMutation) ClearBattery() {
	m.clearedbattery = true
}

// BatteryCleared reports if the "battery" edge to the Battery entity was cleared.
func (m *SubscribeMutation) BatteryCleared() bool {
	return m.clearedbattery
}

// BatteryID returns the "battery" edge ID in the mutation.
func (m *SubscribeMutation) BatteryID() (id uint64, exists bool) {
	if m.battery != nil {
		return *m.battery, true
	}
	return
}

// BatteryIDs returns the "battery" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BatteryID instead. It exists only for internal usage by the builders.
func (m *SubscribeMutation) BatteryIDs() (ids []uint64) {
	if id := m.battery; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBattery resets all changes to the "battery" edge.
func (m *SubscribeMutation) ResetBattery() {
	m.battery = nil
	m.clearedbattery = false
}

// Where appends a list predicates to the SubscribeMutation builder.
func (m *SubscribeMutation) Where(ps ...predicate.Subscribe) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscribeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscribeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Subscribe, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscribeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscribeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Subscribe).
func (m *SubscribeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscribeMutation) Fields() []string {
	fields := make([]string, 0, 39)
	if m.created_at != nil {
		fields = append(fields, subscribe.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscribe.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, subscribe.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, subscribe.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, subscribe.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, subscribe.FieldRemark)
	}
	if m.plan != nil {
		fields = append(fields, subscribe.FieldPlanID)
	}
	if m.employee != nil {
		fields = append(fields, subscribe.FieldEmployeeID)
	}
	if m.city != nil {
		fields = append(fields, subscribe.FieldCityID)
	}
	if m.station != nil {
		fields = append(fields, subscribe.FieldStationID)
	}
	if m.store != nil {
		fields = append(fields, subscribe.FieldStoreID)
	}
	if m.cabinet != nil {
		fields = append(fields, subscribe.FieldCabinetID)
	}
	if m.brand != nil {
		fields = append(fields, subscribe.FieldBrandID)
	}
	if m.ebike != nil {
		fields = append(fields, subscribe.FieldEbikeID)
	}
	if m.rider != nil {
		fields = append(fields, subscribe.FieldRiderID)
	}
	if m.initial_order != nil {
		fields = append(fields, subscribe.FieldInitialOrderID)
	}
	if m.enterprise != nil {
		fields = append(fields, subscribe.FieldEnterpriseID)
	}
	if m.status != nil {
		fields = append(fields, subscribe.FieldStatus)
	}
	if m._type != nil {
		fields = append(fields, subscribe.FieldType)
	}
	if m.model != nil {
		fields = append(fields, subscribe.FieldModel)
	}
	if m.initial_days != nil {
		fields = append(fields, subscribe.FieldInitialDays)
	}
	if m.alter_days != nil {
		fields = append(fields, subscribe.FieldAlterDays)
	}
	if m.pause_days != nil {
		fields = append(fields, subscribe.FieldPauseDays)
	}
	if m.suspend_days != nil {
		fields = append(fields, subscribe.FieldSuspendDays)
	}
	if m.renewal_days != nil {
		fields = append(fields, subscribe.FieldRenewalDays)
	}
	if m.overdue_days != nil {
		fields = append(fields, subscribe.FieldOverdueDays)
	}
	if m.remaining != nil {
		fields = append(fields, subscribe.FieldRemaining)
	}
	if m.paused_at != nil {
		fields = append(fields, subscribe.FieldPausedAt)
	}
	if m.suspend_at != nil {
		fields = append(fields, subscribe.FieldSuspendAt)
	}
	if m.start_at != nil {
		fields = append(fields, subscribe.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, subscribe.FieldEndAt)
	}
	if m.refund_at != nil {
		fields = append(fields, subscribe.FieldRefundAt)
	}
	if m.unsubscribe_reason != nil {
		fields = append(fields, subscribe.FieldUnsubscribeReason)
	}
	if m.last_bill_date != nil {
		fields = append(fields, subscribe.FieldLastBillDate)
	}
	if m.pause_overdue != nil {
		fields = append(fields, subscribe.FieldPauseOverdue)
	}
	if m.agent_end_at != nil {
		fields = append(fields, subscribe.FieldAgentEndAt)
	}
	if m.formula != nil {
		fields = append(fields, subscribe.FieldFormula)
	}
	if m.need_contract != nil {
		fields = append(fields, subscribe.FieldNeedContract)
	}
	if m.intelligent != nil {
		fields = append(fields, subscribe.FieldIntelligent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscribeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscribe.FieldCreatedAt:
		return m.CreatedAt()
	case subscribe.FieldUpdatedAt:
		return m.UpdatedAt()
	case subscribe.FieldDeletedAt:
		return m.DeletedAt()
	case subscribe.FieldCreator:
		return m.Creator()
	case subscribe.FieldLastModifier:
		return m.LastModifier()
	case subscribe.FieldRemark:
		return m.Remark()
	case subscribe.FieldPlanID:
		return m.PlanID()
	case subscribe.FieldEmployeeID:
		return m.EmployeeID()
	case subscribe.FieldCityID:
		return m.CityID()
	case subscribe.FieldStationID:
		return m.StationID()
	case subscribe.FieldStoreID:
		return m.StoreID()
	case subscribe.FieldCabinetID:
		return m.CabinetID()
	case subscribe.FieldBrandID:
		return m.BrandID()
	case subscribe.FieldEbikeID:
		return m.EbikeID()
	case subscribe.FieldRiderID:
		return m.RiderID()
	case subscribe.FieldInitialOrderID:
		return m.InitialOrderID()
	case subscribe.FieldEnterpriseID:
		return m.EnterpriseID()
	case subscribe.FieldStatus:
		return m.Status()
	case subscribe.FieldType:
		return m.GetType()
	case subscribe.FieldModel:
		return m.Model()
	case subscribe.FieldInitialDays:
		return m.InitialDays()
	case subscribe.FieldAlterDays:
		return m.AlterDays()
	case subscribe.FieldPauseDays:
		return m.PauseDays()
	case subscribe.FieldSuspendDays:
		return m.SuspendDays()
	case subscribe.FieldRenewalDays:
		return m.RenewalDays()
	case subscribe.FieldOverdueDays:
		return m.OverdueDays()
	case subscribe.FieldRemaining:
		return m.Remaining()
	case subscribe.FieldPausedAt:
		return m.PausedAt()
	case subscribe.FieldSuspendAt:
		return m.SuspendAt()
	case subscribe.FieldStartAt:
		return m.StartAt()
	case subscribe.FieldEndAt:
		return m.EndAt()
	case subscribe.FieldRefundAt:
		return m.RefundAt()
	case subscribe.FieldUnsubscribeReason:
		return m.UnsubscribeReason()
	case subscribe.FieldLastBillDate:
		return m.LastBillDate()
	case subscribe.FieldPauseOverdue:
		return m.PauseOverdue()
	case subscribe.FieldAgentEndAt:
		return m.AgentEndAt()
	case subscribe.FieldFormula:
		return m.Formula()
	case subscribe.FieldNeedContract:
		return m.NeedContract()
	case subscribe.FieldIntelligent:
		return m.Intelligent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscribeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscribe.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscribe.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subscribe.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subscribe.FieldCreator:
		return m.OldCreator(ctx)
	case subscribe.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case subscribe.FieldRemark:
		return m.OldRemark(ctx)
	case subscribe.FieldPlanID:
		return m.OldPlanID(ctx)
	case subscribe.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case subscribe.FieldCityID:
		return m.OldCityID(ctx)
	case subscribe.FieldStationID:
		return m.OldStationID(ctx)
	case subscribe.FieldStoreID:
		return m.OldStoreID(ctx)
	case subscribe.FieldCabinetID:
		return m.OldCabinetID(ctx)
	case subscribe.FieldBrandID:
		return m.OldBrandID(ctx)
	case subscribe.FieldEbikeID:
		return m.OldEbikeID(ctx)
	case subscribe.FieldRiderID:
		return m.OldRiderID(ctx)
	case subscribe.FieldInitialOrderID:
		return m.OldInitialOrderID(ctx)
	case subscribe.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case subscribe.FieldStatus:
		return m.OldStatus(ctx)
	case subscribe.FieldType:
		return m.OldType(ctx)
	case subscribe.FieldModel:
		return m.OldModel(ctx)
	case subscribe.FieldInitialDays:
		return m.OldInitialDays(ctx)
	case subscribe.FieldAlterDays:
		return m.OldAlterDays(ctx)
	case subscribe.FieldPauseDays:
		return m.OldPauseDays(ctx)
	case subscribe.FieldSuspendDays:
		return m.OldSuspendDays(ctx)
	case subscribe.FieldRenewalDays:
		return m.OldRenewalDays(ctx)
	case subscribe.FieldOverdueDays:
		return m.OldOverdueDays(ctx)
	case subscribe.FieldRemaining:
		return m.OldRemaining(ctx)
	case subscribe.FieldPausedAt:
		return m.OldPausedAt(ctx)
	case subscribe.FieldSuspendAt:
		return m.OldSuspendAt(ctx)
	case subscribe.FieldStartAt:
		return m.OldStartAt(ctx)
	case subscribe.FieldEndAt:
		return m.OldEndAt(ctx)
	case subscribe.FieldRefundAt:
		return m.OldRefundAt(ctx)
	case subscribe.FieldUnsubscribeReason:
		return m.OldUnsubscribeReason(ctx)
	case subscribe.FieldLastBillDate:
		return m.OldLastBillDate(ctx)
	case subscribe.FieldPauseOverdue:
		return m.OldPauseOverdue(ctx)
	case subscribe.FieldAgentEndAt:
		return m.OldAgentEndAt(ctx)
	case subscribe.FieldFormula:
		return m.OldFormula(ctx)
	case subscribe.FieldNeedContract:
		return m.OldNeedContract(ctx)
	case subscribe.FieldIntelligent:
		return m.OldIntelligent(ctx)
	}
	return nil, fmt.Errorf("unknown Subscribe field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscribeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscribe.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscribe.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subscribe.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subscribe.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case subscribe.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case subscribe.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case subscribe.FieldPlanID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanID(v)
		return nil
	case subscribe.FieldEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case subscribe.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case subscribe.FieldStationID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStationID(v)
		return nil
	case subscribe.FieldStoreID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case subscribe.FieldCabinetID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCabinetID(v)
		return nil
	case subscribe.FieldBrandID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrandID(v)
		return nil
	case subscribe.FieldEbikeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEbikeID(v)
		return nil
	case subscribe.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case subscribe.FieldInitialOrderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitialOrderID(v)
		return nil
	case subscribe.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case subscribe.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case subscribe.FieldType:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case subscribe.FieldModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModel(v)
		return nil
	case subscribe.FieldInitialDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitialDays(v)
		return nil
	case subscribe.FieldAlterDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlterDays(v)
		return nil
	case subscribe.FieldPauseDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPauseDays(v)
		return nil
	case subscribe.FieldSuspendDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuspendDays(v)
		return nil
	case subscribe.FieldRenewalDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRenewalDays(v)
		return nil
	case subscribe.FieldOverdueDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverdueDays(v)
		return nil
	case subscribe.FieldRemaining:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemaining(v)
		return nil
	case subscribe.FieldPausedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPausedAt(v)
		return nil
	case subscribe.FieldSuspendAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuspendAt(v)
		return nil
	case subscribe.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case subscribe.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case subscribe.FieldRefundAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefundAt(v)
		return nil
	case subscribe.FieldUnsubscribeReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnsubscribeReason(v)
		return nil
	case subscribe.FieldLastBillDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastBillDate(v)
		return nil
	case subscribe.FieldPauseOverdue:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPauseOverdue(v)
		return nil
	case subscribe.FieldAgentEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentEndAt(v)
		return nil
	case subscribe.FieldFormula:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormula(v)
		return nil
	case subscribe.FieldNeedContract:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeedContract(v)
		return nil
	case subscribe.FieldIntelligent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntelligent(v)
		return nil
	}
	return fmt.Errorf("unknown Subscribe field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscribeMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, subscribe.FieldStatus)
	}
	if m.add_type != nil {
		fields = append(fields, subscribe.FieldType)
	}
	if m.addinitial_days != nil {
		fields = append(fields, subscribe.FieldInitialDays)
	}
	if m.addalter_days != nil {
		fields = append(fields, subscribe.FieldAlterDays)
	}
	if m.addpause_days != nil {
		fields = append(fields, subscribe.FieldPauseDays)
	}
	if m.addsuspend_days != nil {
		fields = append(fields, subscribe.FieldSuspendDays)
	}
	if m.addrenewal_days != nil {
		fields = append(fields, subscribe.FieldRenewalDays)
	}
	if m.addoverdue_days != nil {
		fields = append(fields, subscribe.FieldOverdueDays)
	}
	if m.addremaining != nil {
		fields = append(fields, subscribe.FieldRemaining)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscribeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subscribe.FieldStatus:
		return m.AddedStatus()
	case subscribe.FieldType:
		return m.AddedType()
	case subscribe.FieldInitialDays:
		return m.AddedInitialDays()
	case subscribe.FieldAlterDays:
		return m.AddedAlterDays()
	case subscribe.FieldPauseDays:
		return m.AddedPauseDays()
	case subscribe.FieldSuspendDays:
		return m.AddedSuspendDays()
	case subscribe.FieldRenewalDays:
		return m.AddedRenewalDays()
	case subscribe.FieldOverdueDays:
		return m.AddedOverdueDays()
	case subscribe.FieldRemaining:
		return m.AddedRemaining()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscribeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subscribe.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case subscribe.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case subscribe.FieldInitialDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInitialDays(v)
		return nil
	case subscribe.FieldAlterDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAlterDays(v)
		return nil
	case subscribe.FieldPauseDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPauseDays(v)
		return nil
	case subscribe.FieldSuspendDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSuspendDays(v)
		return nil
	case subscribe.FieldRenewalDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRenewalDays(v)
		return nil
	case subscribe.FieldOverdueDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOverdueDays(v)
		return nil
	case subscribe.FieldRemaining:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRemaining(v)
		return nil
	}
	return fmt.Errorf("unknown Subscribe numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscribeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscribe.FieldDeletedAt) {
		fields = append(fields, subscribe.FieldDeletedAt)
	}
	if m.FieldCleared(subscribe.FieldCreator) {
		fields = append(fields, subscribe.FieldCreator)
	}
	if m.FieldCleared(subscribe.FieldLastModifier) {
		fields = append(fields, subscribe.FieldLastModifier)
	}
	if m.FieldCleared(subscribe.FieldRemark) {
		fields = append(fields, subscribe.FieldRemark)
	}
	if m.FieldCleared(subscribe.FieldPlanID) {
		fields = append(fields, subscribe.FieldPlanID)
	}
	if m.FieldCleared(subscribe.FieldEmployeeID) {
		fields = append(fields, subscribe.FieldEmployeeID)
	}
	if m.FieldCleared(subscribe.FieldStationID) {
		fields = append(fields, subscribe.FieldStationID)
	}
	if m.FieldCleared(subscribe.FieldStoreID) {
		fields = append(fields, subscribe.FieldStoreID)
	}
	if m.FieldCleared(subscribe.FieldCabinetID) {
		fields = append(fields, subscribe.FieldCabinetID)
	}
	if m.FieldCleared(subscribe.FieldBrandID) {
		fields = append(fields, subscribe.FieldBrandID)
	}
	if m.FieldCleared(subscribe.FieldEbikeID) {
		fields = append(fields, subscribe.FieldEbikeID)
	}
	if m.FieldCleared(subscribe.FieldInitialOrderID) {
		fields = append(fields, subscribe.FieldInitialOrderID)
	}
	if m.FieldCleared(subscribe.FieldEnterpriseID) {
		fields = append(fields, subscribe.FieldEnterpriseID)
	}
	if m.FieldCleared(subscribe.FieldInitialDays) {
		fields = append(fields, subscribe.FieldInitialDays)
	}
	if m.FieldCleared(subscribe.FieldPausedAt) {
		fields = append(fields, subscribe.FieldPausedAt)
	}
	if m.FieldCleared(subscribe.FieldSuspendAt) {
		fields = append(fields, subscribe.FieldSuspendAt)
	}
	if m.FieldCleared(subscribe.FieldStartAt) {
		fields = append(fields, subscribe.FieldStartAt)
	}
	if m.FieldCleared(subscribe.FieldEndAt) {
		fields = append(fields, subscribe.FieldEndAt)
	}
	if m.FieldCleared(subscribe.FieldRefundAt) {
		fields = append(fields, subscribe.FieldRefundAt)
	}
	if m.FieldCleared(subscribe.FieldUnsubscribeReason) {
		fields = append(fields, subscribe.FieldUnsubscribeReason)
	}
	if m.FieldCleared(subscribe.FieldLastBillDate) {
		fields = append(fields, subscribe.FieldLastBillDate)
	}
	if m.FieldCleared(subscribe.FieldAgentEndAt) {
		fields = append(fields, subscribe.FieldAgentEndAt)
	}
	if m.FieldCleared(subscribe.FieldFormula) {
		fields = append(fields, subscribe.FieldFormula)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscribeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscribeMutation) ClearField(name string) error {
	switch name {
	case subscribe.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case subscribe.FieldCreator:
		m.ClearCreator()
		return nil
	case subscribe.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case subscribe.FieldRemark:
		m.ClearRemark()
		return nil
	case subscribe.FieldPlanID:
		m.ClearPlanID()
		return nil
	case subscribe.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case subscribe.FieldStationID:
		m.ClearStationID()
		return nil
	case subscribe.FieldStoreID:
		m.ClearStoreID()
		return nil
	case subscribe.FieldCabinetID:
		m.ClearCabinetID()
		return nil
	case subscribe.FieldBrandID:
		m.ClearBrandID()
		return nil
	case subscribe.FieldEbikeID:
		m.ClearEbikeID()
		return nil
	case subscribe.FieldInitialOrderID:
		m.ClearInitialOrderID()
		return nil
	case subscribe.FieldEnterpriseID:
		m.ClearEnterpriseID()
		return nil
	case subscribe.FieldInitialDays:
		m.ClearInitialDays()
		return nil
	case subscribe.FieldPausedAt:
		m.ClearPausedAt()
		return nil
	case subscribe.FieldSuspendAt:
		m.ClearSuspendAt()
		return nil
	case subscribe.FieldStartAt:
		m.ClearStartAt()
		return nil
	case subscribe.FieldEndAt:
		m.ClearEndAt()
		return nil
	case subscribe.FieldRefundAt:
		m.ClearRefundAt()
		return nil
	case subscribe.FieldUnsubscribeReason:
		m.ClearUnsubscribeReason()
		return nil
	case subscribe.FieldLastBillDate:
		m.ClearLastBillDate()
		return nil
	case subscribe.FieldAgentEndAt:
		m.ClearAgentEndAt()
		return nil
	case subscribe.FieldFormula:
		m.ClearFormula()
		return nil
	}
	return fmt.Errorf("unknown Subscribe nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscribeMutation) ResetField(name string) error {
	switch name {
	case subscribe.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscribe.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subscribe.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subscribe.FieldCreator:
		m.ResetCreator()
		return nil
	case subscribe.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case subscribe.FieldRemark:
		m.ResetRemark()
		return nil
	case subscribe.FieldPlanID:
		m.ResetPlanID()
		return nil
	case subscribe.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case subscribe.FieldCityID:
		m.ResetCityID()
		return nil
	case subscribe.FieldStationID:
		m.ResetStationID()
		return nil
	case subscribe.FieldStoreID:
		m.ResetStoreID()
		return nil
	case subscribe.FieldCabinetID:
		m.ResetCabinetID()
		return nil
	case subscribe.FieldBrandID:
		m.ResetBrandID()
		return nil
	case subscribe.FieldEbikeID:
		m.ResetEbikeID()
		return nil
	case subscribe.FieldRiderID:
		m.ResetRiderID()
		return nil
	case subscribe.FieldInitialOrderID:
		m.ResetInitialOrderID()
		return nil
	case subscribe.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case subscribe.FieldStatus:
		m.ResetStatus()
		return nil
	case subscribe.FieldType:
		m.ResetType()
		return nil
	case subscribe.FieldModel:
		m.ResetModel()
		return nil
	case subscribe.FieldInitialDays:
		m.ResetInitialDays()
		return nil
	case subscribe.FieldAlterDays:
		m.ResetAlterDays()
		return nil
	case subscribe.FieldPauseDays:
		m.ResetPauseDays()
		return nil
	case subscribe.FieldSuspendDays:
		m.ResetSuspendDays()
		return nil
	case subscribe.FieldRenewalDays:
		m.ResetRenewalDays()
		return nil
	case subscribe.FieldOverdueDays:
		m.ResetOverdueDays()
		return nil
	case subscribe.FieldRemaining:
		m.ResetRemaining()
		return nil
	case subscribe.FieldPausedAt:
		m.ResetPausedAt()
		return nil
	case subscribe.FieldSuspendAt:
		m.ResetSuspendAt()
		return nil
	case subscribe.FieldStartAt:
		m.ResetStartAt()
		return nil
	case subscribe.FieldEndAt:
		m.ResetEndAt()
		return nil
	case subscribe.FieldRefundAt:
		m.ResetRefundAt()
		return nil
	case subscribe.FieldUnsubscribeReason:
		m.ResetUnsubscribeReason()
		return nil
	case subscribe.FieldLastBillDate:
		m.ResetLastBillDate()
		return nil
	case subscribe.FieldPauseOverdue:
		m.ResetPauseOverdue()
		return nil
	case subscribe.FieldAgentEndAt:
		m.ResetAgentEndAt()
		return nil
	case subscribe.FieldFormula:
		m.ResetFormula()
		return nil
	case subscribe.FieldNeedContract:
		m.ResetNeedContract()
		return nil
	case subscribe.FieldIntelligent:
		m.ResetIntelligent()
		return nil
	}
	return fmt.Errorf("unknown Subscribe field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscribeMutation) AddedEdges() []string {
	edges := make([]string, 0, 17)
	if m.plan != nil {
		edges = append(edges, subscribe.EdgePlan)
	}
	if m.employee != nil {
		edges = append(edges, subscribe.EdgeEmployee)
	}
	if m.city != nil {
		edges = append(edges, subscribe.EdgeCity)
	}
	if m.station != nil {
		edges = append(edges, subscribe.EdgeStation)
	}
	if m.store != nil {
		edges = append(edges, subscribe.EdgeStore)
	}
	if m.cabinet != nil {
		edges = append(edges, subscribe.EdgeCabinet)
	}
	if m.brand != nil {
		edges = append(edges, subscribe.EdgeBrand)
	}
	if m.ebike != nil {
		edges = append(edges, subscribe.EdgeEbike)
	}
	if m.rider != nil {
		edges = append(edges, subscribe.EdgeRider)
	}
	if m.enterprise != nil {
		edges = append(edges, subscribe.EdgeEnterprise)
	}
	if m.pauses != nil {
		edges = append(edges, subscribe.EdgePauses)
	}
	if m.suspends != nil {
		edges = append(edges, subscribe.EdgeSuspends)
	}
	if m.alters != nil {
		edges = append(edges, subscribe.EdgeAlters)
	}
	if m.orders != nil {
		edges = append(edges, subscribe.EdgeOrders)
	}
	if m.initial_order != nil {
		edges = append(edges, subscribe.EdgeInitialOrder)
	}
	if m.bills != nil {
		edges = append(edges, subscribe.EdgeBills)
	}
	if m.battery != nil {
		edges = append(edges, subscribe.EdgeBattery)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscribeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscribe.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	case subscribe.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case subscribe.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case subscribe.EdgeStation:
		if id := m.station; id != nil {
			return []ent.Value{*id}
		}
	case subscribe.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	case subscribe.EdgeCabinet:
		if id := m.cabinet; id != nil {
			return []ent.Value{*id}
		}
	case subscribe.EdgeBrand:
		if id := m.brand; id != nil {
			return []ent.Value{*id}
		}
	case subscribe.EdgeEbike:
		if id := m.ebike; id != nil {
			return []ent.Value{*id}
		}
	case subscribe.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case subscribe.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	case subscribe.EdgePauses:
		ids := make([]ent.Value, 0, len(m.pauses))
		for id := range m.pauses {
			ids = append(ids, id)
		}
		return ids
	case subscribe.EdgeSuspends:
		ids := make([]ent.Value, 0, len(m.suspends))
		for id := range m.suspends {
			ids = append(ids, id)
		}
		return ids
	case subscribe.EdgeAlters:
		ids := make([]ent.Value, 0, len(m.alters))
		for id := range m.alters {
			ids = append(ids, id)
		}
		return ids
	case subscribe.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case subscribe.EdgeInitialOrder:
		if id := m.initial_order; id != nil {
			return []ent.Value{*id}
		}
	case subscribe.EdgeBills:
		ids := make([]ent.Value, 0, len(m.bills))
		for id := range m.bills {
			ids = append(ids, id)
		}
		return ids
	case subscribe.EdgeBattery:
		if id := m.battery; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscribeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 17)
	if m.removedpauses != nil {
		edges = append(edges, subscribe.EdgePauses)
	}
	if m.removedsuspends != nil {
		edges = append(edges, subscribe.EdgeSuspends)
	}
	if m.removedalters != nil {
		edges = append(edges, subscribe.EdgeAlters)
	}
	if m.removedorders != nil {
		edges = append(edges, subscribe.EdgeOrders)
	}
	if m.removedbills != nil {
		edges = append(edges, subscribe.EdgeBills)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscribeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subscribe.EdgePauses:
		ids := make([]ent.Value, 0, len(m.removedpauses))
		for id := range m.removedpauses {
			ids = append(ids, id)
		}
		return ids
	case subscribe.EdgeSuspends:
		ids := make([]ent.Value, 0, len(m.removedsuspends))
		for id := range m.removedsuspends {
			ids = append(ids, id)
		}
		return ids
	case subscribe.EdgeAlters:
		ids := make([]ent.Value, 0, len(m.removedalters))
		for id := range m.removedalters {
			ids = append(ids, id)
		}
		return ids
	case subscribe.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case subscribe.EdgeBills:
		ids := make([]ent.Value, 0, len(m.removedbills))
		for id := range m.removedbills {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscribeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 17)
	if m.clearedplan {
		edges = append(edges, subscribe.EdgePlan)
	}
	if m.clearedemployee {
		edges = append(edges, subscribe.EdgeEmployee)
	}
	if m.clearedcity {
		edges = append(edges, subscribe.EdgeCity)
	}
	if m.clearedstation {
		edges = append(edges, subscribe.EdgeStation)
	}
	if m.clearedstore {
		edges = append(edges, subscribe.EdgeStore)
	}
	if m.clearedcabinet {
		edges = append(edges, subscribe.EdgeCabinet)
	}
	if m.clearedbrand {
		edges = append(edges, subscribe.EdgeBrand)
	}
	if m.clearedebike {
		edges = append(edges, subscribe.EdgeEbike)
	}
	if m.clearedrider {
		edges = append(edges, subscribe.EdgeRider)
	}
	if m.clearedenterprise {
		edges = append(edges, subscribe.EdgeEnterprise)
	}
	if m.clearedpauses {
		edges = append(edges, subscribe.EdgePauses)
	}
	if m.clearedsuspends {
		edges = append(edges, subscribe.EdgeSuspends)
	}
	if m.clearedalters {
		edges = append(edges, subscribe.EdgeAlters)
	}
	if m.clearedorders {
		edges = append(edges, subscribe.EdgeOrders)
	}
	if m.clearedinitial_order {
		edges = append(edges, subscribe.EdgeInitialOrder)
	}
	if m.clearedbills {
		edges = append(edges, subscribe.EdgeBills)
	}
	if m.clearedbattery {
		edges = append(edges, subscribe.EdgeBattery)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscribeMutation) EdgeCleared(name string) bool {
	switch name {
	case subscribe.EdgePlan:
		return m.clearedplan
	case subscribe.EdgeEmployee:
		return m.clearedemployee
	case subscribe.EdgeCity:
		return m.clearedcity
	case subscribe.EdgeStation:
		return m.clearedstation
	case subscribe.EdgeStore:
		return m.clearedstore
	case subscribe.EdgeCabinet:
		return m.clearedcabinet
	case subscribe.EdgeBrand:
		return m.clearedbrand
	case subscribe.EdgeEbike:
		return m.clearedebike
	case subscribe.EdgeRider:
		return m.clearedrider
	case subscribe.EdgeEnterprise:
		return m.clearedenterprise
	case subscribe.EdgePauses:
		return m.clearedpauses
	case subscribe.EdgeSuspends:
		return m.clearedsuspends
	case subscribe.EdgeAlters:
		return m.clearedalters
	case subscribe.EdgeOrders:
		return m.clearedorders
	case subscribe.EdgeInitialOrder:
		return m.clearedinitial_order
	case subscribe.EdgeBills:
		return m.clearedbills
	case subscribe.EdgeBattery:
		return m.clearedbattery
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscribeMutation) ClearEdge(name string) error {
	switch name {
	case subscribe.EdgePlan:
		m.ClearPlan()
		return nil
	case subscribe.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case subscribe.EdgeCity:
		m.ClearCity()
		return nil
	case subscribe.EdgeStation:
		m.ClearStation()
		return nil
	case subscribe.EdgeStore:
		m.ClearStore()
		return nil
	case subscribe.EdgeCabinet:
		m.ClearCabinet()
		return nil
	case subscribe.EdgeBrand:
		m.ClearBrand()
		return nil
	case subscribe.EdgeEbike:
		m.ClearEbike()
		return nil
	case subscribe.EdgeRider:
		m.ClearRider()
		return nil
	case subscribe.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	case subscribe.EdgeInitialOrder:
		m.ClearInitialOrder()
		return nil
	case subscribe.EdgeBattery:
		m.ClearBattery()
		return nil
	}
	return fmt.Errorf("unknown Subscribe unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscribeMutation) ResetEdge(name string) error {
	switch name {
	case subscribe.EdgePlan:
		m.ResetPlan()
		return nil
	case subscribe.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case subscribe.EdgeCity:
		m.ResetCity()
		return nil
	case subscribe.EdgeStation:
		m.ResetStation()
		return nil
	case subscribe.EdgeStore:
		m.ResetStore()
		return nil
	case subscribe.EdgeCabinet:
		m.ResetCabinet()
		return nil
	case subscribe.EdgeBrand:
		m.ResetBrand()
		return nil
	case subscribe.EdgeEbike:
		m.ResetEbike()
		return nil
	case subscribe.EdgeRider:
		m.ResetRider()
		return nil
	case subscribe.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	case subscribe.EdgePauses:
		m.ResetPauses()
		return nil
	case subscribe.EdgeSuspends:
		m.ResetSuspends()
		return nil
	case subscribe.EdgeAlters:
		m.ResetAlters()
		return nil
	case subscribe.EdgeOrders:
		m.ResetOrders()
		return nil
	case subscribe.EdgeInitialOrder:
		m.ResetInitialOrder()
		return nil
	case subscribe.EdgeBills:
		m.ResetBills()
		return nil
	case subscribe.EdgeBattery:
		m.ResetBattery()
		return nil
	}
	return fmt.Errorf("unknown Subscribe edge %s", name)
}

// SubscribeAlterMutation represents an operation that mutates the SubscribeAlter nodes in the graph.
type SubscribeAlterMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	creator           **model.Modifier
	last_modifier     **model.Modifier
	remark            *string
	days              *int
	adddays           *int
	status            *int
	addstatus         *int
	review_time       *time.Time
	subscribe_end_at  *time.Time
	clearedFields     map[string]struct{}
	rider             *uint64
	clearedrider      bool
	manager           *uint64
	clearedmanager    bool
	enterprise        *uint64
	clearedenterprise bool
	agent             *uint64
	clearedagent      bool
	subscribe         *uint64
	clearedsubscribe  bool
	done              bool
	oldValue          func(context.Context) (*SubscribeAlter, error)
	predicates        []predicate.SubscribeAlter
}

var _ ent.Mutation = (*SubscribeAlterMutation)(nil)

// subscribealterOption allows management of the mutation configuration using functional options.
type subscribealterOption func(*SubscribeAlterMutation)

// newSubscribeAlterMutation creates new mutation for the SubscribeAlter entity.
func newSubscribeAlterMutation(c config, op Op, opts ...subscribealterOption) *SubscribeAlterMutation {
	m := &SubscribeAlterMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscribeAlter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscribeAlterID sets the ID field of the mutation.
func withSubscribeAlterID(id uint64) subscribealterOption {
	return func(m *SubscribeAlterMutation) {
		var (
			err   error
			once  sync.Once
			value *SubscribeAlter
		)
		m.oldValue = func(ctx context.Context) (*SubscribeAlter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubscribeAlter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscribeAlter sets the old SubscribeAlter of the mutation.
func withSubscribeAlter(node *SubscribeAlter) subscribealterOption {
	return func(m *SubscribeAlterMutation) {
		m.oldValue = func(context.Context) (*SubscribeAlter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscribeAlterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscribeAlterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscribeAlterMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscribeAlterMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubscribeAlter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscribeAlterMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscribeAlterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscribeAlterMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscribeAlterMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscribeAlterMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscribeAlterMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreator sets the "creator" field.
func (m *SubscribeAlterMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *SubscribeAlterMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *SubscribeAlterMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[subscribealter.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *SubscribeAlterMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[subscribealter.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *SubscribeAlterMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, subscribealter.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *SubscribeAlterMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *SubscribeAlterMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *SubscribeAlterMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[subscribealter.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *SubscribeAlterMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[subscribealter.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *SubscribeAlterMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, subscribealter.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *SubscribeAlterMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *SubscribeAlterMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *SubscribeAlterMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[subscribealter.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *SubscribeAlterMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[subscribealter.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *SubscribeAlterMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, subscribealter.FieldRemark)
}

// SetRiderID sets the "rider_id" field.
func (m *SubscribeAlterMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *SubscribeAlterMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *SubscribeAlterMutation) ResetRiderID() {
	m.rider = nil
}

// SetManagerID sets the "manager_id" field.
func (m *SubscribeAlterMutation) SetManagerID(u uint64) {
	m.manager = &u
}

// ManagerID returns the value of the "manager_id" field in the mutation.
func (m *SubscribeAlterMutation) ManagerID() (r uint64, exists bool) {
	v := m.manager
	if v == nil {
		return
	}
	return *v, true
}

// OldManagerID returns the old "manager_id" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldManagerID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManagerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManagerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManagerID: %w", err)
	}
	return oldValue.ManagerID, nil
}

// ClearManagerID clears the value of the "manager_id" field.
func (m *SubscribeAlterMutation) ClearManagerID() {
	m.manager = nil
	m.clearedFields[subscribealter.FieldManagerID] = struct{}{}
}

// ManagerIDCleared returns if the "manager_id" field was cleared in this mutation.
func (m *SubscribeAlterMutation) ManagerIDCleared() bool {
	_, ok := m.clearedFields[subscribealter.FieldManagerID]
	return ok
}

// ResetManagerID resets all changes to the "manager_id" field.
func (m *SubscribeAlterMutation) ResetManagerID() {
	m.manager = nil
	delete(m.clearedFields, subscribealter.FieldManagerID)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *SubscribeAlterMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *SubscribeAlterMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldEnterpriseID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ClearEnterpriseID clears the value of the "enterprise_id" field.
func (m *SubscribeAlterMutation) ClearEnterpriseID() {
	m.enterprise = nil
	m.clearedFields[subscribealter.FieldEnterpriseID] = struct{}{}
}

// EnterpriseIDCleared returns if the "enterprise_id" field was cleared in this mutation.
func (m *SubscribeAlterMutation) EnterpriseIDCleared() bool {
	_, ok := m.clearedFields[subscribealter.FieldEnterpriseID]
	return ok
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *SubscribeAlterMutation) ResetEnterpriseID() {
	m.enterprise = nil
	delete(m.clearedFields, subscribealter.FieldEnterpriseID)
}

// SetAgentID sets the "agent_id" field.
func (m *SubscribeAlterMutation) SetAgentID(u uint64) {
	m.agent = &u
}

// AgentID returns the value of the "agent_id" field in the mutation.
func (m *SubscribeAlterMutation) AgentID() (r uint64, exists bool) {
	v := m.agent
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentID returns the old "agent_id" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldAgentID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentID: %w", err)
	}
	return oldValue.AgentID, nil
}

// ClearAgentID clears the value of the "agent_id" field.
func (m *SubscribeAlterMutation) ClearAgentID() {
	m.agent = nil
	m.clearedFields[subscribealter.FieldAgentID] = struct{}{}
}

// AgentIDCleared returns if the "agent_id" field was cleared in this mutation.
func (m *SubscribeAlterMutation) AgentIDCleared() bool {
	_, ok := m.clearedFields[subscribealter.FieldAgentID]
	return ok
}

// ResetAgentID resets all changes to the "agent_id" field.
func (m *SubscribeAlterMutation) ResetAgentID() {
	m.agent = nil
	delete(m.clearedFields, subscribealter.FieldAgentID)
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *SubscribeAlterMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *SubscribeAlterMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldSubscribeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *SubscribeAlterMutation) ResetSubscribeID() {
	m.subscribe = nil
}

// SetDays sets the "days" field.
func (m *SubscribeAlterMutation) SetDays(i int) {
	m.days = &i
	m.adddays = nil
}

// Days returns the value of the "days" field in the mutation.
func (m *SubscribeAlterMutation) Days() (r int, exists bool) {
	v := m.days
	if v == nil {
		return
	}
	return *v, true
}

// OldDays returns the old "days" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDays: %w", err)
	}
	return oldValue.Days, nil
}

// AddDays adds i to the "days" field.
func (m *SubscribeAlterMutation) AddDays(i int) {
	if m.adddays != nil {
		*m.adddays += i
	} else {
		m.adddays = &i
	}
}

// AddedDays returns the value that was added to the "days" field in this mutation.
func (m *SubscribeAlterMutation) AddedDays() (r int, exists bool) {
	v := m.adddays
	if v == nil {
		return
	}
	return *v, true
}

// ResetDays resets all changes to the "days" field.
func (m *SubscribeAlterMutation) ResetDays() {
	m.days = nil
	m.adddays = nil
}

// SetStatus sets the "status" field.
func (m *SubscribeAlterMutation) SetStatus(i int) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *SubscribeAlterMutation) Status() (r int, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldStatus(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *SubscribeAlterMutation) AddStatus(i int) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *SubscribeAlterMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *SubscribeAlterMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetReviewTime sets the "review_time" field.
func (m *SubscribeAlterMutation) SetReviewTime(t time.Time) {
	m.review_time = &t
}

// ReviewTime returns the value of the "review_time" field in the mutation.
func (m *SubscribeAlterMutation) ReviewTime() (r time.Time, exists bool) {
	v := m.review_time
	if v == nil {
		return
	}
	return *v, true
}

// OldReviewTime returns the old "review_time" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldReviewTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReviewTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReviewTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReviewTime: %w", err)
	}
	return oldValue.ReviewTime, nil
}

// ClearReviewTime clears the value of the "review_time" field.
func (m *SubscribeAlterMutation) ClearReviewTime() {
	m.review_time = nil
	m.clearedFields[subscribealter.FieldReviewTime] = struct{}{}
}

// ReviewTimeCleared returns if the "review_time" field was cleared in this mutation.
func (m *SubscribeAlterMutation) ReviewTimeCleared() bool {
	_, ok := m.clearedFields[subscribealter.FieldReviewTime]
	return ok
}

// ResetReviewTime resets all changes to the "review_time" field.
func (m *SubscribeAlterMutation) ResetReviewTime() {
	m.review_time = nil
	delete(m.clearedFields, subscribealter.FieldReviewTime)
}

// SetSubscribeEndAt sets the "subscribe_end_at" field.
func (m *SubscribeAlterMutation) SetSubscribeEndAt(t time.Time) {
	m.subscribe_end_at = &t
}

// SubscribeEndAt returns the value of the "subscribe_end_at" field in the mutation.
func (m *SubscribeAlterMutation) SubscribeEndAt() (r time.Time, exists bool) {
	v := m.subscribe_end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeEndAt returns the old "subscribe_end_at" field's value of the SubscribeAlter entity.
// If the SubscribeAlter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeAlterMutation) OldSubscribeEndAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeEndAt: %w", err)
	}
	return oldValue.SubscribeEndAt, nil
}

// ClearSubscribeEndAt clears the value of the "subscribe_end_at" field.
func (m *SubscribeAlterMutation) ClearSubscribeEndAt() {
	m.subscribe_end_at = nil
	m.clearedFields[subscribealter.FieldSubscribeEndAt] = struct{}{}
}

// SubscribeEndAtCleared returns if the "subscribe_end_at" field was cleared in this mutation.
func (m *SubscribeAlterMutation) SubscribeEndAtCleared() bool {
	_, ok := m.clearedFields[subscribealter.FieldSubscribeEndAt]
	return ok
}

// ResetSubscribeEndAt resets all changes to the "subscribe_end_at" field.
func (m *SubscribeAlterMutation) ResetSubscribeEndAt() {
	m.subscribe_end_at = nil
	delete(m.clearedFields, subscribealter.FieldSubscribeEndAt)
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *SubscribeAlterMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[subscribealter.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *SubscribeAlterMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *SubscribeAlterMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *SubscribeAlterMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearManager clears the "manager" edge to the Manager entity.
func (m *SubscribeAlterMutation) ClearManager() {
	m.clearedmanager = true
	m.clearedFields[subscribealter.FieldManagerID] = struct{}{}
}

// ManagerCleared reports if the "manager" edge to the Manager entity was cleared.
func (m *SubscribeAlterMutation) ManagerCleared() bool {
	return m.ManagerIDCleared() || m.clearedmanager
}

// ManagerIDs returns the "manager" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ManagerID instead. It exists only for internal usage by the builders.
func (m *SubscribeAlterMutation) ManagerIDs() (ids []uint64) {
	if id := m.manager; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetManager resets all changes to the "manager" edge.
func (m *SubscribeAlterMutation) ResetManager() {
	m.manager = nil
	m.clearedmanager = false
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *SubscribeAlterMutation) ClearEnterprise() {
	m.clearedenterprise = true
	m.clearedFields[subscribealter.FieldEnterpriseID] = struct{}{}
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *SubscribeAlterMutation) EnterpriseCleared() bool {
	return m.EnterpriseIDCleared() || m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *SubscribeAlterMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *SubscribeAlterMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// ClearAgent clears the "agent" edge to the Agent entity.
func (m *SubscribeAlterMutation) ClearAgent() {
	m.clearedagent = true
	m.clearedFields[subscribealter.FieldAgentID] = struct{}{}
}

// AgentCleared reports if the "agent" edge to the Agent entity was cleared.
func (m *SubscribeAlterMutation) AgentCleared() bool {
	return m.AgentIDCleared() || m.clearedagent
}

// AgentIDs returns the "agent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AgentID instead. It exists only for internal usage by the builders.
func (m *SubscribeAlterMutation) AgentIDs() (ids []uint64) {
	if id := m.agent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAgent resets all changes to the "agent" edge.
func (m *SubscribeAlterMutation) ResetAgent() {
	m.agent = nil
	m.clearedagent = false
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *SubscribeAlterMutation) ClearSubscribe() {
	m.clearedsubscribe = true
	m.clearedFields[subscribealter.FieldSubscribeID] = struct{}{}
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *SubscribeAlterMutation) SubscribeCleared() bool {
	return m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *SubscribeAlterMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *SubscribeAlterMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// Where appends a list predicates to the SubscribeAlterMutation builder.
func (m *SubscribeAlterMutation) Where(ps ...predicate.SubscribeAlter) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscribeAlterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscribeAlterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubscribeAlter, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscribeAlterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscribeAlterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubscribeAlter).
func (m *SubscribeAlterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscribeAlterMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, subscribealter.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscribealter.FieldUpdatedAt)
	}
	if m.creator != nil {
		fields = append(fields, subscribealter.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, subscribealter.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, subscribealter.FieldRemark)
	}
	if m.rider != nil {
		fields = append(fields, subscribealter.FieldRiderID)
	}
	if m.manager != nil {
		fields = append(fields, subscribealter.FieldManagerID)
	}
	if m.enterprise != nil {
		fields = append(fields, subscribealter.FieldEnterpriseID)
	}
	if m.agent != nil {
		fields = append(fields, subscribealter.FieldAgentID)
	}
	if m.subscribe != nil {
		fields = append(fields, subscribealter.FieldSubscribeID)
	}
	if m.days != nil {
		fields = append(fields, subscribealter.FieldDays)
	}
	if m.status != nil {
		fields = append(fields, subscribealter.FieldStatus)
	}
	if m.review_time != nil {
		fields = append(fields, subscribealter.FieldReviewTime)
	}
	if m.subscribe_end_at != nil {
		fields = append(fields, subscribealter.FieldSubscribeEndAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscribeAlterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscribealter.FieldCreatedAt:
		return m.CreatedAt()
	case subscribealter.FieldUpdatedAt:
		return m.UpdatedAt()
	case subscribealter.FieldCreator:
		return m.Creator()
	case subscribealter.FieldLastModifier:
		return m.LastModifier()
	case subscribealter.FieldRemark:
		return m.Remark()
	case subscribealter.FieldRiderID:
		return m.RiderID()
	case subscribealter.FieldManagerID:
		return m.ManagerID()
	case subscribealter.FieldEnterpriseID:
		return m.EnterpriseID()
	case subscribealter.FieldAgentID:
		return m.AgentID()
	case subscribealter.FieldSubscribeID:
		return m.SubscribeID()
	case subscribealter.FieldDays:
		return m.Days()
	case subscribealter.FieldStatus:
		return m.Status()
	case subscribealter.FieldReviewTime:
		return m.ReviewTime()
	case subscribealter.FieldSubscribeEndAt:
		return m.SubscribeEndAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscribeAlterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscribealter.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscribealter.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subscribealter.FieldCreator:
		return m.OldCreator(ctx)
	case subscribealter.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case subscribealter.FieldRemark:
		return m.OldRemark(ctx)
	case subscribealter.FieldRiderID:
		return m.OldRiderID(ctx)
	case subscribealter.FieldManagerID:
		return m.OldManagerID(ctx)
	case subscribealter.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case subscribealter.FieldAgentID:
		return m.OldAgentID(ctx)
	case subscribealter.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case subscribealter.FieldDays:
		return m.OldDays(ctx)
	case subscribealter.FieldStatus:
		return m.OldStatus(ctx)
	case subscribealter.FieldReviewTime:
		return m.OldReviewTime(ctx)
	case subscribealter.FieldSubscribeEndAt:
		return m.OldSubscribeEndAt(ctx)
	}
	return nil, fmt.Errorf("unknown SubscribeAlter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscribeAlterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscribealter.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscribealter.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subscribealter.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case subscribealter.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case subscribealter.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case subscribealter.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case subscribealter.FieldManagerID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManagerID(v)
		return nil
	case subscribealter.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case subscribealter.FieldAgentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentID(v)
		return nil
	case subscribealter.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case subscribealter.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDays(v)
		return nil
	case subscribealter.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case subscribealter.FieldReviewTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReviewTime(v)
		return nil
	case subscribealter.FieldSubscribeEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeEndAt(v)
		return nil
	}
	return fmt.Errorf("unknown SubscribeAlter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscribeAlterMutation) AddedFields() []string {
	var fields []string
	if m.adddays != nil {
		fields = append(fields, subscribealter.FieldDays)
	}
	if m.addstatus != nil {
		fields = append(fields, subscribealter.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscribeAlterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subscribealter.FieldDays:
		return m.AddedDays()
	case subscribealter.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscribeAlterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subscribealter.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDays(v)
		return nil
	case subscribealter.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown SubscribeAlter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscribeAlterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscribealter.FieldCreator) {
		fields = append(fields, subscribealter.FieldCreator)
	}
	if m.FieldCleared(subscribealter.FieldLastModifier) {
		fields = append(fields, subscribealter.FieldLastModifier)
	}
	if m.FieldCleared(subscribealter.FieldRemark) {
		fields = append(fields, subscribealter.FieldRemark)
	}
	if m.FieldCleared(subscribealter.FieldManagerID) {
		fields = append(fields, subscribealter.FieldManagerID)
	}
	if m.FieldCleared(subscribealter.FieldEnterpriseID) {
		fields = append(fields, subscribealter.FieldEnterpriseID)
	}
	if m.FieldCleared(subscribealter.FieldAgentID) {
		fields = append(fields, subscribealter.FieldAgentID)
	}
	if m.FieldCleared(subscribealter.FieldReviewTime) {
		fields = append(fields, subscribealter.FieldReviewTime)
	}
	if m.FieldCleared(subscribealter.FieldSubscribeEndAt) {
		fields = append(fields, subscribealter.FieldSubscribeEndAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscribeAlterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscribeAlterMutation) ClearField(name string) error {
	switch name {
	case subscribealter.FieldCreator:
		m.ClearCreator()
		return nil
	case subscribealter.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case subscribealter.FieldRemark:
		m.ClearRemark()
		return nil
	case subscribealter.FieldManagerID:
		m.ClearManagerID()
		return nil
	case subscribealter.FieldEnterpriseID:
		m.ClearEnterpriseID()
		return nil
	case subscribealter.FieldAgentID:
		m.ClearAgentID()
		return nil
	case subscribealter.FieldReviewTime:
		m.ClearReviewTime()
		return nil
	case subscribealter.FieldSubscribeEndAt:
		m.ClearSubscribeEndAt()
		return nil
	}
	return fmt.Errorf("unknown SubscribeAlter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscribeAlterMutation) ResetField(name string) error {
	switch name {
	case subscribealter.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscribealter.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subscribealter.FieldCreator:
		m.ResetCreator()
		return nil
	case subscribealter.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case subscribealter.FieldRemark:
		m.ResetRemark()
		return nil
	case subscribealter.FieldRiderID:
		m.ResetRiderID()
		return nil
	case subscribealter.FieldManagerID:
		m.ResetManagerID()
		return nil
	case subscribealter.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case subscribealter.FieldAgentID:
		m.ResetAgentID()
		return nil
	case subscribealter.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case subscribealter.FieldDays:
		m.ResetDays()
		return nil
	case subscribealter.FieldStatus:
		m.ResetStatus()
		return nil
	case subscribealter.FieldReviewTime:
		m.ResetReviewTime()
		return nil
	case subscribealter.FieldSubscribeEndAt:
		m.ResetSubscribeEndAt()
		return nil
	}
	return fmt.Errorf("unknown SubscribeAlter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscribeAlterMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.rider != nil {
		edges = append(edges, subscribealter.EdgeRider)
	}
	if m.manager != nil {
		edges = append(edges, subscribealter.EdgeManager)
	}
	if m.enterprise != nil {
		edges = append(edges, subscribealter.EdgeEnterprise)
	}
	if m.agent != nil {
		edges = append(edges, subscribealter.EdgeAgent)
	}
	if m.subscribe != nil {
		edges = append(edges, subscribealter.EdgeSubscribe)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscribeAlterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscribealter.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case subscribealter.EdgeManager:
		if id := m.manager; id != nil {
			return []ent.Value{*id}
		}
	case subscribealter.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	case subscribealter.EdgeAgent:
		if id := m.agent; id != nil {
			return []ent.Value{*id}
		}
	case subscribealter.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscribeAlterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscribeAlterMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscribeAlterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedrider {
		edges = append(edges, subscribealter.EdgeRider)
	}
	if m.clearedmanager {
		edges = append(edges, subscribealter.EdgeManager)
	}
	if m.clearedenterprise {
		edges = append(edges, subscribealter.EdgeEnterprise)
	}
	if m.clearedagent {
		edges = append(edges, subscribealter.EdgeAgent)
	}
	if m.clearedsubscribe {
		edges = append(edges, subscribealter.EdgeSubscribe)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscribeAlterMutation) EdgeCleared(name string) bool {
	switch name {
	case subscribealter.EdgeRider:
		return m.clearedrider
	case subscribealter.EdgeManager:
		return m.clearedmanager
	case subscribealter.EdgeEnterprise:
		return m.clearedenterprise
	case subscribealter.EdgeAgent:
		return m.clearedagent
	case subscribealter.EdgeSubscribe:
		return m.clearedsubscribe
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscribeAlterMutation) ClearEdge(name string) error {
	switch name {
	case subscribealter.EdgeRider:
		m.ClearRider()
		return nil
	case subscribealter.EdgeManager:
		m.ClearManager()
		return nil
	case subscribealter.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	case subscribealter.EdgeAgent:
		m.ClearAgent()
		return nil
	case subscribealter.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	}
	return fmt.Errorf("unknown SubscribeAlter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscribeAlterMutation) ResetEdge(name string) error {
	switch name {
	case subscribealter.EdgeRider:
		m.ResetRider()
		return nil
	case subscribealter.EdgeManager:
		m.ResetManager()
		return nil
	case subscribealter.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	case subscribealter.EdgeAgent:
		m.ResetAgent()
		return nil
	case subscribealter.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	}
	return fmt.Errorf("unknown SubscribeAlter edge %s", name)
}

// SubscribePauseMutation represents an operation that mutates the SubscribePause nodes in the graph.
type SubscribePauseMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uint64
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	creator             **model.Modifier
	last_modifier       **model.Modifier
	remark              *string
	start_at            *time.Time
	end_at              *time.Time
	days                *int
	adddays             *int
	overdue_days        *int
	addoverdue_days     *int
	end_modifier        **model.Modifier
	pause_overdue       *bool
	suspend_days        *int
	addsuspend_days     *int
	clearedFields       map[string]struct{}
	rider               *uint64
	clearedrider        bool
	employee            *uint64
	clearedemployee     bool
	city                *uint64
	clearedcity         bool
	store               *uint64
	clearedstore        bool
	endStore            *uint64
	clearedendStore     bool
	cabinet             *uint64
	clearedcabinet      bool
	endCabinet          *uint64
	clearedendCabinet   bool
	subscribe           *uint64
	clearedsubscribe    bool
	end_employee        *uint64
	clearedend_employee bool
	suspends            map[uint64]struct{}
	removedsuspends     map[uint64]struct{}
	clearedsuspends     bool
	done                bool
	oldValue            func(context.Context) (*SubscribePause, error)
	predicates          []predicate.SubscribePause
}

var _ ent.Mutation = (*SubscribePauseMutation)(nil)

// subscribepauseOption allows management of the mutation configuration using functional options.
type subscribepauseOption func(*SubscribePauseMutation)

// newSubscribePauseMutation creates new mutation for the SubscribePause entity.
func newSubscribePauseMutation(c config, op Op, opts ...subscribepauseOption) *SubscribePauseMutation {
	m := &SubscribePauseMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscribePause,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscribePauseID sets the ID field of the mutation.
func withSubscribePauseID(id uint64) subscribepauseOption {
	return func(m *SubscribePauseMutation) {
		var (
			err   error
			once  sync.Once
			value *SubscribePause
		)
		m.oldValue = func(ctx context.Context) (*SubscribePause, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubscribePause.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscribePause sets the old SubscribePause of the mutation.
func withSubscribePause(node *SubscribePause) subscribepauseOption {
	return func(m *SubscribePauseMutation) {
		m.oldValue = func(context.Context) (*SubscribePause, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscribePauseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscribePauseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscribePauseMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscribePauseMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubscribePause.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscribePauseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscribePauseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscribePauseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscribePauseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscribePauseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscribePauseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SubscribePauseMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SubscribePauseMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SubscribePauseMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[subscribepause.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SubscribePauseMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[subscribepause.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SubscribePauseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, subscribepause.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *SubscribePauseMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *SubscribePauseMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *SubscribePauseMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[subscribepause.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *SubscribePauseMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[subscribepause.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *SubscribePauseMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, subscribepause.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *SubscribePauseMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *SubscribePauseMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *SubscribePauseMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[subscribepause.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *SubscribePauseMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[subscribepause.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *SubscribePauseMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, subscribepause.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *SubscribePauseMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *SubscribePauseMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *SubscribePauseMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[subscribepause.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *SubscribePauseMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[subscribepause.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *SubscribePauseMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, subscribepause.FieldRemark)
}

// SetRiderID sets the "rider_id" field.
func (m *SubscribePauseMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *SubscribePauseMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *SubscribePauseMutation) ResetRiderID() {
	m.rider = nil
}

// SetEmployeeID sets the "employee_id" field.
func (m *SubscribePauseMutation) SetEmployeeID(u uint64) {
	m.employee = &u
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *SubscribePauseMutation) EmployeeID() (r uint64, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldEmployeeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *SubscribePauseMutation) ClearEmployeeID() {
	m.employee = nil
	m.clearedFields[subscribepause.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *SubscribePauseMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[subscribepause.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *SubscribePauseMutation) ResetEmployeeID() {
	m.employee = nil
	delete(m.clearedFields, subscribepause.FieldEmployeeID)
}

// SetCityID sets the "city_id" field.
func (m *SubscribePauseMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *SubscribePauseMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldCityID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ClearCityID clears the value of the "city_id" field.
func (m *SubscribePauseMutation) ClearCityID() {
	m.city = nil
	m.clearedFields[subscribepause.FieldCityID] = struct{}{}
}

// CityIDCleared returns if the "city_id" field was cleared in this mutation.
func (m *SubscribePauseMutation) CityIDCleared() bool {
	_, ok := m.clearedFields[subscribepause.FieldCityID]
	return ok
}

// ResetCityID resets all changes to the "city_id" field.
func (m *SubscribePauseMutation) ResetCityID() {
	m.city = nil
	delete(m.clearedFields, subscribepause.FieldCityID)
}

// SetStoreID sets the "store_id" field.
func (m *SubscribePauseMutation) SetStoreID(u uint64) {
	m.store = &u
}

// StoreID returns the value of the "store_id" field in the mutation.
func (m *SubscribePauseMutation) StoreID() (r uint64, exists bool) {
	v := m.store
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreID returns the old "store_id" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldStoreID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreID: %w", err)
	}
	return oldValue.StoreID, nil
}

// ClearStoreID clears the value of the "store_id" field.
func (m *SubscribePauseMutation) ClearStoreID() {
	m.store = nil
	m.clearedFields[subscribepause.FieldStoreID] = struct{}{}
}

// StoreIDCleared returns if the "store_id" field was cleared in this mutation.
func (m *SubscribePauseMutation) StoreIDCleared() bool {
	_, ok := m.clearedFields[subscribepause.FieldStoreID]
	return ok
}

// ResetStoreID resets all changes to the "store_id" field.
func (m *SubscribePauseMutation) ResetStoreID() {
	m.store = nil
	delete(m.clearedFields, subscribepause.FieldStoreID)
}

// SetEndStoreID sets the "end_store_id" field.
func (m *SubscribePauseMutation) SetEndStoreID(u uint64) {
	m.endStore = &u
}

// EndStoreID returns the value of the "end_store_id" field in the mutation.
func (m *SubscribePauseMutation) EndStoreID() (r uint64, exists bool) {
	v := m.endStore
	if v == nil {
		return
	}
	return *v, true
}

// OldEndStoreID returns the old "end_store_id" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldEndStoreID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndStoreID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndStoreID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndStoreID: %w", err)
	}
	return oldValue.EndStoreID, nil
}

// ClearEndStoreID clears the value of the "end_store_id" field.
func (m *SubscribePauseMutation) ClearEndStoreID() {
	m.endStore = nil
	m.clearedFields[subscribepause.FieldEndStoreID] = struct{}{}
}

// EndStoreIDCleared returns if the "end_store_id" field was cleared in this mutation.
func (m *SubscribePauseMutation) EndStoreIDCleared() bool {
	_, ok := m.clearedFields[subscribepause.FieldEndStoreID]
	return ok
}

// ResetEndStoreID resets all changes to the "end_store_id" field.
func (m *SubscribePauseMutation) ResetEndStoreID() {
	m.endStore = nil
	delete(m.clearedFields, subscribepause.FieldEndStoreID)
}

// SetCabinetID sets the "cabinet_id" field.
func (m *SubscribePauseMutation) SetCabinetID(u uint64) {
	m.cabinet = &u
}

// CabinetID returns the value of the "cabinet_id" field in the mutation.
func (m *SubscribePauseMutation) CabinetID() (r uint64, exists bool) {
	v := m.cabinet
	if v == nil {
		return
	}
	return *v, true
}

// OldCabinetID returns the old "cabinet_id" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldCabinetID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCabinetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCabinetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCabinetID: %w", err)
	}
	return oldValue.CabinetID, nil
}

// ClearCabinetID clears the value of the "cabinet_id" field.
func (m *SubscribePauseMutation) ClearCabinetID() {
	m.cabinet = nil
	m.clearedFields[subscribepause.FieldCabinetID] = struct{}{}
}

// CabinetIDCleared returns if the "cabinet_id" field was cleared in this mutation.
func (m *SubscribePauseMutation) CabinetIDCleared() bool {
	_, ok := m.clearedFields[subscribepause.FieldCabinetID]
	return ok
}

// ResetCabinetID resets all changes to the "cabinet_id" field.
func (m *SubscribePauseMutation) ResetCabinetID() {
	m.cabinet = nil
	delete(m.clearedFields, subscribepause.FieldCabinetID)
}

// SetEndCabinetID sets the "end_cabinet_id" field.
func (m *SubscribePauseMutation) SetEndCabinetID(u uint64) {
	m.endCabinet = &u
}

// EndCabinetID returns the value of the "end_cabinet_id" field in the mutation.
func (m *SubscribePauseMutation) EndCabinetID() (r uint64, exists bool) {
	v := m.endCabinet
	if v == nil {
		return
	}
	return *v, true
}

// OldEndCabinetID returns the old "end_cabinet_id" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldEndCabinetID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndCabinetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndCabinetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndCabinetID: %w", err)
	}
	return oldValue.EndCabinetID, nil
}

// ClearEndCabinetID clears the value of the "end_cabinet_id" field.
func (m *SubscribePauseMutation) ClearEndCabinetID() {
	m.endCabinet = nil
	m.clearedFields[subscribepause.FieldEndCabinetID] = struct{}{}
}

// EndCabinetIDCleared returns if the "end_cabinet_id" field was cleared in this mutation.
func (m *SubscribePauseMutation) EndCabinetIDCleared() bool {
	_, ok := m.clearedFields[subscribepause.FieldEndCabinetID]
	return ok
}

// ResetEndCabinetID resets all changes to the "end_cabinet_id" field.
func (m *SubscribePauseMutation) ResetEndCabinetID() {
	m.endCabinet = nil
	delete(m.clearedFields, subscribepause.FieldEndCabinetID)
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *SubscribePauseMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *SubscribePauseMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldSubscribeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *SubscribePauseMutation) ResetSubscribeID() {
	m.subscribe = nil
}

// SetStartAt sets the "start_at" field.
func (m *SubscribePauseMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *SubscribePauseMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *SubscribePauseMutation) ResetStartAt() {
	m.start_at = nil
}

// SetEndAt sets the "end_at" field.
func (m *SubscribePauseMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *SubscribePauseMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *SubscribePauseMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[subscribepause.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *SubscribePauseMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[subscribepause.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *SubscribePauseMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, subscribepause.FieldEndAt)
}

// SetDays sets the "days" field.
func (m *SubscribePauseMutation) SetDays(i int) {
	m.days = &i
	m.adddays = nil
}

// Days returns the value of the "days" field in the mutation.
func (m *SubscribePauseMutation) Days() (r int, exists bool) {
	v := m.days
	if v == nil {
		return
	}
	return *v, true
}

// OldDays returns the old "days" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDays: %w", err)
	}
	return oldValue.Days, nil
}

// AddDays adds i to the "days" field.
func (m *SubscribePauseMutation) AddDays(i int) {
	if m.adddays != nil {
		*m.adddays += i
	} else {
		m.adddays = &i
	}
}

// AddedDays returns the value that was added to the "days" field in this mutation.
func (m *SubscribePauseMutation) AddedDays() (r int, exists bool) {
	v := m.adddays
	if v == nil {
		return
	}
	return *v, true
}

// ClearDays clears the value of the "days" field.
func (m *SubscribePauseMutation) ClearDays() {
	m.days = nil
	m.adddays = nil
	m.clearedFields[subscribepause.FieldDays] = struct{}{}
}

// DaysCleared returns if the "days" field was cleared in this mutation.
func (m *SubscribePauseMutation) DaysCleared() bool {
	_, ok := m.clearedFields[subscribepause.FieldDays]
	return ok
}

// ResetDays resets all changes to the "days" field.
func (m *SubscribePauseMutation) ResetDays() {
	m.days = nil
	m.adddays = nil
	delete(m.clearedFields, subscribepause.FieldDays)
}

// SetEndEmployeeID sets the "end_employee_id" field.
func (m *SubscribePauseMutation) SetEndEmployeeID(u uint64) {
	m.end_employee = &u
}

// EndEmployeeID returns the value of the "end_employee_id" field in the mutation.
func (m *SubscribePauseMutation) EndEmployeeID() (r uint64, exists bool) {
	v := m.end_employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEndEmployeeID returns the old "end_employee_id" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldEndEmployeeID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndEmployeeID: %w", err)
	}
	return oldValue.EndEmployeeID, nil
}

// ClearEndEmployeeID clears the value of the "end_employee_id" field.
func (m *SubscribePauseMutation) ClearEndEmployeeID() {
	m.end_employee = nil
	m.clearedFields[subscribepause.FieldEndEmployeeID] = struct{}{}
}

// EndEmployeeIDCleared returns if the "end_employee_id" field was cleared in this mutation.
func (m *SubscribePauseMutation) EndEmployeeIDCleared() bool {
	_, ok := m.clearedFields[subscribepause.FieldEndEmployeeID]
	return ok
}

// ResetEndEmployeeID resets all changes to the "end_employee_id" field.
func (m *SubscribePauseMutation) ResetEndEmployeeID() {
	m.end_employee = nil
	delete(m.clearedFields, subscribepause.FieldEndEmployeeID)
}

// SetOverdueDays sets the "overdue_days" field.
func (m *SubscribePauseMutation) SetOverdueDays(i int) {
	m.overdue_days = &i
	m.addoverdue_days = nil
}

// OverdueDays returns the value of the "overdue_days" field in the mutation.
func (m *SubscribePauseMutation) OverdueDays() (r int, exists bool) {
	v := m.overdue_days
	if v == nil {
		return
	}
	return *v, true
}

// OldOverdueDays returns the old "overdue_days" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldOverdueDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverdueDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverdueDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverdueDays: %w", err)
	}
	return oldValue.OverdueDays, nil
}

// AddOverdueDays adds i to the "overdue_days" field.
func (m *SubscribePauseMutation) AddOverdueDays(i int) {
	if m.addoverdue_days != nil {
		*m.addoverdue_days += i
	} else {
		m.addoverdue_days = &i
	}
}

// AddedOverdueDays returns the value that was added to the "overdue_days" field in this mutation.
func (m *SubscribePauseMutation) AddedOverdueDays() (r int, exists bool) {
	v := m.addoverdue_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetOverdueDays resets all changes to the "overdue_days" field.
func (m *SubscribePauseMutation) ResetOverdueDays() {
	m.overdue_days = nil
	m.addoverdue_days = nil
}

// SetEndModifier sets the "end_modifier" field.
func (m *SubscribePauseMutation) SetEndModifier(value *model.Modifier) {
	m.end_modifier = &value
}

// EndModifier returns the value of the "end_modifier" field in the mutation.
func (m *SubscribePauseMutation) EndModifier() (r *model.Modifier, exists bool) {
	v := m.end_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldEndModifier returns the old "end_modifier" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldEndModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndModifier: %w", err)
	}
	return oldValue.EndModifier, nil
}

// ClearEndModifier clears the value of the "end_modifier" field.
func (m *SubscribePauseMutation) ClearEndModifier() {
	m.end_modifier = nil
	m.clearedFields[subscribepause.FieldEndModifier] = struct{}{}
}

// EndModifierCleared returns if the "end_modifier" field was cleared in this mutation.
func (m *SubscribePauseMutation) EndModifierCleared() bool {
	_, ok := m.clearedFields[subscribepause.FieldEndModifier]
	return ok
}

// ResetEndModifier resets all changes to the "end_modifier" field.
func (m *SubscribePauseMutation) ResetEndModifier() {
	m.end_modifier = nil
	delete(m.clearedFields, subscribepause.FieldEndModifier)
}

// SetPauseOverdue sets the "pause_overdue" field.
func (m *SubscribePauseMutation) SetPauseOverdue(b bool) {
	m.pause_overdue = &b
}

// PauseOverdue returns the value of the "pause_overdue" field in the mutation.
func (m *SubscribePauseMutation) PauseOverdue() (r bool, exists bool) {
	v := m.pause_overdue
	if v == nil {
		return
	}
	return *v, true
}

// OldPauseOverdue returns the old "pause_overdue" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldPauseOverdue(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPauseOverdue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPauseOverdue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPauseOverdue: %w", err)
	}
	return oldValue.PauseOverdue, nil
}

// ResetPauseOverdue resets all changes to the "pause_overdue" field.
func (m *SubscribePauseMutation) ResetPauseOverdue() {
	m.pause_overdue = nil
}

// SetSuspendDays sets the "suspend_days" field.
func (m *SubscribePauseMutation) SetSuspendDays(i int) {
	m.suspend_days = &i
	m.addsuspend_days = nil
}

// SuspendDays returns the value of the "suspend_days" field in the mutation.
func (m *SubscribePauseMutation) SuspendDays() (r int, exists bool) {
	v := m.suspend_days
	if v == nil {
		return
	}
	return *v, true
}

// OldSuspendDays returns the old "suspend_days" field's value of the SubscribePause entity.
// If the SubscribePause object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribePauseMutation) OldSuspendDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuspendDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuspendDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuspendDays: %w", err)
	}
	return oldValue.SuspendDays, nil
}

// AddSuspendDays adds i to the "suspend_days" field.
func (m *SubscribePauseMutation) AddSuspendDays(i int) {
	if m.addsuspend_days != nil {
		*m.addsuspend_days += i
	} else {
		m.addsuspend_days = &i
	}
}

// AddedSuspendDays returns the value that was added to the "suspend_days" field in this mutation.
func (m *SubscribePauseMutation) AddedSuspendDays() (r int, exists bool) {
	v := m.addsuspend_days
	if v == nil {
		return
	}
	return *v, true
}

// ResetSuspendDays resets all changes to the "suspend_days" field.
func (m *SubscribePauseMutation) ResetSuspendDays() {
	m.suspend_days = nil
	m.addsuspend_days = nil
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *SubscribePauseMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[subscribepause.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *SubscribePauseMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *SubscribePauseMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *SubscribePauseMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *SubscribePauseMutation) ClearEmployee() {
	m.clearedemployee = true
	m.clearedFields[subscribepause.FieldEmployeeID] = struct{}{}
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *SubscribePauseMutation) EmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *SubscribePauseMutation) EmployeeIDs() (ids []uint64) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *SubscribePauseMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *SubscribePauseMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[subscribepause.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *SubscribePauseMutation) CityCleared() bool {
	return m.CityIDCleared() || m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *SubscribePauseMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *SubscribePauseMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearStore clears the "store" edge to the Store entity.
func (m *SubscribePauseMutation) ClearStore() {
	m.clearedstore = true
	m.clearedFields[subscribepause.FieldStoreID] = struct{}{}
}

// StoreCleared reports if the "store" edge to the Store entity was cleared.
func (m *SubscribePauseMutation) StoreCleared() bool {
	return m.StoreIDCleared() || m.clearedstore
}

// StoreIDs returns the "store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StoreID instead. It exists only for internal usage by the builders.
func (m *SubscribePauseMutation) StoreIDs() (ids []uint64) {
	if id := m.store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStore resets all changes to the "store" edge.
func (m *SubscribePauseMutation) ResetStore() {
	m.store = nil
	m.clearedstore = false
}

// ClearEndStore clears the "endStore" edge to the Store entity.
func (m *SubscribePauseMutation) ClearEndStore() {
	m.clearedendStore = true
	m.clearedFields[subscribepause.FieldEndStoreID] = struct{}{}
}

// EndStoreCleared reports if the "endStore" edge to the Store entity was cleared.
func (m *SubscribePauseMutation) EndStoreCleared() bool {
	return m.EndStoreIDCleared() || m.clearedendStore
}

// EndStoreIDs returns the "endStore" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EndStoreID instead. It exists only for internal usage by the builders.
func (m *SubscribePauseMutation) EndStoreIDs() (ids []uint64) {
	if id := m.endStore; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEndStore resets all changes to the "endStore" edge.
func (m *SubscribePauseMutation) ResetEndStore() {
	m.endStore = nil
	m.clearedendStore = false
}

// ClearCabinet clears the "cabinet" edge to the Cabinet entity.
func (m *SubscribePauseMutation) ClearCabinet() {
	m.clearedcabinet = true
	m.clearedFields[subscribepause.FieldCabinetID] = struct{}{}
}

// CabinetCleared reports if the "cabinet" edge to the Cabinet entity was cleared.
func (m *SubscribePauseMutation) CabinetCleared() bool {
	return m.CabinetIDCleared() || m.clearedcabinet
}

// CabinetIDs returns the "cabinet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CabinetID instead. It exists only for internal usage by the builders.
func (m *SubscribePauseMutation) CabinetIDs() (ids []uint64) {
	if id := m.cabinet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCabinet resets all changes to the "cabinet" edge.
func (m *SubscribePauseMutation) ResetCabinet() {
	m.cabinet = nil
	m.clearedcabinet = false
}

// ClearEndCabinet clears the "endCabinet" edge to the Cabinet entity.
func (m *SubscribePauseMutation) ClearEndCabinet() {
	m.clearedendCabinet = true
	m.clearedFields[subscribepause.FieldEndCabinetID] = struct{}{}
}

// EndCabinetCleared reports if the "endCabinet" edge to the Cabinet entity was cleared.
func (m *SubscribePauseMutation) EndCabinetCleared() bool {
	return m.EndCabinetIDCleared() || m.clearedendCabinet
}

// EndCabinetIDs returns the "endCabinet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EndCabinetID instead. It exists only for internal usage by the builders.
func (m *SubscribePauseMutation) EndCabinetIDs() (ids []uint64) {
	if id := m.endCabinet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEndCabinet resets all changes to the "endCabinet" edge.
func (m *SubscribePauseMutation) ResetEndCabinet() {
	m.endCabinet = nil
	m.clearedendCabinet = false
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *SubscribePauseMutation) ClearSubscribe() {
	m.clearedsubscribe = true
	m.clearedFields[subscribepause.FieldSubscribeID] = struct{}{}
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *SubscribePauseMutation) SubscribeCleared() bool {
	return m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *SubscribePauseMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *SubscribePauseMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// ClearEndEmployee clears the "end_employee" edge to the Employee entity.
func (m *SubscribePauseMutation) ClearEndEmployee() {
	m.clearedend_employee = true
	m.clearedFields[subscribepause.FieldEndEmployeeID] = struct{}{}
}

// EndEmployeeCleared reports if the "end_employee" edge to the Employee entity was cleared.
func (m *SubscribePauseMutation) EndEmployeeCleared() bool {
	return m.EndEmployeeIDCleared() || m.clearedend_employee
}

// EndEmployeeIDs returns the "end_employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EndEmployeeID instead. It exists only for internal usage by the builders.
func (m *SubscribePauseMutation) EndEmployeeIDs() (ids []uint64) {
	if id := m.end_employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEndEmployee resets all changes to the "end_employee" edge.
func (m *SubscribePauseMutation) ResetEndEmployee() {
	m.end_employee = nil
	m.clearedend_employee = false
}

// AddSuspendIDs adds the "suspends" edge to the SubscribeSuspend entity by ids.
func (m *SubscribePauseMutation) AddSuspendIDs(ids ...uint64) {
	if m.suspends == nil {
		m.suspends = make(map[uint64]struct{})
	}
	for i := range ids {
		m.suspends[ids[i]] = struct{}{}
	}
}

// ClearSuspends clears the "suspends" edge to the SubscribeSuspend entity.
func (m *SubscribePauseMutation) ClearSuspends() {
	m.clearedsuspends = true
}

// SuspendsCleared reports if the "suspends" edge to the SubscribeSuspend entity was cleared.
func (m *SubscribePauseMutation) SuspendsCleared() bool {
	return m.clearedsuspends
}

// RemoveSuspendIDs removes the "suspends" edge to the SubscribeSuspend entity by IDs.
func (m *SubscribePauseMutation) RemoveSuspendIDs(ids ...uint64) {
	if m.removedsuspends == nil {
		m.removedsuspends = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.suspends, ids[i])
		m.removedsuspends[ids[i]] = struct{}{}
	}
}

// RemovedSuspends returns the removed IDs of the "suspends" edge to the SubscribeSuspend entity.
func (m *SubscribePauseMutation) RemovedSuspendsIDs() (ids []uint64) {
	for id := range m.removedsuspends {
		ids = append(ids, id)
	}
	return
}

// SuspendsIDs returns the "suspends" edge IDs in the mutation.
func (m *SubscribePauseMutation) SuspendsIDs() (ids []uint64) {
	for id := range m.suspends {
		ids = append(ids, id)
	}
	return
}

// ResetSuspends resets all changes to the "suspends" edge.
func (m *SubscribePauseMutation) ResetSuspends() {
	m.suspends = nil
	m.clearedsuspends = false
	m.removedsuspends = nil
}

// Where appends a list predicates to the SubscribePauseMutation builder.
func (m *SubscribePauseMutation) Where(ps ...predicate.SubscribePause) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscribePauseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscribePauseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubscribePause, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscribePauseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscribePauseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubscribePause).
func (m *SubscribePauseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscribePauseMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.created_at != nil {
		fields = append(fields, subscribepause.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscribepause.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, subscribepause.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, subscribepause.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, subscribepause.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, subscribepause.FieldRemark)
	}
	if m.rider != nil {
		fields = append(fields, subscribepause.FieldRiderID)
	}
	if m.employee != nil {
		fields = append(fields, subscribepause.FieldEmployeeID)
	}
	if m.city != nil {
		fields = append(fields, subscribepause.FieldCityID)
	}
	if m.store != nil {
		fields = append(fields, subscribepause.FieldStoreID)
	}
	if m.endStore != nil {
		fields = append(fields, subscribepause.FieldEndStoreID)
	}
	if m.cabinet != nil {
		fields = append(fields, subscribepause.FieldCabinetID)
	}
	if m.endCabinet != nil {
		fields = append(fields, subscribepause.FieldEndCabinetID)
	}
	if m.subscribe != nil {
		fields = append(fields, subscribepause.FieldSubscribeID)
	}
	if m.start_at != nil {
		fields = append(fields, subscribepause.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, subscribepause.FieldEndAt)
	}
	if m.days != nil {
		fields = append(fields, subscribepause.FieldDays)
	}
	if m.end_employee != nil {
		fields = append(fields, subscribepause.FieldEndEmployeeID)
	}
	if m.overdue_days != nil {
		fields = append(fields, subscribepause.FieldOverdueDays)
	}
	if m.end_modifier != nil {
		fields = append(fields, subscribepause.FieldEndModifier)
	}
	if m.pause_overdue != nil {
		fields = append(fields, subscribepause.FieldPauseOverdue)
	}
	if m.suspend_days != nil {
		fields = append(fields, subscribepause.FieldSuspendDays)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscribePauseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscribepause.FieldCreatedAt:
		return m.CreatedAt()
	case subscribepause.FieldUpdatedAt:
		return m.UpdatedAt()
	case subscribepause.FieldDeletedAt:
		return m.DeletedAt()
	case subscribepause.FieldCreator:
		return m.Creator()
	case subscribepause.FieldLastModifier:
		return m.LastModifier()
	case subscribepause.FieldRemark:
		return m.Remark()
	case subscribepause.FieldRiderID:
		return m.RiderID()
	case subscribepause.FieldEmployeeID:
		return m.EmployeeID()
	case subscribepause.FieldCityID:
		return m.CityID()
	case subscribepause.FieldStoreID:
		return m.StoreID()
	case subscribepause.FieldEndStoreID:
		return m.EndStoreID()
	case subscribepause.FieldCabinetID:
		return m.CabinetID()
	case subscribepause.FieldEndCabinetID:
		return m.EndCabinetID()
	case subscribepause.FieldSubscribeID:
		return m.SubscribeID()
	case subscribepause.FieldStartAt:
		return m.StartAt()
	case subscribepause.FieldEndAt:
		return m.EndAt()
	case subscribepause.FieldDays:
		return m.Days()
	case subscribepause.FieldEndEmployeeID:
		return m.EndEmployeeID()
	case subscribepause.FieldOverdueDays:
		return m.OverdueDays()
	case subscribepause.FieldEndModifier:
		return m.EndModifier()
	case subscribepause.FieldPauseOverdue:
		return m.PauseOverdue()
	case subscribepause.FieldSuspendDays:
		return m.SuspendDays()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscribePauseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscribepause.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscribepause.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subscribepause.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case subscribepause.FieldCreator:
		return m.OldCreator(ctx)
	case subscribepause.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case subscribepause.FieldRemark:
		return m.OldRemark(ctx)
	case subscribepause.FieldRiderID:
		return m.OldRiderID(ctx)
	case subscribepause.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case subscribepause.FieldCityID:
		return m.OldCityID(ctx)
	case subscribepause.FieldStoreID:
		return m.OldStoreID(ctx)
	case subscribepause.FieldEndStoreID:
		return m.OldEndStoreID(ctx)
	case subscribepause.FieldCabinetID:
		return m.OldCabinetID(ctx)
	case subscribepause.FieldEndCabinetID:
		return m.OldEndCabinetID(ctx)
	case subscribepause.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case subscribepause.FieldStartAt:
		return m.OldStartAt(ctx)
	case subscribepause.FieldEndAt:
		return m.OldEndAt(ctx)
	case subscribepause.FieldDays:
		return m.OldDays(ctx)
	case subscribepause.FieldEndEmployeeID:
		return m.OldEndEmployeeID(ctx)
	case subscribepause.FieldOverdueDays:
		return m.OldOverdueDays(ctx)
	case subscribepause.FieldEndModifier:
		return m.OldEndModifier(ctx)
	case subscribepause.FieldPauseOverdue:
		return m.OldPauseOverdue(ctx)
	case subscribepause.FieldSuspendDays:
		return m.OldSuspendDays(ctx)
	}
	return nil, fmt.Errorf("unknown SubscribePause field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscribePauseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscribepause.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscribepause.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subscribepause.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case subscribepause.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case subscribepause.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case subscribepause.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case subscribepause.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case subscribepause.FieldEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case subscribepause.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case subscribepause.FieldStoreID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreID(v)
		return nil
	case subscribepause.FieldEndStoreID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndStoreID(v)
		return nil
	case subscribepause.FieldCabinetID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCabinetID(v)
		return nil
	case subscribepause.FieldEndCabinetID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndCabinetID(v)
		return nil
	case subscribepause.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case subscribepause.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case subscribepause.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case subscribepause.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDays(v)
		return nil
	case subscribepause.FieldEndEmployeeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndEmployeeID(v)
		return nil
	case subscribepause.FieldOverdueDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverdueDays(v)
		return nil
	case subscribepause.FieldEndModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndModifier(v)
		return nil
	case subscribepause.FieldPauseOverdue:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPauseOverdue(v)
		return nil
	case subscribepause.FieldSuspendDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuspendDays(v)
		return nil
	}
	return fmt.Errorf("unknown SubscribePause field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscribePauseMutation) AddedFields() []string {
	var fields []string
	if m.adddays != nil {
		fields = append(fields, subscribepause.FieldDays)
	}
	if m.addoverdue_days != nil {
		fields = append(fields, subscribepause.FieldOverdueDays)
	}
	if m.addsuspend_days != nil {
		fields = append(fields, subscribepause.FieldSuspendDays)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscribePauseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subscribepause.FieldDays:
		return m.AddedDays()
	case subscribepause.FieldOverdueDays:
		return m.AddedOverdueDays()
	case subscribepause.FieldSuspendDays:
		return m.AddedSuspendDays()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscribePauseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subscribepause.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDays(v)
		return nil
	case subscribepause.FieldOverdueDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOverdueDays(v)
		return nil
	case subscribepause.FieldSuspendDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSuspendDays(v)
		return nil
	}
	return fmt.Errorf("unknown SubscribePause numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscribePauseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscribepause.FieldDeletedAt) {
		fields = append(fields, subscribepause.FieldDeletedAt)
	}
	if m.FieldCleared(subscribepause.FieldCreator) {
		fields = append(fields, subscribepause.FieldCreator)
	}
	if m.FieldCleared(subscribepause.FieldLastModifier) {
		fields = append(fields, subscribepause.FieldLastModifier)
	}
	if m.FieldCleared(subscribepause.FieldRemark) {
		fields = append(fields, subscribepause.FieldRemark)
	}
	if m.FieldCleared(subscribepause.FieldEmployeeID) {
		fields = append(fields, subscribepause.FieldEmployeeID)
	}
	if m.FieldCleared(subscribepause.FieldCityID) {
		fields = append(fields, subscribepause.FieldCityID)
	}
	if m.FieldCleared(subscribepause.FieldStoreID) {
		fields = append(fields, subscribepause.FieldStoreID)
	}
	if m.FieldCleared(subscribepause.FieldEndStoreID) {
		fields = append(fields, subscribepause.FieldEndStoreID)
	}
	if m.FieldCleared(subscribepause.FieldCabinetID) {
		fields = append(fields, subscribepause.FieldCabinetID)
	}
	if m.FieldCleared(subscribepause.FieldEndCabinetID) {
		fields = append(fields, subscribepause.FieldEndCabinetID)
	}
	if m.FieldCleared(subscribepause.FieldEndAt) {
		fields = append(fields, subscribepause.FieldEndAt)
	}
	if m.FieldCleared(subscribepause.FieldDays) {
		fields = append(fields, subscribepause.FieldDays)
	}
	if m.FieldCleared(subscribepause.FieldEndEmployeeID) {
		fields = append(fields, subscribepause.FieldEndEmployeeID)
	}
	if m.FieldCleared(subscribepause.FieldEndModifier) {
		fields = append(fields, subscribepause.FieldEndModifier)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscribePauseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscribePauseMutation) ClearField(name string) error {
	switch name {
	case subscribepause.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case subscribepause.FieldCreator:
		m.ClearCreator()
		return nil
	case subscribepause.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case subscribepause.FieldRemark:
		m.ClearRemark()
		return nil
	case subscribepause.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case subscribepause.FieldCityID:
		m.ClearCityID()
		return nil
	case subscribepause.FieldStoreID:
		m.ClearStoreID()
		return nil
	case subscribepause.FieldEndStoreID:
		m.ClearEndStoreID()
		return nil
	case subscribepause.FieldCabinetID:
		m.ClearCabinetID()
		return nil
	case subscribepause.FieldEndCabinetID:
		m.ClearEndCabinetID()
		return nil
	case subscribepause.FieldEndAt:
		m.ClearEndAt()
		return nil
	case subscribepause.FieldDays:
		m.ClearDays()
		return nil
	case subscribepause.FieldEndEmployeeID:
		m.ClearEndEmployeeID()
		return nil
	case subscribepause.FieldEndModifier:
		m.ClearEndModifier()
		return nil
	}
	return fmt.Errorf("unknown SubscribePause nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscribePauseMutation) ResetField(name string) error {
	switch name {
	case subscribepause.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscribepause.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subscribepause.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case subscribepause.FieldCreator:
		m.ResetCreator()
		return nil
	case subscribepause.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case subscribepause.FieldRemark:
		m.ResetRemark()
		return nil
	case subscribepause.FieldRiderID:
		m.ResetRiderID()
		return nil
	case subscribepause.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case subscribepause.FieldCityID:
		m.ResetCityID()
		return nil
	case subscribepause.FieldStoreID:
		m.ResetStoreID()
		return nil
	case subscribepause.FieldEndStoreID:
		m.ResetEndStoreID()
		return nil
	case subscribepause.FieldCabinetID:
		m.ResetCabinetID()
		return nil
	case subscribepause.FieldEndCabinetID:
		m.ResetEndCabinetID()
		return nil
	case subscribepause.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case subscribepause.FieldStartAt:
		m.ResetStartAt()
		return nil
	case subscribepause.FieldEndAt:
		m.ResetEndAt()
		return nil
	case subscribepause.FieldDays:
		m.ResetDays()
		return nil
	case subscribepause.FieldEndEmployeeID:
		m.ResetEndEmployeeID()
		return nil
	case subscribepause.FieldOverdueDays:
		m.ResetOverdueDays()
		return nil
	case subscribepause.FieldEndModifier:
		m.ResetEndModifier()
		return nil
	case subscribepause.FieldPauseOverdue:
		m.ResetPauseOverdue()
		return nil
	case subscribepause.FieldSuspendDays:
		m.ResetSuspendDays()
		return nil
	}
	return fmt.Errorf("unknown SubscribePause field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscribePauseMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.rider != nil {
		edges = append(edges, subscribepause.EdgeRider)
	}
	if m.employee != nil {
		edges = append(edges, subscribepause.EdgeEmployee)
	}
	if m.city != nil {
		edges = append(edges, subscribepause.EdgeCity)
	}
	if m.store != nil {
		edges = append(edges, subscribepause.EdgeStore)
	}
	if m.endStore != nil {
		edges = append(edges, subscribepause.EdgeEndStore)
	}
	if m.cabinet != nil {
		edges = append(edges, subscribepause.EdgeCabinet)
	}
	if m.endCabinet != nil {
		edges = append(edges, subscribepause.EdgeEndCabinet)
	}
	if m.subscribe != nil {
		edges = append(edges, subscribepause.EdgeSubscribe)
	}
	if m.end_employee != nil {
		edges = append(edges, subscribepause.EdgeEndEmployee)
	}
	if m.suspends != nil {
		edges = append(edges, subscribepause.EdgeSuspends)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscribePauseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscribepause.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case subscribepause.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case subscribepause.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case subscribepause.EdgeStore:
		if id := m.store; id != nil {
			return []ent.Value{*id}
		}
	case subscribepause.EdgeEndStore:
		if id := m.endStore; id != nil {
			return []ent.Value{*id}
		}
	case subscribepause.EdgeCabinet:
		if id := m.cabinet; id != nil {
			return []ent.Value{*id}
		}
	case subscribepause.EdgeEndCabinet:
		if id := m.endCabinet; id != nil {
			return []ent.Value{*id}
		}
	case subscribepause.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	case subscribepause.EdgeEndEmployee:
		if id := m.end_employee; id != nil {
			return []ent.Value{*id}
		}
	case subscribepause.EdgeSuspends:
		ids := make([]ent.Value, 0, len(m.suspends))
		for id := range m.suspends {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscribePauseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedsuspends != nil {
		edges = append(edges, subscribepause.EdgeSuspends)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscribePauseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case subscribepause.EdgeSuspends:
		ids := make([]ent.Value, 0, len(m.removedsuspends))
		for id := range m.removedsuspends {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscribePauseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedrider {
		edges = append(edges, subscribepause.EdgeRider)
	}
	if m.clearedemployee {
		edges = append(edges, subscribepause.EdgeEmployee)
	}
	if m.clearedcity {
		edges = append(edges, subscribepause.EdgeCity)
	}
	if m.clearedstore {
		edges = append(edges, subscribepause.EdgeStore)
	}
	if m.clearedendStore {
		edges = append(edges, subscribepause.EdgeEndStore)
	}
	if m.clearedcabinet {
		edges = append(edges, subscribepause.EdgeCabinet)
	}
	if m.clearedendCabinet {
		edges = append(edges, subscribepause.EdgeEndCabinet)
	}
	if m.clearedsubscribe {
		edges = append(edges, subscribepause.EdgeSubscribe)
	}
	if m.clearedend_employee {
		edges = append(edges, subscribepause.EdgeEndEmployee)
	}
	if m.clearedsuspends {
		edges = append(edges, subscribepause.EdgeSuspends)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscribePauseMutation) EdgeCleared(name string) bool {
	switch name {
	case subscribepause.EdgeRider:
		return m.clearedrider
	case subscribepause.EdgeEmployee:
		return m.clearedemployee
	case subscribepause.EdgeCity:
		return m.clearedcity
	case subscribepause.EdgeStore:
		return m.clearedstore
	case subscribepause.EdgeEndStore:
		return m.clearedendStore
	case subscribepause.EdgeCabinet:
		return m.clearedcabinet
	case subscribepause.EdgeEndCabinet:
		return m.clearedendCabinet
	case subscribepause.EdgeSubscribe:
		return m.clearedsubscribe
	case subscribepause.EdgeEndEmployee:
		return m.clearedend_employee
	case subscribepause.EdgeSuspends:
		return m.clearedsuspends
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscribePauseMutation) ClearEdge(name string) error {
	switch name {
	case subscribepause.EdgeRider:
		m.ClearRider()
		return nil
	case subscribepause.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case subscribepause.EdgeCity:
		m.ClearCity()
		return nil
	case subscribepause.EdgeStore:
		m.ClearStore()
		return nil
	case subscribepause.EdgeEndStore:
		m.ClearEndStore()
		return nil
	case subscribepause.EdgeCabinet:
		m.ClearCabinet()
		return nil
	case subscribepause.EdgeEndCabinet:
		m.ClearEndCabinet()
		return nil
	case subscribepause.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	case subscribepause.EdgeEndEmployee:
		m.ClearEndEmployee()
		return nil
	}
	return fmt.Errorf("unknown SubscribePause unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscribePauseMutation) ResetEdge(name string) error {
	switch name {
	case subscribepause.EdgeRider:
		m.ResetRider()
		return nil
	case subscribepause.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case subscribepause.EdgeCity:
		m.ResetCity()
		return nil
	case subscribepause.EdgeStore:
		m.ResetStore()
		return nil
	case subscribepause.EdgeEndStore:
		m.ResetEndStore()
		return nil
	case subscribepause.EdgeCabinet:
		m.ResetCabinet()
		return nil
	case subscribepause.EdgeEndCabinet:
		m.ResetEndCabinet()
		return nil
	case subscribepause.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	case subscribepause.EdgeEndEmployee:
		m.ResetEndEmployee()
		return nil
	case subscribepause.EdgeSuspends:
		m.ResetSuspends()
		return nil
	}
	return fmt.Errorf("unknown SubscribePause edge %s", name)
}

// SubscribeReminderMutation represents an operation that mutates the SubscribeReminder nodes in the graph.
type SubscribeReminderMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	created_at       *time.Time
	updated_at       *time.Time
	_type            *subscribereminder.Type
	phone            *string
	name             *string
	success          *bool
	days             *int
	adddays          *int
	plan_name        *string
	date             *string
	fee              *float64
	addfee           *float64
	fee_formula      *string
	clearedFields    map[string]struct{}
	subscribe        *uint64
	clearedsubscribe bool
	plan             *uint64
	clearedplan      bool
	rider            *uint64
	clearedrider     bool
	done             bool
	oldValue         func(context.Context) (*SubscribeReminder, error)
	predicates       []predicate.SubscribeReminder
}

var _ ent.Mutation = (*SubscribeReminderMutation)(nil)

// subscribereminderOption allows management of the mutation configuration using functional options.
type subscribereminderOption func(*SubscribeReminderMutation)

// newSubscribeReminderMutation creates new mutation for the SubscribeReminder entity.
func newSubscribeReminderMutation(c config, op Op, opts ...subscribereminderOption) *SubscribeReminderMutation {
	m := &SubscribeReminderMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscribeReminder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscribeReminderID sets the ID field of the mutation.
func withSubscribeReminderID(id uint64) subscribereminderOption {
	return func(m *SubscribeReminderMutation) {
		var (
			err   error
			once  sync.Once
			value *SubscribeReminder
		)
		m.oldValue = func(ctx context.Context) (*SubscribeReminder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubscribeReminder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscribeReminder sets the old SubscribeReminder of the mutation.
func withSubscribeReminder(node *SubscribeReminder) subscribereminderOption {
	return func(m *SubscribeReminderMutation) {
		m.oldValue = func(context.Context) (*SubscribeReminder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscribeReminderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscribeReminderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscribeReminderMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscribeReminderMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubscribeReminder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SubscribeReminderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SubscribeReminderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SubscribeReminder entity.
// If the SubscribeReminder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeReminderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SubscribeReminderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SubscribeReminderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SubscribeReminderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SubscribeReminder entity.
// If the SubscribeReminder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeReminderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SubscribeReminderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *SubscribeReminderMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *SubscribeReminderMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the SubscribeReminder entity.
// If the SubscribeReminder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeReminderMutation) OldSubscribeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *SubscribeReminderMutation) ResetSubscribeID() {
	m.subscribe = nil
}

// SetPlanID sets the "plan_id" field.
func (m *SubscribeReminderMutation) SetPlanID(u uint64) {
	m.plan = &u
}

// PlanID returns the value of the "plan_id" field in the mutation.
func (m *SubscribeReminderMutation) PlanID() (r uint64, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanID returns the old "plan_id" field's value of the SubscribeReminder entity.
// If the SubscribeReminder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeReminderMutation) OldPlanID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanID: %w", err)
	}
	return oldValue.PlanID, nil
}

// ResetPlanID resets all changes to the "plan_id" field.
func (m *SubscribeReminderMutation) ResetPlanID() {
	m.plan = nil
}

// SetRiderID sets the "rider_id" field.
func (m *SubscribeReminderMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *SubscribeReminderMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the SubscribeReminder entity.
// If the SubscribeReminder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeReminderMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *SubscribeReminderMutation) ResetRiderID() {
	m.rider = nil
}

// SetType sets the "type" field.
func (m *SubscribeReminderMutation) SetType(s subscribereminder.Type) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *SubscribeReminderMutation) GetType() (r subscribereminder.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the SubscribeReminder entity.
// If the SubscribeReminder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeReminderMutation) OldType(ctx context.Context) (v subscribereminder.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *SubscribeReminderMutation) ResetType() {
	m._type = nil
}

// SetPhone sets the "phone" field.
func (m *SubscribeReminderMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *SubscribeReminderMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the SubscribeReminder entity.
// If the SubscribeReminder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeReminderMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *SubscribeReminderMutation) ResetPhone() {
	m.phone = nil
}

// SetName sets the "name" field.
func (m *SubscribeReminderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SubscribeReminderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SubscribeReminder entity.
// If the SubscribeReminder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeReminderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SubscribeReminderMutation) ResetName() {
	m.name = nil
}

// SetSuccess sets the "success" field.
func (m *SubscribeReminderMutation) SetSuccess(b bool) {
	m.success = &b
}

// Success returns the value of the "success" field in the mutation.
func (m *SubscribeReminderMutation) Success() (r bool, exists bool) {
	v := m.success
	if v == nil {
		return
	}
	return *v, true
}

// OldSuccess returns the old "success" field's value of the SubscribeReminder entity.
// If the SubscribeReminder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeReminderMutation) OldSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSuccess: %w", err)
	}
	return oldValue.Success, nil
}

// ResetSuccess resets all changes to the "success" field.
func (m *SubscribeReminderMutation) ResetSuccess() {
	m.success = nil
}

// SetDays sets the "days" field.
func (m *SubscribeReminderMutation) SetDays(i int) {
	m.days = &i
	m.adddays = nil
}

// Days returns the value of the "days" field in the mutation.
func (m *SubscribeReminderMutation) Days() (r int, exists bool) {
	v := m.days
	if v == nil {
		return
	}
	return *v, true
}

// OldDays returns the old "days" field's value of the SubscribeReminder entity.
// If the SubscribeReminder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeReminderMutation) OldDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDays: %w", err)
	}
	return oldValue.Days, nil
}

// AddDays adds i to the "days" field.
func (m *SubscribeReminderMutation) AddDays(i int) {
	if m.adddays != nil {
		*m.adddays += i
	} else {
		m.adddays = &i
	}
}

// AddedDays returns the value that was added to the "days" field in this mutation.
func (m *SubscribeReminderMutation) AddedDays() (r int, exists bool) {
	v := m.adddays
	if v == nil {
		return
	}
	return *v, true
}

// ResetDays resets all changes to the "days" field.
func (m *SubscribeReminderMutation) ResetDays() {
	m.days = nil
	m.adddays = nil
}

// SetPlanName sets the "plan_name" field.
func (m *SubscribeReminderMutation) SetPlanName(s string) {
	m.plan_name = &s
}

// PlanName returns the value of the "plan_name" field in the mutation.
func (m *SubscribeReminderMutation) PlanName() (r string, exists bool) {
	v := m.plan_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanName returns the old "plan_name" field's value of the SubscribeReminder entity.
// If the SubscribeReminder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeReminderMutation) OldPlanName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanName: %w", err)
	}
	return oldValue.PlanName, nil
}

// ResetPlanName resets all changes to the "plan_name" field.
func (m *SubscribeReminderMutation) ResetPlanName() {
	m.plan_name = nil
}

// SetDate sets the "date" field.
func (m *SubscribeReminderMutation) SetDate(s string) {
	m.date = &s
}

// Date returns the value of the "date" field in the mutation.
func (m *SubscribeReminderMutation) Date() (r string, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the SubscribeReminder entity.
// If the SubscribeReminder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeReminderMutation) OldDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *SubscribeReminderMutation) ResetDate() {
	m.date = nil
}

// SetFee sets the "fee" field.
func (m *SubscribeReminderMutation) SetFee(f float64) {
	m.fee = &f
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *SubscribeReminderMutation) Fee() (r float64, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the SubscribeReminder entity.
// If the SubscribeReminder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeReminderMutation) OldFee(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds f to the "fee" field.
func (m *SubscribeReminderMutation) AddFee(f float64) {
	if m.addfee != nil {
		*m.addfee += f
	} else {
		m.addfee = &f
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *SubscribeReminderMutation) AddedFee() (r float64, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ResetFee resets all changes to the "fee" field.
func (m *SubscribeReminderMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
}

// SetFeeFormula sets the "fee_formula" field.
func (m *SubscribeReminderMutation) SetFeeFormula(s string) {
	m.fee_formula = &s
}

// FeeFormula returns the value of the "fee_formula" field in the mutation.
func (m *SubscribeReminderMutation) FeeFormula() (r string, exists bool) {
	v := m.fee_formula
	if v == nil {
		return
	}
	return *v, true
}

// OldFeeFormula returns the old "fee_formula" field's value of the SubscribeReminder entity.
// If the SubscribeReminder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeReminderMutation) OldFeeFormula(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeeFormula is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeeFormula requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeeFormula: %w", err)
	}
	return oldValue.FeeFormula, nil
}

// ClearFeeFormula clears the value of the "fee_formula" field.
func (m *SubscribeReminderMutation) ClearFeeFormula() {
	m.fee_formula = nil
	m.clearedFields[subscribereminder.FieldFeeFormula] = struct{}{}
}

// FeeFormulaCleared returns if the "fee_formula" field was cleared in this mutation.
func (m *SubscribeReminderMutation) FeeFormulaCleared() bool {
	_, ok := m.clearedFields[subscribereminder.FieldFeeFormula]
	return ok
}

// ResetFeeFormula resets all changes to the "fee_formula" field.
func (m *SubscribeReminderMutation) ResetFeeFormula() {
	m.fee_formula = nil
	delete(m.clearedFields, subscribereminder.FieldFeeFormula)
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *SubscribeReminderMutation) ClearSubscribe() {
	m.clearedsubscribe = true
	m.clearedFields[subscribereminder.FieldSubscribeID] = struct{}{}
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *SubscribeReminderMutation) SubscribeCleared() bool {
	return m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *SubscribeReminderMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *SubscribeReminderMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// ClearPlan clears the "plan" edge to the Plan entity.
func (m *SubscribeReminderMutation) ClearPlan() {
	m.clearedplan = true
	m.clearedFields[subscribereminder.FieldPlanID] = struct{}{}
}

// PlanCleared reports if the "plan" edge to the Plan entity was cleared.
func (m *SubscribeReminderMutation) PlanCleared() bool {
	return m.clearedplan
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *SubscribeReminderMutation) PlanIDs() (ids []uint64) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *SubscribeReminderMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *SubscribeReminderMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[subscribereminder.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *SubscribeReminderMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *SubscribeReminderMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *SubscribeReminderMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// Where appends a list predicates to the SubscribeReminderMutation builder.
func (m *SubscribeReminderMutation) Where(ps ...predicate.SubscribeReminder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscribeReminderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscribeReminderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubscribeReminder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscribeReminderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscribeReminderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubscribeReminder).
func (m *SubscribeReminderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscribeReminderMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, subscribereminder.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, subscribereminder.FieldUpdatedAt)
	}
	if m.subscribe != nil {
		fields = append(fields, subscribereminder.FieldSubscribeID)
	}
	if m.plan != nil {
		fields = append(fields, subscribereminder.FieldPlanID)
	}
	if m.rider != nil {
		fields = append(fields, subscribereminder.FieldRiderID)
	}
	if m._type != nil {
		fields = append(fields, subscribereminder.FieldType)
	}
	if m.phone != nil {
		fields = append(fields, subscribereminder.FieldPhone)
	}
	if m.name != nil {
		fields = append(fields, subscribereminder.FieldName)
	}
	if m.success != nil {
		fields = append(fields, subscribereminder.FieldSuccess)
	}
	if m.days != nil {
		fields = append(fields, subscribereminder.FieldDays)
	}
	if m.plan_name != nil {
		fields = append(fields, subscribereminder.FieldPlanName)
	}
	if m.date != nil {
		fields = append(fields, subscribereminder.FieldDate)
	}
	if m.fee != nil {
		fields = append(fields, subscribereminder.FieldFee)
	}
	if m.fee_formula != nil {
		fields = append(fields, subscribereminder.FieldFeeFormula)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscribeReminderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscribereminder.FieldCreatedAt:
		return m.CreatedAt()
	case subscribereminder.FieldUpdatedAt:
		return m.UpdatedAt()
	case subscribereminder.FieldSubscribeID:
		return m.SubscribeID()
	case subscribereminder.FieldPlanID:
		return m.PlanID()
	case subscribereminder.FieldRiderID:
		return m.RiderID()
	case subscribereminder.FieldType:
		return m.GetType()
	case subscribereminder.FieldPhone:
		return m.Phone()
	case subscribereminder.FieldName:
		return m.Name()
	case subscribereminder.FieldSuccess:
		return m.Success()
	case subscribereminder.FieldDays:
		return m.Days()
	case subscribereminder.FieldPlanName:
		return m.PlanName()
	case subscribereminder.FieldDate:
		return m.Date()
	case subscribereminder.FieldFee:
		return m.Fee()
	case subscribereminder.FieldFeeFormula:
		return m.FeeFormula()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscribeReminderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscribereminder.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case subscribereminder.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case subscribereminder.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case subscribereminder.FieldPlanID:
		return m.OldPlanID(ctx)
	case subscribereminder.FieldRiderID:
		return m.OldRiderID(ctx)
	case subscribereminder.FieldType:
		return m.OldType(ctx)
	case subscribereminder.FieldPhone:
		return m.OldPhone(ctx)
	case subscribereminder.FieldName:
		return m.OldName(ctx)
	case subscribereminder.FieldSuccess:
		return m.OldSuccess(ctx)
	case subscribereminder.FieldDays:
		return m.OldDays(ctx)
	case subscribereminder.FieldPlanName:
		return m.OldPlanName(ctx)
	case subscribereminder.FieldDate:
		return m.OldDate(ctx)
	case subscribereminder.FieldFee:
		return m.OldFee(ctx)
	case subscribereminder.FieldFeeFormula:
		return m.OldFeeFormula(ctx)
	}
	return nil, fmt.Errorf("unknown SubscribeReminder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscribeReminderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscribereminder.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case subscribereminder.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case subscribereminder.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case subscribereminder.FieldPlanID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanID(v)
		return nil
	case subscribereminder.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case subscribereminder.FieldType:
		v, ok := value.(subscribereminder.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case subscribereminder.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case subscribereminder.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case subscribereminder.FieldSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSuccess(v)
		return nil
	case subscribereminder.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDays(v)
		return nil
	case subscribereminder.FieldPlanName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanName(v)
		return nil
	case subscribereminder.FieldDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case subscribereminder.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case subscribereminder.FieldFeeFormula:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeeFormula(v)
		return nil
	}
	return fmt.Errorf("unknown SubscribeReminder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscribeReminderMutation) AddedFields() []string {
	var fields []string
	if m.adddays != nil {
		fields = append(fields, subscribereminder.FieldDays)
	}
	if m.addfee != nil {
		fields = append(fields, subscribereminder.FieldFee)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscribeReminderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subscribereminder.FieldDays:
		return m.AddedDays()
	case subscribereminder.FieldFee:
		return m.AddedFee()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscribeReminderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subscribereminder.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDays(v)
		return nil
	case subscribereminder.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	}
	return fmt.Errorf("unknown SubscribeReminder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscribeReminderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscribereminder.FieldFeeFormula) {
		fields = append(fields, subscribereminder.FieldFeeFormula)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscribeReminderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscribeReminderMutation) ClearField(name string) error {
	switch name {
	case subscribereminder.FieldFeeFormula:
		m.ClearFeeFormula()
		return nil
	}
	return fmt.Errorf("unknown SubscribeReminder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscribeReminderMutation) ResetField(name string) error {
	switch name {
	case subscribereminder.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case subscribereminder.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case subscribereminder.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case subscribereminder.FieldPlanID:
		m.ResetPlanID()
		return nil
	case subscribereminder.FieldRiderID:
		m.ResetRiderID()
		return nil
	case subscribereminder.FieldType:
		m.ResetType()
		return nil
	case subscribereminder.FieldPhone:
		m.ResetPhone()
		return nil
	case subscribereminder.FieldName:
		m.ResetName()
		return nil
	case subscribereminder.FieldSuccess:
		m.ResetSuccess()
		return nil
	case subscribereminder.FieldDays:
		m.ResetDays()
		return nil
	case subscribereminder.FieldPlanName:
		m.ResetPlanName()
		return nil
	case subscribereminder.FieldDate:
		m.ResetDate()
		return nil
	case subscribereminder.FieldFee:
		m.ResetFee()
		return nil
	case subscribereminder.FieldFeeFormula:
		m.ResetFeeFormula()
		return nil
	}
	return fmt.Errorf("unknown SubscribeReminder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscribeReminderMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.subscribe != nil {
		edges = append(edges, subscribereminder.EdgeSubscribe)
	}
	if m.plan != nil {
		edges = append(edges, subscribereminder.EdgePlan)
	}
	if m.rider != nil {
		edges = append(edges, subscribereminder.EdgeRider)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscribeReminderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscribereminder.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	case subscribereminder.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	case subscribereminder.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscribeReminderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscribeReminderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscribeReminderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedsubscribe {
		edges = append(edges, subscribereminder.EdgeSubscribe)
	}
	if m.clearedplan {
		edges = append(edges, subscribereminder.EdgePlan)
	}
	if m.clearedrider {
		edges = append(edges, subscribereminder.EdgeRider)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscribeReminderMutation) EdgeCleared(name string) bool {
	switch name {
	case subscribereminder.EdgeSubscribe:
		return m.clearedsubscribe
	case subscribereminder.EdgePlan:
		return m.clearedplan
	case subscribereminder.EdgeRider:
		return m.clearedrider
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscribeReminderMutation) ClearEdge(name string) error {
	switch name {
	case subscribereminder.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	case subscribereminder.EdgePlan:
		m.ClearPlan()
		return nil
	case subscribereminder.EdgeRider:
		m.ClearRider()
		return nil
	}
	return fmt.Errorf("unknown SubscribeReminder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscribeReminderMutation) ResetEdge(name string) error {
	switch name {
	case subscribereminder.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	case subscribereminder.EdgePlan:
		m.ResetPlan()
		return nil
	case subscribereminder.EdgeRider:
		m.ResetRider()
		return nil
	}
	return fmt.Errorf("unknown SubscribeReminder edge %s", name)
}

// SubscribeSuspendMutation represents an operation that mutates the SubscribeSuspend nodes in the graph.
type SubscribeSuspendMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	creator          **model.Modifier
	last_modifier    **model.Modifier
	remark           *string
	days             *int
	adddays          *int
	start_at         *time.Time
	end_at           *time.Time
	end_reason       *string
	end_modifier     **model.Modifier
	clearedFields    map[string]struct{}
	city             *uint64
	clearedcity      bool
	rider            *uint64
	clearedrider     bool
	subscribe        *uint64
	clearedsubscribe bool
	pause            *uint64
	clearedpause     bool
	done             bool
	oldValue         func(context.Context) (*SubscribeSuspend, error)
	predicates       []predicate.SubscribeSuspend
}

var _ ent.Mutation = (*SubscribeSuspendMutation)(nil)

// subscribesuspendOption allows management of the mutation configuration using functional options.
type subscribesuspendOption func(*SubscribeSuspendMutation)

// newSubscribeSuspendMutation creates new mutation for the SubscribeSuspend entity.
func newSubscribeSuspendMutation(c config, op Op, opts ...subscribesuspendOption) *SubscribeSuspendMutation {
	m := &SubscribeSuspendMutation{
		config:        c,
		op:            op,
		typ:           TypeSubscribeSuspend,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSubscribeSuspendID sets the ID field of the mutation.
func withSubscribeSuspendID(id uint64) subscribesuspendOption {
	return func(m *SubscribeSuspendMutation) {
		var (
			err   error
			once  sync.Once
			value *SubscribeSuspend
		)
		m.oldValue = func(ctx context.Context) (*SubscribeSuspend, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SubscribeSuspend.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSubscribeSuspend sets the old SubscribeSuspend of the mutation.
func withSubscribeSuspend(node *SubscribeSuspend) subscribesuspendOption {
	return func(m *SubscribeSuspendMutation) {
		m.oldValue = func(context.Context) (*SubscribeSuspend, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SubscribeSuspendMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SubscribeSuspendMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SubscribeSuspendMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SubscribeSuspendMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SubscribeSuspend.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreator sets the "creator" field.
func (m *SubscribeSuspendMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *SubscribeSuspendMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the SubscribeSuspend entity.
// If the SubscribeSuspend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeSuspendMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *SubscribeSuspendMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[subscribesuspend.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *SubscribeSuspendMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[subscribesuspend.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *SubscribeSuspendMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, subscribesuspend.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *SubscribeSuspendMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *SubscribeSuspendMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the SubscribeSuspend entity.
// If the SubscribeSuspend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeSuspendMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *SubscribeSuspendMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[subscribesuspend.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *SubscribeSuspendMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[subscribesuspend.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *SubscribeSuspendMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, subscribesuspend.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *SubscribeSuspendMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *SubscribeSuspendMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the SubscribeSuspend entity.
// If the SubscribeSuspend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeSuspendMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *SubscribeSuspendMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[subscribesuspend.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *SubscribeSuspendMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[subscribesuspend.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *SubscribeSuspendMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, subscribesuspend.FieldRemark)
}

// SetCityID sets the "city_id" field.
func (m *SubscribeSuspendMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *SubscribeSuspendMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the SubscribeSuspend entity.
// If the SubscribeSuspend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeSuspendMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *SubscribeSuspendMutation) ResetCityID() {
	m.city = nil
}

// SetRiderID sets the "rider_id" field.
func (m *SubscribeSuspendMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *SubscribeSuspendMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the SubscribeSuspend entity.
// If the SubscribeSuspend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeSuspendMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *SubscribeSuspendMutation) ResetRiderID() {
	m.rider = nil
}

// SetSubscribeID sets the "subscribe_id" field.
func (m *SubscribeSuspendMutation) SetSubscribeID(u uint64) {
	m.subscribe = &u
}

// SubscribeID returns the value of the "subscribe_id" field in the mutation.
func (m *SubscribeSuspendMutation) SubscribeID() (r uint64, exists bool) {
	v := m.subscribe
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribeID returns the old "subscribe_id" field's value of the SubscribeSuspend entity.
// If the SubscribeSuspend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeSuspendMutation) OldSubscribeID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribeID: %w", err)
	}
	return oldValue.SubscribeID, nil
}

// ResetSubscribeID resets all changes to the "subscribe_id" field.
func (m *SubscribeSuspendMutation) ResetSubscribeID() {
	m.subscribe = nil
}

// SetPauseID sets the "pause_id" field.
func (m *SubscribeSuspendMutation) SetPauseID(u uint64) {
	m.pause = &u
}

// PauseID returns the value of the "pause_id" field in the mutation.
func (m *SubscribeSuspendMutation) PauseID() (r uint64, exists bool) {
	v := m.pause
	if v == nil {
		return
	}
	return *v, true
}

// OldPauseID returns the old "pause_id" field's value of the SubscribeSuspend entity.
// If the SubscribeSuspend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeSuspendMutation) OldPauseID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPauseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPauseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPauseID: %w", err)
	}
	return oldValue.PauseID, nil
}

// ClearPauseID clears the value of the "pause_id" field.
func (m *SubscribeSuspendMutation) ClearPauseID() {
	m.pause = nil
	m.clearedFields[subscribesuspend.FieldPauseID] = struct{}{}
}

// PauseIDCleared returns if the "pause_id" field was cleared in this mutation.
func (m *SubscribeSuspendMutation) PauseIDCleared() bool {
	_, ok := m.clearedFields[subscribesuspend.FieldPauseID]
	return ok
}

// ResetPauseID resets all changes to the "pause_id" field.
func (m *SubscribeSuspendMutation) ResetPauseID() {
	m.pause = nil
	delete(m.clearedFields, subscribesuspend.FieldPauseID)
}

// SetDays sets the "days" field.
func (m *SubscribeSuspendMutation) SetDays(i int) {
	m.days = &i
	m.adddays = nil
}

// Days returns the value of the "days" field in the mutation.
func (m *SubscribeSuspendMutation) Days() (r int, exists bool) {
	v := m.days
	if v == nil {
		return
	}
	return *v, true
}

// OldDays returns the old "days" field's value of the SubscribeSuspend entity.
// If the SubscribeSuspend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeSuspendMutation) OldDays(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDays: %w", err)
	}
	return oldValue.Days, nil
}

// AddDays adds i to the "days" field.
func (m *SubscribeSuspendMutation) AddDays(i int) {
	if m.adddays != nil {
		*m.adddays += i
	} else {
		m.adddays = &i
	}
}

// AddedDays returns the value that was added to the "days" field in this mutation.
func (m *SubscribeSuspendMutation) AddedDays() (r int, exists bool) {
	v := m.adddays
	if v == nil {
		return
	}
	return *v, true
}

// ResetDays resets all changes to the "days" field.
func (m *SubscribeSuspendMutation) ResetDays() {
	m.days = nil
	m.adddays = nil
}

// SetStartAt sets the "start_at" field.
func (m *SubscribeSuspendMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *SubscribeSuspendMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the SubscribeSuspend entity.
// If the SubscribeSuspend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeSuspendMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *SubscribeSuspendMutation) ResetStartAt() {
	m.start_at = nil
}

// SetEndAt sets the "end_at" field.
func (m *SubscribeSuspendMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *SubscribeSuspendMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the SubscribeSuspend entity.
// If the SubscribeSuspend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeSuspendMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *SubscribeSuspendMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[subscribesuspend.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *SubscribeSuspendMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[subscribesuspend.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *SubscribeSuspendMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, subscribesuspend.FieldEndAt)
}

// SetEndReason sets the "end_reason" field.
func (m *SubscribeSuspendMutation) SetEndReason(s string) {
	m.end_reason = &s
}

// EndReason returns the value of the "end_reason" field in the mutation.
func (m *SubscribeSuspendMutation) EndReason() (r string, exists bool) {
	v := m.end_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldEndReason returns the old "end_reason" field's value of the SubscribeSuspend entity.
// If the SubscribeSuspend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeSuspendMutation) OldEndReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndReason: %w", err)
	}
	return oldValue.EndReason, nil
}

// ClearEndReason clears the value of the "end_reason" field.
func (m *SubscribeSuspendMutation) ClearEndReason() {
	m.end_reason = nil
	m.clearedFields[subscribesuspend.FieldEndReason] = struct{}{}
}

// EndReasonCleared returns if the "end_reason" field was cleared in this mutation.
func (m *SubscribeSuspendMutation) EndReasonCleared() bool {
	_, ok := m.clearedFields[subscribesuspend.FieldEndReason]
	return ok
}

// ResetEndReason resets all changes to the "end_reason" field.
func (m *SubscribeSuspendMutation) ResetEndReason() {
	m.end_reason = nil
	delete(m.clearedFields, subscribesuspend.FieldEndReason)
}

// SetEndModifier sets the "end_modifier" field.
func (m *SubscribeSuspendMutation) SetEndModifier(value *model.Modifier) {
	m.end_modifier = &value
}

// EndModifier returns the value of the "end_modifier" field in the mutation.
func (m *SubscribeSuspendMutation) EndModifier() (r *model.Modifier, exists bool) {
	v := m.end_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldEndModifier returns the old "end_modifier" field's value of the SubscribeSuspend entity.
// If the SubscribeSuspend object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SubscribeSuspendMutation) OldEndModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndModifier: %w", err)
	}
	return oldValue.EndModifier, nil
}

// ClearEndModifier clears the value of the "end_modifier" field.
func (m *SubscribeSuspendMutation) ClearEndModifier() {
	m.end_modifier = nil
	m.clearedFields[subscribesuspend.FieldEndModifier] = struct{}{}
}

// EndModifierCleared returns if the "end_modifier" field was cleared in this mutation.
func (m *SubscribeSuspendMutation) EndModifierCleared() bool {
	_, ok := m.clearedFields[subscribesuspend.FieldEndModifier]
	return ok
}

// ResetEndModifier resets all changes to the "end_modifier" field.
func (m *SubscribeSuspendMutation) ResetEndModifier() {
	m.end_modifier = nil
	delete(m.clearedFields, subscribesuspend.FieldEndModifier)
}

// ClearCity clears the "city" edge to the City entity.
func (m *SubscribeSuspendMutation) ClearCity() {
	m.clearedcity = true
	m.clearedFields[subscribesuspend.FieldCityID] = struct{}{}
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *SubscribeSuspendMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *SubscribeSuspendMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *SubscribeSuspendMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *SubscribeSuspendMutation) ClearRider() {
	m.clearedrider = true
	m.clearedFields[subscribesuspend.FieldRiderID] = struct{}{}
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *SubscribeSuspendMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *SubscribeSuspendMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *SubscribeSuspendMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearSubscribe clears the "subscribe" edge to the Subscribe entity.
func (m *SubscribeSuspendMutation) ClearSubscribe() {
	m.clearedsubscribe = true
	m.clearedFields[subscribesuspend.FieldSubscribeID] = struct{}{}
}

// SubscribeCleared reports if the "subscribe" edge to the Subscribe entity was cleared.
func (m *SubscribeSuspendMutation) SubscribeCleared() bool {
	return m.clearedsubscribe
}

// SubscribeIDs returns the "subscribe" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SubscribeID instead. It exists only for internal usage by the builders.
func (m *SubscribeSuspendMutation) SubscribeIDs() (ids []uint64) {
	if id := m.subscribe; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSubscribe resets all changes to the "subscribe" edge.
func (m *SubscribeSuspendMutation) ResetSubscribe() {
	m.subscribe = nil
	m.clearedsubscribe = false
}

// ClearPause clears the "pause" edge to the SubscribePause entity.
func (m *SubscribeSuspendMutation) ClearPause() {
	m.clearedpause = true
	m.clearedFields[subscribesuspend.FieldPauseID] = struct{}{}
}

// PauseCleared reports if the "pause" edge to the SubscribePause entity was cleared.
func (m *SubscribeSuspendMutation) PauseCleared() bool {
	return m.PauseIDCleared() || m.clearedpause
}

// PauseIDs returns the "pause" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PauseID instead. It exists only for internal usage by the builders.
func (m *SubscribeSuspendMutation) PauseIDs() (ids []uint64) {
	if id := m.pause; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPause resets all changes to the "pause" edge.
func (m *SubscribeSuspendMutation) ResetPause() {
	m.pause = nil
	m.clearedpause = false
}

// Where appends a list predicates to the SubscribeSuspendMutation builder.
func (m *SubscribeSuspendMutation) Where(ps ...predicate.SubscribeSuspend) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SubscribeSuspendMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SubscribeSuspendMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SubscribeSuspend, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SubscribeSuspendMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SubscribeSuspendMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SubscribeSuspend).
func (m *SubscribeSuspendMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SubscribeSuspendMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.creator != nil {
		fields = append(fields, subscribesuspend.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, subscribesuspend.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, subscribesuspend.FieldRemark)
	}
	if m.city != nil {
		fields = append(fields, subscribesuspend.FieldCityID)
	}
	if m.rider != nil {
		fields = append(fields, subscribesuspend.FieldRiderID)
	}
	if m.subscribe != nil {
		fields = append(fields, subscribesuspend.FieldSubscribeID)
	}
	if m.pause != nil {
		fields = append(fields, subscribesuspend.FieldPauseID)
	}
	if m.days != nil {
		fields = append(fields, subscribesuspend.FieldDays)
	}
	if m.start_at != nil {
		fields = append(fields, subscribesuspend.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, subscribesuspend.FieldEndAt)
	}
	if m.end_reason != nil {
		fields = append(fields, subscribesuspend.FieldEndReason)
	}
	if m.end_modifier != nil {
		fields = append(fields, subscribesuspend.FieldEndModifier)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SubscribeSuspendMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case subscribesuspend.FieldCreator:
		return m.Creator()
	case subscribesuspend.FieldLastModifier:
		return m.LastModifier()
	case subscribesuspend.FieldRemark:
		return m.Remark()
	case subscribesuspend.FieldCityID:
		return m.CityID()
	case subscribesuspend.FieldRiderID:
		return m.RiderID()
	case subscribesuspend.FieldSubscribeID:
		return m.SubscribeID()
	case subscribesuspend.FieldPauseID:
		return m.PauseID()
	case subscribesuspend.FieldDays:
		return m.Days()
	case subscribesuspend.FieldStartAt:
		return m.StartAt()
	case subscribesuspend.FieldEndAt:
		return m.EndAt()
	case subscribesuspend.FieldEndReason:
		return m.EndReason()
	case subscribesuspend.FieldEndModifier:
		return m.EndModifier()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SubscribeSuspendMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case subscribesuspend.FieldCreator:
		return m.OldCreator(ctx)
	case subscribesuspend.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case subscribesuspend.FieldRemark:
		return m.OldRemark(ctx)
	case subscribesuspend.FieldCityID:
		return m.OldCityID(ctx)
	case subscribesuspend.FieldRiderID:
		return m.OldRiderID(ctx)
	case subscribesuspend.FieldSubscribeID:
		return m.OldSubscribeID(ctx)
	case subscribesuspend.FieldPauseID:
		return m.OldPauseID(ctx)
	case subscribesuspend.FieldDays:
		return m.OldDays(ctx)
	case subscribesuspend.FieldStartAt:
		return m.OldStartAt(ctx)
	case subscribesuspend.FieldEndAt:
		return m.OldEndAt(ctx)
	case subscribesuspend.FieldEndReason:
		return m.OldEndReason(ctx)
	case subscribesuspend.FieldEndModifier:
		return m.OldEndModifier(ctx)
	}
	return nil, fmt.Errorf("unknown SubscribeSuspend field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscribeSuspendMutation) SetField(name string, value ent.Value) error {
	switch name {
	case subscribesuspend.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case subscribesuspend.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case subscribesuspend.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case subscribesuspend.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case subscribesuspend.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case subscribesuspend.FieldSubscribeID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribeID(v)
		return nil
	case subscribesuspend.FieldPauseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPauseID(v)
		return nil
	case subscribesuspend.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDays(v)
		return nil
	case subscribesuspend.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case subscribesuspend.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case subscribesuspend.FieldEndReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndReason(v)
		return nil
	case subscribesuspend.FieldEndModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndModifier(v)
		return nil
	}
	return fmt.Errorf("unknown SubscribeSuspend field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SubscribeSuspendMutation) AddedFields() []string {
	var fields []string
	if m.adddays != nil {
		fields = append(fields, subscribesuspend.FieldDays)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SubscribeSuspendMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case subscribesuspend.FieldDays:
		return m.AddedDays()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SubscribeSuspendMutation) AddField(name string, value ent.Value) error {
	switch name {
	case subscribesuspend.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDays(v)
		return nil
	}
	return fmt.Errorf("unknown SubscribeSuspend numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SubscribeSuspendMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(subscribesuspend.FieldCreator) {
		fields = append(fields, subscribesuspend.FieldCreator)
	}
	if m.FieldCleared(subscribesuspend.FieldLastModifier) {
		fields = append(fields, subscribesuspend.FieldLastModifier)
	}
	if m.FieldCleared(subscribesuspend.FieldRemark) {
		fields = append(fields, subscribesuspend.FieldRemark)
	}
	if m.FieldCleared(subscribesuspend.FieldPauseID) {
		fields = append(fields, subscribesuspend.FieldPauseID)
	}
	if m.FieldCleared(subscribesuspend.FieldEndAt) {
		fields = append(fields, subscribesuspend.FieldEndAt)
	}
	if m.FieldCleared(subscribesuspend.FieldEndReason) {
		fields = append(fields, subscribesuspend.FieldEndReason)
	}
	if m.FieldCleared(subscribesuspend.FieldEndModifier) {
		fields = append(fields, subscribesuspend.FieldEndModifier)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SubscribeSuspendMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SubscribeSuspendMutation) ClearField(name string) error {
	switch name {
	case subscribesuspend.FieldCreator:
		m.ClearCreator()
		return nil
	case subscribesuspend.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case subscribesuspend.FieldRemark:
		m.ClearRemark()
		return nil
	case subscribesuspend.FieldPauseID:
		m.ClearPauseID()
		return nil
	case subscribesuspend.FieldEndAt:
		m.ClearEndAt()
		return nil
	case subscribesuspend.FieldEndReason:
		m.ClearEndReason()
		return nil
	case subscribesuspend.FieldEndModifier:
		m.ClearEndModifier()
		return nil
	}
	return fmt.Errorf("unknown SubscribeSuspend nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SubscribeSuspendMutation) ResetField(name string) error {
	switch name {
	case subscribesuspend.FieldCreator:
		m.ResetCreator()
		return nil
	case subscribesuspend.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case subscribesuspend.FieldRemark:
		m.ResetRemark()
		return nil
	case subscribesuspend.FieldCityID:
		m.ResetCityID()
		return nil
	case subscribesuspend.FieldRiderID:
		m.ResetRiderID()
		return nil
	case subscribesuspend.FieldSubscribeID:
		m.ResetSubscribeID()
		return nil
	case subscribesuspend.FieldPauseID:
		m.ResetPauseID()
		return nil
	case subscribesuspend.FieldDays:
		m.ResetDays()
		return nil
	case subscribesuspend.FieldStartAt:
		m.ResetStartAt()
		return nil
	case subscribesuspend.FieldEndAt:
		m.ResetEndAt()
		return nil
	case subscribesuspend.FieldEndReason:
		m.ResetEndReason()
		return nil
	case subscribesuspend.FieldEndModifier:
		m.ResetEndModifier()
		return nil
	}
	return fmt.Errorf("unknown SubscribeSuspend field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SubscribeSuspendMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.city != nil {
		edges = append(edges, subscribesuspend.EdgeCity)
	}
	if m.rider != nil {
		edges = append(edges, subscribesuspend.EdgeRider)
	}
	if m.subscribe != nil {
		edges = append(edges, subscribesuspend.EdgeSubscribe)
	}
	if m.pause != nil {
		edges = append(edges, subscribesuspend.EdgePause)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SubscribeSuspendMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case subscribesuspend.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case subscribesuspend.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case subscribesuspend.EdgeSubscribe:
		if id := m.subscribe; id != nil {
			return []ent.Value{*id}
		}
	case subscribesuspend.EdgePause:
		if id := m.pause; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SubscribeSuspendMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SubscribeSuspendMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SubscribeSuspendMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcity {
		edges = append(edges, subscribesuspend.EdgeCity)
	}
	if m.clearedrider {
		edges = append(edges, subscribesuspend.EdgeRider)
	}
	if m.clearedsubscribe {
		edges = append(edges, subscribesuspend.EdgeSubscribe)
	}
	if m.clearedpause {
		edges = append(edges, subscribesuspend.EdgePause)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SubscribeSuspendMutation) EdgeCleared(name string) bool {
	switch name {
	case subscribesuspend.EdgeCity:
		return m.clearedcity
	case subscribesuspend.EdgeRider:
		return m.clearedrider
	case subscribesuspend.EdgeSubscribe:
		return m.clearedsubscribe
	case subscribesuspend.EdgePause:
		return m.clearedpause
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SubscribeSuspendMutation) ClearEdge(name string) error {
	switch name {
	case subscribesuspend.EdgeCity:
		m.ClearCity()
		return nil
	case subscribesuspend.EdgeRider:
		m.ClearRider()
		return nil
	case subscribesuspend.EdgeSubscribe:
		m.ClearSubscribe()
		return nil
	case subscribesuspend.EdgePause:
		m.ClearPause()
		return nil
	}
	return fmt.Errorf("unknown SubscribeSuspend unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SubscribeSuspendMutation) ResetEdge(name string) error {
	switch name {
	case subscribesuspend.EdgeCity:
		m.ResetCity()
		return nil
	case subscribesuspend.EdgeRider:
		m.ResetRider()
		return nil
	case subscribesuspend.EdgeSubscribe:
		m.ResetSubscribe()
		return nil
	case subscribesuspend.EdgePause:
		m.ResetPause()
		return nil
	}
	return fmt.Errorf("unknown SubscribeSuspend edge %s", name)
}

// VersionMutation represents an operation that mutates the Version nodes in the graph.
type VersionMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	creator       **model.Modifier
	last_modifier **model.Modifier
	remark        *string
	platform      *model.AppPlatform
	version       *string
	content       *string
	force         *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Version, error)
	predicates    []predicate.Version
}

var _ ent.Mutation = (*VersionMutation)(nil)

// versionOption allows management of the mutation configuration using functional options.
type versionOption func(*VersionMutation)

// newVersionMutation creates new mutation for the Version entity.
func newVersionMutation(c config, op Op, opts ...versionOption) *VersionMutation {
	m := &VersionMutation{
		config:        c,
		op:            op,
		typ:           TypeVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVersionID sets the ID field of the mutation.
func withVersionID(id uint64) versionOption {
	return func(m *VersionMutation) {
		var (
			err   error
			once  sync.Once
			value *Version
		)
		m.oldValue = func(ctx context.Context) (*Version, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Version.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVersion sets the old Version of the mutation.
func withVersion(node *Version) versionOption {
	return func(m *VersionMutation) {
		m.oldValue = func(context.Context) (*Version, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VersionMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VersionMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Version.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VersionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VersionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VersionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VersionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VersionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VersionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *VersionMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *VersionMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *VersionMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[version.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *VersionMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[version.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *VersionMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, version.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *VersionMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *VersionMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *VersionMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[version.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *VersionMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[version.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *VersionMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, version.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *VersionMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *VersionMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *VersionMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[version.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *VersionMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[version.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *VersionMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, version.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *VersionMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *VersionMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *VersionMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[version.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *VersionMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[version.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *VersionMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, version.FieldRemark)
}

// SetPlatform sets the "platform" field.
func (m *VersionMutation) SetPlatform(mp model.AppPlatform) {
	m.platform = &mp
}

// Platform returns the value of the "platform" field in the mutation.
func (m *VersionMutation) Platform() (r model.AppPlatform, exists bool) {
	v := m.platform
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatform returns the old "platform" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldPlatform(ctx context.Context) (v model.AppPlatform, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatform is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatform requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatform: %w", err)
	}
	return oldValue.Platform, nil
}

// ResetPlatform resets all changes to the "platform" field.
func (m *VersionMutation) ResetPlatform() {
	m.platform = nil
}

// SetVersion sets the "version" field.
func (m *VersionMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *VersionMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *VersionMutation) ResetVersion() {
	m.version = nil
}

// SetContent sets the "content" field.
func (m *VersionMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *VersionMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *VersionMutation) ResetContent() {
	m.content = nil
}

// SetForce sets the "force" field.
func (m *VersionMutation) SetForce(b bool) {
	m.force = &b
}

// Force returns the value of the "force" field in the mutation.
func (m *VersionMutation) Force() (r bool, exists bool) {
	v := m.force
	if v == nil {
		return
	}
	return *v, true
}

// OldForce returns the old "force" field's value of the Version entity.
// If the Version object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VersionMutation) OldForce(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForce is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForce requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForce: %w", err)
	}
	return oldValue.Force, nil
}

// ResetForce resets all changes to the "force" field.
func (m *VersionMutation) ResetForce() {
	m.force = nil
}

// Where appends a list predicates to the VersionMutation builder.
func (m *VersionMutation) Where(ps ...predicate.Version) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Version, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Version).
func (m *VersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VersionMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, version.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, version.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, version.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, version.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, version.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, version.FieldRemark)
	}
	if m.platform != nil {
		fields = append(fields, version.FieldPlatform)
	}
	if m.version != nil {
		fields = append(fields, version.FieldVersion)
	}
	if m.content != nil {
		fields = append(fields, version.FieldContent)
	}
	if m.force != nil {
		fields = append(fields, version.FieldForce)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VersionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case version.FieldCreatedAt:
		return m.CreatedAt()
	case version.FieldUpdatedAt:
		return m.UpdatedAt()
	case version.FieldDeletedAt:
		return m.DeletedAt()
	case version.FieldCreator:
		return m.Creator()
	case version.FieldLastModifier:
		return m.LastModifier()
	case version.FieldRemark:
		return m.Remark()
	case version.FieldPlatform:
		return m.Platform()
	case version.FieldVersion:
		return m.Version()
	case version.FieldContent:
		return m.Content()
	case version.FieldForce:
		return m.Force()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case version.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case version.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case version.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case version.FieldCreator:
		return m.OldCreator(ctx)
	case version.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case version.FieldRemark:
		return m.OldRemark(ctx)
	case version.FieldPlatform:
		return m.OldPlatform(ctx)
	case version.FieldVersion:
		return m.OldVersion(ctx)
	case version.FieldContent:
		return m.OldContent(ctx)
	case version.FieldForce:
		return m.OldForce(ctx)
	}
	return nil, fmt.Errorf("unknown Version field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case version.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case version.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case version.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case version.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case version.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case version.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case version.FieldPlatform:
		v, ok := value.(model.AppPlatform)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatform(v)
		return nil
	case version.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case version.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case version.FieldForce:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForce(v)
		return nil
	}
	return fmt.Errorf("unknown Version field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VersionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VersionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VersionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Version numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VersionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(version.FieldDeletedAt) {
		fields = append(fields, version.FieldDeletedAt)
	}
	if m.FieldCleared(version.FieldCreator) {
		fields = append(fields, version.FieldCreator)
	}
	if m.FieldCleared(version.FieldLastModifier) {
		fields = append(fields, version.FieldLastModifier)
	}
	if m.FieldCleared(version.FieldRemark) {
		fields = append(fields, version.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VersionMutation) ClearField(name string) error {
	switch name {
	case version.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case version.FieldCreator:
		m.ClearCreator()
		return nil
	case version.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case version.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Version nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VersionMutation) ResetField(name string) error {
	switch name {
	case version.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case version.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case version.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case version.FieldCreator:
		m.ResetCreator()
		return nil
	case version.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case version.FieldRemark:
		m.ResetRemark()
		return nil
	case version.FieldPlatform:
		m.ResetPlatform()
		return nil
	case version.FieldVersion:
		m.ResetVersion()
		return nil
	case version.FieldContent:
		m.ResetContent()
		return nil
	case version.FieldForce:
		m.ResetForce()
		return nil
	}
	return fmt.Errorf("unknown Version field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Version unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Version edge %s", name)
}
