// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/auroraride/aurservd/app/model"
	"github.com/auroraride/aurservd/internal/ent/batterymodel"
	"github.com/auroraride/aurservd/internal/ent/branch"
	"github.com/auroraride/aurservd/internal/ent/branchcontract"
	"github.com/auroraride/aurservd/internal/ent/cabinet"
	"github.com/auroraride/aurservd/internal/ent/cabinetfault"
	"github.com/auroraride/aurservd/internal/ent/city"
	"github.com/auroraride/aurservd/internal/ent/contract"
	"github.com/auroraride/aurservd/internal/ent/enterprise"
	"github.com/auroraride/aurservd/internal/ent/manager"
	"github.com/auroraride/aurservd/internal/ent/person"
	"github.com/auroraride/aurservd/internal/ent/plan"
	"github.com/auroraride/aurservd/internal/ent/predicate"
	"github.com/auroraride/aurservd/internal/ent/rider"
	"github.com/auroraride/aurservd/internal/ent/setting"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBatteryModel   = "BatteryModel"
	TypeBranch         = "Branch"
	TypeBranchContract = "BranchContract"
	TypeCabinet        = "Cabinet"
	TypeCabinetFault   = "CabinetFault"
	TypeCity           = "City"
	TypeContract       = "Contract"
	TypeEnterprise     = "Enterprise"
	TypeManager        = "Manager"
	TypePerson         = "Person"
	TypePlan           = "Plan"
	TypeRider          = "Rider"
	TypeSetting        = "Setting"
)

// BatteryModelMutation represents an operation that mutates the BatteryModel nodes in the graph.
type BatteryModelMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	creator         **model.Modifier
	last_modifier   **model.Modifier
	remark          *string
	voltage         *string
	capacity        *string
	clearedFields   map[string]struct{}
	cabinets        map[uint64]struct{}
	removedcabinets map[uint64]struct{}
	clearedcabinets bool
	plans           map[uint64]struct{}
	removedplans    map[uint64]struct{}
	clearedplans    bool
	done            bool
	oldValue        func(context.Context) (*BatteryModel, error)
	predicates      []predicate.BatteryModel
}

var _ ent.Mutation = (*BatteryModelMutation)(nil)

// batterymodelOption allows management of the mutation configuration using functional options.
type batterymodelOption func(*BatteryModelMutation)

// newBatteryModelMutation creates new mutation for the BatteryModel entity.
func newBatteryModelMutation(c config, op Op, opts ...batterymodelOption) *BatteryModelMutation {
	m := &BatteryModelMutation{
		config:        c,
		op:            op,
		typ:           TypeBatteryModel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBatteryModelID sets the ID field of the mutation.
func withBatteryModelID(id uint64) batterymodelOption {
	return func(m *BatteryModelMutation) {
		var (
			err   error
			once  sync.Once
			value *BatteryModel
		)
		m.oldValue = func(ctx context.Context) (*BatteryModel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BatteryModel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBatteryModel sets the old BatteryModel of the mutation.
func withBatteryModel(node *BatteryModel) batterymodelOption {
	return func(m *BatteryModelMutation) {
		m.oldValue = func(context.Context) (*BatteryModel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BatteryModelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BatteryModelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BatteryModelMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BatteryModelMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BatteryModel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BatteryModelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BatteryModelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BatteryModel entity.
// If the BatteryModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryModelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BatteryModelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BatteryModelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BatteryModelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BatteryModel entity.
// If the BatteryModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryModelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BatteryModelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BatteryModelMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BatteryModelMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BatteryModel entity.
// If the BatteryModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryModelMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BatteryModelMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[batterymodel.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BatteryModelMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[batterymodel.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BatteryModelMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, batterymodel.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *BatteryModelMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *BatteryModelMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the BatteryModel entity.
// If the BatteryModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryModelMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *BatteryModelMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[batterymodel.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *BatteryModelMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[batterymodel.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *BatteryModelMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, batterymodel.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *BatteryModelMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *BatteryModelMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the BatteryModel entity.
// If the BatteryModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryModelMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *BatteryModelMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[batterymodel.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *BatteryModelMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[batterymodel.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *BatteryModelMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, batterymodel.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *BatteryModelMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *BatteryModelMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the BatteryModel entity.
// If the BatteryModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryModelMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *BatteryModelMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[batterymodel.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *BatteryModelMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[batterymodel.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *BatteryModelMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, batterymodel.FieldRemark)
}

// SetVoltage sets the "voltage" field.
func (m *BatteryModelMutation) SetVoltage(s string) {
	m.voltage = &s
}

// Voltage returns the value of the "voltage" field in the mutation.
func (m *BatteryModelMutation) Voltage() (r string, exists bool) {
	v := m.voltage
	if v == nil {
		return
	}
	return *v, true
}

// OldVoltage returns the old "voltage" field's value of the BatteryModel entity.
// If the BatteryModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryModelMutation) OldVoltage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVoltage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVoltage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVoltage: %w", err)
	}
	return oldValue.Voltage, nil
}

// ResetVoltage resets all changes to the "voltage" field.
func (m *BatteryModelMutation) ResetVoltage() {
	m.voltage = nil
}

// SetCapacity sets the "capacity" field.
func (m *BatteryModelMutation) SetCapacity(s string) {
	m.capacity = &s
}

// Capacity returns the value of the "capacity" field in the mutation.
func (m *BatteryModelMutation) Capacity() (r string, exists bool) {
	v := m.capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldCapacity returns the old "capacity" field's value of the BatteryModel entity.
// If the BatteryModel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BatteryModelMutation) OldCapacity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCapacity: %w", err)
	}
	return oldValue.Capacity, nil
}

// ResetCapacity resets all changes to the "capacity" field.
func (m *BatteryModelMutation) ResetCapacity() {
	m.capacity = nil
}

// AddCabinetIDs adds the "cabinets" edge to the Cabinet entity by ids.
func (m *BatteryModelMutation) AddCabinetIDs(ids ...uint64) {
	if m.cabinets == nil {
		m.cabinets = make(map[uint64]struct{})
	}
	for i := range ids {
		m.cabinets[ids[i]] = struct{}{}
	}
}

// ClearCabinets clears the "cabinets" edge to the Cabinet entity.
func (m *BatteryModelMutation) ClearCabinets() {
	m.clearedcabinets = true
}

// CabinetsCleared reports if the "cabinets" edge to the Cabinet entity was cleared.
func (m *BatteryModelMutation) CabinetsCleared() bool {
	return m.clearedcabinets
}

// RemoveCabinetIDs removes the "cabinets" edge to the Cabinet entity by IDs.
func (m *BatteryModelMutation) RemoveCabinetIDs(ids ...uint64) {
	if m.removedcabinets == nil {
		m.removedcabinets = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.cabinets, ids[i])
		m.removedcabinets[ids[i]] = struct{}{}
	}
}

// RemovedCabinets returns the removed IDs of the "cabinets" edge to the Cabinet entity.
func (m *BatteryModelMutation) RemovedCabinetsIDs() (ids []uint64) {
	for id := range m.removedcabinets {
		ids = append(ids, id)
	}
	return
}

// CabinetsIDs returns the "cabinets" edge IDs in the mutation.
func (m *BatteryModelMutation) CabinetsIDs() (ids []uint64) {
	for id := range m.cabinets {
		ids = append(ids, id)
	}
	return
}

// ResetCabinets resets all changes to the "cabinets" edge.
func (m *BatteryModelMutation) ResetCabinets() {
	m.cabinets = nil
	m.clearedcabinets = false
	m.removedcabinets = nil
}

// AddPlanIDs adds the "plans" edge to the Plan entity by ids.
func (m *BatteryModelMutation) AddPlanIDs(ids ...uint64) {
	if m.plans == nil {
		m.plans = make(map[uint64]struct{})
	}
	for i := range ids {
		m.plans[ids[i]] = struct{}{}
	}
}

// ClearPlans clears the "plans" edge to the Plan entity.
func (m *BatteryModelMutation) ClearPlans() {
	m.clearedplans = true
}

// PlansCleared reports if the "plans" edge to the Plan entity was cleared.
func (m *BatteryModelMutation) PlansCleared() bool {
	return m.clearedplans
}

// RemovePlanIDs removes the "plans" edge to the Plan entity by IDs.
func (m *BatteryModelMutation) RemovePlanIDs(ids ...uint64) {
	if m.removedplans == nil {
		m.removedplans = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.plans, ids[i])
		m.removedplans[ids[i]] = struct{}{}
	}
}

// RemovedPlans returns the removed IDs of the "plans" edge to the Plan entity.
func (m *BatteryModelMutation) RemovedPlansIDs() (ids []uint64) {
	for id := range m.removedplans {
		ids = append(ids, id)
	}
	return
}

// PlansIDs returns the "plans" edge IDs in the mutation.
func (m *BatteryModelMutation) PlansIDs() (ids []uint64) {
	for id := range m.plans {
		ids = append(ids, id)
	}
	return
}

// ResetPlans resets all changes to the "plans" edge.
func (m *BatteryModelMutation) ResetPlans() {
	m.plans = nil
	m.clearedplans = false
	m.removedplans = nil
}

// Where appends a list predicates to the BatteryModelMutation builder.
func (m *BatteryModelMutation) Where(ps ...predicate.BatteryModel) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BatteryModelMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BatteryModel).
func (m *BatteryModelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BatteryModelMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, batterymodel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, batterymodel.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, batterymodel.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, batterymodel.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, batterymodel.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, batterymodel.FieldRemark)
	}
	if m.voltage != nil {
		fields = append(fields, batterymodel.FieldVoltage)
	}
	if m.capacity != nil {
		fields = append(fields, batterymodel.FieldCapacity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BatteryModelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case batterymodel.FieldCreatedAt:
		return m.CreatedAt()
	case batterymodel.FieldUpdatedAt:
		return m.UpdatedAt()
	case batterymodel.FieldDeletedAt:
		return m.DeletedAt()
	case batterymodel.FieldCreator:
		return m.Creator()
	case batterymodel.FieldLastModifier:
		return m.LastModifier()
	case batterymodel.FieldRemark:
		return m.Remark()
	case batterymodel.FieldVoltage:
		return m.Voltage()
	case batterymodel.FieldCapacity:
		return m.Capacity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BatteryModelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case batterymodel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case batterymodel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case batterymodel.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case batterymodel.FieldCreator:
		return m.OldCreator(ctx)
	case batterymodel.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case batterymodel.FieldRemark:
		return m.OldRemark(ctx)
	case batterymodel.FieldVoltage:
		return m.OldVoltage(ctx)
	case batterymodel.FieldCapacity:
		return m.OldCapacity(ctx)
	}
	return nil, fmt.Errorf("unknown BatteryModel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BatteryModelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case batterymodel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case batterymodel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case batterymodel.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case batterymodel.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case batterymodel.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case batterymodel.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case batterymodel.FieldVoltage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVoltage(v)
		return nil
	case batterymodel.FieldCapacity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCapacity(v)
		return nil
	}
	return fmt.Errorf("unknown BatteryModel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BatteryModelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BatteryModelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BatteryModelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BatteryModel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BatteryModelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(batterymodel.FieldDeletedAt) {
		fields = append(fields, batterymodel.FieldDeletedAt)
	}
	if m.FieldCleared(batterymodel.FieldCreator) {
		fields = append(fields, batterymodel.FieldCreator)
	}
	if m.FieldCleared(batterymodel.FieldLastModifier) {
		fields = append(fields, batterymodel.FieldLastModifier)
	}
	if m.FieldCleared(batterymodel.FieldRemark) {
		fields = append(fields, batterymodel.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BatteryModelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BatteryModelMutation) ClearField(name string) error {
	switch name {
	case batterymodel.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case batterymodel.FieldCreator:
		m.ClearCreator()
		return nil
	case batterymodel.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case batterymodel.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown BatteryModel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BatteryModelMutation) ResetField(name string) error {
	switch name {
	case batterymodel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case batterymodel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case batterymodel.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case batterymodel.FieldCreator:
		m.ResetCreator()
		return nil
	case batterymodel.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case batterymodel.FieldRemark:
		m.ResetRemark()
		return nil
	case batterymodel.FieldVoltage:
		m.ResetVoltage()
		return nil
	case batterymodel.FieldCapacity:
		m.ResetCapacity()
		return nil
	}
	return fmt.Errorf("unknown BatteryModel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BatteryModelMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cabinets != nil {
		edges = append(edges, batterymodel.EdgeCabinets)
	}
	if m.plans != nil {
		edges = append(edges, batterymodel.EdgePlans)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BatteryModelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case batterymodel.EdgeCabinets:
		ids := make([]ent.Value, 0, len(m.cabinets))
		for id := range m.cabinets {
			ids = append(ids, id)
		}
		return ids
	case batterymodel.EdgePlans:
		ids := make([]ent.Value, 0, len(m.plans))
		for id := range m.plans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BatteryModelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcabinets != nil {
		edges = append(edges, batterymodel.EdgeCabinets)
	}
	if m.removedplans != nil {
		edges = append(edges, batterymodel.EdgePlans)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BatteryModelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case batterymodel.EdgeCabinets:
		ids := make([]ent.Value, 0, len(m.removedcabinets))
		for id := range m.removedcabinets {
			ids = append(ids, id)
		}
		return ids
	case batterymodel.EdgePlans:
		ids := make([]ent.Value, 0, len(m.removedplans))
		for id := range m.removedplans {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BatteryModelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcabinets {
		edges = append(edges, batterymodel.EdgeCabinets)
	}
	if m.clearedplans {
		edges = append(edges, batterymodel.EdgePlans)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BatteryModelMutation) EdgeCleared(name string) bool {
	switch name {
	case batterymodel.EdgeCabinets:
		return m.clearedcabinets
	case batterymodel.EdgePlans:
		return m.clearedplans
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BatteryModelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown BatteryModel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BatteryModelMutation) ResetEdge(name string) error {
	switch name {
	case batterymodel.EdgeCabinets:
		m.ResetCabinets()
		return nil
	case batterymodel.EdgePlans:
		m.ResetPlans()
		return nil
	}
	return fmt.Errorf("unknown BatteryModel edge %s", name)
}

// BranchMutation represents an operation that mutates the Branch nodes in the graph.
type BranchMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	creator          **model.Modifier
	last_modifier    **model.Modifier
	remark           *string
	name             *string
	lng              *float64
	addlng           *float64
	lat              *float64
	addlat           *float64
	address          *string
	photos           *[]string
	clearedFields    map[string]struct{}
	contracts        map[uint64]struct{}
	removedcontracts map[uint64]struct{}
	clearedcontracts bool
	cabinets         map[uint64]struct{}
	removedcabinets  map[uint64]struct{}
	clearedcabinets  bool
	city             *uint64
	clearedcity      bool
	faults           map[uint64]struct{}
	removedfaults    map[uint64]struct{}
	clearedfaults    bool
	done             bool
	oldValue         func(context.Context) (*Branch, error)
	predicates       []predicate.Branch
}

var _ ent.Mutation = (*BranchMutation)(nil)

// branchOption allows management of the mutation configuration using functional options.
type branchOption func(*BranchMutation)

// newBranchMutation creates new mutation for the Branch entity.
func newBranchMutation(c config, op Op, opts ...branchOption) *BranchMutation {
	m := &BranchMutation{
		config:        c,
		op:            op,
		typ:           TypeBranch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBranchID sets the ID field of the mutation.
func withBranchID(id uint64) branchOption {
	return func(m *BranchMutation) {
		var (
			err   error
			once  sync.Once
			value *Branch
		)
		m.oldValue = func(ctx context.Context) (*Branch, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Branch.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBranch sets the old Branch of the mutation.
func withBranch(node *Branch) branchOption {
	return func(m *BranchMutation) {
		m.oldValue = func(context.Context) (*Branch, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BranchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BranchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BranchMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BranchMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Branch.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BranchMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BranchMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BranchMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BranchMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BranchMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BranchMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BranchMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BranchMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BranchMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[branch.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BranchMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[branch.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BranchMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, branch.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *BranchMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *BranchMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *BranchMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[branch.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *BranchMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[branch.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *BranchMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, branch.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *BranchMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *BranchMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *BranchMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[branch.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *BranchMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[branch.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *BranchMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, branch.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *BranchMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *BranchMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *BranchMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[branch.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *BranchMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[branch.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *BranchMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, branch.FieldRemark)
}

// SetCityID sets the "city_id" field.
func (m *BranchMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *BranchMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *BranchMutation) ResetCityID() {
	m.city = nil
}

// SetName sets the "name" field.
func (m *BranchMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *BranchMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *BranchMutation) ResetName() {
	m.name = nil
}

// SetLng sets the "lng" field.
func (m *BranchMutation) SetLng(f float64) {
	m.lng = &f
	m.addlng = nil
}

// Lng returns the value of the "lng" field in the mutation.
func (m *BranchMutation) Lng() (r float64, exists bool) {
	v := m.lng
	if v == nil {
		return
	}
	return *v, true
}

// OldLng returns the old "lng" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldLng(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLng is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLng requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLng: %w", err)
	}
	return oldValue.Lng, nil
}

// AddLng adds f to the "lng" field.
func (m *BranchMutation) AddLng(f float64) {
	if m.addlng != nil {
		*m.addlng += f
	} else {
		m.addlng = &f
	}
}

// AddedLng returns the value that was added to the "lng" field in this mutation.
func (m *BranchMutation) AddedLng() (r float64, exists bool) {
	v := m.addlng
	if v == nil {
		return
	}
	return *v, true
}

// ResetLng resets all changes to the "lng" field.
func (m *BranchMutation) ResetLng() {
	m.lng = nil
	m.addlng = nil
}

// SetLat sets the "lat" field.
func (m *BranchMutation) SetLat(f float64) {
	m.lat = &f
	m.addlat = nil
}

// Lat returns the value of the "lat" field in the mutation.
func (m *BranchMutation) Lat() (r float64, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "lat" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldLat(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// AddLat adds f to the "lat" field.
func (m *BranchMutation) AddLat(f float64) {
	if m.addlat != nil {
		*m.addlat += f
	} else {
		m.addlat = &f
	}
}

// AddedLat returns the value that was added to the "lat" field in this mutation.
func (m *BranchMutation) AddedLat() (r float64, exists bool) {
	v := m.addlat
	if v == nil {
		return
	}
	return *v, true
}

// ResetLat resets all changes to the "lat" field.
func (m *BranchMutation) ResetLat() {
	m.lat = nil
	m.addlat = nil
}

// SetAddress sets the "address" field.
func (m *BranchMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *BranchMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *BranchMutation) ResetAddress() {
	m.address = nil
}

// SetPhotos sets the "photos" field.
func (m *BranchMutation) SetPhotos(s []string) {
	m.photos = &s
}

// Photos returns the value of the "photos" field in the mutation.
func (m *BranchMutation) Photos() (r []string, exists bool) {
	v := m.photos
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotos returns the old "photos" field's value of the Branch entity.
// If the Branch object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchMutation) OldPhotos(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotos is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotos requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotos: %w", err)
	}
	return oldValue.Photos, nil
}

// ResetPhotos resets all changes to the "photos" field.
func (m *BranchMutation) ResetPhotos() {
	m.photos = nil
}

// AddContractIDs adds the "contracts" edge to the BranchContract entity by ids.
func (m *BranchMutation) AddContractIDs(ids ...uint64) {
	if m.contracts == nil {
		m.contracts = make(map[uint64]struct{})
	}
	for i := range ids {
		m.contracts[ids[i]] = struct{}{}
	}
}

// ClearContracts clears the "contracts" edge to the BranchContract entity.
func (m *BranchMutation) ClearContracts() {
	m.clearedcontracts = true
}

// ContractsCleared reports if the "contracts" edge to the BranchContract entity was cleared.
func (m *BranchMutation) ContractsCleared() bool {
	return m.clearedcontracts
}

// RemoveContractIDs removes the "contracts" edge to the BranchContract entity by IDs.
func (m *BranchMutation) RemoveContractIDs(ids ...uint64) {
	if m.removedcontracts == nil {
		m.removedcontracts = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.contracts, ids[i])
		m.removedcontracts[ids[i]] = struct{}{}
	}
}

// RemovedContracts returns the removed IDs of the "contracts" edge to the BranchContract entity.
func (m *BranchMutation) RemovedContractsIDs() (ids []uint64) {
	for id := range m.removedcontracts {
		ids = append(ids, id)
	}
	return
}

// ContractsIDs returns the "contracts" edge IDs in the mutation.
func (m *BranchMutation) ContractsIDs() (ids []uint64) {
	for id := range m.contracts {
		ids = append(ids, id)
	}
	return
}

// ResetContracts resets all changes to the "contracts" edge.
func (m *BranchMutation) ResetContracts() {
	m.contracts = nil
	m.clearedcontracts = false
	m.removedcontracts = nil
}

// AddCabinetIDs adds the "cabinets" edge to the Cabinet entity by ids.
func (m *BranchMutation) AddCabinetIDs(ids ...uint64) {
	if m.cabinets == nil {
		m.cabinets = make(map[uint64]struct{})
	}
	for i := range ids {
		m.cabinets[ids[i]] = struct{}{}
	}
}

// ClearCabinets clears the "cabinets" edge to the Cabinet entity.
func (m *BranchMutation) ClearCabinets() {
	m.clearedcabinets = true
}

// CabinetsCleared reports if the "cabinets" edge to the Cabinet entity was cleared.
func (m *BranchMutation) CabinetsCleared() bool {
	return m.clearedcabinets
}

// RemoveCabinetIDs removes the "cabinets" edge to the Cabinet entity by IDs.
func (m *BranchMutation) RemoveCabinetIDs(ids ...uint64) {
	if m.removedcabinets == nil {
		m.removedcabinets = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.cabinets, ids[i])
		m.removedcabinets[ids[i]] = struct{}{}
	}
}

// RemovedCabinets returns the removed IDs of the "cabinets" edge to the Cabinet entity.
func (m *BranchMutation) RemovedCabinetsIDs() (ids []uint64) {
	for id := range m.removedcabinets {
		ids = append(ids, id)
	}
	return
}

// CabinetsIDs returns the "cabinets" edge IDs in the mutation.
func (m *BranchMutation) CabinetsIDs() (ids []uint64) {
	for id := range m.cabinets {
		ids = append(ids, id)
	}
	return
}

// ResetCabinets resets all changes to the "cabinets" edge.
func (m *BranchMutation) ResetCabinets() {
	m.cabinets = nil
	m.clearedcabinets = false
	m.removedcabinets = nil
}

// ClearCity clears the "city" edge to the City entity.
func (m *BranchMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *BranchMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *BranchMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *BranchMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// AddFaultIDs adds the "faults" edge to the CabinetFault entity by ids.
func (m *BranchMutation) AddFaultIDs(ids ...uint64) {
	if m.faults == nil {
		m.faults = make(map[uint64]struct{})
	}
	for i := range ids {
		m.faults[ids[i]] = struct{}{}
	}
}

// ClearFaults clears the "faults" edge to the CabinetFault entity.
func (m *BranchMutation) ClearFaults() {
	m.clearedfaults = true
}

// FaultsCleared reports if the "faults" edge to the CabinetFault entity was cleared.
func (m *BranchMutation) FaultsCleared() bool {
	return m.clearedfaults
}

// RemoveFaultIDs removes the "faults" edge to the CabinetFault entity by IDs.
func (m *BranchMutation) RemoveFaultIDs(ids ...uint64) {
	if m.removedfaults == nil {
		m.removedfaults = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.faults, ids[i])
		m.removedfaults[ids[i]] = struct{}{}
	}
}

// RemovedFaults returns the removed IDs of the "faults" edge to the CabinetFault entity.
func (m *BranchMutation) RemovedFaultsIDs() (ids []uint64) {
	for id := range m.removedfaults {
		ids = append(ids, id)
	}
	return
}

// FaultsIDs returns the "faults" edge IDs in the mutation.
func (m *BranchMutation) FaultsIDs() (ids []uint64) {
	for id := range m.faults {
		ids = append(ids, id)
	}
	return
}

// ResetFaults resets all changes to the "faults" edge.
func (m *BranchMutation) ResetFaults() {
	m.faults = nil
	m.clearedfaults = false
	m.removedfaults = nil
}

// Where appends a list predicates to the BranchMutation builder.
func (m *BranchMutation) Where(ps ...predicate.Branch) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BranchMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Branch).
func (m *BranchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BranchMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, branch.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, branch.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, branch.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, branch.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, branch.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, branch.FieldRemark)
	}
	if m.city != nil {
		fields = append(fields, branch.FieldCityID)
	}
	if m.name != nil {
		fields = append(fields, branch.FieldName)
	}
	if m.lng != nil {
		fields = append(fields, branch.FieldLng)
	}
	if m.lat != nil {
		fields = append(fields, branch.FieldLat)
	}
	if m.address != nil {
		fields = append(fields, branch.FieldAddress)
	}
	if m.photos != nil {
		fields = append(fields, branch.FieldPhotos)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BranchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case branch.FieldCreatedAt:
		return m.CreatedAt()
	case branch.FieldUpdatedAt:
		return m.UpdatedAt()
	case branch.FieldDeletedAt:
		return m.DeletedAt()
	case branch.FieldCreator:
		return m.Creator()
	case branch.FieldLastModifier:
		return m.LastModifier()
	case branch.FieldRemark:
		return m.Remark()
	case branch.FieldCityID:
		return m.CityID()
	case branch.FieldName:
		return m.Name()
	case branch.FieldLng:
		return m.Lng()
	case branch.FieldLat:
		return m.Lat()
	case branch.FieldAddress:
		return m.Address()
	case branch.FieldPhotos:
		return m.Photos()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BranchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case branch.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case branch.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case branch.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case branch.FieldCreator:
		return m.OldCreator(ctx)
	case branch.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case branch.FieldRemark:
		return m.OldRemark(ctx)
	case branch.FieldCityID:
		return m.OldCityID(ctx)
	case branch.FieldName:
		return m.OldName(ctx)
	case branch.FieldLng:
		return m.OldLng(ctx)
	case branch.FieldLat:
		return m.OldLat(ctx)
	case branch.FieldAddress:
		return m.OldAddress(ctx)
	case branch.FieldPhotos:
		return m.OldPhotos(ctx)
	}
	return nil, fmt.Errorf("unknown Branch field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BranchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case branch.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case branch.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case branch.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case branch.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case branch.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case branch.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case branch.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case branch.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case branch.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLng(v)
		return nil
	case branch.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	case branch.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case branch.FieldPhotos:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotos(v)
		return nil
	}
	return fmt.Errorf("unknown Branch field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BranchMutation) AddedFields() []string {
	var fields []string
	if m.addlng != nil {
		fields = append(fields, branch.FieldLng)
	}
	if m.addlat != nil {
		fields = append(fields, branch.FieldLat)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BranchMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case branch.FieldLng:
		return m.AddedLng()
	case branch.FieldLat:
		return m.AddedLat()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BranchMutation) AddField(name string, value ent.Value) error {
	switch name {
	case branch.FieldLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLng(v)
		return nil
	case branch.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLat(v)
		return nil
	}
	return fmt.Errorf("unknown Branch numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BranchMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(branch.FieldDeletedAt) {
		fields = append(fields, branch.FieldDeletedAt)
	}
	if m.FieldCleared(branch.FieldCreator) {
		fields = append(fields, branch.FieldCreator)
	}
	if m.FieldCleared(branch.FieldLastModifier) {
		fields = append(fields, branch.FieldLastModifier)
	}
	if m.FieldCleared(branch.FieldRemark) {
		fields = append(fields, branch.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BranchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BranchMutation) ClearField(name string) error {
	switch name {
	case branch.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case branch.FieldCreator:
		m.ClearCreator()
		return nil
	case branch.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case branch.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Branch nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BranchMutation) ResetField(name string) error {
	switch name {
	case branch.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case branch.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case branch.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case branch.FieldCreator:
		m.ResetCreator()
		return nil
	case branch.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case branch.FieldRemark:
		m.ResetRemark()
		return nil
	case branch.FieldCityID:
		m.ResetCityID()
		return nil
	case branch.FieldName:
		m.ResetName()
		return nil
	case branch.FieldLng:
		m.ResetLng()
		return nil
	case branch.FieldLat:
		m.ResetLat()
		return nil
	case branch.FieldAddress:
		m.ResetAddress()
		return nil
	case branch.FieldPhotos:
		m.ResetPhotos()
		return nil
	}
	return fmt.Errorf("unknown Branch field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BranchMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.contracts != nil {
		edges = append(edges, branch.EdgeContracts)
	}
	if m.cabinets != nil {
		edges = append(edges, branch.EdgeCabinets)
	}
	if m.city != nil {
		edges = append(edges, branch.EdgeCity)
	}
	if m.faults != nil {
		edges = append(edges, branch.EdgeFaults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BranchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case branch.EdgeContracts:
		ids := make([]ent.Value, 0, len(m.contracts))
		for id := range m.contracts {
			ids = append(ids, id)
		}
		return ids
	case branch.EdgeCabinets:
		ids := make([]ent.Value, 0, len(m.cabinets))
		for id := range m.cabinets {
			ids = append(ids, id)
		}
		return ids
	case branch.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	case branch.EdgeFaults:
		ids := make([]ent.Value, 0, len(m.faults))
		for id := range m.faults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BranchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcontracts != nil {
		edges = append(edges, branch.EdgeContracts)
	}
	if m.removedcabinets != nil {
		edges = append(edges, branch.EdgeCabinets)
	}
	if m.removedfaults != nil {
		edges = append(edges, branch.EdgeFaults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BranchMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case branch.EdgeContracts:
		ids := make([]ent.Value, 0, len(m.removedcontracts))
		for id := range m.removedcontracts {
			ids = append(ids, id)
		}
		return ids
	case branch.EdgeCabinets:
		ids := make([]ent.Value, 0, len(m.removedcabinets))
		for id := range m.removedcabinets {
			ids = append(ids, id)
		}
		return ids
	case branch.EdgeFaults:
		ids := make([]ent.Value, 0, len(m.removedfaults))
		for id := range m.removedfaults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BranchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcontracts {
		edges = append(edges, branch.EdgeContracts)
	}
	if m.clearedcabinets {
		edges = append(edges, branch.EdgeCabinets)
	}
	if m.clearedcity {
		edges = append(edges, branch.EdgeCity)
	}
	if m.clearedfaults {
		edges = append(edges, branch.EdgeFaults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BranchMutation) EdgeCleared(name string) bool {
	switch name {
	case branch.EdgeContracts:
		return m.clearedcontracts
	case branch.EdgeCabinets:
		return m.clearedcabinets
	case branch.EdgeCity:
		return m.clearedcity
	case branch.EdgeFaults:
		return m.clearedfaults
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BranchMutation) ClearEdge(name string) error {
	switch name {
	case branch.EdgeCity:
		m.ClearCity()
		return nil
	}
	return fmt.Errorf("unknown Branch unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BranchMutation) ResetEdge(name string) error {
	switch name {
	case branch.EdgeContracts:
		m.ResetContracts()
		return nil
	case branch.EdgeCabinets:
		m.ResetCabinets()
		return nil
	case branch.EdgeCity:
		m.ResetCity()
		return nil
	case branch.EdgeFaults:
		m.ResetFaults()
		return nil
	}
	return fmt.Errorf("unknown Branch edge %s", name)
}

// BranchContractMutation represents an operation that mutates the BranchContract nodes in the graph.
type BranchContractMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uint64
	created_at            *time.Time
	updated_at            *time.Time
	deleted_at            *time.Time
	creator               **model.Modifier
	last_modifier         **model.Modifier
	remark                *string
	landlord_name         *string
	id_card_number        *string
	phone                 *string
	bank_number           *string
	pledge                *float64
	addpledge             *float64
	rent                  *float64
	addrent               *float64
	lease                 *uint
	addlease              *int
	electricity_pledge    *float64
	addelectricity_pledge *float64
	electricity           *float64
	addelectricity        *float64
	area                  *float64
	addarea               *float64
	start_time            *string
	end_time              *string
	file                  *string
	sheets                *[]string
	clearedFields         map[string]struct{}
	branch                *uint64
	clearedbranch         bool
	done                  bool
	oldValue              func(context.Context) (*BranchContract, error)
	predicates            []predicate.BranchContract
}

var _ ent.Mutation = (*BranchContractMutation)(nil)

// branchcontractOption allows management of the mutation configuration using functional options.
type branchcontractOption func(*BranchContractMutation)

// newBranchContractMutation creates new mutation for the BranchContract entity.
func newBranchContractMutation(c config, op Op, opts ...branchcontractOption) *BranchContractMutation {
	m := &BranchContractMutation{
		config:        c,
		op:            op,
		typ:           TypeBranchContract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBranchContractID sets the ID field of the mutation.
func withBranchContractID(id uint64) branchcontractOption {
	return func(m *BranchContractMutation) {
		var (
			err   error
			once  sync.Once
			value *BranchContract
		)
		m.oldValue = func(ctx context.Context) (*BranchContract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BranchContract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBranchContract sets the old BranchContract of the mutation.
func withBranchContract(node *BranchContract) branchcontractOption {
	return func(m *BranchContractMutation) {
		m.oldValue = func(context.Context) (*BranchContract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BranchContractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BranchContractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BranchContractMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BranchContractMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BranchContract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BranchContractMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BranchContractMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BranchContractMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BranchContractMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BranchContractMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BranchContractMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *BranchContractMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *BranchContractMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *BranchContractMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[branchcontract.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *BranchContractMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[branchcontract.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *BranchContractMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, branchcontract.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *BranchContractMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *BranchContractMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *BranchContractMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[branchcontract.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *BranchContractMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[branchcontract.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *BranchContractMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, branchcontract.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *BranchContractMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *BranchContractMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *BranchContractMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[branchcontract.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *BranchContractMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[branchcontract.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *BranchContractMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, branchcontract.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *BranchContractMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *BranchContractMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *BranchContractMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[branchcontract.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *BranchContractMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[branchcontract.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *BranchContractMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, branchcontract.FieldRemark)
}

// SetBranchID sets the "branch_id" field.
func (m *BranchContractMutation) SetBranchID(u uint64) {
	m.branch = &u
}

// BranchID returns the value of the "branch_id" field in the mutation.
func (m *BranchContractMutation) BranchID() (r uint64, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranchID returns the old "branch_id" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldBranchID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBranchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBranchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranchID: %w", err)
	}
	return oldValue.BranchID, nil
}

// ResetBranchID resets all changes to the "branch_id" field.
func (m *BranchContractMutation) ResetBranchID() {
	m.branch = nil
}

// SetLandlordName sets the "landlord_name" field.
func (m *BranchContractMutation) SetLandlordName(s string) {
	m.landlord_name = &s
}

// LandlordName returns the value of the "landlord_name" field in the mutation.
func (m *BranchContractMutation) LandlordName() (r string, exists bool) {
	v := m.landlord_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLandlordName returns the old "landlord_name" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldLandlordName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLandlordName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLandlordName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLandlordName: %w", err)
	}
	return oldValue.LandlordName, nil
}

// ResetLandlordName resets all changes to the "landlord_name" field.
func (m *BranchContractMutation) ResetLandlordName() {
	m.landlord_name = nil
}

// SetIDCardNumber sets the "id_card_number" field.
func (m *BranchContractMutation) SetIDCardNumber(s string) {
	m.id_card_number = &s
}

// IDCardNumber returns the value of the "id_card_number" field in the mutation.
func (m *BranchContractMutation) IDCardNumber() (r string, exists bool) {
	v := m.id_card_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCardNumber returns the old "id_card_number" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldIDCardNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCardNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCardNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCardNumber: %w", err)
	}
	return oldValue.IDCardNumber, nil
}

// ResetIDCardNumber resets all changes to the "id_card_number" field.
func (m *BranchContractMutation) ResetIDCardNumber() {
	m.id_card_number = nil
}

// SetPhone sets the "phone" field.
func (m *BranchContractMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *BranchContractMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *BranchContractMutation) ResetPhone() {
	m.phone = nil
}

// SetBankNumber sets the "bank_number" field.
func (m *BranchContractMutation) SetBankNumber(s string) {
	m.bank_number = &s
}

// BankNumber returns the value of the "bank_number" field in the mutation.
func (m *BranchContractMutation) BankNumber() (r string, exists bool) {
	v := m.bank_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBankNumber returns the old "bank_number" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldBankNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBankNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBankNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankNumber: %w", err)
	}
	return oldValue.BankNumber, nil
}

// ResetBankNumber resets all changes to the "bank_number" field.
func (m *BranchContractMutation) ResetBankNumber() {
	m.bank_number = nil
}

// SetPledge sets the "pledge" field.
func (m *BranchContractMutation) SetPledge(f float64) {
	m.pledge = &f
	m.addpledge = nil
}

// Pledge returns the value of the "pledge" field in the mutation.
func (m *BranchContractMutation) Pledge() (r float64, exists bool) {
	v := m.pledge
	if v == nil {
		return
	}
	return *v, true
}

// OldPledge returns the old "pledge" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldPledge(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPledge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPledge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPledge: %w", err)
	}
	return oldValue.Pledge, nil
}

// AddPledge adds f to the "pledge" field.
func (m *BranchContractMutation) AddPledge(f float64) {
	if m.addpledge != nil {
		*m.addpledge += f
	} else {
		m.addpledge = &f
	}
}

// AddedPledge returns the value that was added to the "pledge" field in this mutation.
func (m *BranchContractMutation) AddedPledge() (r float64, exists bool) {
	v := m.addpledge
	if v == nil {
		return
	}
	return *v, true
}

// ResetPledge resets all changes to the "pledge" field.
func (m *BranchContractMutation) ResetPledge() {
	m.pledge = nil
	m.addpledge = nil
}

// SetRent sets the "rent" field.
func (m *BranchContractMutation) SetRent(f float64) {
	m.rent = &f
	m.addrent = nil
}

// Rent returns the value of the "rent" field in the mutation.
func (m *BranchContractMutation) Rent() (r float64, exists bool) {
	v := m.rent
	if v == nil {
		return
	}
	return *v, true
}

// OldRent returns the old "rent" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldRent(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRent: %w", err)
	}
	return oldValue.Rent, nil
}

// AddRent adds f to the "rent" field.
func (m *BranchContractMutation) AddRent(f float64) {
	if m.addrent != nil {
		*m.addrent += f
	} else {
		m.addrent = &f
	}
}

// AddedRent returns the value that was added to the "rent" field in this mutation.
func (m *BranchContractMutation) AddedRent() (r float64, exists bool) {
	v := m.addrent
	if v == nil {
		return
	}
	return *v, true
}

// ResetRent resets all changes to the "rent" field.
func (m *BranchContractMutation) ResetRent() {
	m.rent = nil
	m.addrent = nil
}

// SetLease sets the "lease" field.
func (m *BranchContractMutation) SetLease(u uint) {
	m.lease = &u
	m.addlease = nil
}

// Lease returns the value of the "lease" field in the mutation.
func (m *BranchContractMutation) Lease() (r uint, exists bool) {
	v := m.lease
	if v == nil {
		return
	}
	return *v, true
}

// OldLease returns the old "lease" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldLease(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLease is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLease requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLease: %w", err)
	}
	return oldValue.Lease, nil
}

// AddLease adds u to the "lease" field.
func (m *BranchContractMutation) AddLease(u int) {
	if m.addlease != nil {
		*m.addlease += u
	} else {
		m.addlease = &u
	}
}

// AddedLease returns the value that was added to the "lease" field in this mutation.
func (m *BranchContractMutation) AddedLease() (r int, exists bool) {
	v := m.addlease
	if v == nil {
		return
	}
	return *v, true
}

// ResetLease resets all changes to the "lease" field.
func (m *BranchContractMutation) ResetLease() {
	m.lease = nil
	m.addlease = nil
}

// SetElectricityPledge sets the "electricity_pledge" field.
func (m *BranchContractMutation) SetElectricityPledge(f float64) {
	m.electricity_pledge = &f
	m.addelectricity_pledge = nil
}

// ElectricityPledge returns the value of the "electricity_pledge" field in the mutation.
func (m *BranchContractMutation) ElectricityPledge() (r float64, exists bool) {
	v := m.electricity_pledge
	if v == nil {
		return
	}
	return *v, true
}

// OldElectricityPledge returns the old "electricity_pledge" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldElectricityPledge(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElectricityPledge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElectricityPledge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElectricityPledge: %w", err)
	}
	return oldValue.ElectricityPledge, nil
}

// AddElectricityPledge adds f to the "electricity_pledge" field.
func (m *BranchContractMutation) AddElectricityPledge(f float64) {
	if m.addelectricity_pledge != nil {
		*m.addelectricity_pledge += f
	} else {
		m.addelectricity_pledge = &f
	}
}

// AddedElectricityPledge returns the value that was added to the "electricity_pledge" field in this mutation.
func (m *BranchContractMutation) AddedElectricityPledge() (r float64, exists bool) {
	v := m.addelectricity_pledge
	if v == nil {
		return
	}
	return *v, true
}

// ResetElectricityPledge resets all changes to the "electricity_pledge" field.
func (m *BranchContractMutation) ResetElectricityPledge() {
	m.electricity_pledge = nil
	m.addelectricity_pledge = nil
}

// SetElectricity sets the "electricity" field.
func (m *BranchContractMutation) SetElectricity(f float64) {
	m.electricity = &f
	m.addelectricity = nil
}

// Electricity returns the value of the "electricity" field in the mutation.
func (m *BranchContractMutation) Electricity() (r float64, exists bool) {
	v := m.electricity
	if v == nil {
		return
	}
	return *v, true
}

// OldElectricity returns the old "electricity" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldElectricity(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElectricity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElectricity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElectricity: %w", err)
	}
	return oldValue.Electricity, nil
}

// AddElectricity adds f to the "electricity" field.
func (m *BranchContractMutation) AddElectricity(f float64) {
	if m.addelectricity != nil {
		*m.addelectricity += f
	} else {
		m.addelectricity = &f
	}
}

// AddedElectricity returns the value that was added to the "electricity" field in this mutation.
func (m *BranchContractMutation) AddedElectricity() (r float64, exists bool) {
	v := m.addelectricity
	if v == nil {
		return
	}
	return *v, true
}

// ResetElectricity resets all changes to the "electricity" field.
func (m *BranchContractMutation) ResetElectricity() {
	m.electricity = nil
	m.addelectricity = nil
}

// SetArea sets the "area" field.
func (m *BranchContractMutation) SetArea(f float64) {
	m.area = &f
	m.addarea = nil
}

// Area returns the value of the "area" field in the mutation.
func (m *BranchContractMutation) Area() (r float64, exists bool) {
	v := m.area
	if v == nil {
		return
	}
	return *v, true
}

// OldArea returns the old "area" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldArea(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArea: %w", err)
	}
	return oldValue.Area, nil
}

// AddArea adds f to the "area" field.
func (m *BranchContractMutation) AddArea(f float64) {
	if m.addarea != nil {
		*m.addarea += f
	} else {
		m.addarea = &f
	}
}

// AddedArea returns the value that was added to the "area" field in this mutation.
func (m *BranchContractMutation) AddedArea() (r float64, exists bool) {
	v := m.addarea
	if v == nil {
		return
	}
	return *v, true
}

// ResetArea resets all changes to the "area" field.
func (m *BranchContractMutation) ResetArea() {
	m.area = nil
	m.addarea = nil
}

// SetStartTime sets the "start_time" field.
func (m *BranchContractMutation) SetStartTime(s string) {
	m.start_time = &s
}

// StartTime returns the value of the "start_time" field in the mutation.
func (m *BranchContractMutation) StartTime() (r string, exists bool) {
	v := m.start_time
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "start_time" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldStartTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "start_time" field.
func (m *BranchContractMutation) ResetStartTime() {
	m.start_time = nil
}

// SetEndTime sets the "end_time" field.
func (m *BranchContractMutation) SetEndTime(s string) {
	m.end_time = &s
}

// EndTime returns the value of the "end_time" field in the mutation.
func (m *BranchContractMutation) EndTime() (r string, exists bool) {
	v := m.end_time
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "end_time" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldEndTime(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "end_time" field.
func (m *BranchContractMutation) ResetEndTime() {
	m.end_time = nil
}

// SetFile sets the "file" field.
func (m *BranchContractMutation) SetFile(s string) {
	m.file = &s
}

// File returns the value of the "file" field in the mutation.
func (m *BranchContractMutation) File() (r string, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldFile returns the old "file" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldFile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFile: %w", err)
	}
	return oldValue.File, nil
}

// ResetFile resets all changes to the "file" field.
func (m *BranchContractMutation) ResetFile() {
	m.file = nil
}

// SetSheets sets the "sheets" field.
func (m *BranchContractMutation) SetSheets(s []string) {
	m.sheets = &s
}

// Sheets returns the value of the "sheets" field in the mutation.
func (m *BranchContractMutation) Sheets() (r []string, exists bool) {
	v := m.sheets
	if v == nil {
		return
	}
	return *v, true
}

// OldSheets returns the old "sheets" field's value of the BranchContract entity.
// If the BranchContract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BranchContractMutation) OldSheets(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSheets is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSheets requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSheets: %w", err)
	}
	return oldValue.Sheets, nil
}

// ResetSheets resets all changes to the "sheets" field.
func (m *BranchContractMutation) ResetSheets() {
	m.sheets = nil
}

// ClearBranch clears the "branch" edge to the Branch entity.
func (m *BranchContractMutation) ClearBranch() {
	m.clearedbranch = true
}

// BranchCleared reports if the "branch" edge to the Branch entity was cleared.
func (m *BranchContractMutation) BranchCleared() bool {
	return m.clearedbranch
}

// BranchIDs returns the "branch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BranchID instead. It exists only for internal usage by the builders.
func (m *BranchContractMutation) BranchIDs() (ids []uint64) {
	if id := m.branch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBranch resets all changes to the "branch" edge.
func (m *BranchContractMutation) ResetBranch() {
	m.branch = nil
	m.clearedbranch = false
}

// Where appends a list predicates to the BranchContractMutation builder.
func (m *BranchContractMutation) Where(ps ...predicate.BranchContract) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BranchContractMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BranchContract).
func (m *BranchContractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BranchContractMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.created_at != nil {
		fields = append(fields, branchcontract.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, branchcontract.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, branchcontract.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, branchcontract.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, branchcontract.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, branchcontract.FieldRemark)
	}
	if m.branch != nil {
		fields = append(fields, branchcontract.FieldBranchID)
	}
	if m.landlord_name != nil {
		fields = append(fields, branchcontract.FieldLandlordName)
	}
	if m.id_card_number != nil {
		fields = append(fields, branchcontract.FieldIDCardNumber)
	}
	if m.phone != nil {
		fields = append(fields, branchcontract.FieldPhone)
	}
	if m.bank_number != nil {
		fields = append(fields, branchcontract.FieldBankNumber)
	}
	if m.pledge != nil {
		fields = append(fields, branchcontract.FieldPledge)
	}
	if m.rent != nil {
		fields = append(fields, branchcontract.FieldRent)
	}
	if m.lease != nil {
		fields = append(fields, branchcontract.FieldLease)
	}
	if m.electricity_pledge != nil {
		fields = append(fields, branchcontract.FieldElectricityPledge)
	}
	if m.electricity != nil {
		fields = append(fields, branchcontract.FieldElectricity)
	}
	if m.area != nil {
		fields = append(fields, branchcontract.FieldArea)
	}
	if m.start_time != nil {
		fields = append(fields, branchcontract.FieldStartTime)
	}
	if m.end_time != nil {
		fields = append(fields, branchcontract.FieldEndTime)
	}
	if m.file != nil {
		fields = append(fields, branchcontract.FieldFile)
	}
	if m.sheets != nil {
		fields = append(fields, branchcontract.FieldSheets)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BranchContractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case branchcontract.FieldCreatedAt:
		return m.CreatedAt()
	case branchcontract.FieldUpdatedAt:
		return m.UpdatedAt()
	case branchcontract.FieldDeletedAt:
		return m.DeletedAt()
	case branchcontract.FieldCreator:
		return m.Creator()
	case branchcontract.FieldLastModifier:
		return m.LastModifier()
	case branchcontract.FieldRemark:
		return m.Remark()
	case branchcontract.FieldBranchID:
		return m.BranchID()
	case branchcontract.FieldLandlordName:
		return m.LandlordName()
	case branchcontract.FieldIDCardNumber:
		return m.IDCardNumber()
	case branchcontract.FieldPhone:
		return m.Phone()
	case branchcontract.FieldBankNumber:
		return m.BankNumber()
	case branchcontract.FieldPledge:
		return m.Pledge()
	case branchcontract.FieldRent:
		return m.Rent()
	case branchcontract.FieldLease:
		return m.Lease()
	case branchcontract.FieldElectricityPledge:
		return m.ElectricityPledge()
	case branchcontract.FieldElectricity:
		return m.Electricity()
	case branchcontract.FieldArea:
		return m.Area()
	case branchcontract.FieldStartTime:
		return m.StartTime()
	case branchcontract.FieldEndTime:
		return m.EndTime()
	case branchcontract.FieldFile:
		return m.File()
	case branchcontract.FieldSheets:
		return m.Sheets()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BranchContractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case branchcontract.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case branchcontract.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case branchcontract.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case branchcontract.FieldCreator:
		return m.OldCreator(ctx)
	case branchcontract.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case branchcontract.FieldRemark:
		return m.OldRemark(ctx)
	case branchcontract.FieldBranchID:
		return m.OldBranchID(ctx)
	case branchcontract.FieldLandlordName:
		return m.OldLandlordName(ctx)
	case branchcontract.FieldIDCardNumber:
		return m.OldIDCardNumber(ctx)
	case branchcontract.FieldPhone:
		return m.OldPhone(ctx)
	case branchcontract.FieldBankNumber:
		return m.OldBankNumber(ctx)
	case branchcontract.FieldPledge:
		return m.OldPledge(ctx)
	case branchcontract.FieldRent:
		return m.OldRent(ctx)
	case branchcontract.FieldLease:
		return m.OldLease(ctx)
	case branchcontract.FieldElectricityPledge:
		return m.OldElectricityPledge(ctx)
	case branchcontract.FieldElectricity:
		return m.OldElectricity(ctx)
	case branchcontract.FieldArea:
		return m.OldArea(ctx)
	case branchcontract.FieldStartTime:
		return m.OldStartTime(ctx)
	case branchcontract.FieldEndTime:
		return m.OldEndTime(ctx)
	case branchcontract.FieldFile:
		return m.OldFile(ctx)
	case branchcontract.FieldSheets:
		return m.OldSheets(ctx)
	}
	return nil, fmt.Errorf("unknown BranchContract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BranchContractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case branchcontract.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case branchcontract.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case branchcontract.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case branchcontract.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case branchcontract.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case branchcontract.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case branchcontract.FieldBranchID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranchID(v)
		return nil
	case branchcontract.FieldLandlordName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLandlordName(v)
		return nil
	case branchcontract.FieldIDCardNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCardNumber(v)
		return nil
	case branchcontract.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case branchcontract.FieldBankNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankNumber(v)
		return nil
	case branchcontract.FieldPledge:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPledge(v)
		return nil
	case branchcontract.FieldRent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRent(v)
		return nil
	case branchcontract.FieldLease:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLease(v)
		return nil
	case branchcontract.FieldElectricityPledge:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElectricityPledge(v)
		return nil
	case branchcontract.FieldElectricity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElectricity(v)
		return nil
	case branchcontract.FieldArea:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArea(v)
		return nil
	case branchcontract.FieldStartTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case branchcontract.FieldEndTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case branchcontract.FieldFile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFile(v)
		return nil
	case branchcontract.FieldSheets:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSheets(v)
		return nil
	}
	return fmt.Errorf("unknown BranchContract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BranchContractMutation) AddedFields() []string {
	var fields []string
	if m.addpledge != nil {
		fields = append(fields, branchcontract.FieldPledge)
	}
	if m.addrent != nil {
		fields = append(fields, branchcontract.FieldRent)
	}
	if m.addlease != nil {
		fields = append(fields, branchcontract.FieldLease)
	}
	if m.addelectricity_pledge != nil {
		fields = append(fields, branchcontract.FieldElectricityPledge)
	}
	if m.addelectricity != nil {
		fields = append(fields, branchcontract.FieldElectricity)
	}
	if m.addarea != nil {
		fields = append(fields, branchcontract.FieldArea)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BranchContractMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case branchcontract.FieldPledge:
		return m.AddedPledge()
	case branchcontract.FieldRent:
		return m.AddedRent()
	case branchcontract.FieldLease:
		return m.AddedLease()
	case branchcontract.FieldElectricityPledge:
		return m.AddedElectricityPledge()
	case branchcontract.FieldElectricity:
		return m.AddedElectricity()
	case branchcontract.FieldArea:
		return m.AddedArea()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BranchContractMutation) AddField(name string, value ent.Value) error {
	switch name {
	case branchcontract.FieldPledge:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPledge(v)
		return nil
	case branchcontract.FieldRent:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRent(v)
		return nil
	case branchcontract.FieldLease:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLease(v)
		return nil
	case branchcontract.FieldElectricityPledge:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddElectricityPledge(v)
		return nil
	case branchcontract.FieldElectricity:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddElectricity(v)
		return nil
	case branchcontract.FieldArea:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddArea(v)
		return nil
	}
	return fmt.Errorf("unknown BranchContract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BranchContractMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(branchcontract.FieldDeletedAt) {
		fields = append(fields, branchcontract.FieldDeletedAt)
	}
	if m.FieldCleared(branchcontract.FieldCreator) {
		fields = append(fields, branchcontract.FieldCreator)
	}
	if m.FieldCleared(branchcontract.FieldLastModifier) {
		fields = append(fields, branchcontract.FieldLastModifier)
	}
	if m.FieldCleared(branchcontract.FieldRemark) {
		fields = append(fields, branchcontract.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BranchContractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BranchContractMutation) ClearField(name string) error {
	switch name {
	case branchcontract.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case branchcontract.FieldCreator:
		m.ClearCreator()
		return nil
	case branchcontract.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case branchcontract.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown BranchContract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BranchContractMutation) ResetField(name string) error {
	switch name {
	case branchcontract.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case branchcontract.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case branchcontract.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case branchcontract.FieldCreator:
		m.ResetCreator()
		return nil
	case branchcontract.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case branchcontract.FieldRemark:
		m.ResetRemark()
		return nil
	case branchcontract.FieldBranchID:
		m.ResetBranchID()
		return nil
	case branchcontract.FieldLandlordName:
		m.ResetLandlordName()
		return nil
	case branchcontract.FieldIDCardNumber:
		m.ResetIDCardNumber()
		return nil
	case branchcontract.FieldPhone:
		m.ResetPhone()
		return nil
	case branchcontract.FieldBankNumber:
		m.ResetBankNumber()
		return nil
	case branchcontract.FieldPledge:
		m.ResetPledge()
		return nil
	case branchcontract.FieldRent:
		m.ResetRent()
		return nil
	case branchcontract.FieldLease:
		m.ResetLease()
		return nil
	case branchcontract.FieldElectricityPledge:
		m.ResetElectricityPledge()
		return nil
	case branchcontract.FieldElectricity:
		m.ResetElectricity()
		return nil
	case branchcontract.FieldArea:
		m.ResetArea()
		return nil
	case branchcontract.FieldStartTime:
		m.ResetStartTime()
		return nil
	case branchcontract.FieldEndTime:
		m.ResetEndTime()
		return nil
	case branchcontract.FieldFile:
		m.ResetFile()
		return nil
	case branchcontract.FieldSheets:
		m.ResetSheets()
		return nil
	}
	return fmt.Errorf("unknown BranchContract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BranchContractMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.branch != nil {
		edges = append(edges, branchcontract.EdgeBranch)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BranchContractMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case branchcontract.EdgeBranch:
		if id := m.branch; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BranchContractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BranchContractMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BranchContractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbranch {
		edges = append(edges, branchcontract.EdgeBranch)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BranchContractMutation) EdgeCleared(name string) bool {
	switch name {
	case branchcontract.EdgeBranch:
		return m.clearedbranch
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BranchContractMutation) ClearEdge(name string) error {
	switch name {
	case branchcontract.EdgeBranch:
		m.ClearBranch()
		return nil
	}
	return fmt.Errorf("unknown BranchContract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BranchContractMutation) ResetEdge(name string) error {
	switch name {
	case branchcontract.EdgeBranch:
		m.ResetBranch()
		return nil
	}
	return fmt.Errorf("unknown BranchContract edge %s", name)
}

// CabinetMutation represents an operation that mutates the Cabinet nodes in the graph.
type CabinetMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uint64
	created_at          *time.Time
	updated_at          *time.Time
	deleted_at          *time.Time
	creator             **model.Modifier
	last_modifier       **model.Modifier
	remark              *string
	sn                  *string
	brand               *string
	serial              *string
	name                *string
	doors               *uint
	adddoors            *int
	status              *uint
	addstatus           *int
	models              *[]model.BatteryModel
	health              *uint
	addhealth           *int
	bin                 *[]model.CabinetBin
	battery_num         *uint
	addbattery_num      *int
	battery_full_num    *uint
	addbattery_full_num *int
	clearedFields       map[string]struct{}
	branch              *uint64
	clearedbranch       bool
	bms                 map[uint64]struct{}
	removedbms          map[uint64]struct{}
	clearedbms          bool
	faults              map[uint64]struct{}
	removedfaults       map[uint64]struct{}
	clearedfaults       bool
	done                bool
	oldValue            func(context.Context) (*Cabinet, error)
	predicates          []predicate.Cabinet
}

var _ ent.Mutation = (*CabinetMutation)(nil)

// cabinetOption allows management of the mutation configuration using functional options.
type cabinetOption func(*CabinetMutation)

// newCabinetMutation creates new mutation for the Cabinet entity.
func newCabinetMutation(c config, op Op, opts ...cabinetOption) *CabinetMutation {
	m := &CabinetMutation{
		config:        c,
		op:            op,
		typ:           TypeCabinet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCabinetID sets the ID field of the mutation.
func withCabinetID(id uint64) cabinetOption {
	return func(m *CabinetMutation) {
		var (
			err   error
			once  sync.Once
			value *Cabinet
		)
		m.oldValue = func(ctx context.Context) (*Cabinet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Cabinet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCabinet sets the old Cabinet of the mutation.
func withCabinet(node *Cabinet) cabinetOption {
	return func(m *CabinetMutation) {
		m.oldValue = func(context.Context) (*Cabinet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CabinetMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CabinetMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CabinetMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CabinetMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Cabinet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CabinetMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CabinetMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CabinetMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CabinetMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CabinetMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CabinetMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CabinetMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CabinetMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CabinetMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[cabinet.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CabinetMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CabinetMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, cabinet.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *CabinetMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *CabinetMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *CabinetMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[cabinet.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *CabinetMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *CabinetMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, cabinet.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *CabinetMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *CabinetMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *CabinetMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[cabinet.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *CabinetMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *CabinetMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, cabinet.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *CabinetMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CabinetMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *CabinetMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[cabinet.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *CabinetMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *CabinetMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, cabinet.FieldRemark)
}

// SetBranchID sets the "branch_id" field.
func (m *CabinetMutation) SetBranchID(u uint64) {
	m.branch = &u
}

// BranchID returns the value of the "branch_id" field in the mutation.
func (m *CabinetMutation) BranchID() (r uint64, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranchID returns the old "branch_id" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldBranchID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBranchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBranchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranchID: %w", err)
	}
	return oldValue.BranchID, nil
}

// ClearBranchID clears the value of the "branch_id" field.
func (m *CabinetMutation) ClearBranchID() {
	m.branch = nil
	m.clearedFields[cabinet.FieldBranchID] = struct{}{}
}

// BranchIDCleared returns if the "branch_id" field was cleared in this mutation.
func (m *CabinetMutation) BranchIDCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldBranchID]
	return ok
}

// ResetBranchID resets all changes to the "branch_id" field.
func (m *CabinetMutation) ResetBranchID() {
	m.branch = nil
	delete(m.clearedFields, cabinet.FieldBranchID)
}

// SetSn sets the "sn" field.
func (m *CabinetMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *CabinetMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *CabinetMutation) ResetSn() {
	m.sn = nil
}

// SetBrand sets the "brand" field.
func (m *CabinetMutation) SetBrand(s string) {
	m.brand = &s
}

// Brand returns the value of the "brand" field in the mutation.
func (m *CabinetMutation) Brand() (r string, exists bool) {
	v := m.brand
	if v == nil {
		return
	}
	return *v, true
}

// OldBrand returns the old "brand" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldBrand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBrand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBrand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBrand: %w", err)
	}
	return oldValue.Brand, nil
}

// ResetBrand resets all changes to the "brand" field.
func (m *CabinetMutation) ResetBrand() {
	m.brand = nil
}

// SetSerial sets the "serial" field.
func (m *CabinetMutation) SetSerial(s string) {
	m.serial = &s
}

// Serial returns the value of the "serial" field in the mutation.
func (m *CabinetMutation) Serial() (r string, exists bool) {
	v := m.serial
	if v == nil {
		return
	}
	return *v, true
}

// OldSerial returns the old "serial" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldSerial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSerial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSerial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSerial: %w", err)
	}
	return oldValue.Serial, nil
}

// ResetSerial resets all changes to the "serial" field.
func (m *CabinetMutation) ResetSerial() {
	m.serial = nil
}

// SetName sets the "name" field.
func (m *CabinetMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CabinetMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CabinetMutation) ResetName() {
	m.name = nil
}

// SetDoors sets the "doors" field.
func (m *CabinetMutation) SetDoors(u uint) {
	m.doors = &u
	m.adddoors = nil
}

// Doors returns the value of the "doors" field in the mutation.
func (m *CabinetMutation) Doors() (r uint, exists bool) {
	v := m.doors
	if v == nil {
		return
	}
	return *v, true
}

// OldDoors returns the old "doors" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldDoors(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDoors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDoors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoors: %w", err)
	}
	return oldValue.Doors, nil
}

// AddDoors adds u to the "doors" field.
func (m *CabinetMutation) AddDoors(u int) {
	if m.adddoors != nil {
		*m.adddoors += u
	} else {
		m.adddoors = &u
	}
}

// AddedDoors returns the value that was added to the "doors" field in this mutation.
func (m *CabinetMutation) AddedDoors() (r int, exists bool) {
	v := m.adddoors
	if v == nil {
		return
	}
	return *v, true
}

// ResetDoors resets all changes to the "doors" field.
func (m *CabinetMutation) ResetDoors() {
	m.doors = nil
	m.adddoors = nil
}

// SetStatus sets the "status" field.
func (m *CabinetMutation) SetStatus(u uint) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CabinetMutation) Status() (r uint, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldStatus(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *CabinetMutation) AddStatus(u int) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CabinetMutation) AddedStatus() (r int, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CabinetMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetModels sets the "models" field.
func (m *CabinetMutation) SetModels(mm []model.BatteryModel) {
	m.models = &mm
}

// Models returns the value of the "models" field in the mutation.
func (m *CabinetMutation) Models() (r []model.BatteryModel, exists bool) {
	v := m.models
	if v == nil {
		return
	}
	return *v, true
}

// OldModels returns the old "models" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldModels(ctx context.Context) (v []model.BatteryModel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModels is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModels requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModels: %w", err)
	}
	return oldValue.Models, nil
}

// ResetModels resets all changes to the "models" field.
func (m *CabinetMutation) ResetModels() {
	m.models = nil
}

// SetHealth sets the "health" field.
func (m *CabinetMutation) SetHealth(u uint) {
	m.health = &u
	m.addhealth = nil
}

// Health returns the value of the "health" field in the mutation.
func (m *CabinetMutation) Health() (r uint, exists bool) {
	v := m.health
	if v == nil {
		return
	}
	return *v, true
}

// OldHealth returns the old "health" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldHealth(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHealth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHealth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealth: %w", err)
	}
	return oldValue.Health, nil
}

// AddHealth adds u to the "health" field.
func (m *CabinetMutation) AddHealth(u int) {
	if m.addhealth != nil {
		*m.addhealth += u
	} else {
		m.addhealth = &u
	}
}

// AddedHealth returns the value that was added to the "health" field in this mutation.
func (m *CabinetMutation) AddedHealth() (r int, exists bool) {
	v := m.addhealth
	if v == nil {
		return
	}
	return *v, true
}

// ResetHealth resets all changes to the "health" field.
func (m *CabinetMutation) ResetHealth() {
	m.health = nil
	m.addhealth = nil
}

// SetBin sets the "bin" field.
func (m *CabinetMutation) SetBin(mb []model.CabinetBin) {
	m.bin = &mb
}

// Bin returns the value of the "bin" field in the mutation.
func (m *CabinetMutation) Bin() (r []model.CabinetBin, exists bool) {
	v := m.bin
	if v == nil {
		return
	}
	return *v, true
}

// OldBin returns the old "bin" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldBin(ctx context.Context) (v []model.CabinetBin, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBin: %w", err)
	}
	return oldValue.Bin, nil
}

// ClearBin clears the value of the "bin" field.
func (m *CabinetMutation) ClearBin() {
	m.bin = nil
	m.clearedFields[cabinet.FieldBin] = struct{}{}
}

// BinCleared returns if the "bin" field was cleared in this mutation.
func (m *CabinetMutation) BinCleared() bool {
	_, ok := m.clearedFields[cabinet.FieldBin]
	return ok
}

// ResetBin resets all changes to the "bin" field.
func (m *CabinetMutation) ResetBin() {
	m.bin = nil
	delete(m.clearedFields, cabinet.FieldBin)
}

// SetBatteryNum sets the "battery_num" field.
func (m *CabinetMutation) SetBatteryNum(u uint) {
	m.battery_num = &u
	m.addbattery_num = nil
}

// BatteryNum returns the value of the "battery_num" field in the mutation.
func (m *CabinetMutation) BatteryNum() (r uint, exists bool) {
	v := m.battery_num
	if v == nil {
		return
	}
	return *v, true
}

// OldBatteryNum returns the old "battery_num" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldBatteryNum(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatteryNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatteryNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatteryNum: %w", err)
	}
	return oldValue.BatteryNum, nil
}

// AddBatteryNum adds u to the "battery_num" field.
func (m *CabinetMutation) AddBatteryNum(u int) {
	if m.addbattery_num != nil {
		*m.addbattery_num += u
	} else {
		m.addbattery_num = &u
	}
}

// AddedBatteryNum returns the value that was added to the "battery_num" field in this mutation.
func (m *CabinetMutation) AddedBatteryNum() (r int, exists bool) {
	v := m.addbattery_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetBatteryNum resets all changes to the "battery_num" field.
func (m *CabinetMutation) ResetBatteryNum() {
	m.battery_num = nil
	m.addbattery_num = nil
}

// SetBatteryFullNum sets the "battery_full_num" field.
func (m *CabinetMutation) SetBatteryFullNum(u uint) {
	m.battery_full_num = &u
	m.addbattery_full_num = nil
}

// BatteryFullNum returns the value of the "battery_full_num" field in the mutation.
func (m *CabinetMutation) BatteryFullNum() (r uint, exists bool) {
	v := m.battery_full_num
	if v == nil {
		return
	}
	return *v, true
}

// OldBatteryFullNum returns the old "battery_full_num" field's value of the Cabinet entity.
// If the Cabinet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetMutation) OldBatteryFullNum(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBatteryFullNum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBatteryFullNum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBatteryFullNum: %w", err)
	}
	return oldValue.BatteryFullNum, nil
}

// AddBatteryFullNum adds u to the "battery_full_num" field.
func (m *CabinetMutation) AddBatteryFullNum(u int) {
	if m.addbattery_full_num != nil {
		*m.addbattery_full_num += u
	} else {
		m.addbattery_full_num = &u
	}
}

// AddedBatteryFullNum returns the value that was added to the "battery_full_num" field in this mutation.
func (m *CabinetMutation) AddedBatteryFullNum() (r int, exists bool) {
	v := m.addbattery_full_num
	if v == nil {
		return
	}
	return *v, true
}

// ResetBatteryFullNum resets all changes to the "battery_full_num" field.
func (m *CabinetMutation) ResetBatteryFullNum() {
	m.battery_full_num = nil
	m.addbattery_full_num = nil
}

// ClearBranch clears the "branch" edge to the Branch entity.
func (m *CabinetMutation) ClearBranch() {
	m.clearedbranch = true
}

// BranchCleared reports if the "branch" edge to the Branch entity was cleared.
func (m *CabinetMutation) BranchCleared() bool {
	return m.BranchIDCleared() || m.clearedbranch
}

// BranchIDs returns the "branch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BranchID instead. It exists only for internal usage by the builders.
func (m *CabinetMutation) BranchIDs() (ids []uint64) {
	if id := m.branch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBranch resets all changes to the "branch" edge.
func (m *CabinetMutation) ResetBranch() {
	m.branch = nil
	m.clearedbranch = false
}

// AddBmIDs adds the "bms" edge to the BatteryModel entity by ids.
func (m *CabinetMutation) AddBmIDs(ids ...uint64) {
	if m.bms == nil {
		m.bms = make(map[uint64]struct{})
	}
	for i := range ids {
		m.bms[ids[i]] = struct{}{}
	}
}

// ClearBms clears the "bms" edge to the BatteryModel entity.
func (m *CabinetMutation) ClearBms() {
	m.clearedbms = true
}

// BmsCleared reports if the "bms" edge to the BatteryModel entity was cleared.
func (m *CabinetMutation) BmsCleared() bool {
	return m.clearedbms
}

// RemoveBmIDs removes the "bms" edge to the BatteryModel entity by IDs.
func (m *CabinetMutation) RemoveBmIDs(ids ...uint64) {
	if m.removedbms == nil {
		m.removedbms = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.bms, ids[i])
		m.removedbms[ids[i]] = struct{}{}
	}
}

// RemovedBms returns the removed IDs of the "bms" edge to the BatteryModel entity.
func (m *CabinetMutation) RemovedBmsIDs() (ids []uint64) {
	for id := range m.removedbms {
		ids = append(ids, id)
	}
	return
}

// BmsIDs returns the "bms" edge IDs in the mutation.
func (m *CabinetMutation) BmsIDs() (ids []uint64) {
	for id := range m.bms {
		ids = append(ids, id)
	}
	return
}

// ResetBms resets all changes to the "bms" edge.
func (m *CabinetMutation) ResetBms() {
	m.bms = nil
	m.clearedbms = false
	m.removedbms = nil
}

// AddFaultIDs adds the "faults" edge to the CabinetFault entity by ids.
func (m *CabinetMutation) AddFaultIDs(ids ...uint64) {
	if m.faults == nil {
		m.faults = make(map[uint64]struct{})
	}
	for i := range ids {
		m.faults[ids[i]] = struct{}{}
	}
}

// ClearFaults clears the "faults" edge to the CabinetFault entity.
func (m *CabinetMutation) ClearFaults() {
	m.clearedfaults = true
}

// FaultsCleared reports if the "faults" edge to the CabinetFault entity was cleared.
func (m *CabinetMutation) FaultsCleared() bool {
	return m.clearedfaults
}

// RemoveFaultIDs removes the "faults" edge to the CabinetFault entity by IDs.
func (m *CabinetMutation) RemoveFaultIDs(ids ...uint64) {
	if m.removedfaults == nil {
		m.removedfaults = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.faults, ids[i])
		m.removedfaults[ids[i]] = struct{}{}
	}
}

// RemovedFaults returns the removed IDs of the "faults" edge to the CabinetFault entity.
func (m *CabinetMutation) RemovedFaultsIDs() (ids []uint64) {
	for id := range m.removedfaults {
		ids = append(ids, id)
	}
	return
}

// FaultsIDs returns the "faults" edge IDs in the mutation.
func (m *CabinetMutation) FaultsIDs() (ids []uint64) {
	for id := range m.faults {
		ids = append(ids, id)
	}
	return
}

// ResetFaults resets all changes to the "faults" edge.
func (m *CabinetMutation) ResetFaults() {
	m.faults = nil
	m.clearedfaults = false
	m.removedfaults = nil
}

// Where appends a list predicates to the CabinetMutation builder.
func (m *CabinetMutation) Where(ps ...predicate.Cabinet) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CabinetMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Cabinet).
func (m *CabinetMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CabinetMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, cabinet.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cabinet.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, cabinet.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, cabinet.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, cabinet.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, cabinet.FieldRemark)
	}
	if m.branch != nil {
		fields = append(fields, cabinet.FieldBranchID)
	}
	if m.sn != nil {
		fields = append(fields, cabinet.FieldSn)
	}
	if m.brand != nil {
		fields = append(fields, cabinet.FieldBrand)
	}
	if m.serial != nil {
		fields = append(fields, cabinet.FieldSerial)
	}
	if m.name != nil {
		fields = append(fields, cabinet.FieldName)
	}
	if m.doors != nil {
		fields = append(fields, cabinet.FieldDoors)
	}
	if m.status != nil {
		fields = append(fields, cabinet.FieldStatus)
	}
	if m.models != nil {
		fields = append(fields, cabinet.FieldModels)
	}
	if m.health != nil {
		fields = append(fields, cabinet.FieldHealth)
	}
	if m.bin != nil {
		fields = append(fields, cabinet.FieldBin)
	}
	if m.battery_num != nil {
		fields = append(fields, cabinet.FieldBatteryNum)
	}
	if m.battery_full_num != nil {
		fields = append(fields, cabinet.FieldBatteryFullNum)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CabinetMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cabinet.FieldCreatedAt:
		return m.CreatedAt()
	case cabinet.FieldUpdatedAt:
		return m.UpdatedAt()
	case cabinet.FieldDeletedAt:
		return m.DeletedAt()
	case cabinet.FieldCreator:
		return m.Creator()
	case cabinet.FieldLastModifier:
		return m.LastModifier()
	case cabinet.FieldRemark:
		return m.Remark()
	case cabinet.FieldBranchID:
		return m.BranchID()
	case cabinet.FieldSn:
		return m.Sn()
	case cabinet.FieldBrand:
		return m.Brand()
	case cabinet.FieldSerial:
		return m.Serial()
	case cabinet.FieldName:
		return m.Name()
	case cabinet.FieldDoors:
		return m.Doors()
	case cabinet.FieldStatus:
		return m.Status()
	case cabinet.FieldModels:
		return m.Models()
	case cabinet.FieldHealth:
		return m.Health()
	case cabinet.FieldBin:
		return m.Bin()
	case cabinet.FieldBatteryNum:
		return m.BatteryNum()
	case cabinet.FieldBatteryFullNum:
		return m.BatteryFullNum()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CabinetMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cabinet.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cabinet.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cabinet.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case cabinet.FieldCreator:
		return m.OldCreator(ctx)
	case cabinet.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case cabinet.FieldRemark:
		return m.OldRemark(ctx)
	case cabinet.FieldBranchID:
		return m.OldBranchID(ctx)
	case cabinet.FieldSn:
		return m.OldSn(ctx)
	case cabinet.FieldBrand:
		return m.OldBrand(ctx)
	case cabinet.FieldSerial:
		return m.OldSerial(ctx)
	case cabinet.FieldName:
		return m.OldName(ctx)
	case cabinet.FieldDoors:
		return m.OldDoors(ctx)
	case cabinet.FieldStatus:
		return m.OldStatus(ctx)
	case cabinet.FieldModels:
		return m.OldModels(ctx)
	case cabinet.FieldHealth:
		return m.OldHealth(ctx)
	case cabinet.FieldBin:
		return m.OldBin(ctx)
	case cabinet.FieldBatteryNum:
		return m.OldBatteryNum(ctx)
	case cabinet.FieldBatteryFullNum:
		return m.OldBatteryFullNum(ctx)
	}
	return nil, fmt.Errorf("unknown Cabinet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CabinetMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cabinet.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cabinet.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cabinet.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case cabinet.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case cabinet.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case cabinet.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case cabinet.FieldBranchID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranchID(v)
		return nil
	case cabinet.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case cabinet.FieldBrand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBrand(v)
		return nil
	case cabinet.FieldSerial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSerial(v)
		return nil
	case cabinet.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cabinet.FieldDoors:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoors(v)
		return nil
	case cabinet.FieldStatus:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case cabinet.FieldModels:
		v, ok := value.([]model.BatteryModel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModels(v)
		return nil
	case cabinet.FieldHealth:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealth(v)
		return nil
	case cabinet.FieldBin:
		v, ok := value.([]model.CabinetBin)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBin(v)
		return nil
	case cabinet.FieldBatteryNum:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatteryNum(v)
		return nil
	case cabinet.FieldBatteryFullNum:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBatteryFullNum(v)
		return nil
	}
	return fmt.Errorf("unknown Cabinet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CabinetMutation) AddedFields() []string {
	var fields []string
	if m.adddoors != nil {
		fields = append(fields, cabinet.FieldDoors)
	}
	if m.addstatus != nil {
		fields = append(fields, cabinet.FieldStatus)
	}
	if m.addhealth != nil {
		fields = append(fields, cabinet.FieldHealth)
	}
	if m.addbattery_num != nil {
		fields = append(fields, cabinet.FieldBatteryNum)
	}
	if m.addbattery_full_num != nil {
		fields = append(fields, cabinet.FieldBatteryFullNum)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CabinetMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cabinet.FieldDoors:
		return m.AddedDoors()
	case cabinet.FieldStatus:
		return m.AddedStatus()
	case cabinet.FieldHealth:
		return m.AddedHealth()
	case cabinet.FieldBatteryNum:
		return m.AddedBatteryNum()
	case cabinet.FieldBatteryFullNum:
		return m.AddedBatteryFullNum()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CabinetMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cabinet.FieldDoors:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDoors(v)
		return nil
	case cabinet.FieldStatus:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case cabinet.FieldHealth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHealth(v)
		return nil
	case cabinet.FieldBatteryNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBatteryNum(v)
		return nil
	case cabinet.FieldBatteryFullNum:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBatteryFullNum(v)
		return nil
	}
	return fmt.Errorf("unknown Cabinet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CabinetMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cabinet.FieldDeletedAt) {
		fields = append(fields, cabinet.FieldDeletedAt)
	}
	if m.FieldCleared(cabinet.FieldCreator) {
		fields = append(fields, cabinet.FieldCreator)
	}
	if m.FieldCleared(cabinet.FieldLastModifier) {
		fields = append(fields, cabinet.FieldLastModifier)
	}
	if m.FieldCleared(cabinet.FieldRemark) {
		fields = append(fields, cabinet.FieldRemark)
	}
	if m.FieldCleared(cabinet.FieldBranchID) {
		fields = append(fields, cabinet.FieldBranchID)
	}
	if m.FieldCleared(cabinet.FieldBin) {
		fields = append(fields, cabinet.FieldBin)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CabinetMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CabinetMutation) ClearField(name string) error {
	switch name {
	case cabinet.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case cabinet.FieldCreator:
		m.ClearCreator()
		return nil
	case cabinet.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case cabinet.FieldRemark:
		m.ClearRemark()
		return nil
	case cabinet.FieldBranchID:
		m.ClearBranchID()
		return nil
	case cabinet.FieldBin:
		m.ClearBin()
		return nil
	}
	return fmt.Errorf("unknown Cabinet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CabinetMutation) ResetField(name string) error {
	switch name {
	case cabinet.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cabinet.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cabinet.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case cabinet.FieldCreator:
		m.ResetCreator()
		return nil
	case cabinet.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case cabinet.FieldRemark:
		m.ResetRemark()
		return nil
	case cabinet.FieldBranchID:
		m.ResetBranchID()
		return nil
	case cabinet.FieldSn:
		m.ResetSn()
		return nil
	case cabinet.FieldBrand:
		m.ResetBrand()
		return nil
	case cabinet.FieldSerial:
		m.ResetSerial()
		return nil
	case cabinet.FieldName:
		m.ResetName()
		return nil
	case cabinet.FieldDoors:
		m.ResetDoors()
		return nil
	case cabinet.FieldStatus:
		m.ResetStatus()
		return nil
	case cabinet.FieldModels:
		m.ResetModels()
		return nil
	case cabinet.FieldHealth:
		m.ResetHealth()
		return nil
	case cabinet.FieldBin:
		m.ResetBin()
		return nil
	case cabinet.FieldBatteryNum:
		m.ResetBatteryNum()
		return nil
	case cabinet.FieldBatteryFullNum:
		m.ResetBatteryFullNum()
		return nil
	}
	return fmt.Errorf("unknown Cabinet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CabinetMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.branch != nil {
		edges = append(edges, cabinet.EdgeBranch)
	}
	if m.bms != nil {
		edges = append(edges, cabinet.EdgeBms)
	}
	if m.faults != nil {
		edges = append(edges, cabinet.EdgeFaults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CabinetMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cabinet.EdgeBranch:
		if id := m.branch; id != nil {
			return []ent.Value{*id}
		}
	case cabinet.EdgeBms:
		ids := make([]ent.Value, 0, len(m.bms))
		for id := range m.bms {
			ids = append(ids, id)
		}
		return ids
	case cabinet.EdgeFaults:
		ids := make([]ent.Value, 0, len(m.faults))
		for id := range m.faults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CabinetMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedbms != nil {
		edges = append(edges, cabinet.EdgeBms)
	}
	if m.removedfaults != nil {
		edges = append(edges, cabinet.EdgeFaults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CabinetMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case cabinet.EdgeBms:
		ids := make([]ent.Value, 0, len(m.removedbms))
		for id := range m.removedbms {
			ids = append(ids, id)
		}
		return ids
	case cabinet.EdgeFaults:
		ids := make([]ent.Value, 0, len(m.removedfaults))
		for id := range m.removedfaults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CabinetMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedbranch {
		edges = append(edges, cabinet.EdgeBranch)
	}
	if m.clearedbms {
		edges = append(edges, cabinet.EdgeBms)
	}
	if m.clearedfaults {
		edges = append(edges, cabinet.EdgeFaults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CabinetMutation) EdgeCleared(name string) bool {
	switch name {
	case cabinet.EdgeBranch:
		return m.clearedbranch
	case cabinet.EdgeBms:
		return m.clearedbms
	case cabinet.EdgeFaults:
		return m.clearedfaults
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CabinetMutation) ClearEdge(name string) error {
	switch name {
	case cabinet.EdgeBranch:
		m.ClearBranch()
		return nil
	}
	return fmt.Errorf("unknown Cabinet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CabinetMutation) ResetEdge(name string) error {
	switch name {
	case cabinet.EdgeBranch:
		m.ResetBranch()
		return nil
	case cabinet.EdgeBms:
		m.ResetBms()
		return nil
	case cabinet.EdgeFaults:
		m.ResetFaults()
		return nil
	}
	return fmt.Errorf("unknown Cabinet edge %s", name)
}

// CabinetFaultMutation represents an operation that mutates the CabinetFault nodes in the graph.
type CabinetFaultMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	creator        **model.Modifier
	last_modifier  **model.Modifier
	remark         *string
	status         *uint8
	addstatus      *int8
	fault          *string
	attachments    *[]string
	description    *string
	clearedFields  map[string]struct{}
	branch         *uint64
	clearedbranch  bool
	cabinet        *uint64
	clearedcabinet bool
	rider          *uint64
	clearedrider   bool
	city           *uint64
	clearedcity    bool
	done           bool
	oldValue       func(context.Context) (*CabinetFault, error)
	predicates     []predicate.CabinetFault
}

var _ ent.Mutation = (*CabinetFaultMutation)(nil)

// cabinetfaultOption allows management of the mutation configuration using functional options.
type cabinetfaultOption func(*CabinetFaultMutation)

// newCabinetFaultMutation creates new mutation for the CabinetFault entity.
func newCabinetFaultMutation(c config, op Op, opts ...cabinetfaultOption) *CabinetFaultMutation {
	m := &CabinetFaultMutation{
		config:        c,
		op:            op,
		typ:           TypeCabinetFault,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCabinetFaultID sets the ID field of the mutation.
func withCabinetFaultID(id uint64) cabinetfaultOption {
	return func(m *CabinetFaultMutation) {
		var (
			err   error
			once  sync.Once
			value *CabinetFault
		)
		m.oldValue = func(ctx context.Context) (*CabinetFault, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CabinetFault.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCabinetFault sets the old CabinetFault of the mutation.
func withCabinetFault(node *CabinetFault) cabinetfaultOption {
	return func(m *CabinetFaultMutation) {
		m.oldValue = func(context.Context) (*CabinetFault, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CabinetFaultMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CabinetFaultMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CabinetFaultMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CabinetFaultMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CabinetFault.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CabinetFaultMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CabinetFaultMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CabinetFaultMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CabinetFaultMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CabinetFaultMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CabinetFaultMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CabinetFaultMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CabinetFaultMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CabinetFaultMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[cabinetfault.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CabinetFaultMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[cabinetfault.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CabinetFaultMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, cabinetfault.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *CabinetFaultMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *CabinetFaultMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *CabinetFaultMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[cabinetfault.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *CabinetFaultMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[cabinetfault.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *CabinetFaultMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, cabinetfault.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *CabinetFaultMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *CabinetFaultMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *CabinetFaultMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[cabinetfault.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *CabinetFaultMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[cabinetfault.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *CabinetFaultMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, cabinetfault.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *CabinetFaultMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CabinetFaultMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *CabinetFaultMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[cabinetfault.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *CabinetFaultMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[cabinetfault.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *CabinetFaultMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, cabinetfault.FieldRemark)
}

// SetStatus sets the "status" field.
func (m *CabinetFaultMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CabinetFaultMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *CabinetFaultMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CabinetFaultMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CabinetFaultMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCityID sets the "city_id" field.
func (m *CabinetFaultMutation) SetCityID(u uint64) {
	m.city = &u
}

// CityID returns the value of the "city_id" field in the mutation.
func (m *CabinetFaultMutation) CityID() (r uint64, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCityID returns the old "city_id" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldCityID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCityID: %w", err)
	}
	return oldValue.CityID, nil
}

// ResetCityID resets all changes to the "city_id" field.
func (m *CabinetFaultMutation) ResetCityID() {
	m.city = nil
}

// SetBranchID sets the "branch_id" field.
func (m *CabinetFaultMutation) SetBranchID(u uint64) {
	m.branch = &u
}

// BranchID returns the value of the "branch_id" field in the mutation.
func (m *CabinetFaultMutation) BranchID() (r uint64, exists bool) {
	v := m.branch
	if v == nil {
		return
	}
	return *v, true
}

// OldBranchID returns the old "branch_id" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldBranchID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBranchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBranchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBranchID: %w", err)
	}
	return oldValue.BranchID, nil
}

// ResetBranchID resets all changes to the "branch_id" field.
func (m *CabinetFaultMutation) ResetBranchID() {
	m.branch = nil
}

// SetCabinetID sets the "cabinet_id" field.
func (m *CabinetFaultMutation) SetCabinetID(u uint64) {
	m.cabinet = &u
}

// CabinetID returns the value of the "cabinet_id" field in the mutation.
func (m *CabinetFaultMutation) CabinetID() (r uint64, exists bool) {
	v := m.cabinet
	if v == nil {
		return
	}
	return *v, true
}

// OldCabinetID returns the old "cabinet_id" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldCabinetID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCabinetID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCabinetID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCabinetID: %w", err)
	}
	return oldValue.CabinetID, nil
}

// ResetCabinetID resets all changes to the "cabinet_id" field.
func (m *CabinetFaultMutation) ResetCabinetID() {
	m.cabinet = nil
}

// SetRiderID sets the "rider_id" field.
func (m *CabinetFaultMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *CabinetFaultMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *CabinetFaultMutation) ResetRiderID() {
	m.rider = nil
}

// SetFault sets the "fault" field.
func (m *CabinetFaultMutation) SetFault(s string) {
	m.fault = &s
}

// Fault returns the value of the "fault" field in the mutation.
func (m *CabinetFaultMutation) Fault() (r string, exists bool) {
	v := m.fault
	if v == nil {
		return
	}
	return *v, true
}

// OldFault returns the old "fault" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldFault(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFault: %w", err)
	}
	return oldValue.Fault, nil
}

// ClearFault clears the value of the "fault" field.
func (m *CabinetFaultMutation) ClearFault() {
	m.fault = nil
	m.clearedFields[cabinetfault.FieldFault] = struct{}{}
}

// FaultCleared returns if the "fault" field was cleared in this mutation.
func (m *CabinetFaultMutation) FaultCleared() bool {
	_, ok := m.clearedFields[cabinetfault.FieldFault]
	return ok
}

// ResetFault resets all changes to the "fault" field.
func (m *CabinetFaultMutation) ResetFault() {
	m.fault = nil
	delete(m.clearedFields, cabinetfault.FieldFault)
}

// SetAttachments sets the "attachments" field.
func (m *CabinetFaultMutation) SetAttachments(s []string) {
	m.attachments = &s
}

// Attachments returns the value of the "attachments" field in the mutation.
func (m *CabinetFaultMutation) Attachments() (r []string, exists bool) {
	v := m.attachments
	if v == nil {
		return
	}
	return *v, true
}

// OldAttachments returns the old "attachments" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldAttachments(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttachments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttachments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttachments: %w", err)
	}
	return oldValue.Attachments, nil
}

// ClearAttachments clears the value of the "attachments" field.
func (m *CabinetFaultMutation) ClearAttachments() {
	m.attachments = nil
	m.clearedFields[cabinetfault.FieldAttachments] = struct{}{}
}

// AttachmentsCleared returns if the "attachments" field was cleared in this mutation.
func (m *CabinetFaultMutation) AttachmentsCleared() bool {
	_, ok := m.clearedFields[cabinetfault.FieldAttachments]
	return ok
}

// ResetAttachments resets all changes to the "attachments" field.
func (m *CabinetFaultMutation) ResetAttachments() {
	m.attachments = nil
	delete(m.clearedFields, cabinetfault.FieldAttachments)
}

// SetDescription sets the "description" field.
func (m *CabinetFaultMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CabinetFaultMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the CabinetFault entity.
// If the CabinetFault object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CabinetFaultMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CabinetFaultMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[cabinetfault.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CabinetFaultMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[cabinetfault.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CabinetFaultMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, cabinetfault.FieldDescription)
}

// ClearBranch clears the "branch" edge to the Branch entity.
func (m *CabinetFaultMutation) ClearBranch() {
	m.clearedbranch = true
}

// BranchCleared reports if the "branch" edge to the Branch entity was cleared.
func (m *CabinetFaultMutation) BranchCleared() bool {
	return m.clearedbranch
}

// BranchIDs returns the "branch" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BranchID instead. It exists only for internal usage by the builders.
func (m *CabinetFaultMutation) BranchIDs() (ids []uint64) {
	if id := m.branch; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBranch resets all changes to the "branch" edge.
func (m *CabinetFaultMutation) ResetBranch() {
	m.branch = nil
	m.clearedbranch = false
}

// ClearCabinet clears the "cabinet" edge to the Cabinet entity.
func (m *CabinetFaultMutation) ClearCabinet() {
	m.clearedcabinet = true
}

// CabinetCleared reports if the "cabinet" edge to the Cabinet entity was cleared.
func (m *CabinetFaultMutation) CabinetCleared() bool {
	return m.clearedcabinet
}

// CabinetIDs returns the "cabinet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CabinetID instead. It exists only for internal usage by the builders.
func (m *CabinetFaultMutation) CabinetIDs() (ids []uint64) {
	if id := m.cabinet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCabinet resets all changes to the "cabinet" edge.
func (m *CabinetFaultMutation) ResetCabinet() {
	m.cabinet = nil
	m.clearedcabinet = false
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *CabinetFaultMutation) ClearRider() {
	m.clearedrider = true
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *CabinetFaultMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *CabinetFaultMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *CabinetFaultMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// ClearCity clears the "city" edge to the City entity.
func (m *CabinetFaultMutation) ClearCity() {
	m.clearedcity = true
}

// CityCleared reports if the "city" edge to the City entity was cleared.
func (m *CabinetFaultMutation) CityCleared() bool {
	return m.clearedcity
}

// CityIDs returns the "city" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CityID instead. It exists only for internal usage by the builders.
func (m *CabinetFaultMutation) CityIDs() (ids []uint64) {
	if id := m.city; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCity resets all changes to the "city" edge.
func (m *CabinetFaultMutation) ResetCity() {
	m.city = nil
	m.clearedcity = false
}

// Where appends a list predicates to the CabinetFaultMutation builder.
func (m *CabinetFaultMutation) Where(ps ...predicate.CabinetFault) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CabinetFaultMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CabinetFault).
func (m *CabinetFaultMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CabinetFaultMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, cabinetfault.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, cabinetfault.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, cabinetfault.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, cabinetfault.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, cabinetfault.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, cabinetfault.FieldRemark)
	}
	if m.status != nil {
		fields = append(fields, cabinetfault.FieldStatus)
	}
	if m.city != nil {
		fields = append(fields, cabinetfault.FieldCityID)
	}
	if m.branch != nil {
		fields = append(fields, cabinetfault.FieldBranchID)
	}
	if m.cabinet != nil {
		fields = append(fields, cabinetfault.FieldCabinetID)
	}
	if m.rider != nil {
		fields = append(fields, cabinetfault.FieldRiderID)
	}
	if m.fault != nil {
		fields = append(fields, cabinetfault.FieldFault)
	}
	if m.attachments != nil {
		fields = append(fields, cabinetfault.FieldAttachments)
	}
	if m.description != nil {
		fields = append(fields, cabinetfault.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CabinetFaultMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cabinetfault.FieldCreatedAt:
		return m.CreatedAt()
	case cabinetfault.FieldUpdatedAt:
		return m.UpdatedAt()
	case cabinetfault.FieldDeletedAt:
		return m.DeletedAt()
	case cabinetfault.FieldCreator:
		return m.Creator()
	case cabinetfault.FieldLastModifier:
		return m.LastModifier()
	case cabinetfault.FieldRemark:
		return m.Remark()
	case cabinetfault.FieldStatus:
		return m.Status()
	case cabinetfault.FieldCityID:
		return m.CityID()
	case cabinetfault.FieldBranchID:
		return m.BranchID()
	case cabinetfault.FieldCabinetID:
		return m.CabinetID()
	case cabinetfault.FieldRiderID:
		return m.RiderID()
	case cabinetfault.FieldFault:
		return m.Fault()
	case cabinetfault.FieldAttachments:
		return m.Attachments()
	case cabinetfault.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CabinetFaultMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cabinetfault.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case cabinetfault.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case cabinetfault.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case cabinetfault.FieldCreator:
		return m.OldCreator(ctx)
	case cabinetfault.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case cabinetfault.FieldRemark:
		return m.OldRemark(ctx)
	case cabinetfault.FieldStatus:
		return m.OldStatus(ctx)
	case cabinetfault.FieldCityID:
		return m.OldCityID(ctx)
	case cabinetfault.FieldBranchID:
		return m.OldBranchID(ctx)
	case cabinetfault.FieldCabinetID:
		return m.OldCabinetID(ctx)
	case cabinetfault.FieldRiderID:
		return m.OldRiderID(ctx)
	case cabinetfault.FieldFault:
		return m.OldFault(ctx)
	case cabinetfault.FieldAttachments:
		return m.OldAttachments(ctx)
	case cabinetfault.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown CabinetFault field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CabinetFaultMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cabinetfault.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case cabinetfault.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case cabinetfault.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case cabinetfault.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case cabinetfault.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case cabinetfault.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case cabinetfault.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case cabinetfault.FieldCityID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCityID(v)
		return nil
	case cabinetfault.FieldBranchID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBranchID(v)
		return nil
	case cabinetfault.FieldCabinetID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCabinetID(v)
		return nil
	case cabinetfault.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case cabinetfault.FieldFault:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFault(v)
		return nil
	case cabinetfault.FieldAttachments:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttachments(v)
		return nil
	case cabinetfault.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown CabinetFault field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CabinetFaultMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, cabinetfault.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CabinetFaultMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case cabinetfault.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CabinetFaultMutation) AddField(name string, value ent.Value) error {
	switch name {
	case cabinetfault.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown CabinetFault numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CabinetFaultMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(cabinetfault.FieldDeletedAt) {
		fields = append(fields, cabinetfault.FieldDeletedAt)
	}
	if m.FieldCleared(cabinetfault.FieldCreator) {
		fields = append(fields, cabinetfault.FieldCreator)
	}
	if m.FieldCleared(cabinetfault.FieldLastModifier) {
		fields = append(fields, cabinetfault.FieldLastModifier)
	}
	if m.FieldCleared(cabinetfault.FieldRemark) {
		fields = append(fields, cabinetfault.FieldRemark)
	}
	if m.FieldCleared(cabinetfault.FieldFault) {
		fields = append(fields, cabinetfault.FieldFault)
	}
	if m.FieldCleared(cabinetfault.FieldAttachments) {
		fields = append(fields, cabinetfault.FieldAttachments)
	}
	if m.FieldCleared(cabinetfault.FieldDescription) {
		fields = append(fields, cabinetfault.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CabinetFaultMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CabinetFaultMutation) ClearField(name string) error {
	switch name {
	case cabinetfault.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case cabinetfault.FieldCreator:
		m.ClearCreator()
		return nil
	case cabinetfault.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case cabinetfault.FieldRemark:
		m.ClearRemark()
		return nil
	case cabinetfault.FieldFault:
		m.ClearFault()
		return nil
	case cabinetfault.FieldAttachments:
		m.ClearAttachments()
		return nil
	case cabinetfault.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown CabinetFault nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CabinetFaultMutation) ResetField(name string) error {
	switch name {
	case cabinetfault.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case cabinetfault.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case cabinetfault.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case cabinetfault.FieldCreator:
		m.ResetCreator()
		return nil
	case cabinetfault.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case cabinetfault.FieldRemark:
		m.ResetRemark()
		return nil
	case cabinetfault.FieldStatus:
		m.ResetStatus()
		return nil
	case cabinetfault.FieldCityID:
		m.ResetCityID()
		return nil
	case cabinetfault.FieldBranchID:
		m.ResetBranchID()
		return nil
	case cabinetfault.FieldCabinetID:
		m.ResetCabinetID()
		return nil
	case cabinetfault.FieldRiderID:
		m.ResetRiderID()
		return nil
	case cabinetfault.FieldFault:
		m.ResetFault()
		return nil
	case cabinetfault.FieldAttachments:
		m.ResetAttachments()
		return nil
	case cabinetfault.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown CabinetFault field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CabinetFaultMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.branch != nil {
		edges = append(edges, cabinetfault.EdgeBranch)
	}
	if m.cabinet != nil {
		edges = append(edges, cabinetfault.EdgeCabinet)
	}
	if m.rider != nil {
		edges = append(edges, cabinetfault.EdgeRider)
	}
	if m.city != nil {
		edges = append(edges, cabinetfault.EdgeCity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CabinetFaultMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cabinetfault.EdgeBranch:
		if id := m.branch; id != nil {
			return []ent.Value{*id}
		}
	case cabinetfault.EdgeCabinet:
		if id := m.cabinet; id != nil {
			return []ent.Value{*id}
		}
	case cabinetfault.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	case cabinetfault.EdgeCity:
		if id := m.city; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CabinetFaultMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CabinetFaultMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CabinetFaultMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedbranch {
		edges = append(edges, cabinetfault.EdgeBranch)
	}
	if m.clearedcabinet {
		edges = append(edges, cabinetfault.EdgeCabinet)
	}
	if m.clearedrider {
		edges = append(edges, cabinetfault.EdgeRider)
	}
	if m.clearedcity {
		edges = append(edges, cabinetfault.EdgeCity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CabinetFaultMutation) EdgeCleared(name string) bool {
	switch name {
	case cabinetfault.EdgeBranch:
		return m.clearedbranch
	case cabinetfault.EdgeCabinet:
		return m.clearedcabinet
	case cabinetfault.EdgeRider:
		return m.clearedrider
	case cabinetfault.EdgeCity:
		return m.clearedcity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CabinetFaultMutation) ClearEdge(name string) error {
	switch name {
	case cabinetfault.EdgeBranch:
		m.ClearBranch()
		return nil
	case cabinetfault.EdgeCabinet:
		m.ClearCabinet()
		return nil
	case cabinetfault.EdgeRider:
		m.ClearRider()
		return nil
	case cabinetfault.EdgeCity:
		m.ClearCity()
		return nil
	}
	return fmt.Errorf("unknown CabinetFault unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CabinetFaultMutation) ResetEdge(name string) error {
	switch name {
	case cabinetfault.EdgeBranch:
		m.ResetBranch()
		return nil
	case cabinetfault.EdgeCabinet:
		m.ResetCabinet()
		return nil
	case cabinetfault.EdgeRider:
		m.ResetRider()
		return nil
	case cabinetfault.EdgeCity:
		m.ResetCity()
		return nil
	}
	return fmt.Errorf("unknown CabinetFault edge %s", name)
}

// CityMutation represents an operation that mutates the City nodes in the graph.
type CityMutation struct {
	config
	op              Op
	typ             string
	id              *uint64
	created_at      *time.Time
	updated_at      *time.Time
	deleted_at      *time.Time
	last_modifier   **model.Modifier
	remark          *string
	open            *bool
	name            *string
	code            *string
	clearedFields   map[string]struct{}
	plans           map[uint64]struct{}
	removedplans    map[uint64]struct{}
	clearedplans    bool
	parent          *uint64
	clearedparent   bool
	children        map[uint64]struct{}
	removedchildren map[uint64]struct{}
	clearedchildren bool
	branches        map[uint64]struct{}
	removedbranches map[uint64]struct{}
	clearedbranches bool
	faults          map[uint64]struct{}
	removedfaults   map[uint64]struct{}
	clearedfaults   bool
	done            bool
	oldValue        func(context.Context) (*City, error)
	predicates      []predicate.City
}

var _ ent.Mutation = (*CityMutation)(nil)

// cityOption allows management of the mutation configuration using functional options.
type cityOption func(*CityMutation)

// newCityMutation creates new mutation for the City entity.
func newCityMutation(c config, op Op, opts ...cityOption) *CityMutation {
	m := &CityMutation{
		config:        c,
		op:            op,
		typ:           TypeCity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCityID sets the ID field of the mutation.
func withCityID(id uint64) cityOption {
	return func(m *CityMutation) {
		var (
			err   error
			once  sync.Once
			value *City
		)
		m.oldValue = func(ctx context.Context) (*City, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().City.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCity sets the old City of the mutation.
func withCity(node *City) cityOption {
	return func(m *CityMutation) {
		m.oldValue = func(context.Context) (*City, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of City entities.
func (m *CityMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CityMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CityMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().City.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *CityMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *CityMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *CityMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[city.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *CityMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[city.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *CityMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, city.FieldDeletedAt)
}

// SetLastModifier sets the "last_modifier" field.
func (m *CityMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *CityMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *CityMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[city.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *CityMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[city.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *CityMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, city.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *CityMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *CityMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *CityMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[city.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *CityMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[city.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *CityMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, city.FieldRemark)
}

// SetOpen sets the "open" field.
func (m *CityMutation) SetOpen(b bool) {
	m.open = &b
}

// Open returns the value of the "open" field in the mutation.
func (m *CityMutation) Open() (r bool, exists bool) {
	v := m.open
	if v == nil {
		return
	}
	return *v, true
}

// OldOpen returns the old "open" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldOpen(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpen: %w", err)
	}
	return oldValue.Open, nil
}

// ClearOpen clears the value of the "open" field.
func (m *CityMutation) ClearOpen() {
	m.open = nil
	m.clearedFields[city.FieldOpen] = struct{}{}
}

// OpenCleared returns if the "open" field was cleared in this mutation.
func (m *CityMutation) OpenCleared() bool {
	_, ok := m.clearedFields[city.FieldOpen]
	return ok
}

// ResetOpen resets all changes to the "open" field.
func (m *CityMutation) ResetOpen() {
	m.open = nil
	delete(m.clearedFields, city.FieldOpen)
}

// SetName sets the "name" field.
func (m *CityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CityMutation) ResetName() {
	m.name = nil
}

// SetCode sets the "code" field.
func (m *CityMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CityMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CityMutation) ResetCode() {
	m.code = nil
}

// SetParentID sets the "parent_id" field.
func (m *CityMutation) SetParentID(u uint64) {
	m.parent = &u
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CityMutation) ParentID() (r uint64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the City entity.
// If the City object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CityMutation) OldParentID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *CityMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[city.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *CityMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[city.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CityMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, city.FieldParentID)
}

// AddPlanIDs adds the "plans" edge to the Plan entity by ids.
func (m *CityMutation) AddPlanIDs(ids ...uint64) {
	if m.plans == nil {
		m.plans = make(map[uint64]struct{})
	}
	for i := range ids {
		m.plans[ids[i]] = struct{}{}
	}
}

// ClearPlans clears the "plans" edge to the Plan entity.
func (m *CityMutation) ClearPlans() {
	m.clearedplans = true
}

// PlansCleared reports if the "plans" edge to the Plan entity was cleared.
func (m *CityMutation) PlansCleared() bool {
	return m.clearedplans
}

// RemovePlanIDs removes the "plans" edge to the Plan entity by IDs.
func (m *CityMutation) RemovePlanIDs(ids ...uint64) {
	if m.removedplans == nil {
		m.removedplans = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.plans, ids[i])
		m.removedplans[ids[i]] = struct{}{}
	}
}

// RemovedPlans returns the removed IDs of the "plans" edge to the Plan entity.
func (m *CityMutation) RemovedPlansIDs() (ids []uint64) {
	for id := range m.removedplans {
		ids = append(ids, id)
	}
	return
}

// PlansIDs returns the "plans" edge IDs in the mutation.
func (m *CityMutation) PlansIDs() (ids []uint64) {
	for id := range m.plans {
		ids = append(ids, id)
	}
	return
}

// ResetPlans resets all changes to the "plans" edge.
func (m *CityMutation) ResetPlans() {
	m.plans = nil
	m.clearedplans = false
	m.removedplans = nil
}

// ClearParent clears the "parent" edge to the City entity.
func (m *CityMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the City entity was cleared.
func (m *CityMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CityMutation) ParentIDs() (ids []uint64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CityMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the City entity by ids.
func (m *CityMutation) AddChildIDs(ids ...uint64) {
	if m.children == nil {
		m.children = make(map[uint64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the City entity.
func (m *CityMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the City entity was cleared.
func (m *CityMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the City entity by IDs.
func (m *CityMutation) RemoveChildIDs(ids ...uint64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the City entity.
func (m *CityMutation) RemovedChildrenIDs() (ids []uint64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *CityMutation) ChildrenIDs() (ids []uint64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *CityMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddBranchIDs adds the "branches" edge to the Branch entity by ids.
func (m *CityMutation) AddBranchIDs(ids ...uint64) {
	if m.branches == nil {
		m.branches = make(map[uint64]struct{})
	}
	for i := range ids {
		m.branches[ids[i]] = struct{}{}
	}
}

// ClearBranches clears the "branches" edge to the Branch entity.
func (m *CityMutation) ClearBranches() {
	m.clearedbranches = true
}

// BranchesCleared reports if the "branches" edge to the Branch entity was cleared.
func (m *CityMutation) BranchesCleared() bool {
	return m.clearedbranches
}

// RemoveBranchIDs removes the "branches" edge to the Branch entity by IDs.
func (m *CityMutation) RemoveBranchIDs(ids ...uint64) {
	if m.removedbranches == nil {
		m.removedbranches = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.branches, ids[i])
		m.removedbranches[ids[i]] = struct{}{}
	}
}

// RemovedBranches returns the removed IDs of the "branches" edge to the Branch entity.
func (m *CityMutation) RemovedBranchesIDs() (ids []uint64) {
	for id := range m.removedbranches {
		ids = append(ids, id)
	}
	return
}

// BranchesIDs returns the "branches" edge IDs in the mutation.
func (m *CityMutation) BranchesIDs() (ids []uint64) {
	for id := range m.branches {
		ids = append(ids, id)
	}
	return
}

// ResetBranches resets all changes to the "branches" edge.
func (m *CityMutation) ResetBranches() {
	m.branches = nil
	m.clearedbranches = false
	m.removedbranches = nil
}

// AddFaultIDs adds the "faults" edge to the CabinetFault entity by ids.
func (m *CityMutation) AddFaultIDs(ids ...uint64) {
	if m.faults == nil {
		m.faults = make(map[uint64]struct{})
	}
	for i := range ids {
		m.faults[ids[i]] = struct{}{}
	}
}

// ClearFaults clears the "faults" edge to the CabinetFault entity.
func (m *CityMutation) ClearFaults() {
	m.clearedfaults = true
}

// FaultsCleared reports if the "faults" edge to the CabinetFault entity was cleared.
func (m *CityMutation) FaultsCleared() bool {
	return m.clearedfaults
}

// RemoveFaultIDs removes the "faults" edge to the CabinetFault entity by IDs.
func (m *CityMutation) RemoveFaultIDs(ids ...uint64) {
	if m.removedfaults == nil {
		m.removedfaults = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.faults, ids[i])
		m.removedfaults[ids[i]] = struct{}{}
	}
}

// RemovedFaults returns the removed IDs of the "faults" edge to the CabinetFault entity.
func (m *CityMutation) RemovedFaultsIDs() (ids []uint64) {
	for id := range m.removedfaults {
		ids = append(ids, id)
	}
	return
}

// FaultsIDs returns the "faults" edge IDs in the mutation.
func (m *CityMutation) FaultsIDs() (ids []uint64) {
	for id := range m.faults {
		ids = append(ids, id)
	}
	return
}

// ResetFaults resets all changes to the "faults" edge.
func (m *CityMutation) ResetFaults() {
	m.faults = nil
	m.clearedfaults = false
	m.removedfaults = nil
}

// Where appends a list predicates to the CityMutation builder.
func (m *CityMutation) Where(ps ...predicate.City) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (City).
func (m *CityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CityMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, city.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, city.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, city.FieldDeletedAt)
	}
	if m.last_modifier != nil {
		fields = append(fields, city.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, city.FieldRemark)
	}
	if m.open != nil {
		fields = append(fields, city.FieldOpen)
	}
	if m.name != nil {
		fields = append(fields, city.FieldName)
	}
	if m.code != nil {
		fields = append(fields, city.FieldCode)
	}
	if m.parent != nil {
		fields = append(fields, city.FieldParentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case city.FieldCreatedAt:
		return m.CreatedAt()
	case city.FieldUpdatedAt:
		return m.UpdatedAt()
	case city.FieldDeletedAt:
		return m.DeletedAt()
	case city.FieldLastModifier:
		return m.LastModifier()
	case city.FieldRemark:
		return m.Remark()
	case city.FieldOpen:
		return m.Open()
	case city.FieldName:
		return m.Name()
	case city.FieldCode:
		return m.Code()
	case city.FieldParentID:
		return m.ParentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case city.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case city.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case city.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case city.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case city.FieldRemark:
		return m.OldRemark(ctx)
	case city.FieldOpen:
		return m.OldOpen(ctx)
	case city.FieldName:
		return m.OldName(ctx)
	case city.FieldCode:
		return m.OldCode(ctx)
	case city.FieldParentID:
		return m.OldParentID(ctx)
	}
	return nil, fmt.Errorf("unknown City field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case city.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case city.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case city.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case city.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case city.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case city.FieldOpen:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpen(v)
		return nil
	case city.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case city.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case city.FieldParentID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CityMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown City numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(city.FieldDeletedAt) {
		fields = append(fields, city.FieldDeletedAt)
	}
	if m.FieldCleared(city.FieldLastModifier) {
		fields = append(fields, city.FieldLastModifier)
	}
	if m.FieldCleared(city.FieldRemark) {
		fields = append(fields, city.FieldRemark)
	}
	if m.FieldCleared(city.FieldOpen) {
		fields = append(fields, city.FieldOpen)
	}
	if m.FieldCleared(city.FieldParentID) {
		fields = append(fields, city.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CityMutation) ClearField(name string) error {
	switch name {
	case city.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case city.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case city.FieldRemark:
		m.ClearRemark()
		return nil
	case city.FieldOpen:
		m.ClearOpen()
		return nil
	case city.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown City nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CityMutation) ResetField(name string) error {
	switch name {
	case city.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case city.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case city.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case city.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case city.FieldRemark:
		m.ResetRemark()
		return nil
	case city.FieldOpen:
		m.ResetOpen()
		return nil
	case city.FieldName:
		m.ResetName()
		return nil
	case city.FieldCode:
		m.ResetCode()
		return nil
	case city.FieldParentID:
		m.ResetParentID()
		return nil
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CityMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.plans != nil {
		edges = append(edges, city.EdgePlans)
	}
	if m.parent != nil {
		edges = append(edges, city.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, city.EdgeChildren)
	}
	if m.branches != nil {
		edges = append(edges, city.EdgeBranches)
	}
	if m.faults != nil {
		edges = append(edges, city.EdgeFaults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case city.EdgePlans:
		ids := make([]ent.Value, 0, len(m.plans))
		for id := range m.plans {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case city.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeBranches:
		ids := make([]ent.Value, 0, len(m.branches))
		for id := range m.branches {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeFaults:
		ids := make([]ent.Value, 0, len(m.faults))
		for id := range m.faults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedplans != nil {
		edges = append(edges, city.EdgePlans)
	}
	if m.removedchildren != nil {
		edges = append(edges, city.EdgeChildren)
	}
	if m.removedbranches != nil {
		edges = append(edges, city.EdgeBranches)
	}
	if m.removedfaults != nil {
		edges = append(edges, city.EdgeFaults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case city.EdgePlans:
		ids := make([]ent.Value, 0, len(m.removedplans))
		for id := range m.removedplans {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeBranches:
		ids := make([]ent.Value, 0, len(m.removedbranches))
		for id := range m.removedbranches {
			ids = append(ids, id)
		}
		return ids
	case city.EdgeFaults:
		ids := make([]ent.Value, 0, len(m.removedfaults))
		for id := range m.removedfaults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedplans {
		edges = append(edges, city.EdgePlans)
	}
	if m.clearedparent {
		edges = append(edges, city.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, city.EdgeChildren)
	}
	if m.clearedbranches {
		edges = append(edges, city.EdgeBranches)
	}
	if m.clearedfaults {
		edges = append(edges, city.EdgeFaults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CityMutation) EdgeCleared(name string) bool {
	switch name {
	case city.EdgePlans:
		return m.clearedplans
	case city.EdgeParent:
		return m.clearedparent
	case city.EdgeChildren:
		return m.clearedchildren
	case city.EdgeBranches:
		return m.clearedbranches
	case city.EdgeFaults:
		return m.clearedfaults
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CityMutation) ClearEdge(name string) error {
	switch name {
	case city.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown City unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CityMutation) ResetEdge(name string) error {
	switch name {
	case city.EdgePlans:
		m.ResetPlans()
		return nil
	case city.EdgeParent:
		m.ResetParent()
		return nil
	case city.EdgeChildren:
		m.ResetChildren()
		return nil
	case city.EdgeBranches:
		m.ResetBranches()
		return nil
	case city.EdgeFaults:
		m.ResetFaults()
		return nil
	}
	return fmt.Errorf("unknown City edge %s", name)
}

// ContractMutation represents an operation that mutates the Contract nodes in the graph.
type ContractMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	last_modifier **model.Modifier
	remark        *string
	status        *uint8
	addstatus     *int8
	flow_id       *string
	sn            *string
	files         *[]string
	clearedFields map[string]struct{}
	rider         *uint64
	clearedrider  bool
	done          bool
	oldValue      func(context.Context) (*Contract, error)
	predicates    []predicate.Contract
}

var _ ent.Mutation = (*ContractMutation)(nil)

// contractOption allows management of the mutation configuration using functional options.
type contractOption func(*ContractMutation)

// newContractMutation creates new mutation for the Contract entity.
func newContractMutation(c config, op Op, opts ...contractOption) *ContractMutation {
	m := &ContractMutation{
		config:        c,
		op:            op,
		typ:           TypeContract,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContractID sets the ID field of the mutation.
func withContractID(id uint64) contractOption {
	return func(m *ContractMutation) {
		var (
			err   error
			once  sync.Once
			value *Contract
		)
		m.oldValue = func(ctx context.Context) (*Contract, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contract.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContract sets the old Contract of the mutation.
func withContract(node *Contract) contractOption {
	return func(m *ContractMutation) {
		m.oldValue = func(context.Context) (*Contract, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContractMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContractMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContractMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContractMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Contract.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ContractMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContractMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContractMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ContractMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ContractMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ContractMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ContractMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ContractMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ContractMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[contract.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ContractMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[contract.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ContractMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, contract.FieldDeletedAt)
}

// SetLastModifier sets the "last_modifier" field.
func (m *ContractMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *ContractMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *ContractMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[contract.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *ContractMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[contract.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *ContractMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, contract.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *ContractMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ContractMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ContractMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[contract.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ContractMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[contract.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ContractMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, contract.FieldRemark)
}

// SetStatus sets the "status" field.
func (m *ContractMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ContractMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *ContractMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ContractMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ContractMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetRiderID sets the "rider_id" field.
func (m *ContractMutation) SetRiderID(u uint64) {
	m.rider = &u
}

// RiderID returns the value of the "rider_id" field in the mutation.
func (m *ContractMutation) RiderID() (r uint64, exists bool) {
	v := m.rider
	if v == nil {
		return
	}
	return *v, true
}

// OldRiderID returns the old "rider_id" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldRiderID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRiderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRiderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRiderID: %w", err)
	}
	return oldValue.RiderID, nil
}

// ResetRiderID resets all changes to the "rider_id" field.
func (m *ContractMutation) ResetRiderID() {
	m.rider = nil
}

// SetFlowID sets the "flow_id" field.
func (m *ContractMutation) SetFlowID(s string) {
	m.flow_id = &s
}

// FlowID returns the value of the "flow_id" field in the mutation.
func (m *ContractMutation) FlowID() (r string, exists bool) {
	v := m.flow_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowID returns the old "flow_id" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldFlowID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowID: %w", err)
	}
	return oldValue.FlowID, nil
}

// ResetFlowID resets all changes to the "flow_id" field.
func (m *ContractMutation) ResetFlowID() {
	m.flow_id = nil
}

// SetSn sets the "sn" field.
func (m *ContractMutation) SetSn(s string) {
	m.sn = &s
}

// Sn returns the value of the "sn" field in the mutation.
func (m *ContractMutation) Sn() (r string, exists bool) {
	v := m.sn
	if v == nil {
		return
	}
	return *v, true
}

// OldSn returns the old "sn" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSn: %w", err)
	}
	return oldValue.Sn, nil
}

// ResetSn resets all changes to the "sn" field.
func (m *ContractMutation) ResetSn() {
	m.sn = nil
}

// SetFiles sets the "files" field.
func (m *ContractMutation) SetFiles(s []string) {
	m.files = &s
}

// Files returns the value of the "files" field in the mutation.
func (m *ContractMutation) Files() (r []string, exists bool) {
	v := m.files
	if v == nil {
		return
	}
	return *v, true
}

// OldFiles returns the old "files" field's value of the Contract entity.
// If the Contract object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContractMutation) OldFiles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFiles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFiles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFiles: %w", err)
	}
	return oldValue.Files, nil
}

// ClearFiles clears the value of the "files" field.
func (m *ContractMutation) ClearFiles() {
	m.files = nil
	m.clearedFields[contract.FieldFiles] = struct{}{}
}

// FilesCleared returns if the "files" field was cleared in this mutation.
func (m *ContractMutation) FilesCleared() bool {
	_, ok := m.clearedFields[contract.FieldFiles]
	return ok
}

// ResetFiles resets all changes to the "files" field.
func (m *ContractMutation) ResetFiles() {
	m.files = nil
	delete(m.clearedFields, contract.FieldFiles)
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *ContractMutation) ClearRider() {
	m.clearedrider = true
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *ContractMutation) RiderCleared() bool {
	return m.clearedrider
}

// RiderIDs returns the "rider" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RiderID instead. It exists only for internal usage by the builders.
func (m *ContractMutation) RiderIDs() (ids []uint64) {
	if id := m.rider; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *ContractMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
}

// Where appends a list predicates to the ContractMutation builder.
func (m *ContractMutation) Where(ps ...predicate.Contract) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ContractMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Contract).
func (m *ContractMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContractMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, contract.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, contract.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, contract.FieldDeletedAt)
	}
	if m.last_modifier != nil {
		fields = append(fields, contract.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, contract.FieldRemark)
	}
	if m.status != nil {
		fields = append(fields, contract.FieldStatus)
	}
	if m.rider != nil {
		fields = append(fields, contract.FieldRiderID)
	}
	if m.flow_id != nil {
		fields = append(fields, contract.FieldFlowID)
	}
	if m.sn != nil {
		fields = append(fields, contract.FieldSn)
	}
	if m.files != nil {
		fields = append(fields, contract.FieldFiles)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContractMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contract.FieldCreatedAt:
		return m.CreatedAt()
	case contract.FieldUpdatedAt:
		return m.UpdatedAt()
	case contract.FieldDeletedAt:
		return m.DeletedAt()
	case contract.FieldLastModifier:
		return m.LastModifier()
	case contract.FieldRemark:
		return m.Remark()
	case contract.FieldStatus:
		return m.Status()
	case contract.FieldRiderID:
		return m.RiderID()
	case contract.FieldFlowID:
		return m.FlowID()
	case contract.FieldSn:
		return m.Sn()
	case contract.FieldFiles:
		return m.Files()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContractMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contract.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case contract.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case contract.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case contract.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case contract.FieldRemark:
		return m.OldRemark(ctx)
	case contract.FieldStatus:
		return m.OldStatus(ctx)
	case contract.FieldRiderID:
		return m.OldRiderID(ctx)
	case contract.FieldFlowID:
		return m.OldFlowID(ctx)
	case contract.FieldSn:
		return m.OldSn(ctx)
	case contract.FieldFiles:
		return m.OldFiles(ctx)
	}
	return nil, fmt.Errorf("unknown Contract field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContractMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contract.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case contract.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case contract.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case contract.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case contract.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case contract.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case contract.FieldRiderID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRiderID(v)
		return nil
	case contract.FieldFlowID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowID(v)
		return nil
	case contract.FieldSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSn(v)
		return nil
	case contract.FieldFiles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFiles(v)
		return nil
	}
	return fmt.Errorf("unknown Contract field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContractMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, contract.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContractMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case contract.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContractMutation) AddField(name string, value ent.Value) error {
	switch name {
	case contract.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Contract numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContractMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(contract.FieldDeletedAt) {
		fields = append(fields, contract.FieldDeletedAt)
	}
	if m.FieldCleared(contract.FieldLastModifier) {
		fields = append(fields, contract.FieldLastModifier)
	}
	if m.FieldCleared(contract.FieldRemark) {
		fields = append(fields, contract.FieldRemark)
	}
	if m.FieldCleared(contract.FieldFiles) {
		fields = append(fields, contract.FieldFiles)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContractMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContractMutation) ClearField(name string) error {
	switch name {
	case contract.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case contract.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case contract.FieldRemark:
		m.ClearRemark()
		return nil
	case contract.FieldFiles:
		m.ClearFiles()
		return nil
	}
	return fmt.Errorf("unknown Contract nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContractMutation) ResetField(name string) error {
	switch name {
	case contract.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case contract.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case contract.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case contract.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case contract.FieldRemark:
		m.ResetRemark()
		return nil
	case contract.FieldStatus:
		m.ResetStatus()
		return nil
	case contract.FieldRiderID:
		m.ResetRiderID()
		return nil
	case contract.FieldFlowID:
		m.ResetFlowID()
		return nil
	case contract.FieldSn:
		m.ResetSn()
		return nil
	case contract.FieldFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown Contract field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContractMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.rider != nil {
		edges = append(edges, contract.EdgeRider)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContractMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contract.EdgeRider:
		if id := m.rider; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContractMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContractMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContractMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrider {
		edges = append(edges, contract.EdgeRider)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContractMutation) EdgeCleared(name string) bool {
	switch name {
	case contract.EdgeRider:
		return m.clearedrider
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContractMutation) ClearEdge(name string) error {
	switch name {
	case contract.EdgeRider:
		m.ClearRider()
		return nil
	}
	return fmt.Errorf("unknown Contract unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContractMutation) ResetEdge(name string) error {
	switch name {
	case contract.EdgeRider:
		m.ResetRider()
		return nil
	}
	return fmt.Errorf("unknown Contract edge %s", name)
}

// EnterpriseMutation represents an operation that mutates the Enterprise nodes in the graph.
type EnterpriseMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	creator       **model.Modifier
	last_modifier **model.Modifier
	remark        *string
	name          *string
	clearedFields map[string]struct{}
	riders        map[uint64]struct{}
	removedriders map[uint64]struct{}
	clearedriders bool
	done          bool
	oldValue      func(context.Context) (*Enterprise, error)
	predicates    []predicate.Enterprise
}

var _ ent.Mutation = (*EnterpriseMutation)(nil)

// enterpriseOption allows management of the mutation configuration using functional options.
type enterpriseOption func(*EnterpriseMutation)

// newEnterpriseMutation creates new mutation for the Enterprise entity.
func newEnterpriseMutation(c config, op Op, opts ...enterpriseOption) *EnterpriseMutation {
	m := &EnterpriseMutation{
		config:        c,
		op:            op,
		typ:           TypeEnterprise,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEnterpriseID sets the ID field of the mutation.
func withEnterpriseID(id uint64) enterpriseOption {
	return func(m *EnterpriseMutation) {
		var (
			err   error
			once  sync.Once
			value *Enterprise
		)
		m.oldValue = func(ctx context.Context) (*Enterprise, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Enterprise.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEnterprise sets the old Enterprise of the mutation.
func withEnterprise(node *Enterprise) enterpriseOption {
	return func(m *EnterpriseMutation) {
		m.oldValue = func(context.Context) (*Enterprise, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EnterpriseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EnterpriseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EnterpriseMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EnterpriseMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Enterprise.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EnterpriseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EnterpriseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EnterpriseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EnterpriseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EnterpriseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EnterpriseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *EnterpriseMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *EnterpriseMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *EnterpriseMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[enterprise.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *EnterpriseMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[enterprise.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *EnterpriseMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, enterprise.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *EnterpriseMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *EnterpriseMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *EnterpriseMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[enterprise.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *EnterpriseMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[enterprise.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *EnterpriseMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, enterprise.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *EnterpriseMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *EnterpriseMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *EnterpriseMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[enterprise.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *EnterpriseMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[enterprise.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *EnterpriseMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, enterprise.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *EnterpriseMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *EnterpriseMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *EnterpriseMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[enterprise.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *EnterpriseMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[enterprise.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *EnterpriseMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, enterprise.FieldRemark)
}

// SetName sets the "name" field.
func (m *EnterpriseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EnterpriseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Enterprise entity.
// If the Enterprise object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EnterpriseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EnterpriseMutation) ResetName() {
	m.name = nil
}

// AddRiderIDs adds the "riders" edge to the Rider entity by ids.
func (m *EnterpriseMutation) AddRiderIDs(ids ...uint64) {
	if m.riders == nil {
		m.riders = make(map[uint64]struct{})
	}
	for i := range ids {
		m.riders[ids[i]] = struct{}{}
	}
}

// ClearRiders clears the "riders" edge to the Rider entity.
func (m *EnterpriseMutation) ClearRiders() {
	m.clearedriders = true
}

// RidersCleared reports if the "riders" edge to the Rider entity was cleared.
func (m *EnterpriseMutation) RidersCleared() bool {
	return m.clearedriders
}

// RemoveRiderIDs removes the "riders" edge to the Rider entity by IDs.
func (m *EnterpriseMutation) RemoveRiderIDs(ids ...uint64) {
	if m.removedriders == nil {
		m.removedriders = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.riders, ids[i])
		m.removedriders[ids[i]] = struct{}{}
	}
}

// RemovedRiders returns the removed IDs of the "riders" edge to the Rider entity.
func (m *EnterpriseMutation) RemovedRidersIDs() (ids []uint64) {
	for id := range m.removedriders {
		ids = append(ids, id)
	}
	return
}

// RidersIDs returns the "riders" edge IDs in the mutation.
func (m *EnterpriseMutation) RidersIDs() (ids []uint64) {
	for id := range m.riders {
		ids = append(ids, id)
	}
	return
}

// ResetRiders resets all changes to the "riders" edge.
func (m *EnterpriseMutation) ResetRiders() {
	m.riders = nil
	m.clearedriders = false
	m.removedriders = nil
}

// Where appends a list predicates to the EnterpriseMutation builder.
func (m *EnterpriseMutation) Where(ps ...predicate.Enterprise) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EnterpriseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Enterprise).
func (m *EnterpriseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EnterpriseMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, enterprise.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, enterprise.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, enterprise.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, enterprise.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, enterprise.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, enterprise.FieldRemark)
	}
	if m.name != nil {
		fields = append(fields, enterprise.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EnterpriseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case enterprise.FieldCreatedAt:
		return m.CreatedAt()
	case enterprise.FieldUpdatedAt:
		return m.UpdatedAt()
	case enterprise.FieldDeletedAt:
		return m.DeletedAt()
	case enterprise.FieldCreator:
		return m.Creator()
	case enterprise.FieldLastModifier:
		return m.LastModifier()
	case enterprise.FieldRemark:
		return m.Remark()
	case enterprise.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EnterpriseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case enterprise.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case enterprise.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case enterprise.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case enterprise.FieldCreator:
		return m.OldCreator(ctx)
	case enterprise.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case enterprise.FieldRemark:
		return m.OldRemark(ctx)
	case enterprise.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Enterprise field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case enterprise.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case enterprise.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case enterprise.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case enterprise.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case enterprise.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case enterprise.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case enterprise.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Enterprise field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EnterpriseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EnterpriseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EnterpriseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Enterprise numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EnterpriseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(enterprise.FieldDeletedAt) {
		fields = append(fields, enterprise.FieldDeletedAt)
	}
	if m.FieldCleared(enterprise.FieldCreator) {
		fields = append(fields, enterprise.FieldCreator)
	}
	if m.FieldCleared(enterprise.FieldLastModifier) {
		fields = append(fields, enterprise.FieldLastModifier)
	}
	if m.FieldCleared(enterprise.FieldRemark) {
		fields = append(fields, enterprise.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EnterpriseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EnterpriseMutation) ClearField(name string) error {
	switch name {
	case enterprise.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case enterprise.FieldCreator:
		m.ClearCreator()
		return nil
	case enterprise.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case enterprise.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Enterprise nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EnterpriseMutation) ResetField(name string) error {
	switch name {
	case enterprise.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case enterprise.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case enterprise.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case enterprise.FieldCreator:
		m.ResetCreator()
		return nil
	case enterprise.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case enterprise.FieldRemark:
		m.ResetRemark()
		return nil
	case enterprise.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Enterprise field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EnterpriseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.riders != nil {
		edges = append(edges, enterprise.EdgeRiders)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EnterpriseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case enterprise.EdgeRiders:
		ids := make([]ent.Value, 0, len(m.riders))
		for id := range m.riders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EnterpriseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedriders != nil {
		edges = append(edges, enterprise.EdgeRiders)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EnterpriseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case enterprise.EdgeRiders:
		ids := make([]ent.Value, 0, len(m.removedriders))
		for id := range m.removedriders {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EnterpriseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedriders {
		edges = append(edges, enterprise.EdgeRiders)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EnterpriseMutation) EdgeCleared(name string) bool {
	switch name {
	case enterprise.EdgeRiders:
		return m.clearedriders
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EnterpriseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Enterprise unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EnterpriseMutation) ResetEdge(name string) error {
	switch name {
	case enterprise.EdgeRiders:
		m.ResetRiders()
		return nil
	}
	return fmt.Errorf("unknown Enterprise edge %s", name)
}

// ManagerMutation represents an operation that mutates the Manager nodes in the graph.
type ManagerMutation struct {
	config
	op             Op
	typ            string
	id             *uint64
	created_at     *time.Time
	updated_at     *time.Time
	deleted_at     *time.Time
	last_modifier  **model.Modifier
	remark         *string
	phone          *string
	name           *string
	password       *string
	last_signin_at *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Manager, error)
	predicates     []predicate.Manager
}

var _ ent.Mutation = (*ManagerMutation)(nil)

// managerOption allows management of the mutation configuration using functional options.
type managerOption func(*ManagerMutation)

// newManagerMutation creates new mutation for the Manager entity.
func newManagerMutation(c config, op Op, opts ...managerOption) *ManagerMutation {
	m := &ManagerMutation{
		config:        c,
		op:            op,
		typ:           TypeManager,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withManagerID sets the ID field of the mutation.
func withManagerID(id uint64) managerOption {
	return func(m *ManagerMutation) {
		var (
			err   error
			once  sync.Once
			value *Manager
		)
		m.oldValue = func(ctx context.Context) (*Manager, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Manager.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withManager sets the old Manager of the mutation.
func withManager(node *Manager) managerOption {
	return func(m *ManagerMutation) {
		m.oldValue = func(context.Context) (*Manager, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ManagerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ManagerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ManagerMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ManagerMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Manager.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ManagerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ManagerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ManagerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ManagerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ManagerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ManagerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *ManagerMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *ManagerMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *ManagerMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[manager.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *ManagerMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[manager.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *ManagerMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, manager.FieldDeletedAt)
}

// SetLastModifier sets the "last_modifier" field.
func (m *ManagerMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *ManagerMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *ManagerMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[manager.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *ManagerMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[manager.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *ManagerMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, manager.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *ManagerMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *ManagerMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *ManagerMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[manager.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *ManagerMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[manager.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *ManagerMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, manager.FieldRemark)
}

// SetPhone sets the "phone" field.
func (m *ManagerMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *ManagerMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *ManagerMutation) ResetPhone() {
	m.phone = nil
}

// SetName sets the "name" field.
func (m *ManagerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ManagerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ManagerMutation) ResetName() {
	m.name = nil
}

// SetPassword sets the "password" field.
func (m *ManagerMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *ManagerMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *ManagerMutation) ResetPassword() {
	m.password = nil
}

// SetLastSigninAt sets the "last_signin_at" field.
func (m *ManagerMutation) SetLastSigninAt(t time.Time) {
	m.last_signin_at = &t
}

// LastSigninAt returns the value of the "last_signin_at" field in the mutation.
func (m *ManagerMutation) LastSigninAt() (r time.Time, exists bool) {
	v := m.last_signin_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSigninAt returns the old "last_signin_at" field's value of the Manager entity.
// If the Manager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManagerMutation) OldLastSigninAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSigninAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSigninAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSigninAt: %w", err)
	}
	return oldValue.LastSigninAt, nil
}

// ClearLastSigninAt clears the value of the "last_signin_at" field.
func (m *ManagerMutation) ClearLastSigninAt() {
	m.last_signin_at = nil
	m.clearedFields[manager.FieldLastSigninAt] = struct{}{}
}

// LastSigninAtCleared returns if the "last_signin_at" field was cleared in this mutation.
func (m *ManagerMutation) LastSigninAtCleared() bool {
	_, ok := m.clearedFields[manager.FieldLastSigninAt]
	return ok
}

// ResetLastSigninAt resets all changes to the "last_signin_at" field.
func (m *ManagerMutation) ResetLastSigninAt() {
	m.last_signin_at = nil
	delete(m.clearedFields, manager.FieldLastSigninAt)
}

// Where appends a list predicates to the ManagerMutation builder.
func (m *ManagerMutation) Where(ps ...predicate.Manager) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ManagerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Manager).
func (m *ManagerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ManagerMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, manager.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, manager.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, manager.FieldDeletedAt)
	}
	if m.last_modifier != nil {
		fields = append(fields, manager.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, manager.FieldRemark)
	}
	if m.phone != nil {
		fields = append(fields, manager.FieldPhone)
	}
	if m.name != nil {
		fields = append(fields, manager.FieldName)
	}
	if m.password != nil {
		fields = append(fields, manager.FieldPassword)
	}
	if m.last_signin_at != nil {
		fields = append(fields, manager.FieldLastSigninAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ManagerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case manager.FieldCreatedAt:
		return m.CreatedAt()
	case manager.FieldUpdatedAt:
		return m.UpdatedAt()
	case manager.FieldDeletedAt:
		return m.DeletedAt()
	case manager.FieldLastModifier:
		return m.LastModifier()
	case manager.FieldRemark:
		return m.Remark()
	case manager.FieldPhone:
		return m.Phone()
	case manager.FieldName:
		return m.Name()
	case manager.FieldPassword:
		return m.Password()
	case manager.FieldLastSigninAt:
		return m.LastSigninAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ManagerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case manager.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case manager.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case manager.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case manager.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case manager.FieldRemark:
		return m.OldRemark(ctx)
	case manager.FieldPhone:
		return m.OldPhone(ctx)
	case manager.FieldName:
		return m.OldName(ctx)
	case manager.FieldPassword:
		return m.OldPassword(ctx)
	case manager.FieldLastSigninAt:
		return m.OldLastSigninAt(ctx)
	}
	return nil, fmt.Errorf("unknown Manager field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ManagerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case manager.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case manager.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case manager.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case manager.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case manager.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case manager.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case manager.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case manager.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case manager.FieldLastSigninAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSigninAt(v)
		return nil
	}
	return fmt.Errorf("unknown Manager field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ManagerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ManagerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ManagerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Manager numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ManagerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(manager.FieldDeletedAt) {
		fields = append(fields, manager.FieldDeletedAt)
	}
	if m.FieldCleared(manager.FieldLastModifier) {
		fields = append(fields, manager.FieldLastModifier)
	}
	if m.FieldCleared(manager.FieldRemark) {
		fields = append(fields, manager.FieldRemark)
	}
	if m.FieldCleared(manager.FieldLastSigninAt) {
		fields = append(fields, manager.FieldLastSigninAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ManagerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ManagerMutation) ClearField(name string) error {
	switch name {
	case manager.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case manager.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case manager.FieldRemark:
		m.ClearRemark()
		return nil
	case manager.FieldLastSigninAt:
		m.ClearLastSigninAt()
		return nil
	}
	return fmt.Errorf("unknown Manager nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ManagerMutation) ResetField(name string) error {
	switch name {
	case manager.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case manager.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case manager.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case manager.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case manager.FieldRemark:
		m.ResetRemark()
		return nil
	case manager.FieldPhone:
		m.ResetPhone()
		return nil
	case manager.FieldName:
		m.ResetName()
		return nil
	case manager.FieldPassword:
		m.ResetPassword()
		return nil
	case manager.FieldLastSigninAt:
		m.ResetLastSigninAt()
		return nil
	}
	return fmt.Errorf("unknown Manager field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ManagerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ManagerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ManagerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ManagerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ManagerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ManagerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ManagerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Manager unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ManagerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Manager edge %s", name)
}

// PersonMutation represents an operation that mutates the Person nodes in the graph.
type PersonMutation struct {
	config
	op               Op
	typ              string
	id               *uint64
	created_at       *time.Time
	updated_at       *time.Time
	deleted_at       *time.Time
	last_modifier    **model.Modifier
	remark           *string
	status           *uint8
	addstatus        *int8
	banned           *bool
	name             *string
	id_card_number   *string
	id_card_type     *uint8
	addid_card_type  *int8
	id_card_portrait *string
	id_card_national *string
	auth_face        *string
	auth_result      **model.FaceVerifyResult
	auth_at          *time.Time
	clearedFields    map[string]struct{}
	rider            map[uint64]struct{}
	removedrider     map[uint64]struct{}
	clearedrider     bool
	done             bool
	oldValue         func(context.Context) (*Person, error)
	predicates       []predicate.Person
}

var _ ent.Mutation = (*PersonMutation)(nil)

// personOption allows management of the mutation configuration using functional options.
type personOption func(*PersonMutation)

// newPersonMutation creates new mutation for the Person entity.
func newPersonMutation(c config, op Op, opts ...personOption) *PersonMutation {
	m := &PersonMutation{
		config:        c,
		op:            op,
		typ:           TypePerson,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPersonID sets the ID field of the mutation.
func withPersonID(id uint64) personOption {
	return func(m *PersonMutation) {
		var (
			err   error
			once  sync.Once
			value *Person
		)
		m.oldValue = func(ctx context.Context) (*Person, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Person.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPerson sets the old Person of the mutation.
func withPerson(node *Person) personOption {
	return func(m *PersonMutation) {
		m.oldValue = func(context.Context) (*Person, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PersonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PersonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PersonMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PersonMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Person.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PersonMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PersonMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PersonMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PersonMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PersonMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PersonMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PersonMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PersonMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PersonMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[person.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PersonMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[person.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PersonMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, person.FieldDeletedAt)
}

// SetLastModifier sets the "last_modifier" field.
func (m *PersonMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *PersonMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *PersonMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[person.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *PersonMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[person.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *PersonMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, person.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *PersonMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PersonMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PersonMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[person.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PersonMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[person.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PersonMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, person.FieldRemark)
}

// SetStatus sets the "status" field.
func (m *PersonMutation) SetStatus(u uint8) {
	m.status = &u
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *PersonMutation) Status() (r uint8, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldStatus(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds u to the "status" field.
func (m *PersonMutation) AddStatus(u int8) {
	if m.addstatus != nil {
		*m.addstatus += u
	} else {
		m.addstatus = &u
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *PersonMutation) AddedStatus() (r int8, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *PersonMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetBanned sets the "banned" field.
func (m *PersonMutation) SetBanned(b bool) {
	m.banned = &b
}

// Banned returns the value of the "banned" field in the mutation.
func (m *PersonMutation) Banned() (r bool, exists bool) {
	v := m.banned
	if v == nil {
		return
	}
	return *v, true
}

// OldBanned returns the old "banned" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldBanned(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBanned is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBanned requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBanned: %w", err)
	}
	return oldValue.Banned, nil
}

// ResetBanned resets all changes to the "banned" field.
func (m *PersonMutation) ResetBanned() {
	m.banned = nil
}

// SetName sets the "name" field.
func (m *PersonMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PersonMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PersonMutation) ResetName() {
	m.name = nil
}

// SetIDCardNumber sets the "id_card_number" field.
func (m *PersonMutation) SetIDCardNumber(s string) {
	m.id_card_number = &s
}

// IDCardNumber returns the value of the "id_card_number" field in the mutation.
func (m *PersonMutation) IDCardNumber() (r string, exists bool) {
	v := m.id_card_number
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCardNumber returns the old "id_card_number" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldIDCardNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCardNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCardNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCardNumber: %w", err)
	}
	return oldValue.IDCardNumber, nil
}

// ResetIDCardNumber resets all changes to the "id_card_number" field.
func (m *PersonMutation) ResetIDCardNumber() {
	m.id_card_number = nil
}

// SetIDCardType sets the "id_card_type" field.
func (m *PersonMutation) SetIDCardType(u uint8) {
	m.id_card_type = &u
	m.addid_card_type = nil
}

// IDCardType returns the value of the "id_card_type" field in the mutation.
func (m *PersonMutation) IDCardType() (r uint8, exists bool) {
	v := m.id_card_type
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCardType returns the old "id_card_type" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldIDCardType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCardType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCardType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCardType: %w", err)
	}
	return oldValue.IDCardType, nil
}

// AddIDCardType adds u to the "id_card_type" field.
func (m *PersonMutation) AddIDCardType(u int8) {
	if m.addid_card_type != nil {
		*m.addid_card_type += u
	} else {
		m.addid_card_type = &u
	}
}

// AddedIDCardType returns the value that was added to the "id_card_type" field in this mutation.
func (m *PersonMutation) AddedIDCardType() (r int8, exists bool) {
	v := m.addid_card_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetIDCardType resets all changes to the "id_card_type" field.
func (m *PersonMutation) ResetIDCardType() {
	m.id_card_type = nil
	m.addid_card_type = nil
}

// SetIDCardPortrait sets the "id_card_portrait" field.
func (m *PersonMutation) SetIDCardPortrait(s string) {
	m.id_card_portrait = &s
}

// IDCardPortrait returns the value of the "id_card_portrait" field in the mutation.
func (m *PersonMutation) IDCardPortrait() (r string, exists bool) {
	v := m.id_card_portrait
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCardPortrait returns the old "id_card_portrait" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldIDCardPortrait(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCardPortrait is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCardPortrait requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCardPortrait: %w", err)
	}
	return oldValue.IDCardPortrait, nil
}

// ResetIDCardPortrait resets all changes to the "id_card_portrait" field.
func (m *PersonMutation) ResetIDCardPortrait() {
	m.id_card_portrait = nil
}

// SetIDCardNational sets the "id_card_national" field.
func (m *PersonMutation) SetIDCardNational(s string) {
	m.id_card_national = &s
}

// IDCardNational returns the value of the "id_card_national" field in the mutation.
func (m *PersonMutation) IDCardNational() (r string, exists bool) {
	v := m.id_card_national
	if v == nil {
		return
	}
	return *v, true
}

// OldIDCardNational returns the old "id_card_national" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldIDCardNational(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIDCardNational is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIDCardNational requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIDCardNational: %w", err)
	}
	return oldValue.IDCardNational, nil
}

// ResetIDCardNational resets all changes to the "id_card_national" field.
func (m *PersonMutation) ResetIDCardNational() {
	m.id_card_national = nil
}

// SetAuthFace sets the "auth_face" field.
func (m *PersonMutation) SetAuthFace(s string) {
	m.auth_face = &s
}

// AuthFace returns the value of the "auth_face" field in the mutation.
func (m *PersonMutation) AuthFace() (r string, exists bool) {
	v := m.auth_face
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthFace returns the old "auth_face" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldAuthFace(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthFace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthFace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthFace: %w", err)
	}
	return oldValue.AuthFace, nil
}

// ResetAuthFace resets all changes to the "auth_face" field.
func (m *PersonMutation) ResetAuthFace() {
	m.auth_face = nil
}

// SetAuthResult sets the "auth_result" field.
func (m *PersonMutation) SetAuthResult(mvr *model.FaceVerifyResult) {
	m.auth_result = &mvr
}

// AuthResult returns the value of the "auth_result" field in the mutation.
func (m *PersonMutation) AuthResult() (r *model.FaceVerifyResult, exists bool) {
	v := m.auth_result
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthResult returns the old "auth_result" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldAuthResult(ctx context.Context) (v *model.FaceVerifyResult, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthResult is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthResult requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthResult: %w", err)
	}
	return oldValue.AuthResult, nil
}

// ClearAuthResult clears the value of the "auth_result" field.
func (m *PersonMutation) ClearAuthResult() {
	m.auth_result = nil
	m.clearedFields[person.FieldAuthResult] = struct{}{}
}

// AuthResultCleared returns if the "auth_result" field was cleared in this mutation.
func (m *PersonMutation) AuthResultCleared() bool {
	_, ok := m.clearedFields[person.FieldAuthResult]
	return ok
}

// ResetAuthResult resets all changes to the "auth_result" field.
func (m *PersonMutation) ResetAuthResult() {
	m.auth_result = nil
	delete(m.clearedFields, person.FieldAuthResult)
}

// SetAuthAt sets the "auth_at" field.
func (m *PersonMutation) SetAuthAt(t time.Time) {
	m.auth_at = &t
}

// AuthAt returns the value of the "auth_at" field in the mutation.
func (m *PersonMutation) AuthAt() (r time.Time, exists bool) {
	v := m.auth_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthAt returns the old "auth_at" field's value of the Person entity.
// If the Person object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PersonMutation) OldAuthAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthAt: %w", err)
	}
	return oldValue.AuthAt, nil
}

// ClearAuthAt clears the value of the "auth_at" field.
func (m *PersonMutation) ClearAuthAt() {
	m.auth_at = nil
	m.clearedFields[person.FieldAuthAt] = struct{}{}
}

// AuthAtCleared returns if the "auth_at" field was cleared in this mutation.
func (m *PersonMutation) AuthAtCleared() bool {
	_, ok := m.clearedFields[person.FieldAuthAt]
	return ok
}

// ResetAuthAt resets all changes to the "auth_at" field.
func (m *PersonMutation) ResetAuthAt() {
	m.auth_at = nil
	delete(m.clearedFields, person.FieldAuthAt)
}

// AddRiderIDs adds the "rider" edge to the Rider entity by ids.
func (m *PersonMutation) AddRiderIDs(ids ...uint64) {
	if m.rider == nil {
		m.rider = make(map[uint64]struct{})
	}
	for i := range ids {
		m.rider[ids[i]] = struct{}{}
	}
}

// ClearRider clears the "rider" edge to the Rider entity.
func (m *PersonMutation) ClearRider() {
	m.clearedrider = true
}

// RiderCleared reports if the "rider" edge to the Rider entity was cleared.
func (m *PersonMutation) RiderCleared() bool {
	return m.clearedrider
}

// RemoveRiderIDs removes the "rider" edge to the Rider entity by IDs.
func (m *PersonMutation) RemoveRiderIDs(ids ...uint64) {
	if m.removedrider == nil {
		m.removedrider = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.rider, ids[i])
		m.removedrider[ids[i]] = struct{}{}
	}
}

// RemovedRider returns the removed IDs of the "rider" edge to the Rider entity.
func (m *PersonMutation) RemovedRiderIDs() (ids []uint64) {
	for id := range m.removedrider {
		ids = append(ids, id)
	}
	return
}

// RiderIDs returns the "rider" edge IDs in the mutation.
func (m *PersonMutation) RiderIDs() (ids []uint64) {
	for id := range m.rider {
		ids = append(ids, id)
	}
	return
}

// ResetRider resets all changes to the "rider" edge.
func (m *PersonMutation) ResetRider() {
	m.rider = nil
	m.clearedrider = false
	m.removedrider = nil
}

// Where appends a list predicates to the PersonMutation builder.
func (m *PersonMutation) Where(ps ...predicate.Person) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PersonMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Person).
func (m *PersonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PersonMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.created_at != nil {
		fields = append(fields, person.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, person.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, person.FieldDeletedAt)
	}
	if m.last_modifier != nil {
		fields = append(fields, person.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, person.FieldRemark)
	}
	if m.status != nil {
		fields = append(fields, person.FieldStatus)
	}
	if m.banned != nil {
		fields = append(fields, person.FieldBanned)
	}
	if m.name != nil {
		fields = append(fields, person.FieldName)
	}
	if m.id_card_number != nil {
		fields = append(fields, person.FieldIDCardNumber)
	}
	if m.id_card_type != nil {
		fields = append(fields, person.FieldIDCardType)
	}
	if m.id_card_portrait != nil {
		fields = append(fields, person.FieldIDCardPortrait)
	}
	if m.id_card_national != nil {
		fields = append(fields, person.FieldIDCardNational)
	}
	if m.auth_face != nil {
		fields = append(fields, person.FieldAuthFace)
	}
	if m.auth_result != nil {
		fields = append(fields, person.FieldAuthResult)
	}
	if m.auth_at != nil {
		fields = append(fields, person.FieldAuthAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PersonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case person.FieldCreatedAt:
		return m.CreatedAt()
	case person.FieldUpdatedAt:
		return m.UpdatedAt()
	case person.FieldDeletedAt:
		return m.DeletedAt()
	case person.FieldLastModifier:
		return m.LastModifier()
	case person.FieldRemark:
		return m.Remark()
	case person.FieldStatus:
		return m.Status()
	case person.FieldBanned:
		return m.Banned()
	case person.FieldName:
		return m.Name()
	case person.FieldIDCardNumber:
		return m.IDCardNumber()
	case person.FieldIDCardType:
		return m.IDCardType()
	case person.FieldIDCardPortrait:
		return m.IDCardPortrait()
	case person.FieldIDCardNational:
		return m.IDCardNational()
	case person.FieldAuthFace:
		return m.AuthFace()
	case person.FieldAuthResult:
		return m.AuthResult()
	case person.FieldAuthAt:
		return m.AuthAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PersonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case person.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case person.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case person.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case person.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case person.FieldRemark:
		return m.OldRemark(ctx)
	case person.FieldStatus:
		return m.OldStatus(ctx)
	case person.FieldBanned:
		return m.OldBanned(ctx)
	case person.FieldName:
		return m.OldName(ctx)
	case person.FieldIDCardNumber:
		return m.OldIDCardNumber(ctx)
	case person.FieldIDCardType:
		return m.OldIDCardType(ctx)
	case person.FieldIDCardPortrait:
		return m.OldIDCardPortrait(ctx)
	case person.FieldIDCardNational:
		return m.OldIDCardNational(ctx)
	case person.FieldAuthFace:
		return m.OldAuthFace(ctx)
	case person.FieldAuthResult:
		return m.OldAuthResult(ctx)
	case person.FieldAuthAt:
		return m.OldAuthAt(ctx)
	}
	return nil, fmt.Errorf("unknown Person field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case person.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case person.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case person.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case person.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case person.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case person.FieldStatus:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case person.FieldBanned:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBanned(v)
		return nil
	case person.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case person.FieldIDCardNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCardNumber(v)
		return nil
	case person.FieldIDCardType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCardType(v)
		return nil
	case person.FieldIDCardPortrait:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCardPortrait(v)
		return nil
	case person.FieldIDCardNational:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIDCardNational(v)
		return nil
	case person.FieldAuthFace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthFace(v)
		return nil
	case person.FieldAuthResult:
		v, ok := value.(*model.FaceVerifyResult)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthResult(v)
		return nil
	case person.FieldAuthAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthAt(v)
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PersonMutation) AddedFields() []string {
	var fields []string
	if m.addstatus != nil {
		fields = append(fields, person.FieldStatus)
	}
	if m.addid_card_type != nil {
		fields = append(fields, person.FieldIDCardType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PersonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case person.FieldStatus:
		return m.AddedStatus()
	case person.FieldIDCardType:
		return m.AddedIDCardType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PersonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case person.FieldStatus:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case person.FieldIDCardType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIDCardType(v)
		return nil
	}
	return fmt.Errorf("unknown Person numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PersonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(person.FieldDeletedAt) {
		fields = append(fields, person.FieldDeletedAt)
	}
	if m.FieldCleared(person.FieldLastModifier) {
		fields = append(fields, person.FieldLastModifier)
	}
	if m.FieldCleared(person.FieldRemark) {
		fields = append(fields, person.FieldRemark)
	}
	if m.FieldCleared(person.FieldAuthResult) {
		fields = append(fields, person.FieldAuthResult)
	}
	if m.FieldCleared(person.FieldAuthAt) {
		fields = append(fields, person.FieldAuthAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PersonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PersonMutation) ClearField(name string) error {
	switch name {
	case person.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case person.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case person.FieldRemark:
		m.ClearRemark()
		return nil
	case person.FieldAuthResult:
		m.ClearAuthResult()
		return nil
	case person.FieldAuthAt:
		m.ClearAuthAt()
		return nil
	}
	return fmt.Errorf("unknown Person nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PersonMutation) ResetField(name string) error {
	switch name {
	case person.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case person.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case person.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case person.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case person.FieldRemark:
		m.ResetRemark()
		return nil
	case person.FieldStatus:
		m.ResetStatus()
		return nil
	case person.FieldBanned:
		m.ResetBanned()
		return nil
	case person.FieldName:
		m.ResetName()
		return nil
	case person.FieldIDCardNumber:
		m.ResetIDCardNumber()
		return nil
	case person.FieldIDCardType:
		m.ResetIDCardType()
		return nil
	case person.FieldIDCardPortrait:
		m.ResetIDCardPortrait()
		return nil
	case person.FieldIDCardNational:
		m.ResetIDCardNational()
		return nil
	case person.FieldAuthFace:
		m.ResetAuthFace()
		return nil
	case person.FieldAuthResult:
		m.ResetAuthResult()
		return nil
	case person.FieldAuthAt:
		m.ResetAuthAt()
		return nil
	}
	return fmt.Errorf("unknown Person field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PersonMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.rider != nil {
		edges = append(edges, person.EdgeRider)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PersonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeRider:
		ids := make([]ent.Value, 0, len(m.rider))
		for id := range m.rider {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PersonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrider != nil {
		edges = append(edges, person.EdgeRider)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PersonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case person.EdgeRider:
		ids := make([]ent.Value, 0, len(m.removedrider))
		for id := range m.removedrider {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PersonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrider {
		edges = append(edges, person.EdgeRider)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PersonMutation) EdgeCleared(name string) bool {
	switch name {
	case person.EdgeRider:
		return m.clearedrider
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PersonMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Person unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PersonMutation) ResetEdge(name string) error {
	switch name {
	case person.EdgeRider:
		m.ResetRider()
		return nil
	}
	return fmt.Errorf("unknown Person edge %s", name)
}

// PlanMutation represents an operation that mutates the Plan nodes in the graph.
type PlanMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	deleted_at    *time.Time
	creator       **model.Modifier
	last_modifier **model.Modifier
	remark        *string
	enable        *bool
	name          *string
	start         *time.Time
	end           *time.Time
	price         *float64
	addprice      *float64
	days          *uint
	adddays       *int
	commission    *float64
	addcommission *float64
	clearedFields map[string]struct{}
	pms           map[uint64]struct{}
	removedpms    map[uint64]struct{}
	clearedpms    bool
	cities        map[uint64]struct{}
	removedcities map[uint64]struct{}
	clearedcities bool
	done          bool
	oldValue      func(context.Context) (*Plan, error)
	predicates    []predicate.Plan
}

var _ ent.Mutation = (*PlanMutation)(nil)

// planOption allows management of the mutation configuration using functional options.
type planOption func(*PlanMutation)

// newPlanMutation creates new mutation for the Plan entity.
func newPlanMutation(c config, op Op, opts ...planOption) *PlanMutation {
	m := &PlanMutation{
		config:        c,
		op:            op,
		typ:           TypePlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanID sets the ID field of the mutation.
func withPlanID(id uint64) planOption {
	return func(m *PlanMutation) {
		var (
			err   error
			once  sync.Once
			value *Plan
		)
		m.oldValue = func(ctx context.Context) (*Plan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Plan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlan sets the old Plan of the mutation.
func withPlan(node *Plan) planOption {
	return func(m *PlanMutation) {
		m.oldValue = func(context.Context) (*Plan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Plan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PlanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlanMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlanMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlanMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlanMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *PlanMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *PlanMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *PlanMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[plan.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *PlanMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[plan.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *PlanMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, plan.FieldDeletedAt)
}

// SetCreator sets the "creator" field.
func (m *PlanMutation) SetCreator(value *model.Modifier) {
	m.creator = &value
}

// Creator returns the value of the "creator" field in the mutation.
func (m *PlanMutation) Creator() (r *model.Modifier, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreator returns the old "creator" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldCreator(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreator: %w", err)
	}
	return oldValue.Creator, nil
}

// ClearCreator clears the value of the "creator" field.
func (m *PlanMutation) ClearCreator() {
	m.creator = nil
	m.clearedFields[plan.FieldCreator] = struct{}{}
}

// CreatorCleared returns if the "creator" field was cleared in this mutation.
func (m *PlanMutation) CreatorCleared() bool {
	_, ok := m.clearedFields[plan.FieldCreator]
	return ok
}

// ResetCreator resets all changes to the "creator" field.
func (m *PlanMutation) ResetCreator() {
	m.creator = nil
	delete(m.clearedFields, plan.FieldCreator)
}

// SetLastModifier sets the "last_modifier" field.
func (m *PlanMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *PlanMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *PlanMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[plan.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *PlanMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[plan.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *PlanMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, plan.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *PlanMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *PlanMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *PlanMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[plan.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *PlanMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[plan.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *PlanMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, plan.FieldRemark)
}

// SetEnable sets the "enable" field.
func (m *PlanMutation) SetEnable(b bool) {
	m.enable = &b
}

// Enable returns the value of the "enable" field in the mutation.
func (m *PlanMutation) Enable() (r bool, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// ResetEnable resets all changes to the "enable" field.
func (m *PlanMutation) ResetEnable() {
	m.enable = nil
}

// SetName sets the "name" field.
func (m *PlanMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlanMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlanMutation) ResetName() {
	m.name = nil
}

// SetStart sets the "start" field.
func (m *PlanMutation) SetStart(t time.Time) {
	m.start = &t
}

// Start returns the value of the "start" field in the mutation.
func (m *PlanMutation) Start() (r time.Time, exists bool) {
	v := m.start
	if v == nil {
		return
	}
	return *v, true
}

// OldStart returns the old "start" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStart: %w", err)
	}
	return oldValue.Start, nil
}

// ResetStart resets all changes to the "start" field.
func (m *PlanMutation) ResetStart() {
	m.start = nil
}

// SetEnd sets the "end" field.
func (m *PlanMutation) SetEnd(t time.Time) {
	m.end = &t
}

// End returns the value of the "end" field in the mutation.
func (m *PlanMutation) End() (r time.Time, exists bool) {
	v := m.end
	if v == nil {
		return
	}
	return *v, true
}

// OldEnd returns the old "end" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnd: %w", err)
	}
	return oldValue.End, nil
}

// ResetEnd resets all changes to the "end" field.
func (m *PlanMutation) ResetEnd() {
	m.end = nil
}

// SetPrice sets the "price" field.
func (m *PlanMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *PlanMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *PlanMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *PlanMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *PlanMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetDays sets the "days" field.
func (m *PlanMutation) SetDays(u uint) {
	m.days = &u
	m.adddays = nil
}

// Days returns the value of the "days" field in the mutation.
func (m *PlanMutation) Days() (r uint, exists bool) {
	v := m.days
	if v == nil {
		return
	}
	return *v, true
}

// OldDays returns the old "days" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldDays(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDays: %w", err)
	}
	return oldValue.Days, nil
}

// AddDays adds u to the "days" field.
func (m *PlanMutation) AddDays(u int) {
	if m.adddays != nil {
		*m.adddays += u
	} else {
		m.adddays = &u
	}
}

// AddedDays returns the value that was added to the "days" field in this mutation.
func (m *PlanMutation) AddedDays() (r int, exists bool) {
	v := m.adddays
	if v == nil {
		return
	}
	return *v, true
}

// ResetDays resets all changes to the "days" field.
func (m *PlanMutation) ResetDays() {
	m.days = nil
	m.adddays = nil
}

// SetCommission sets the "commission" field.
func (m *PlanMutation) SetCommission(f float64) {
	m.commission = &f
	m.addcommission = nil
}

// Commission returns the value of the "commission" field in the mutation.
func (m *PlanMutation) Commission() (r float64, exists bool) {
	v := m.commission
	if v == nil {
		return
	}
	return *v, true
}

// OldCommission returns the old "commission" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldCommission(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommission is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommission requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommission: %w", err)
	}
	return oldValue.Commission, nil
}

// AddCommission adds f to the "commission" field.
func (m *PlanMutation) AddCommission(f float64) {
	if m.addcommission != nil {
		*m.addcommission += f
	} else {
		m.addcommission = &f
	}
}

// AddedCommission returns the value that was added to the "commission" field in this mutation.
func (m *PlanMutation) AddedCommission() (r float64, exists bool) {
	v := m.addcommission
	if v == nil {
		return
	}
	return *v, true
}

// ResetCommission resets all changes to the "commission" field.
func (m *PlanMutation) ResetCommission() {
	m.commission = nil
	m.addcommission = nil
}

// AddPmIDs adds the "pms" edge to the BatteryModel entity by ids.
func (m *PlanMutation) AddPmIDs(ids ...uint64) {
	if m.pms == nil {
		m.pms = make(map[uint64]struct{})
	}
	for i := range ids {
		m.pms[ids[i]] = struct{}{}
	}
}

// ClearPms clears the "pms" edge to the BatteryModel entity.
func (m *PlanMutation) ClearPms() {
	m.clearedpms = true
}

// PmsCleared reports if the "pms" edge to the BatteryModel entity was cleared.
func (m *PlanMutation) PmsCleared() bool {
	return m.clearedpms
}

// RemovePmIDs removes the "pms" edge to the BatteryModel entity by IDs.
func (m *PlanMutation) RemovePmIDs(ids ...uint64) {
	if m.removedpms == nil {
		m.removedpms = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.pms, ids[i])
		m.removedpms[ids[i]] = struct{}{}
	}
}

// RemovedPms returns the removed IDs of the "pms" edge to the BatteryModel entity.
func (m *PlanMutation) RemovedPmsIDs() (ids []uint64) {
	for id := range m.removedpms {
		ids = append(ids, id)
	}
	return
}

// PmsIDs returns the "pms" edge IDs in the mutation.
func (m *PlanMutation) PmsIDs() (ids []uint64) {
	for id := range m.pms {
		ids = append(ids, id)
	}
	return
}

// ResetPms resets all changes to the "pms" edge.
func (m *PlanMutation) ResetPms() {
	m.pms = nil
	m.clearedpms = false
	m.removedpms = nil
}

// AddCityIDs adds the "cities" edge to the City entity by ids.
func (m *PlanMutation) AddCityIDs(ids ...uint64) {
	if m.cities == nil {
		m.cities = make(map[uint64]struct{})
	}
	for i := range ids {
		m.cities[ids[i]] = struct{}{}
	}
}

// ClearCities clears the "cities" edge to the City entity.
func (m *PlanMutation) ClearCities() {
	m.clearedcities = true
}

// CitiesCleared reports if the "cities" edge to the City entity was cleared.
func (m *PlanMutation) CitiesCleared() bool {
	return m.clearedcities
}

// RemoveCityIDs removes the "cities" edge to the City entity by IDs.
func (m *PlanMutation) RemoveCityIDs(ids ...uint64) {
	if m.removedcities == nil {
		m.removedcities = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.cities, ids[i])
		m.removedcities[ids[i]] = struct{}{}
	}
}

// RemovedCities returns the removed IDs of the "cities" edge to the City entity.
func (m *PlanMutation) RemovedCitiesIDs() (ids []uint64) {
	for id := range m.removedcities {
		ids = append(ids, id)
	}
	return
}

// CitiesIDs returns the "cities" edge IDs in the mutation.
func (m *PlanMutation) CitiesIDs() (ids []uint64) {
	for id := range m.cities {
		ids = append(ids, id)
	}
	return
}

// ResetCities resets all changes to the "cities" edge.
func (m *PlanMutation) ResetCities() {
	m.cities = nil
	m.clearedcities = false
	m.removedcities = nil
}

// Where appends a list predicates to the PlanMutation builder.
func (m *PlanMutation) Where(ps ...predicate.Plan) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PlanMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Plan).
func (m *PlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, plan.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, plan.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, plan.FieldDeletedAt)
	}
	if m.creator != nil {
		fields = append(fields, plan.FieldCreator)
	}
	if m.last_modifier != nil {
		fields = append(fields, plan.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, plan.FieldRemark)
	}
	if m.enable != nil {
		fields = append(fields, plan.FieldEnable)
	}
	if m.name != nil {
		fields = append(fields, plan.FieldName)
	}
	if m.start != nil {
		fields = append(fields, plan.FieldStart)
	}
	if m.end != nil {
		fields = append(fields, plan.FieldEnd)
	}
	if m.price != nil {
		fields = append(fields, plan.FieldPrice)
	}
	if m.days != nil {
		fields = append(fields, plan.FieldDays)
	}
	if m.commission != nil {
		fields = append(fields, plan.FieldCommission)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plan.FieldCreatedAt:
		return m.CreatedAt()
	case plan.FieldUpdatedAt:
		return m.UpdatedAt()
	case plan.FieldDeletedAt:
		return m.DeletedAt()
	case plan.FieldCreator:
		return m.Creator()
	case plan.FieldLastModifier:
		return m.LastModifier()
	case plan.FieldRemark:
		return m.Remark()
	case plan.FieldEnable:
		return m.Enable()
	case plan.FieldName:
		return m.Name()
	case plan.FieldStart:
		return m.Start()
	case plan.FieldEnd:
		return m.End()
	case plan.FieldPrice:
		return m.Price()
	case plan.FieldDays:
		return m.Days()
	case plan.FieldCommission:
		return m.Commission()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case plan.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case plan.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case plan.FieldCreator:
		return m.OldCreator(ctx)
	case plan.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case plan.FieldRemark:
		return m.OldRemark(ctx)
	case plan.FieldEnable:
		return m.OldEnable(ctx)
	case plan.FieldName:
		return m.OldName(ctx)
	case plan.FieldStart:
		return m.OldStart(ctx)
	case plan.FieldEnd:
		return m.OldEnd(ctx)
	case plan.FieldPrice:
		return m.OldPrice(ctx)
	case plan.FieldDays:
		return m.OldDays(ctx)
	case plan.FieldCommission:
		return m.OldCommission(ctx)
	}
	return nil, fmt.Errorf("unknown Plan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plan.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case plan.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case plan.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case plan.FieldCreator:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreator(v)
		return nil
	case plan.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case plan.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case plan.FieldEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case plan.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case plan.FieldStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStart(v)
		return nil
	case plan.FieldEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnd(v)
		return nil
	case plan.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case plan.FieldDays:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDays(v)
		return nil
	case plan.FieldCommission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommission(v)
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, plan.FieldPrice)
	}
	if m.adddays != nil {
		fields = append(fields, plan.FieldDays)
	}
	if m.addcommission != nil {
		fields = append(fields, plan.FieldCommission)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case plan.FieldPrice:
		return m.AddedPrice()
	case plan.FieldDays:
		return m.AddedDays()
	case plan.FieldCommission:
		return m.AddedCommission()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case plan.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case plan.FieldDays:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDays(v)
		return nil
	case plan.FieldCommission:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCommission(v)
		return nil
	}
	return fmt.Errorf("unknown Plan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(plan.FieldDeletedAt) {
		fields = append(fields, plan.FieldDeletedAt)
	}
	if m.FieldCleared(plan.FieldCreator) {
		fields = append(fields, plan.FieldCreator)
	}
	if m.FieldCleared(plan.FieldLastModifier) {
		fields = append(fields, plan.FieldLastModifier)
	}
	if m.FieldCleared(plan.FieldRemark) {
		fields = append(fields, plan.FieldRemark)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanMutation) ClearField(name string) error {
	switch name {
	case plan.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case plan.FieldCreator:
		m.ClearCreator()
		return nil
	case plan.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case plan.FieldRemark:
		m.ClearRemark()
		return nil
	}
	return fmt.Errorf("unknown Plan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanMutation) ResetField(name string) error {
	switch name {
	case plan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case plan.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case plan.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case plan.FieldCreator:
		m.ResetCreator()
		return nil
	case plan.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case plan.FieldRemark:
		m.ResetRemark()
		return nil
	case plan.FieldEnable:
		m.ResetEnable()
		return nil
	case plan.FieldName:
		m.ResetName()
		return nil
	case plan.FieldStart:
		m.ResetStart()
		return nil
	case plan.FieldEnd:
		m.ResetEnd()
		return nil
	case plan.FieldPrice:
		m.ResetPrice()
		return nil
	case plan.FieldDays:
		m.ResetDays()
		return nil
	case plan.FieldCommission:
		m.ResetCommission()
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.pms != nil {
		edges = append(edges, plan.EdgePms)
	}
	if m.cities != nil {
		edges = append(edges, plan.EdgeCities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case plan.EdgePms:
		ids := make([]ent.Value, 0, len(m.pms))
		for id := range m.pms {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeCities:
		ids := make([]ent.Value, 0, len(m.cities))
		for id := range m.cities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedpms != nil {
		edges = append(edges, plan.EdgePms)
	}
	if m.removedcities != nil {
		edges = append(edges, plan.EdgeCities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case plan.EdgePms:
		ids := make([]ent.Value, 0, len(m.removedpms))
		for id := range m.removedpms {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgeCities:
		ids := make([]ent.Value, 0, len(m.removedcities))
		for id := range m.removedcities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpms {
		edges = append(edges, plan.EdgePms)
	}
	if m.clearedcities {
		edges = append(edges, plan.EdgeCities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanMutation) EdgeCleared(name string) bool {
	switch name {
	case plan.EdgePms:
		return m.clearedpms
	case plan.EdgeCities:
		return m.clearedcities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Plan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanMutation) ResetEdge(name string) error {
	switch name {
	case plan.EdgePms:
		m.ResetPms()
		return nil
	case plan.EdgeCities:
		m.ResetCities()
		return nil
	}
	return fmt.Errorf("unknown Plan edge %s", name)
}

// RiderMutation represents an operation that mutates the Rider nodes in the graph.
type RiderMutation struct {
	config
	op                Op
	typ               string
	id                *uint64
	created_at        *time.Time
	updated_at        *time.Time
	deleted_at        *time.Time
	last_modifier     **model.Modifier
	remark            *string
	phone             *string
	contact           **model.RiderContact
	device_type       *uint8
	adddevice_type    *int8
	last_device       *string
	is_new_device     *bool
	last_face         *string
	push_id           *string
	last_signin_at    *time.Time
	esign_account_id  *string
	plan_at           *time.Time
	blocked           *bool
	clearedFields     map[string]struct{}
	person            *uint64
	clearedperson     bool
	enterprise        *uint64
	clearedenterprise bool
	contract          map[uint64]struct{}
	removedcontract   map[uint64]struct{}
	clearedcontract   bool
	faults            map[uint64]struct{}
	removedfaults     map[uint64]struct{}
	clearedfaults     bool
	done              bool
	oldValue          func(context.Context) (*Rider, error)
	predicates        []predicate.Rider
}

var _ ent.Mutation = (*RiderMutation)(nil)

// riderOption allows management of the mutation configuration using functional options.
type riderOption func(*RiderMutation)

// newRiderMutation creates new mutation for the Rider entity.
func newRiderMutation(c config, op Op, opts ...riderOption) *RiderMutation {
	m := &RiderMutation{
		config:        c,
		op:            op,
		typ:           TypeRider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRiderID sets the ID field of the mutation.
func withRiderID(id uint64) riderOption {
	return func(m *RiderMutation) {
		var (
			err   error
			once  sync.Once
			value *Rider
		)
		m.oldValue = func(ctx context.Context) (*Rider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Rider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRider sets the old Rider of the mutation.
func withRider(node *Rider) riderOption {
	return func(m *RiderMutation) {
		m.oldValue = func(context.Context) (*Rider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RiderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RiderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Rider entities.
func (m *RiderMutation) SetID(id uint64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RiderMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RiderMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Rider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RiderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RiderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RiderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RiderMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RiderMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RiderMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *RiderMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *RiderMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *RiderMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[rider.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *RiderMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[rider.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *RiderMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, rider.FieldDeletedAt)
}

// SetLastModifier sets the "last_modifier" field.
func (m *RiderMutation) SetLastModifier(value *model.Modifier) {
	m.last_modifier = &value
}

// LastModifier returns the value of the "last_modifier" field in the mutation.
func (m *RiderMutation) LastModifier() (r *model.Modifier, exists bool) {
	v := m.last_modifier
	if v == nil {
		return
	}
	return *v, true
}

// OldLastModifier returns the old "last_modifier" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldLastModifier(ctx context.Context) (v *model.Modifier, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastModifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastModifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastModifier: %w", err)
	}
	return oldValue.LastModifier, nil
}

// ClearLastModifier clears the value of the "last_modifier" field.
func (m *RiderMutation) ClearLastModifier() {
	m.last_modifier = nil
	m.clearedFields[rider.FieldLastModifier] = struct{}{}
}

// LastModifierCleared returns if the "last_modifier" field was cleared in this mutation.
func (m *RiderMutation) LastModifierCleared() bool {
	_, ok := m.clearedFields[rider.FieldLastModifier]
	return ok
}

// ResetLastModifier resets all changes to the "last_modifier" field.
func (m *RiderMutation) ResetLastModifier() {
	m.last_modifier = nil
	delete(m.clearedFields, rider.FieldLastModifier)
}

// SetRemark sets the "remark" field.
func (m *RiderMutation) SetRemark(s string) {
	m.remark = &s
}

// Remark returns the value of the "remark" field in the mutation.
func (m *RiderMutation) Remark() (r string, exists bool) {
	v := m.remark
	if v == nil {
		return
	}
	return *v, true
}

// OldRemark returns the old "remark" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemark: %w", err)
	}
	return oldValue.Remark, nil
}

// ClearRemark clears the value of the "remark" field.
func (m *RiderMutation) ClearRemark() {
	m.remark = nil
	m.clearedFields[rider.FieldRemark] = struct{}{}
}

// RemarkCleared returns if the "remark" field was cleared in this mutation.
func (m *RiderMutation) RemarkCleared() bool {
	_, ok := m.clearedFields[rider.FieldRemark]
	return ok
}

// ResetRemark resets all changes to the "remark" field.
func (m *RiderMutation) ResetRemark() {
	m.remark = nil
	delete(m.clearedFields, rider.FieldRemark)
}

// SetPersonID sets the "person_id" field.
func (m *RiderMutation) SetPersonID(u uint64) {
	m.person = &u
}

// PersonID returns the value of the "person_id" field in the mutation.
func (m *RiderMutation) PersonID() (r uint64, exists bool) {
	v := m.person
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonID returns the old "person_id" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldPersonID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersonID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersonID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonID: %w", err)
	}
	return oldValue.PersonID, nil
}

// ClearPersonID clears the value of the "person_id" field.
func (m *RiderMutation) ClearPersonID() {
	m.person = nil
	m.clearedFields[rider.FieldPersonID] = struct{}{}
}

// PersonIDCleared returns if the "person_id" field was cleared in this mutation.
func (m *RiderMutation) PersonIDCleared() bool {
	_, ok := m.clearedFields[rider.FieldPersonID]
	return ok
}

// ResetPersonID resets all changes to the "person_id" field.
func (m *RiderMutation) ResetPersonID() {
	m.person = nil
	delete(m.clearedFields, rider.FieldPersonID)
}

// SetEnterpriseID sets the "enterprise_id" field.
func (m *RiderMutation) SetEnterpriseID(u uint64) {
	m.enterprise = &u
}

// EnterpriseID returns the value of the "enterprise_id" field in the mutation.
func (m *RiderMutation) EnterpriseID() (r uint64, exists bool) {
	v := m.enterprise
	if v == nil {
		return
	}
	return *v, true
}

// OldEnterpriseID returns the old "enterprise_id" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldEnterpriseID(ctx context.Context) (v *uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnterpriseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnterpriseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnterpriseID: %w", err)
	}
	return oldValue.EnterpriseID, nil
}

// ClearEnterpriseID clears the value of the "enterprise_id" field.
func (m *RiderMutation) ClearEnterpriseID() {
	m.enterprise = nil
	m.clearedFields[rider.FieldEnterpriseID] = struct{}{}
}

// EnterpriseIDCleared returns if the "enterprise_id" field was cleared in this mutation.
func (m *RiderMutation) EnterpriseIDCleared() bool {
	_, ok := m.clearedFields[rider.FieldEnterpriseID]
	return ok
}

// ResetEnterpriseID resets all changes to the "enterprise_id" field.
func (m *RiderMutation) ResetEnterpriseID() {
	m.enterprise = nil
	delete(m.clearedFields, rider.FieldEnterpriseID)
}

// SetPhone sets the "phone" field.
func (m *RiderMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *RiderMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ResetPhone resets all changes to the "phone" field.
func (m *RiderMutation) ResetPhone() {
	m.phone = nil
}

// SetContact sets the "contact" field.
func (m *RiderMutation) SetContact(mc *model.RiderContact) {
	m.contact = &mc
}

// Contact returns the value of the "contact" field in the mutation.
func (m *RiderMutation) Contact() (r *model.RiderContact, exists bool) {
	v := m.contact
	if v == nil {
		return
	}
	return *v, true
}

// OldContact returns the old "contact" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldContact(ctx context.Context) (v *model.RiderContact, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContact: %w", err)
	}
	return oldValue.Contact, nil
}

// ClearContact clears the value of the "contact" field.
func (m *RiderMutation) ClearContact() {
	m.contact = nil
	m.clearedFields[rider.FieldContact] = struct{}{}
}

// ContactCleared returns if the "contact" field was cleared in this mutation.
func (m *RiderMutation) ContactCleared() bool {
	_, ok := m.clearedFields[rider.FieldContact]
	return ok
}

// ResetContact resets all changes to the "contact" field.
func (m *RiderMutation) ResetContact() {
	m.contact = nil
	delete(m.clearedFields, rider.FieldContact)
}

// SetDeviceType sets the "device_type" field.
func (m *RiderMutation) SetDeviceType(u uint8) {
	m.device_type = &u
	m.adddevice_type = nil
}

// DeviceType returns the value of the "device_type" field in the mutation.
func (m *RiderMutation) DeviceType() (r uint8, exists bool) {
	v := m.device_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceType returns the old "device_type" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldDeviceType(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceType: %w", err)
	}
	return oldValue.DeviceType, nil
}

// AddDeviceType adds u to the "device_type" field.
func (m *RiderMutation) AddDeviceType(u int8) {
	if m.adddevice_type != nil {
		*m.adddevice_type += u
	} else {
		m.adddevice_type = &u
	}
}

// AddedDeviceType returns the value that was added to the "device_type" field in this mutation.
func (m *RiderMutation) AddedDeviceType() (r int8, exists bool) {
	v := m.adddevice_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetDeviceType resets all changes to the "device_type" field.
func (m *RiderMutation) ResetDeviceType() {
	m.device_type = nil
	m.adddevice_type = nil
}

// SetLastDevice sets the "last_device" field.
func (m *RiderMutation) SetLastDevice(s string) {
	m.last_device = &s
}

// LastDevice returns the value of the "last_device" field in the mutation.
func (m *RiderMutation) LastDevice() (r string, exists bool) {
	v := m.last_device
	if v == nil {
		return
	}
	return *v, true
}

// OldLastDevice returns the old "last_device" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldLastDevice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastDevice: %w", err)
	}
	return oldValue.LastDevice, nil
}

// ResetLastDevice resets all changes to the "last_device" field.
func (m *RiderMutation) ResetLastDevice() {
	m.last_device = nil
}

// SetIsNewDevice sets the "is_new_device" field.
func (m *RiderMutation) SetIsNewDevice(b bool) {
	m.is_new_device = &b
}

// IsNewDevice returns the value of the "is_new_device" field in the mutation.
func (m *RiderMutation) IsNewDevice() (r bool, exists bool) {
	v := m.is_new_device
	if v == nil {
		return
	}
	return *v, true
}

// OldIsNewDevice returns the old "is_new_device" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldIsNewDevice(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsNewDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsNewDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsNewDevice: %w", err)
	}
	return oldValue.IsNewDevice, nil
}

// ResetIsNewDevice resets all changes to the "is_new_device" field.
func (m *RiderMutation) ResetIsNewDevice() {
	m.is_new_device = nil
}

// SetLastFace sets the "last_face" field.
func (m *RiderMutation) SetLastFace(s string) {
	m.last_face = &s
}

// LastFace returns the value of the "last_face" field in the mutation.
func (m *RiderMutation) LastFace() (r string, exists bool) {
	v := m.last_face
	if v == nil {
		return
	}
	return *v, true
}

// OldLastFace returns the old "last_face" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldLastFace(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastFace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastFace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastFace: %w", err)
	}
	return oldValue.LastFace, nil
}

// ClearLastFace clears the value of the "last_face" field.
func (m *RiderMutation) ClearLastFace() {
	m.last_face = nil
	m.clearedFields[rider.FieldLastFace] = struct{}{}
}

// LastFaceCleared returns if the "last_face" field was cleared in this mutation.
func (m *RiderMutation) LastFaceCleared() bool {
	_, ok := m.clearedFields[rider.FieldLastFace]
	return ok
}

// ResetLastFace resets all changes to the "last_face" field.
func (m *RiderMutation) ResetLastFace() {
	m.last_face = nil
	delete(m.clearedFields, rider.FieldLastFace)
}

// SetPushID sets the "push_id" field.
func (m *RiderMutation) SetPushID(s string) {
	m.push_id = &s
}

// PushID returns the value of the "push_id" field in the mutation.
func (m *RiderMutation) PushID() (r string, exists bool) {
	v := m.push_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPushID returns the old "push_id" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldPushID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPushID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPushID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPushID: %w", err)
	}
	return oldValue.PushID, nil
}

// ClearPushID clears the value of the "push_id" field.
func (m *RiderMutation) ClearPushID() {
	m.push_id = nil
	m.clearedFields[rider.FieldPushID] = struct{}{}
}

// PushIDCleared returns if the "push_id" field was cleared in this mutation.
func (m *RiderMutation) PushIDCleared() bool {
	_, ok := m.clearedFields[rider.FieldPushID]
	return ok
}

// ResetPushID resets all changes to the "push_id" field.
func (m *RiderMutation) ResetPushID() {
	m.push_id = nil
	delete(m.clearedFields, rider.FieldPushID)
}

// SetLastSigninAt sets the "last_signin_at" field.
func (m *RiderMutation) SetLastSigninAt(t time.Time) {
	m.last_signin_at = &t
}

// LastSigninAt returns the value of the "last_signin_at" field in the mutation.
func (m *RiderMutation) LastSigninAt() (r time.Time, exists bool) {
	v := m.last_signin_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSigninAt returns the old "last_signin_at" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldLastSigninAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSigninAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSigninAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSigninAt: %w", err)
	}
	return oldValue.LastSigninAt, nil
}

// ClearLastSigninAt clears the value of the "last_signin_at" field.
func (m *RiderMutation) ClearLastSigninAt() {
	m.last_signin_at = nil
	m.clearedFields[rider.FieldLastSigninAt] = struct{}{}
}

// LastSigninAtCleared returns if the "last_signin_at" field was cleared in this mutation.
func (m *RiderMutation) LastSigninAtCleared() bool {
	_, ok := m.clearedFields[rider.FieldLastSigninAt]
	return ok
}

// ResetLastSigninAt resets all changes to the "last_signin_at" field.
func (m *RiderMutation) ResetLastSigninAt() {
	m.last_signin_at = nil
	delete(m.clearedFields, rider.FieldLastSigninAt)
}

// SetEsignAccountID sets the "esign_account_id" field.
func (m *RiderMutation) SetEsignAccountID(s string) {
	m.esign_account_id = &s
}

// EsignAccountID returns the value of the "esign_account_id" field in the mutation.
func (m *RiderMutation) EsignAccountID() (r string, exists bool) {
	v := m.esign_account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEsignAccountID returns the old "esign_account_id" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldEsignAccountID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEsignAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEsignAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEsignAccountID: %w", err)
	}
	return oldValue.EsignAccountID, nil
}

// ClearEsignAccountID clears the value of the "esign_account_id" field.
func (m *RiderMutation) ClearEsignAccountID() {
	m.esign_account_id = nil
	m.clearedFields[rider.FieldEsignAccountID] = struct{}{}
}

// EsignAccountIDCleared returns if the "esign_account_id" field was cleared in this mutation.
func (m *RiderMutation) EsignAccountIDCleared() bool {
	_, ok := m.clearedFields[rider.FieldEsignAccountID]
	return ok
}

// ResetEsignAccountID resets all changes to the "esign_account_id" field.
func (m *RiderMutation) ResetEsignAccountID() {
	m.esign_account_id = nil
	delete(m.clearedFields, rider.FieldEsignAccountID)
}

// SetPlanAt sets the "plan_at" field.
func (m *RiderMutation) SetPlanAt(t time.Time) {
	m.plan_at = &t
}

// PlanAt returns the value of the "plan_at" field in the mutation.
func (m *RiderMutation) PlanAt() (r time.Time, exists bool) {
	v := m.plan_at
	if v == nil {
		return
	}
	return *v, true
}

// OldPlanAt returns the old "plan_at" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldPlanAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlanAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlanAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlanAt: %w", err)
	}
	return oldValue.PlanAt, nil
}

// ClearPlanAt clears the value of the "plan_at" field.
func (m *RiderMutation) ClearPlanAt() {
	m.plan_at = nil
	m.clearedFields[rider.FieldPlanAt] = struct{}{}
}

// PlanAtCleared returns if the "plan_at" field was cleared in this mutation.
func (m *RiderMutation) PlanAtCleared() bool {
	_, ok := m.clearedFields[rider.FieldPlanAt]
	return ok
}

// ResetPlanAt resets all changes to the "plan_at" field.
func (m *RiderMutation) ResetPlanAt() {
	m.plan_at = nil
	delete(m.clearedFields, rider.FieldPlanAt)
}

// SetBlocked sets the "blocked" field.
func (m *RiderMutation) SetBlocked(b bool) {
	m.blocked = &b
}

// Blocked returns the value of the "blocked" field in the mutation.
func (m *RiderMutation) Blocked() (r bool, exists bool) {
	v := m.blocked
	if v == nil {
		return
	}
	return *v, true
}

// OldBlocked returns the old "blocked" field's value of the Rider entity.
// If the Rider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RiderMutation) OldBlocked(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlocked is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlocked requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlocked: %w", err)
	}
	return oldValue.Blocked, nil
}

// ResetBlocked resets all changes to the "blocked" field.
func (m *RiderMutation) ResetBlocked() {
	m.blocked = nil
}

// ClearPerson clears the "person" edge to the Person entity.
func (m *RiderMutation) ClearPerson() {
	m.clearedperson = true
}

// PersonCleared reports if the "person" edge to the Person entity was cleared.
func (m *RiderMutation) PersonCleared() bool {
	return m.PersonIDCleared() || m.clearedperson
}

// PersonIDs returns the "person" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PersonID instead. It exists only for internal usage by the builders.
func (m *RiderMutation) PersonIDs() (ids []uint64) {
	if id := m.person; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPerson resets all changes to the "person" edge.
func (m *RiderMutation) ResetPerson() {
	m.person = nil
	m.clearedperson = false
}

// ClearEnterprise clears the "enterprise" edge to the Enterprise entity.
func (m *RiderMutation) ClearEnterprise() {
	m.clearedenterprise = true
}

// EnterpriseCleared reports if the "enterprise" edge to the Enterprise entity was cleared.
func (m *RiderMutation) EnterpriseCleared() bool {
	return m.EnterpriseIDCleared() || m.clearedenterprise
}

// EnterpriseIDs returns the "enterprise" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EnterpriseID instead. It exists only for internal usage by the builders.
func (m *RiderMutation) EnterpriseIDs() (ids []uint64) {
	if id := m.enterprise; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEnterprise resets all changes to the "enterprise" edge.
func (m *RiderMutation) ResetEnterprise() {
	m.enterprise = nil
	m.clearedenterprise = false
}

// AddContractIDs adds the "contract" edge to the Contract entity by ids.
func (m *RiderMutation) AddContractIDs(ids ...uint64) {
	if m.contract == nil {
		m.contract = make(map[uint64]struct{})
	}
	for i := range ids {
		m.contract[ids[i]] = struct{}{}
	}
}

// ClearContract clears the "contract" edge to the Contract entity.
func (m *RiderMutation) ClearContract() {
	m.clearedcontract = true
}

// ContractCleared reports if the "contract" edge to the Contract entity was cleared.
func (m *RiderMutation) ContractCleared() bool {
	return m.clearedcontract
}

// RemoveContractIDs removes the "contract" edge to the Contract entity by IDs.
func (m *RiderMutation) RemoveContractIDs(ids ...uint64) {
	if m.removedcontract == nil {
		m.removedcontract = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.contract, ids[i])
		m.removedcontract[ids[i]] = struct{}{}
	}
}

// RemovedContract returns the removed IDs of the "contract" edge to the Contract entity.
func (m *RiderMutation) RemovedContractIDs() (ids []uint64) {
	for id := range m.removedcontract {
		ids = append(ids, id)
	}
	return
}

// ContractIDs returns the "contract" edge IDs in the mutation.
func (m *RiderMutation) ContractIDs() (ids []uint64) {
	for id := range m.contract {
		ids = append(ids, id)
	}
	return
}

// ResetContract resets all changes to the "contract" edge.
func (m *RiderMutation) ResetContract() {
	m.contract = nil
	m.clearedcontract = false
	m.removedcontract = nil
}

// AddFaultIDs adds the "faults" edge to the CabinetFault entity by ids.
func (m *RiderMutation) AddFaultIDs(ids ...uint64) {
	if m.faults == nil {
		m.faults = make(map[uint64]struct{})
	}
	for i := range ids {
		m.faults[ids[i]] = struct{}{}
	}
}

// ClearFaults clears the "faults" edge to the CabinetFault entity.
func (m *RiderMutation) ClearFaults() {
	m.clearedfaults = true
}

// FaultsCleared reports if the "faults" edge to the CabinetFault entity was cleared.
func (m *RiderMutation) FaultsCleared() bool {
	return m.clearedfaults
}

// RemoveFaultIDs removes the "faults" edge to the CabinetFault entity by IDs.
func (m *RiderMutation) RemoveFaultIDs(ids ...uint64) {
	if m.removedfaults == nil {
		m.removedfaults = make(map[uint64]struct{})
	}
	for i := range ids {
		delete(m.faults, ids[i])
		m.removedfaults[ids[i]] = struct{}{}
	}
}

// RemovedFaults returns the removed IDs of the "faults" edge to the CabinetFault entity.
func (m *RiderMutation) RemovedFaultsIDs() (ids []uint64) {
	for id := range m.removedfaults {
		ids = append(ids, id)
	}
	return
}

// FaultsIDs returns the "faults" edge IDs in the mutation.
func (m *RiderMutation) FaultsIDs() (ids []uint64) {
	for id := range m.faults {
		ids = append(ids, id)
	}
	return
}

// ResetFaults resets all changes to the "faults" edge.
func (m *RiderMutation) ResetFaults() {
	m.faults = nil
	m.clearedfaults = false
	m.removedfaults = nil
}

// Where appends a list predicates to the RiderMutation builder.
func (m *RiderMutation) Where(ps ...predicate.Rider) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RiderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Rider).
func (m *RiderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RiderMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.created_at != nil {
		fields = append(fields, rider.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, rider.FieldUpdatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, rider.FieldDeletedAt)
	}
	if m.last_modifier != nil {
		fields = append(fields, rider.FieldLastModifier)
	}
	if m.remark != nil {
		fields = append(fields, rider.FieldRemark)
	}
	if m.person != nil {
		fields = append(fields, rider.FieldPersonID)
	}
	if m.enterprise != nil {
		fields = append(fields, rider.FieldEnterpriseID)
	}
	if m.phone != nil {
		fields = append(fields, rider.FieldPhone)
	}
	if m.contact != nil {
		fields = append(fields, rider.FieldContact)
	}
	if m.device_type != nil {
		fields = append(fields, rider.FieldDeviceType)
	}
	if m.last_device != nil {
		fields = append(fields, rider.FieldLastDevice)
	}
	if m.is_new_device != nil {
		fields = append(fields, rider.FieldIsNewDevice)
	}
	if m.last_face != nil {
		fields = append(fields, rider.FieldLastFace)
	}
	if m.push_id != nil {
		fields = append(fields, rider.FieldPushID)
	}
	if m.last_signin_at != nil {
		fields = append(fields, rider.FieldLastSigninAt)
	}
	if m.esign_account_id != nil {
		fields = append(fields, rider.FieldEsignAccountID)
	}
	if m.plan_at != nil {
		fields = append(fields, rider.FieldPlanAt)
	}
	if m.blocked != nil {
		fields = append(fields, rider.FieldBlocked)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RiderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rider.FieldCreatedAt:
		return m.CreatedAt()
	case rider.FieldUpdatedAt:
		return m.UpdatedAt()
	case rider.FieldDeletedAt:
		return m.DeletedAt()
	case rider.FieldLastModifier:
		return m.LastModifier()
	case rider.FieldRemark:
		return m.Remark()
	case rider.FieldPersonID:
		return m.PersonID()
	case rider.FieldEnterpriseID:
		return m.EnterpriseID()
	case rider.FieldPhone:
		return m.Phone()
	case rider.FieldContact:
		return m.Contact()
	case rider.FieldDeviceType:
		return m.DeviceType()
	case rider.FieldLastDevice:
		return m.LastDevice()
	case rider.FieldIsNewDevice:
		return m.IsNewDevice()
	case rider.FieldLastFace:
		return m.LastFace()
	case rider.FieldPushID:
		return m.PushID()
	case rider.FieldLastSigninAt:
		return m.LastSigninAt()
	case rider.FieldEsignAccountID:
		return m.EsignAccountID()
	case rider.FieldPlanAt:
		return m.PlanAt()
	case rider.FieldBlocked:
		return m.Blocked()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RiderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rider.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case rider.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case rider.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case rider.FieldLastModifier:
		return m.OldLastModifier(ctx)
	case rider.FieldRemark:
		return m.OldRemark(ctx)
	case rider.FieldPersonID:
		return m.OldPersonID(ctx)
	case rider.FieldEnterpriseID:
		return m.OldEnterpriseID(ctx)
	case rider.FieldPhone:
		return m.OldPhone(ctx)
	case rider.FieldContact:
		return m.OldContact(ctx)
	case rider.FieldDeviceType:
		return m.OldDeviceType(ctx)
	case rider.FieldLastDevice:
		return m.OldLastDevice(ctx)
	case rider.FieldIsNewDevice:
		return m.OldIsNewDevice(ctx)
	case rider.FieldLastFace:
		return m.OldLastFace(ctx)
	case rider.FieldPushID:
		return m.OldPushID(ctx)
	case rider.FieldLastSigninAt:
		return m.OldLastSigninAt(ctx)
	case rider.FieldEsignAccountID:
		return m.OldEsignAccountID(ctx)
	case rider.FieldPlanAt:
		return m.OldPlanAt(ctx)
	case rider.FieldBlocked:
		return m.OldBlocked(ctx)
	}
	return nil, fmt.Errorf("unknown Rider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rider.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case rider.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case rider.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case rider.FieldLastModifier:
		v, ok := value.(*model.Modifier)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastModifier(v)
		return nil
	case rider.FieldRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemark(v)
		return nil
	case rider.FieldPersonID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonID(v)
		return nil
	case rider.FieldEnterpriseID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnterpriseID(v)
		return nil
	case rider.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case rider.FieldContact:
		v, ok := value.(*model.RiderContact)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContact(v)
		return nil
	case rider.FieldDeviceType:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceType(v)
		return nil
	case rider.FieldLastDevice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastDevice(v)
		return nil
	case rider.FieldIsNewDevice:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNewDevice(v)
		return nil
	case rider.FieldLastFace:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastFace(v)
		return nil
	case rider.FieldPushID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPushID(v)
		return nil
	case rider.FieldLastSigninAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSigninAt(v)
		return nil
	case rider.FieldEsignAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEsignAccountID(v)
		return nil
	case rider.FieldPlanAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlanAt(v)
		return nil
	case rider.FieldBlocked:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlocked(v)
		return nil
	}
	return fmt.Errorf("unknown Rider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RiderMutation) AddedFields() []string {
	var fields []string
	if m.adddevice_type != nil {
		fields = append(fields, rider.FieldDeviceType)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RiderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case rider.FieldDeviceType:
		return m.AddedDeviceType()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RiderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case rider.FieldDeviceType:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeviceType(v)
		return nil
	}
	return fmt.Errorf("unknown Rider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RiderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(rider.FieldDeletedAt) {
		fields = append(fields, rider.FieldDeletedAt)
	}
	if m.FieldCleared(rider.FieldLastModifier) {
		fields = append(fields, rider.FieldLastModifier)
	}
	if m.FieldCleared(rider.FieldRemark) {
		fields = append(fields, rider.FieldRemark)
	}
	if m.FieldCleared(rider.FieldPersonID) {
		fields = append(fields, rider.FieldPersonID)
	}
	if m.FieldCleared(rider.FieldEnterpriseID) {
		fields = append(fields, rider.FieldEnterpriseID)
	}
	if m.FieldCleared(rider.FieldContact) {
		fields = append(fields, rider.FieldContact)
	}
	if m.FieldCleared(rider.FieldLastFace) {
		fields = append(fields, rider.FieldLastFace)
	}
	if m.FieldCleared(rider.FieldPushID) {
		fields = append(fields, rider.FieldPushID)
	}
	if m.FieldCleared(rider.FieldLastSigninAt) {
		fields = append(fields, rider.FieldLastSigninAt)
	}
	if m.FieldCleared(rider.FieldEsignAccountID) {
		fields = append(fields, rider.FieldEsignAccountID)
	}
	if m.FieldCleared(rider.FieldPlanAt) {
		fields = append(fields, rider.FieldPlanAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RiderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RiderMutation) ClearField(name string) error {
	switch name {
	case rider.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case rider.FieldLastModifier:
		m.ClearLastModifier()
		return nil
	case rider.FieldRemark:
		m.ClearRemark()
		return nil
	case rider.FieldPersonID:
		m.ClearPersonID()
		return nil
	case rider.FieldEnterpriseID:
		m.ClearEnterpriseID()
		return nil
	case rider.FieldContact:
		m.ClearContact()
		return nil
	case rider.FieldLastFace:
		m.ClearLastFace()
		return nil
	case rider.FieldPushID:
		m.ClearPushID()
		return nil
	case rider.FieldLastSigninAt:
		m.ClearLastSigninAt()
		return nil
	case rider.FieldEsignAccountID:
		m.ClearEsignAccountID()
		return nil
	case rider.FieldPlanAt:
		m.ClearPlanAt()
		return nil
	}
	return fmt.Errorf("unknown Rider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RiderMutation) ResetField(name string) error {
	switch name {
	case rider.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case rider.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case rider.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case rider.FieldLastModifier:
		m.ResetLastModifier()
		return nil
	case rider.FieldRemark:
		m.ResetRemark()
		return nil
	case rider.FieldPersonID:
		m.ResetPersonID()
		return nil
	case rider.FieldEnterpriseID:
		m.ResetEnterpriseID()
		return nil
	case rider.FieldPhone:
		m.ResetPhone()
		return nil
	case rider.FieldContact:
		m.ResetContact()
		return nil
	case rider.FieldDeviceType:
		m.ResetDeviceType()
		return nil
	case rider.FieldLastDevice:
		m.ResetLastDevice()
		return nil
	case rider.FieldIsNewDevice:
		m.ResetIsNewDevice()
		return nil
	case rider.FieldLastFace:
		m.ResetLastFace()
		return nil
	case rider.FieldPushID:
		m.ResetPushID()
		return nil
	case rider.FieldLastSigninAt:
		m.ResetLastSigninAt()
		return nil
	case rider.FieldEsignAccountID:
		m.ResetEsignAccountID()
		return nil
	case rider.FieldPlanAt:
		m.ResetPlanAt()
		return nil
	case rider.FieldBlocked:
		m.ResetBlocked()
		return nil
	}
	return fmt.Errorf("unknown Rider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RiderMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.person != nil {
		edges = append(edges, rider.EdgePerson)
	}
	if m.enterprise != nil {
		edges = append(edges, rider.EdgeEnterprise)
	}
	if m.contract != nil {
		edges = append(edges, rider.EdgeContract)
	}
	if m.faults != nil {
		edges = append(edges, rider.EdgeFaults)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RiderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rider.EdgePerson:
		if id := m.person; id != nil {
			return []ent.Value{*id}
		}
	case rider.EdgeEnterprise:
		if id := m.enterprise; id != nil {
			return []ent.Value{*id}
		}
	case rider.EdgeContract:
		ids := make([]ent.Value, 0, len(m.contract))
		for id := range m.contract {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeFaults:
		ids := make([]ent.Value, 0, len(m.faults))
		for id := range m.faults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RiderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcontract != nil {
		edges = append(edges, rider.EdgeContract)
	}
	if m.removedfaults != nil {
		edges = append(edges, rider.EdgeFaults)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RiderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case rider.EdgeContract:
		ids := make([]ent.Value, 0, len(m.removedcontract))
		for id := range m.removedcontract {
			ids = append(ids, id)
		}
		return ids
	case rider.EdgeFaults:
		ids := make([]ent.Value, 0, len(m.removedfaults))
		for id := range m.removedfaults {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RiderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedperson {
		edges = append(edges, rider.EdgePerson)
	}
	if m.clearedenterprise {
		edges = append(edges, rider.EdgeEnterprise)
	}
	if m.clearedcontract {
		edges = append(edges, rider.EdgeContract)
	}
	if m.clearedfaults {
		edges = append(edges, rider.EdgeFaults)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RiderMutation) EdgeCleared(name string) bool {
	switch name {
	case rider.EdgePerson:
		return m.clearedperson
	case rider.EdgeEnterprise:
		return m.clearedenterprise
	case rider.EdgeContract:
		return m.clearedcontract
	case rider.EdgeFaults:
		return m.clearedfaults
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RiderMutation) ClearEdge(name string) error {
	switch name {
	case rider.EdgePerson:
		m.ClearPerson()
		return nil
	case rider.EdgeEnterprise:
		m.ClearEnterprise()
		return nil
	}
	return fmt.Errorf("unknown Rider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RiderMutation) ResetEdge(name string) error {
	switch name {
	case rider.EdgePerson:
		m.ResetPerson()
		return nil
	case rider.EdgeEnterprise:
		m.ResetEnterprise()
		return nil
	case rider.EdgeContract:
		m.ResetContract()
		return nil
	case rider.EdgeFaults:
		m.ResetFaults()
		return nil
	}
	return fmt.Errorf("unknown Rider edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *uint64
	created_at    *time.Time
	updated_at    *time.Time
	key           *string
	val           *model.Setting
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id uint64) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id uint64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]uint64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SettingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SettingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SettingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SettingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetKey sets the "key" field.
func (m *SettingMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SettingMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SettingMutation) ResetKey() {
	m.key = nil
}

// SetVal sets the "val" field.
func (m *SettingMutation) SetVal(value model.Setting) {
	m.val = &value
}

// Val returns the value of the "val" field in the mutation.
func (m *SettingMutation) Val() (r model.Setting, exists bool) {
	v := m.val
	if v == nil {
		return
	}
	return *v, true
}

// OldVal returns the old "val" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldVal(ctx context.Context) (v model.Setting, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVal: %w", err)
	}
	return oldValue.Val, nil
}

// ResetVal resets all changes to the "val" field.
func (m *SettingMutation) ResetVal() {
	m.val = nil
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, setting.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, setting.FieldUpdatedAt)
	}
	if m.key != nil {
		fields = append(fields, setting.FieldKey)
	}
	if m.val != nil {
		fields = append(fields, setting.FieldVal)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldCreatedAt:
		return m.CreatedAt()
	case setting.FieldUpdatedAt:
		return m.UpdatedAt()
	case setting.FieldKey:
		return m.Key()
	case setting.FieldVal:
		return m.Val()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case setting.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case setting.FieldKey:
		return m.OldKey(ctx)
	case setting.FieldVal:
		return m.OldVal(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case setting.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case setting.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case setting.FieldVal:
		v, ok := value.(model.Setting)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVal(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case setting.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case setting.FieldKey:
		m.ResetKey()
		return nil
	case setting.FieldVal:
		m.ResetVal()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}
